<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DOM节点层级</title>
    <url>/2021/12/12/DOM-%E8%8A%82%E7%82%B9%E5%B1%82%E7%BA%A7/</url>
    <content><![CDATA[<h2 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h2><p>DOM Level 1描述为名为Node的接口，Node接口在JavaScript中被实现为Node类型，所有结点都继承Node类型，因此所有类型都共享相同的基本属性和方法。</p>
<p>节点类型可通过与这些常量比较来确定</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//节点类型可通过与这些常量比较确定，如果两者相等，则意味着someNode是一个元素节点</span></span><br><span class="line"><span class="keyword">if</span>(someNode.nodeType==Node.ELEMENT_NODE)&#123;</span><br><span class="line">    alert(<span class="string">&quot;Node is an element&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//nodeName和nodeValue保存着有关节点的信息</span></span><br><span class="line"><span class="keyword">if</span>(someNode.nodeType==<span class="number">1</span>)&#123;</span><br><span class="line">    value=someNode.nodeName;<span class="comment">//会显示元素的标签名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h4><p>节点与其他节点的关系可形容为家族关系，每个节点有一个childNodes属性其中包含一个NodeList的实例，NodeList是一个类数组对象，它是DOM结构的查询，DOM结构的变化会自动地在NodeList中反映出来，用于存储可以按位置存取的有序节点。可以使用中括号或者item()方法访问它的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstChild=someNode.childNodes[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> secondChild=someNode.childNodes.item(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> count=someNode.childNodes.length;</span><br><span class="line"><span class="keyword">let</span> arrayofNodes=<span class="built_in">Array</span>.from(someNode.childNodes);</span><br></pre></td></tr></table></figure>

<p>parentNode指向DOM树中的父元素，childNode中所有节点都有同一个父元素，parentNode指向同一个节点，childNodes列表中每个结点都是同一列表中其他节点的同胞节点，使用previousSibling和nextSibling可以在这个列表的节点间导航。</p>
<p>hasChildNodes()节点返回true则说明节点有一个或多个子节点。</p>
<p>ownerDocument属性是一个指向代表整个文档的文档节点的指针</p>
<h4 id="操纵节点"><a href="#操纵节点" class="headerlink" title="操纵节点"></a>操纵节点</h4><p>appendChild():用于在childNodes列表末尾添加节点，返回新添加的节点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> returnedNode=someNode.appendChild(newNode);</span><br><span class="line">alert(returnedNode==newNode);<span class="comment">//true</span></span><br><span class="line">alert(someNode.lastChild==newNode);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>inserBefore():接收两个参数，要插入的节点和参照节点。要插入的节点会变成参照节点的前一个同胞节点，并被返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">returnedNode=someNode.insertBefore(newNode,<span class="literal">null</span>);</span><br><span class="line">alert(newNode==someNode.lastChild);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//作为新的第一个子节点插入</span></span><br><span class="line">retunedNode=someNode.insertBefore(newNode,someNode.firstChild);</span><br><span class="line">alert(returnedNode==newNode);<span class="comment">//true</span></span><br><span class="line">alert(newNode==someNode.fiestChild);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//插入最后一个子节点的前面</span></span><br><span class="line">returnedNode==someNode.insertBefore(newNode,someNode.lastChild);</span><br><span class="line">alert(newNode==someNode.childNodes[someNode.childNodes.length-<span class="number">2</span>]);<span class="comment">//true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>replaceChild():接收两个参数，要插入的节点和要替换的节点。要替换的节点被返回并从文档中被移除</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">returnedNode=someNode.replaceChild(newNode,someNode.lastChild);<span class="comment">//替换最后一个子节点</span></span><br></pre></td></tr></table></figure>

<p>removeChild():接收一个参数，即要被移除的节点，被移除的节点会被返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> formerFirstChild=someNode.removeChild(someNode.firstChild);</span><br></pre></td></tr></table></figure>

<p>cloneNode():传入true参数会进行深复制，即复制节点和整个子DOM树；传入false进行浅复制，只会复制该方法的节点。复制返回的节点属于文档所有，但未指定父节点，称为孤儿节点，通过appendChild()和insertBefore()或replaceChild()方法把孤儿节点添加到文档中</p>
<p>normalize():处理文本节点，如果发现空文本节点则将其删除否则如果两个同胞节点相邻则将其合并为一个文本节点</p>
<h2 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h2><p>表示文档节点的类型,document是HTMLDocument的实例（HTMLDocument继承Document）,表示整个HTML页面，document是window对象的属性是一个全局对象。</p>
<ul>
<li><p>nodetype等于9</p>
</li>
<li><p>nodeName值为“#document”</p>
</li>
<li><p>nodevalue值为null</p>
</li>
<li><p>parentNode值为null</p>
</li>
<li><p>ownerDocument值为null</p>
</li>
<li><p>子节点可以使DocumentType(最多一个)，Element(最多一个)，ProcessingInstruction或Comment类型</p>
</li>
</ul>
<h4 id="文档子节点"><a href="#文档子节点" class="headerlink" title="文档子节点"></a>文档子节点</h4><p>documentElement:始终指向HTML页面中的<html>元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br><span class="line"><span class="keyword">let</span> html=<span class="built_in">document</span>.documentElement;<span class="comment">//取得对&lt;html&gt;的引用</span></span><br><span class="line">alert(html===<span class="built_in">document</span>.childNodes[<span class="number">0</span>]);</span><br><span class="line">alert(html===<span class="built_in">document</span>.firstChild);</span><br></pre></td></tr></table></figure>

<p>document.body:直接指向<body>元素，取得对<body>的引用</p>
<h4 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h4><p>title:显示浏览器窗口或标签页的标题栏</p>
<p>URL:包含当前页面的完整URL</p>
<p>domain:包含页面的域名</p>
<p>referrer:包含空字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//document.URL=&quot;http://www.wrox.com/WileyCDA/&quot;,document.domain就是www.wrox.com</span></span><br><span class="line"><span class="built_in">document</span>=<span class="string">&quot;wrrox.com&quot;</span>;<span class="comment">//成功</span></span><br><span class="line"><span class="built_in">document</span>=<span class="string">&quot;nczonline.net&quot;</span>;<span class="comment">//出错,不能给这个属性设置URL中不包含的值</span></span><br></pre></td></tr></table></figure>

<p>当页面中包含来自某个不同子域的窗格（<frame>)或内嵌窗格(<iframe>)设置document.domain是有用的，比如一个加载自<a href="http://www.wrox.com的页面包含一个内嵌窗格其中的页面加载自p2p.wrox.com,这两个页面包含不同的字符串,内部和外部不能相互访问对方的javascript对象,如果每个页面都把document.domain设置为wrox.com,那两个页面就可以相互通信/">www.wrox.com的页面包含一个内嵌窗格其中的页面加载自p2p.wrox.com，这两个页面包含不同的字符串，内部和外部不能相互访问对方的JavaScript对象，如果每个页面都把document.domain设置为wrox.com,那两个页面就可以相互通信</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain=<span class="string">&quot;wrox.com&quot;</span>;<span class="comment">//放松，成功</span></span><br><span class="line"><span class="built_in">document</span>.doman=<span class="string">&quot;p2p2.wrox.com&quot;</span>;<span class="comment">//收紧，失败,一旦放松就不能收紧</span></span><br></pre></td></tr></table></figure>

<h4 id="定位元素"><a href="#定位元素" class="headerlink" title="定位元素"></a>定位元素</h4><p>getElementById()：接收一个要获取元素的ID，如果找到这个元素则返回，没找到返回null。参数I必须跟元素在页面中大的id属性完全匹配，包括大小写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;myDiv&quot;</span>&gt;ome text&lt;/div&gt;</span><br><span class="line"><span class="keyword">let</span> div=<span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>);<span class="comment">//取得对&lt;div&gt;的引用,如果存在多个相同ID的元素则返回在文档中的第一个元素</span></span><br></pre></td></tr></table></figure>

<p>getElementsByTagName():接收一个参数，即要获取元素的标签名,返回包含0个或多个元素的NodeList，在HTML文档中返回一个HTMLCollection对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> images=<span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">alert(images.length);<span class="comment">//图片数量</span></span><br><span class="line">alert(images[<span class="number">0</span>].src);<span class="comment">//第一张图片的src属性</span></span><br><span class="line">alert(images.item(<span class="number">0</span>).src);</span><br><span class="line"><span class="comment">//通过name属性获得引用</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;myImage.gif&quot;</span> <span class="attr">name</span>=<span class="string">&quot;myImage&quot;</span>&gt;</span>;</span></span><br><span class="line"><span class="xml">let myImage=images.namedItem(&quot;myImage&quot;);</span></span><br><span class="line"><span class="xml">//images[&quot;myImage&quot;]</span></span><br><span class="line"><span class="xml">//取得文档的所有元素</span></span><br><span class="line"><span class="xml">let allElements=document.getElementsByTagName(&quot;*&quot;);</span></span><br></pre></td></tr></table></figure>

<p>getElementsByName():返回具有给定name属性的所有元素，常用于单选按钮</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;fieldset&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">legend</span>&gt;</span>Which color do you prefer?<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span></span><br><span class="line">	&lt;ul&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">        &lt;input type=&quot;radio&quot; value=&quot;red&quot; name=&quot;color&quot; id=&quot;colorRed&quot;&gt;&lt;label for=&quot;colorRed&quot;&gt;Red&lt;/label&gt;</span><br><span class="line">    	&lt;/li&gt;</span><br><span class="line">    	&lt;li&gt; &lt;input type=&quot;radio&quot; value=&quot;blue&quot; name=&quot;color&quot; id=&quot;colorBlue&quot;&gt;&lt;label for=&quot;colorBlue&quot;&gt;Blue&lt;/label&gt;</span><br><span class="line">    	&lt;/li&gt;</span><br><span class="line">    let radios=document.getElementsByName(&quot;color&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h2><ul>
<li><p>nodeType=1</p>
</li>
<li><p>nodeName值为元素的标签名</p>
</li>
<li><p>nodeValue的值为null</p>
</li>
<li><p>parentNode值为Document或Element对象</p>
</li>
<li><p>子节点可以是Element,Text,Comment,ProcessingInstruction等类型</p>
</li>
</ul>
<p>通过nodeName或tagName属性获得元素的标签名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用对象属性</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;  </span><br><span class="line">    &lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">       let div=document.getElementById(&quot;myDiv&quot;);</span><br><span class="line">	alert(div.tagName);//&quot;DIV&quot;</span><br><span class="line">	alert(div.tagName==div.nodeName);//true</span><br><span class="line">	if(element.tagName.toLowerCase()==&quot;div&quot;)&#123;</span><br><span class="line">    //,HTML中，元素标签名以答谢表示，XML中标签名与代码中的大小写一致，不确定脚本是HTML还是XML运行，推荐将标签名转换为小写形式，适合所有文档</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h4 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h4><ul>
<li><p>id:元素在文档中的唯一标识符</p>
</li>
<li><p>title：包含元素的额外信息，通常以提示条形式展示</p>
</li>
<li><p>lang：元素内容的语言代码</p>
</li>
<li><p>dir：语言的书写方向（ltr从左到右，rtl从右到左)</p>
</li>
<li><p>className:相当于class属性，用于指定元素的CSS类</p>
</li>
</ul>
<h5 id="取得属性"><a href="#取得属性" class="headerlink" title="取得属性"></a>取得属性</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用对象属性</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;  </span><br><span class="line">    &lt;div id=&quot;myDiv&quot; class=&quot;bd&quot; title=&quot;Body text&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var div=document.getElementById(&quot;myDiv&quot;);</span><br><span class="line">        alert(div.id);</span><br><span class="line">        alert(div.className);</span><br><span class="line">        alert(div.title);</span><br><span class="line">        alert(div.lang);</span><br><span class="line">        alert(div.dir);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">//使用getAttribute()方法</span><br><span class="line">alert(div.getAttribute(&quot;class&quot;));</span><br></pre></td></tr></table></figure>

<p>getAttribute()主要用于取得自定义属性的值，其他情况使用对象属性</p>
<h5 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h5><p>setAttribute():接收两个参数，要设置的属性名和属性值,如果属性存在则用指定的值替换原来的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接给对象属性赋值</span></span><br><span class="line">div.id=<span class="string">&quot;someOtherId&quot;</span></span><br><span class="line"><span class="comment">//在对象属性上添加自定义属性，不会让它变成元素的属性</span></span><br><span class="line">div.mycolor=<span class="string">&quot;red&quot;</span>;</span><br><span class="line">alert(div.getAttribute(<span class="string">&quot;mycolor&quot;</span>));<span class="comment">//null</span></span><br><span class="line"><span class="comment">//使用setAttribute赋值</span></span><br><span class="line">div.setAttribute(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;someOtherId&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="attributes属性"><a href="#attributes属性" class="headerlink" title="attributes属性"></a>attributes属性</h5><p>attributes属性包含一个NamedNodeMap实例，是一个类似NodeList的“实时”集合，元素的每个属性都表示为一个Attr节点，并保存在NamedNodeMap对象中</p>
<p>attributed属性中的每个节点的nodeName是对应属性的名字，nodeValue是属性的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputAttributes</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pairs=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,len=element.attributes.length;i&lt;len;++i)&#123;</span><br><span class="line">        <span class="keyword">const</span> attribute=element.attributes[i];</span><br><span class="line">        pairs.push(<span class="string">`<span class="subst">$&#123;attribute.nodeName&#125;</span>=<span class="subst">$&#123;attribute.nodeValue&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> pairs.join(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h5><p>document.createElement():一个参数，即要创建元素的标签名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> div=<span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">div.id=<span class="string">&quot;myNewDiv&quot;</span>;</span><br><span class="line">div.className=<span class="string">&quot;box&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div);</span><br></pre></td></tr></table></figure>

<h2 id="Text-类型"><a href="#Text-类型" class="headerlink" title="Text 类型"></a>Text 类型</h2><p>Text节点由Text类型表示，包含按字面解释的纯文本，也可能包含转义后的HTML字符，Text节点中包含的文本可以通过nodeValue或者data属性访问</p>
<ul>
<li><p>nodetype=3</p>
</li>
<li><p>nodeName=”#text”</p>
</li>
<li><p>nodeValue值为节点中包含的文本</p>
</li>
<li><p>parentNode值为Element对象</p>
</li>
<li><p>不支持子节点</p>
</li>
<li><p>appendData(text):向节点末尾添加文本text</p>
</li>
<li><p>deleteData(offset,count),从位置offset开始删除count个字符</p>
</li>
<li><p>insertData(offset,text),在位置offset插入text；</p>
</li>
<li><p>replaceData(offset,count,text)，用text替换从位置offset到offset+count大的文本</p>
</li>
<li><p>splitText(offset),在位置offset将当前文本节点拆分为两个文本节点</p>
</li>
<li><p>substringData(offset,count),提取从位置offset到offset+count的文本</p>
</li>
</ul>
<p>包含文本内容的每个元素最多只能有一个文本节点</p>
<h4 id="创建文本节点"><a href="#创建文本节点" class="headerlink" title="创建文本节点"></a>创建文本节点</h4><p>document.createTextNode():创建新文本节点，接收一个参数，即要插入节点的文本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> element=<span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">element.className=<span class="string">&quot;message&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> textNode=<span class="built_in">document</span>.createTextNode(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">element.appendChild(textNode);</span><br><span class="line"><span class="keyword">let</span> anotherTextNode=<span class="built_in">document</span>.createTextNode(<span class="string">&quot;Yippee&quot;</span>);</span><br><span class="line">element.appendChild(anotherTextNode);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="规范化文本节点"><a href="#规范化文本节点" class="headerlink" title="规范化文本节点"></a>规范化文本节点</h4><h5 id="合并文本节点"><a href="#合并文本节点" class="headerlink" title="合并文本节点"></a>合并文本节点</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> element=<span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">element.className=<span class="string">&quot;message&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> textNode=<span class="built_in">document</span>.createTextNode(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">element.appendChild(textNode);</span><br><span class="line"><span class="keyword">let</span> anotherTextNode=<span class="built_in">document</span>.createTextNode(<span class="string">&quot;Yippee&quot;</span>);</span><br><span class="line">element.appendChild(anotherTextNode);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line">alert(element.childNodes.length);<span class="comment">//2</span></span><br><span class="line">element.normalize();</span><br><span class="line">alert(element.childNodes.length);<span class="comment">//1</span></span><br><span class="line">alert(element.firstChild.nodeValue);</span><br></pre></td></tr></table></figure>

<h5 id="拆分文本节点"><a href="#拆分文本节点" class="headerlink" title="拆分文本节点"></a>拆分文本节点</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> element=<span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">element.className=<span class="string">&quot;message&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> textNode=<span class="built_in">document</span>.createTextNode(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">element.appendChild(textNode);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line"><span class="keyword">let</span> newNode=element.firstChild.splitText(<span class="number">5</span>);</span><br><span class="line">alert(element.fiestChild.nodeValue);<span class="comment">//&quot;Hello&quot;</span></span><br><span class="line">alert(newNode.nodeValue);<span class="comment">//&quot;world&quot;</span></span><br><span class="line">alert(element.chileNodes.length);<span class="comment">//2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h2><ul>
<li><p>nodeType=8</p>
</li>
<li><p>nodeName=”#comment”</p>
</li>
<li><p>nodeValue值为注释内容</p>
</li>
<li><p>parentNode值为Document或Element对象</p>
</li>
<li><p>不支持子节点</p>
</li>
</ul>
<p>Comment类型与Text类型继承自同一个基类(CharacterData),因此拥有除splitText之外的Text节点所有的字符串操作方法</p>
<h2 id="CDATASection类型"><a href="#CDATASection类型" class="headerlink" title="CDATASection类型"></a>CDATASection类型</h2><p>继承Text类型，拥有除splitText之外的Text节点所有的字符串操作方法</p>
<h2 id="DocumentType类型"><a href="#DocumentType类型" class="headerlink" title="DocumentType类型"></a>DocumentType类型</h2><ul>
<li><p>在DOM Level1中不支持动态创建，只能在解析文档代码时创建，DocumentType对象保存在document.doctype属性中.</p>
</li>
<li><p>DocumentType对象有3个属性：name,entities,notations.</p>
</li>
<li><p>name是文档名称，entities是这个文档类型描述实体的NameNodeMap,而notations是这个文档类型描述的表示法的NamedNodeMap.</p>
</li>
<li><p>浏览器文档通常是HTML或XHTML类型，所以entities和notations列表为空，只有name属性有用，包含文档类型的名称</p>
</li>
</ul>
<h2 id="DocumentFragment类型"><a href="#DocumentFragment类型" class="headerlink" title="DocumentFragment类型"></a>DocumentFragment类型</h2><ul>
<li><p>nodeType=11</p>
</li>
<li><p>nodeName=”#document-fragment”</p>
</li>
<li><p>nodeValue=null</p>
</li>
<li><p>parentNode=null</p>
</li>
<li><p>子节点可以是Element,ProcessingInstruction,Comment,Text,CDATASection</p>
</li>
</ul>
<p>充当其他要被添加的文档节点的仓库</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;myList&quot;</span>&gt;&lt;/ul&gt;</span><br><span class="line"><span class="keyword">let</span> fragment=<span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"><span class="keyword">let</span> ul=<span class="built_in">document</span>.getElementById(<span class="string">&quot;myList&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> li=<span class="built_in">document</span>.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">    li.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">`Item <span class="subst">$&#123;i+<span class="number">1</span>&#125;</span>`</span>));</span><br><span class="line">    fragment.appendChild(li);</span><br><span class="line">&#125;</span><br><span class="line">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure>

<h2 id="Attr类型"><a href="#Attr类型" class="headerlink" title="Attr类型"></a>Attr类型</h2><p>属性是存在于元素attributes属性中的节点</p>
<ul>
<li><p>nodeType=2</p>
</li>
<li><p>nodeName值为属性名</p>
</li>
<li><p>nodeValue值为属性值</p>
</li>
<li><p>parentNode值为null</p>
</li>
</ul>
<p>Attr对象上3个属性</p>
<ul>
<li><p>name包含属性名</p>
</li>
<li><p>value包含属性值</p>
</li>
<li><p>specified是一个布尔值，表示属性使用的是默认值和还是被指定的值</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> attr=<span class="built_in">document</span>.createAttribute(<span class="string">&quot;align&quot;</span>);<span class="comment">//创建新的Attr节点，参数为属性名</span></span><br><span class="line">attr.value=<span class="string">&quot;left&quot;</span>;</span><br><span class="line">element.setAttributeNode(attr);<span class="comment">//添加属性节点</span></span><br><span class="line">alert(element.attributes[<span class="string">&quot;align&quot;</span>].value);<span class="comment">//返回对应属性节点</span></span><br><span class="line">alert(element.getAttributeNode(<span class="string">&quot;align&quot;</span>).value);<span class="comment">//返回对应属性节点</span></span><br><span class="line">alert(element.getAttribute(<span class="string">&quot;align&quot;</span>));<span class="comment">//只返回属性值</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>DOM编程</title>
    <url>/2021/12/12/DOM-DOM%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="DOM编程"><a href="#DOM编程" class="headerlink" title="DOM编程"></a>DOM编程</h1><h2 id="动态脚本"><a href="#动态脚本" class="headerlink" title="动态脚本"></a>动态脚本</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScriptString</span>(<span class="params">code</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script=<span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">    script.type=<span class="string">&quot;text/javascript&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        script.appendChild(<span class="built_in">document</span>.createTextNode(code));<span class="comment">//旧版本的IE浏览器可能出问题</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(ex)&#123;</span><br><span class="line">        script.text=code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">loadScriptString(<span class="string">&quot;function sayHi()&#123;alert(&#x27;hi&#x27;);&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStyleString</span>(<span class="params">css</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> style=<span class="built_in">document</span>.createElement(<span class="string">&quot;style&quot;</span>);</span><br><span class="line">    style.type=<span class="string">&quot;text/css&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        style.appendChild(<span class="built_in">document</span>.createTextNode(css));</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ex)&#123;</span><br><span class="line">        style.styleSheet.cssText=css;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> head=<span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">    head.appendChild(style);</span><br><span class="line">&#125;</span><br><span class="line">loadStyleString(<span class="string">&quot;body[background-color:red&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>对于IE，要小心使用styleSheet.cssText,如果重用同一个<style>元素并设置该属性超过一次，则可能导致浏览器崩溃，将cssText设置为空字符串也可能导致浏览器崩溃</p>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> table=<span class="built_in">document</span>.createElement(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">table.border=<span class="number">1</span>;</span><br><span class="line">table.width=<span class="string">&quot;100%&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> tbody=<span class="built_in">document</span>.createElement(<span class="string">&quot;tbody&quot;</span>);</span><br><span class="line">table.appendChild(tbody);</span><br><span class="line"></span><br><span class="line">table.insertRow(<span class="number">0</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">0</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">0</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;Cell 1,1&quot;</span>));</span><br><span class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">1</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">1</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;Cell 2,1&quot;</span>));</span><br><span class="line"></span><br><span class="line">table.insertRow(<span class="number">1</span>);</span><br><span class="line">tbody.rows[<span class="number">1</span>].insertCell(<span class="number">0</span>);</span><br><span class="line">tbody.rows[<span class="number">1</span>].cells[<span class="number">0</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;Cell 1,2&quot;</span>));</span><br><span class="line">tbody.rows[<span class="number">1</span>].insertCell(<span class="number">1</span>);</span><br><span class="line">tbody.rows[<span class="number">1</span>].cells[<span class="number">1</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;Cell 2,2&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(table);</span><br></pre></td></tr></table></figure>

<h2 id="NodeList"><a href="#NodeList" class="headerlink" title="NodeList"></a>NodeList</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> divs=<span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,len=divs.length;i&lt;len;i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> div=doocument.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;<span class="comment">//避免导致无穷循环</span></span><br></pre></td></tr></table></figure>

<h1 id="Mutationobserver接口"><a href="#Mutationobserver接口" class="headerlink" title="Mutationobserver接口"></a>Mutationobserver接口</h1><p>在DOM被修改时异步执行回调，使用MutationObserver可以观察整个文档，DOM树的一部分或某个元素</p>
<p>MutationObserver的实例通过调用MutationObserver构造函数并传入一个回调函数创建</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer=<span class="keyword">new</span> MutationObserver(<span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="string">&#x27;DOM was mutated&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="observe-方法"><a href="#observe-方法" class="headerlink" title="observe()方法"></a>observe()方法</h2><p>接收两个参数：要观察其变化的DOM节点，以及一个MutationObserverInit对象（用于控制观察哪些方面的变化，是一个键值对形式配置选项的字典）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer=<span class="keyword">new</span> MutationObserver(<span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="string">&#x27;&lt;body&gt; attributes changed&#x27;</span>));</span><br><span class="line">observer.observe(<span class="built_in">document</span>.body,&#123;<span class="attr">attributes</span>:<span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure>

<body>元素上任何属性发生变化都会被这个MutationObserver实例发现，然后异步执行注册的回调函数,<body>元素后代修改或其他非属性修改不会触发回调进入任务

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer=<span class="keyword">new</span> MutationObserver(<span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="string">&#x27;&lt;body&gt; attributes changed&#x27;</span>));</span><br><span class="line">observer.observe(<span class="built_in">document</span>.body,&#123;<span class="attr">attributes</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.className=<span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Changed body class&#x27;</span>);</span><br><span class="line"><span class="comment">//Changed body class</span></span><br><span class="line"><span class="comment">//&lt;body&gt; attributes changed</span></span><br></pre></td></tr></table></figure>

<h2 id="回调与MutationRecord"><a href="#回调与MutationRecord" class="headerlink" title="回调与MutationRecord"></a>回调与MutationRecord</h2><p>每次回调都会收到一个MutationRecord实例的数组,包含的信息发生了什么变化以及DOM哪一部分受到影响</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer=<span class="keyword">new</span> MutationObserver(<span class="function">(<span class="params">mutationRecords</span>)=&gt;</span><span class="built_in">console</span>.log(mutationRecords));[</span><br><span class="line">observer.observe(<span class="built_in">document</span>.body,&#123;<span class="attr">attributes</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.setAttributeNS(<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;bar&#x27;</span>,<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"><span class="comment">//连续修改多个MutationRecord实例，回调函数就会受到包含这些实例的数组，顺序为变化事件的顺序</span></span><br><span class="line"><span class="keyword">let</span> observer=<span class="keyword">new</span> MutationObserver(<span class="function">(<span class="params">mutationRecords</span>)=&gt;</span><span class="built_in">console</span>.log(mutationRecords));</span><br><span class="line">observer.observe(<span class="built_in">document</span>.body,&#123;<span class="attr">attributes</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.className=<span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.body.className=<span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="comment">//[MutationRecord, MutationRecord]</span></span><br></pre></td></tr></table></figure>

<h2 id="disconnect-方法"><a href="#disconnect-方法" class="headerlink" title="disconnect()方法"></a>disconnect()方法</h2><p>会停止此后变化事件的回调，也会抛弃已经加入任务队列要异步执行的回调</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer=<span class="keyword">new</span> MutationObserver(<span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="string">&#x27;&lt;body&gt;attributes changed&#x27;</span>));</span><br><span class="line">observer.observe(<span class="built_in">document</span>.body,&#123;<span class="attr">attributes</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.className=<span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">observer.disconnect();</span><br><span class="line"><span class="built_in">document</span>.body.className=<span class="string">&#x27;bar&#x27;</span>;<span class="comment">//无日志输出</span></span><br><span class="line"><span class="comment">//让已经入队的回调函数执行完毕后再调用disconnect()</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    observer.disconnect();</span><br><span class="line">    <span class="built_in">document</span>.body.className=<span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2 id="复用MutationObserver"><a href="#复用MutationObserver" class="headerlink" title="复用MutationObserver"></a>复用MutationObserver</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer=<span class="keyword">new</span> MutationObserver(<span class="function">(<span class="params">mutationRecords</span>)=&gt;</span><span class="built_in">console</span>.log(mutationRecords.map(<span class="function">(<span class="params">x</span>)=&gt;</span>x.target)));</span><br><span class="line"><span class="keyword">let</span> childA=<span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    childB=<span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(childA);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(childB);</span><br><span class="line">observer.observe(childA,&#123;<span class="attr">attributes</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">observer.observe(childB,&#123;<span class="attr">attributes</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">childA.setAttribute(<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">childB.setAttribute(<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="comment">//[div, span]</span></span><br></pre></td></tr></table></figure>

<h2 id="重用MutationObserver"><a href="#重用MutationObserver" class="headerlink" title="重用MutationObserver"></a>重用MutationObserver</h2><p>调用diaconnect()不会结束MutationObserver的生命，还可以重新使用这个观察者，再将它关联到新的目标结点</p>
<h1 id="MutationObserverInit与观察范围"><a href="#MutationObserverInit与观察范围" class="headerlink" title="MutationObserverInit与观察范围"></a>MutationObserverInit与观察范围</h1><h2 id="观察属性"><a href="#观察属性" class="headerlink" title="观察属性"></a>观察属性</h2><p>设置attributes为true,观察所有属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer=<span class="keyword">new</span> MutationObserver(<span class="function">(<span class="params">mutationRecords</span>)=&gt;</span><span class="built_in">console</span>.log(mutationRecords));</span><br><span class="line">observer.observe(<span class="built_in">document</span>.body,&#123;<span class="attr">attributes</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"><span class="comment">//添加属性</span></span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="comment">//修改属性</span></span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"><span class="comment">//移除属性</span></span><br><span class="line"><span class="built_in">document</span>.body.removeAttribute(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用attributeFilter添加白名单属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer=<span class="keyword">new</span> MutationObserver(<span class="function">(<span class="params">mutationRecords</span>)=&gt;</span><span class="built_in">console</span>.log(mutationRecords));</span><br><span class="line">observer.observe(<span class="built_in">document</span>.body,&#123;<span class="attr">attributeFilter</span>:[<span class="string">&#x27;foo&#x27;</span>]&#125;);</span><br><span class="line"><span class="comment">//添加白名单属性</span></span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="comment">//添加被排除的属性</span></span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">&#x27;baz&#x27;</span>,<span class="string">&#x27;qux&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>在记录中保存属性原来的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer=<span class="keyword">new</span> MutationObserver(<span class="function">(<span class="params">mutationRecords</span>)=&gt;</span><span class="built_in">console</span>.log(mutationRecords.map(<span class="function">(<span class="params">x</span>)=&gt;</span>x.oldValue)));</span><br><span class="line">observer.observe(<span class="built_in">document</span>.body,&#123;<span class="attr">attributeOldValue</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"><span class="comment">//[null, &#x27;bar&#x27;, &#x27;baz&#x27;]</span></span><br></pre></td></tr></table></figure>

<h2 id="观察字符数据"><a href="#观察字符数据" class="headerlink" title="观察字符数据"></a>观察字符数据</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer=<span class="keyword">new</span> MutationObserver(<span class="built_in">document</span>.body.firstChild,&#123;<span class="attr">characterData</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.firstChild.textContent=<span class="string">&#x27;foo&#x27;</span>;<span class="comment">//创建要观察的文本节点</span></span><br><span class="line">observer.observe(<span class="built_in">document</span>.body.firstChild,&#123;<span class="attr">characterData</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.firstChild.textContent=<span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.body.firstChild.textContent=<span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.body.firstChild.textContent=<span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line"><span class="comment">//使用characterDataOldValue</span></span><br><span class="line"><span class="keyword">let</span> observer=<span class="keyword">new</span> MutationObserver(<span class="function">(<span class="params">mutationRecords</span>)=&gt;</span><span class="built_in">console</span>.log(mutationRecords.map(<span class="function">(<span class="params">x</span>)=&gt;</span>x.oldValue)));</span><br><span class="line"><span class="built_in">document</span>.body.firstChild.textContent=<span class="string">&#x27;foo&#x27;</span>;<span class="comment">//创建要观察的文本节点</span></span><br><span class="line">observer.observe(<span class="built_in">document</span>.body.firstChild,&#123;<span class="attr">characterDataOldValue</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.firstChild.textContent=<span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.body.firstChild.textContent=<span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.body.firstChild.textContent=<span class="string">&#x27;baz&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="观察子节点"><a href="#观察子节点" class="headerlink" title="观察子节点"></a>观察子节点</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.innerHTML=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> observer=<span class="keyword">new</span> MutationObserver(<span class="function">(<span class="params">mutationRecords</span>)=&gt;</span><span class="built_in">console</span>.log(mutationRecords));</span><br><span class="line"><span class="comment">//创建两个初始子节点</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>));</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>));</span><br><span class="line">observer.observe(<span class="built_in">document</span>.body,&#123;<span class="attr">childList</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(<span class="built_in">document</span>.body.lastChild,<span class="built_in">document</span>.body.firstChild);</span><br><span class="line"><span class="comment">//发生两次变化，先移除节点再添加节点</span></span><br></pre></td></tr></table></figure>

<h2 id="观察子树"><a href="#观察子树" class="headerlink" title="观察子树"></a>观察子树</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.innerHTML=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> observer=<span class="keyword">new</span> MutationObserver(<span class="function">(<span class="params">mutationRecords</span>)=&gt;</span><span class="built_in">console</span>.log(mutationRecords));</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>));</span><br><span class="line">observer.observe(<span class="built_in">document</span>.body,&#123;<span class="attr">attributes</span>:<span class="literal">true</span>,<span class="attr">subtree</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.firstChild.setAttribute(<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;baz&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="异步回调与记录队列"><a href="#异步回调与记录队列" class="headerlink" title="异步回调与记录队列"></a>异步回调与记录队列</h2><h3 id="takeRecords-方法"><a href="#takeRecords-方法" class="headerlink" title="takeRecords()方法"></a>takeRecords()方法</h3><p>清空记录队列，取出并·返回其中的所有MutationRecord实例,可以用在希望断开与观察目标的联系，但又希望处理由于disconnect()而被抛弃的记录队列中的MutationRecord实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer=<span class="keyword">new</span> MutationObserver(<span class="function">(<span class="params">mutationRecords</span>)=&gt;</span><span class="built_in">console</span>.log(mutationRecords));</span><br><span class="line">observer.observe(<span class="built_in">document</span>.body,&#123;<span class="attr">attributes</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.className=<span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.body.className=<span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(observer.takeRecords());</span><br><span class="line"><span class="built_in">console</span>.log(observer.takeRecords());</span><br><span class="line"><span class="comment">//[MutationRecord, MutationRecord]</span></span><br><span class="line"><span class="comment">//[]</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>BOM</title>
    <url>/2021/11/25/BOM/</url>
    <content><![CDATA[<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p>提供当前窗口加载文档的信息，以及通常的导航功能，它既是window的属性也是document的属性。</p>
<h3 id="查询字符串"><a href="#查询字符串" class="headerlink" title="查询字符串"></a>查询字符串</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> getQueryStringArgs=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//取得没有开头问号的查询字符串</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> qs=(location.search.length&gt;<span class="number">0</span>)?location.search.substring(<span class="number">1</span>):<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> args=&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span>(qs.split(<span class="string">&#x27;&amp;&#x27;</span>).map(<span class="function"><span class="params">kv</span>=&gt;</span>kv.split(<span class="string">&#x27;=&#x27;</span>))))&#123;</span><br><span class="line">        <span class="keyword">let</span> name=item[<span class="number">0</span>];</span><br><span class="line">            value=item[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(name.length)&#123;</span><br><span class="line">            args[name]=value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//qs=&quot;?q=javaScript&amp;num=10&quot;;</span></span><br><span class="line"><span class="keyword">let</span> args=getQueryStringArgs();</span><br><span class="line">alert(args[<span class="string">&quot;q&quot;</span>]);</span><br><span class="line">alert(args[<span class="string">&#x27;num&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<p>使用USLSearchParams检查和修改查询字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> qs=<span class="string">&quot;?q=javaScript&amp;num=10&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> searchParams=<span class="keyword">new</span> URLSearchParams(qs);</span><br><span class="line">alert(searchParams.toString());</span><br><span class="line">searchParams.has(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">searchParams.get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">searchParams.set(<span class="string">&quot;page&quot;</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line">alert(searchParams.toString());</span><br><span class="line">searchParams.delete(<span class="string">&quot;q&quot;</span>);</span><br><span class="line">alert(searchParams.toString());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> param <span class="keyword">of</span> searchParams)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="操作地址"><a href="#操作地址" class="headerlink" title="操作地址"></a>操作地址</h3><p>通过修改location对象修改浏览器地址，使用assign方法传进一个URL,会导航到新URL同时在浏览器历史记录增加一条记录，下面三种方法功能相同</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">location.assign(<span class="string">&quot;http://www.wrox.com&quot;</span>);</span><br><span class="line"><span class="built_in">window</span>.location=<span class="string">&quot;http://www.wrox.com&quot;</span>;</span><br><span class="line">location.href=<span class="string">&quot;http://www.wrox.com&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>通过修改location属性可以修改当前加载的页面,hash,search,hostname,pathname.port属性被设置为新值后会修改当前的URL</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设当前URL为http://www.wrox.com/WileyCDA/</span></span><br><span class="line">location.assign(<span class="string">&quot;http://www.wrox.com/WileyCDA&quot;</span>);</span><br><span class="line"><span class="comment">//把URL修改为http://www.wrox.com/WileyCDA/#section1</span></span><br><span class="line">location.hash=<span class="string">&quot;#section1&quot;</span>;</span><br><span class="line"><span class="comment">//把URL修改为http://www.wrox.com/WileyCDA/?q=javascript</span></span><br><span class="line">location.search=<span class="string">&quot;?q=javascript&quot;</span>;</span><br><span class="line"><span class="comment">//把URL修改为http://www.somewhere.com/WileyCDA/</span></span><br><span class="line">location.hostname=<span class="string">&quot;www.somewhere.com&quot;</span>;</span><br><span class="line"><span class="comment">//把URL修改为http://www.somewhere.com/mydir/</span></span><br><span class="line">location.pathname=<span class="string">&quot;mydir&quot;</span>;</span><br><span class="line"><span class="comment">//把URL修改为http://www.somewhere.com:8080/WileyCDA/</span></span><br><span class="line">location.port=<span class="number">8080</span>;</span><br></pre></td></tr></table></figure>

<p>以上的修改会在浏览器中增加记录，点击后退即可导航到前一个界面，不希望增加历史记录可以使用replace()方法，reload()可以重新加载当前页面，如果页面自从上次请求后没有修改过，则浏览器可能会从缓存中加载页面，如果想强制从服务器中加载，必须传入true</p>
<h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><p>history用来导航历史记录，同时不会暴露用户访问过的URL。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">history.go(-<span class="number">1</span>);<span class="comment">//后退一页</span></span><br><span class="line">history.go(<span class="number">1</span>);<span class="comment">//前进一页</span></span><br><span class="line">history.go(<span class="string">&quot;wrox.com&quot;</span>)<span class="comment">//导航到最近的wrox.com页面</span></span><br><span class="line"><span class="comment">//go有两个简写方法：back()和forward()</span></span><br><span class="line">history.back();<span class="comment">//后退一页</span></span><br><span class="line">history.forward()<span class="comment">//前进一页</span></span><br><span class="line"><span class="comment">//history的length属性记录历史记录有多少条目</span></span><br><span class="line"><span class="keyword">if</span>(history.length==<span class="number">1</span>)&#123;<span class="comment">//这是用户窗口第一个页面&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h2><p>navigator对象通常用来确定浏览器的类型</p>
<h3 id="检测插件"><a href="#检测插件" class="headerlink" title="检测插件"></a>检测插件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPlugin</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    name=name.toLowerCase();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> plugin <span class="keyword">of</span> <span class="built_in">window</span>.navigator.plugins)&#123;</span><br><span class="line">        <span class="keyword">if</span>(plugin.name.toLowerCase().indexOf(name)&gt;-<span class="number">1</span>)&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//alert(hasPlugin(&quot;Flash&quot;));</span></span><br><span class="line"><span class="comment">//alert(hasPlugin(&quot;QuickTime&quot;));</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasIEPlugin</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ActiveXObject(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ex)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在所有浏览器中检测插件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasFlash</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result=hasPlugin(<span class="string">&quot;Flash&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">        result=hasIEPlugin(<span class="string">&quot;ShockwaveFlash.ShockwaveFlash&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasQuickTime</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res=hasPlugin(<span class="string">&quot;QuickTime&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!res)&#123;</span><br><span class="line">        res=hasIEPlugin(<span class="string">&quot;QuickTime.QuickTime&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">alert(hasFlash());</span><br><span class="line">alert(hasQuickTime());</span><br></pre></td></tr></table></figure>

<h3 id="注册处理程序"><a href="#注册处理程序" class="headerlink" title="注册处理程序"></a>注册处理程序</h3><p>registerProtocolHandler()方法可以把一个网站注册处理为某种特定类型信息应用程序，传入3个参数：要处理的协议（“mailto或ftp),处理该协议的URL，以及应用名称</p>
<p>例如，把一个Web应用程序注册为默认客户端</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">navigator.registerProtocolHandler(<span class="string">&quot;mailto&quot;</span>,<span class="string">&quot;http://www.somemailclient.com?cmd=%s&quot;</span>,<span class="string">&quot;Some Mail Client&quot;</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>DOM扩展</title>
    <url>/2021/11/25/DOM%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h1 id="Selectors-API"><a href="#Selectors-API" class="headerlink" title="Selectors API"></a>Selectors API</h1><h2 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector()"></a>querySelector()</h2><p>接收CSS选择符参数，返回匹配模式的第一个后代元素，如果没有匹配项则返回null</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> body=<span class="built_in">document</span>.querySelector(<span class="string">&quot;body&quot;</span>);</span><br><span class="line"><span class="comment">//取得id名为myDiv的元素</span></span><br><span class="line"><span class="keyword">let</span> myDiv=<span class="built_in">document</span>.querySelector(<span class="string">&quot;#myDiv&quot;</span>);</span><br><span class="line"><span class="comment">//取得类名为“selector&quot;的第一个元素</span></span><br><span class="line"><span class="keyword">let</span> selected=<span class="built_in">document</span>.querySelector(<span class="string">&quot;.selected&quot;</span>);</span><br><span class="line"><span class="comment">//取得类名为&quot;button&quot;的图片</span></span><br><span class="line"><span class="keyword">let</span> img=<span class="built_in">document</span>.querySelector(<span class="string">&quot;img.button&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll()"></a>querySelectorAll()</h2><p>接收一个查询参数，返回所有匹配的节点，即一个NodeList的静态实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取得id为&#x27;myDiv&#x27;的&lt;div&gt;元素中的所有&lt;em&gt;元素</span></span><br><span class="line"><span class="keyword">let</span> ems=<span class="built_in">document</span>.getElementByid(<span class="string">&#x27;myDiv&#x27;</span>).querySelectorAll(<span class="string">&quot;em&quot;</span>);</span><br><span class="line"><span class="comment">//取得所有类名中包含&#x27;selected&#x27;的元素</span></span><br><span class="line"><span class="keyword">let</span> selecteds=<span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;.selected&quot;</span>);</span><br><span class="line"><span class="comment">//取得所有是&lt;p&gt;元素子元素的&lt;strong&gt;元素</span></span><br><span class="line"><span class="keyword">let</span> strongs=<span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;p strong&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> strong <span class="keyword">of</span> strongs)&#123;</span><br><span class="line">    strong.className=<span class="string">&quot;important&quot;</span>;</span><br><span class="line">    <span class="comment">//strong.item(i).className=&quot;important&quot;;</span></span><br><span class="line">    <span class="comment">//strong[i].className=&quot;important&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h2 id="getElementsByClassName"><a href="#getElementsByClassName" class="headerlink" title="getElementsByClassName()"></a>getElementsByClassName()</h2><p>接收一个参数，即包含一个或多个类名的字符串，返回类名中包含相应类的元素的NodeList</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取得所有类名中包含&#x27;username&#x27;和&#x27;current&#x27;元素</span></span><br><span class="line"><span class="keyword">let</span> allCurrentUsernames=<span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;username current&quot;</span>);</span><br><span class="line"><span class="comment">//取得id为“myDiv&quot;的元素子树中所有包含&#x27;selected’类的元素</span></span><br><span class="line"><span class="keyword">let</span> selected=<span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).getElementsByClassName(<span class="string">&quot;selected&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这个方法返回以调用它的对象为根元素的子树中所有匹配的元素，在document上调用getElementsByClassName()返回文档中所有匹配的元素，而在特定元素中调用getElementsByClassName()返回该元素后代中匹配的元素</p>
<h2 id="classList属性"><a href="#classList属性" class="headerlink" title="classList属性"></a>classList属性</h2><ul>
<li><p>add(value)</p>
</li>
<li><p>contains(value)</p>
</li>
<li><p>remove(value)</p>
</li>
<li><p>toggle(value)：如果类名列表中已经存在指定的value，则删除，如果不存在，添加</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">div.classList.remove(<span class="string">&quot;disabled&quot;</span>);</span><br><span class="line">div.classList.add(<span class="string">&quot;current&quot;</span>);</span><br><span class="line"><span class="comment">//检测类名</span></span><br><span class="line"><span class="keyword">if</span>(div.classList.contains(<span class="string">&quot;bd&quot;</span>)&amp;&amp;!div.classList.contains(<span class="string">&quot;disabled&quot;</span>))&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="焦点管理"><a href="#焦点管理" class="headerlink" title="焦点管理"></a>焦点管理</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> button=<span class="built_in">document</span>.getElementById(<span class="string">&quot;myButton&quot;</span>);</span><br><span class="line">button.focus();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.activeElement===button);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.hasFocus());<span class="comment">//true文档已经拥有焦点</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>reduce</title>
    <url>/2022/01/07/reduce/</url>
    <content><![CDATA[<blockquote>
<p>arr.reduce(callback(accumulator,currentValue,index,array),InitValue)</p>
</blockquote>
<p>callback:执行数组中的每个值的函数，包括4个参数：</p>
<p><strong><code>accumulator</code></strong></p>
<ul>
<li><p><code>currentValue</code></p>
<p>数组中正在处理的元素。</p>
</li>
<li><p><code>index</code> 可选</p>
<p>数组中正在处理的当前元素的索引。 如果提供了<code>initialValue</code>，则起始索引号为0，否则从索引1起始。</p>
</li>
<li><p><code>array</code>可选</p>
<p>调用<code>reduce()</code>的数组</p>
</li>
</ul>
<p><code>initialValue</code>可选</p>
<p>作为第一次调用 <code>callback</code>函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。</p>
<p>返回累计处理后的结果</p>
<h1 id="求数组中的所有值的和"><a href="#求数组中的所有值的和" class="headerlink" title="求数组中的所有值的和"></a>求数组中的所有值的和</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator,currentValue</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> accumulator+currentValue;</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="comment">//6</span></span><br><span class="line"><span class="comment">//累加对象数组里的值</span></span><br><span class="line"><span class="keyword">var</span> InitValue=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> sum=[&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;,&#123;<span class="attr">x</span>:<span class="number">2</span>&#125;,&#123;<span class="attr">x</span>:<span class="number">3</span>&#125;].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator,currentValue</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> accumulator+currentValue;</span><br><span class="line">&#125;,InitValue);</span><br><span class="line"><span class="built_in">console</span>.log(sum);<span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<h1 id="将二维数组转为一维"><a href="#将二维数组转为一维" class="headerlink" title="将二维数组转为一维"></a>将二维数组转为一维</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> flattened=[[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>]].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a.concat(b);&#125;,[])</span><br></pre></td></tr></table></figure>

<h1 id="计算数组中每个元素出现的个数"><a href="#计算数组中每个元素出现的个数" class="headerlink" title="计算数组中每个元素出现的个数"></a>计算数组中每个元素出现的个数</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names=[<span class="string">&#x27;Alice&#x27;</span>,<span class="string">&#x27;Bob&#x27;</span>,<span class="string">&#x27;Ann&#x27;</span>,<span class="string">&#x27;Alice&#x27;</span>,<span class="string">&#x27;Bob&#x27;</span>];</span><br><span class="line">    <span class="keyword">var</span> countNames=names.reduce(<span class="function">(<span class="params">allNames,name</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(name <span class="keyword">in</span> allNames)&#123;</span><br><span class="line">            allNames[name]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            allNames[name]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allNames;</span><br><span class="line">    &#125;,&#123;&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(countNames);</span><br></pre></td></tr></table></figure>

<h1 id="按照属性对object分类"><a href="#按照属性对object分类" class="headerlink" title="按照属性对object分类"></a>按照属性对object分类</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> people=[</span><br><span class="line">        &#123;<span class="attr">name</span>:<span class="string">&#x27;Alice&#x27;</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">name</span>:<span class="string">&#x27;Max&#x27;</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">name</span>:<span class="string">&#x27;Jane&#x27;</span>,<span class="attr">age</span>:<span class="number">21</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">groupBy</span>(<span class="params">objectArray,property</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objectArray.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">acc,obj</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> key=obj[property];</span><br><span class="line">            <span class="keyword">if</span>(!acc[key])&#123;</span><br><span class="line">                acc[key]=[];</span><br><span class="line">            &#125;</span><br><span class="line">            acc[key].push(obj);</span><br><span class="line">            <span class="keyword">return</span> acc;</span><br><span class="line"></span><br><span class="line">        &#125;,&#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> groupedPeople=groupBy(people,<span class="string">&#x27;age&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(groupedPeople);</span><br></pre></td></tr></table></figure>

<h1 id="使用扩展运算符绑定包含在对象数组中的数组"><a href="#使用扩展运算符绑定包含在对象数组中的数组" class="headerlink" title="使用扩展运算符绑定包含在对象数组中的数组"></a>使用扩展运算符绑定包含在对象数组中的数组</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> friends=[&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;Anna&#x27;</span>,</span><br><span class="line">        <span class="attr">books</span>:[<span class="string">&#x27;Bible&#x27;</span>,<span class="string">&#x27;Harry Potter&#x27;</span>],</span><br><span class="line">        <span class="attr">age</span>:<span class="number">21</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>:<span class="string">&#x27;Bob&#x27;</span>,<span class="attr">books</span>:[<span class="string">&#x27;War and Peace&#x27;</span>],<span class="attr">age</span>:<span class="number">16</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>:<span class="string">&#x27;Mike&#x27;</span>,<span class="attr">books</span>:[<span class="string">&#x27;The Shining&#x27;</span>,<span class="string">&#x27;The Lord of the Rings&#x27;</span>],<span class="attr">age</span>:<span class="number">18</span>&#125;];</span><br><span class="line">    <span class="keyword">var</span> allBooks=friends.reduce(<span class="function">(<span class="params">prev,curr</span>)=&gt;</span>&#123;<span class="keyword">return</span> [...prev,...curr.books]&#125;,[<span class="string">&#x27;Alphabet&#x27;</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(allBooks);</span><br></pre></td></tr></table></figure>

<h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myArray=[<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">  <span class="keyword">let</span> myOrderedArray=myArray.reduce(<span class="function">(<span class="params">accumulator,currval</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(accumulator.indexOf(currval)==-<span class="number">1</span>)&#123;</span><br><span class="line">          accumulator.push(currval);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> accumulator;</span><br><span class="line"></span><br><span class="line">  &#125;,[])</span><br><span class="line">  <span class="built_in">console</span>.log(myOrderedArray);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>HTML+CSS</title>
    <url>/2021/11/25/HTML+CSS/</url>
    <content><![CDATA[<h2 id="定位："><a href="#定位：" class="headerlink" title="定位："></a><strong>定位</strong>：</h2><h3 id="定位总结："><a href="#定位总结：" class="headerlink" title="定位总结："></a><strong>定位总结：</strong></h3><ol>
<li>static: 不脱标，不能使用边偏移</li>
<li>relative:不脱标（占有位置），可用margin,相对于自身位置移动</li>
<li>absolute:脱标（不占有位置）,不可用margin,带有定位的父级</li>
<li>fixed：脱标（不占有位置），浏览器可视区</li>
<li>sticky:不脱标（占有位置），浏览器可视区</li>
</ol>
<ul>
<li><p>绝对定位特点：如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位 </p>
</li>
<li><p> 如果祖先元素有定位（相对，绝对，固定定位）则以最近一级的有定位的祖先元素为参考点移动位置 </p>
</li>
<li><p>绝对定位不占有原先的位置（脱标） </p>
</li>
</ul>
<h3 id="叠放次序-z-index"><a href="#叠放次序-z-index" class="headerlink" title="叠放次序 z-index"></a><strong>叠放次序 z-index</strong></h3><p>在使用定位布局时，可以使用z-index来控制盒子的前后次序</p>
<p>语法：</p>
<h4 id="选择器-z-index-1"><a href="#选择器-z-index-1" class="headerlink" title="选择器{z-index:1;}"></a>选择器{z-index:1;}</h4><ul>
<li>数值可以是正整数，负整数或者0，默认是auto，数值越大，盒子越靠上</li>
<li>如果属性相同，则按照书写顺序，后来居上</li>
<li>数字后面不能加单位</li>
<li>只有定位的盒子才有z-index属性</li>
</ul>
<h2 id="定位的拓展"><a href="#定位的拓展" class="headerlink" title="定位的拓展"></a>定位的拓展</h2><h4 id="1-绝对定位盒子居中"><a href="#1-绝对定位盒子居中" class="headerlink" title="1.绝对定位盒子居中"></a>1.<strong>绝对定位盒子居中</strong></h4><ul>
<li><code>left:50%</code></li>
<li><code>margin-left:-100px;</code></li>
</ul>
<h4 id="2-定位特殊性："><a href="#2-定位特殊性：" class="headerlink" title="2.定位特殊性："></a>2.<strong>定位特殊性：</strong></h4><p>绝对定位固定定位和浮动相似</p>
<ol>
<li><p>行内元素添加绝对或者固定定位，可以直接设置高度和宽度（span)</p>
</li>
<li><p>块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小</p>
</li>
<li><p>脱标的盒子不会触发外边距合并问题</p>
</li>
</ol>
<h4 id="3-绝对定位（固定定位）会完全压住盒子"><a href="#3-绝对定位（固定定位）会完全压住盒子" class="headerlink" title="3.绝对定位（固定定位）会完全压住盒子"></a><strong>3.绝对定位（固定定位）会完全压住盒子</strong></h4><p>浮动元素只会压住下面标准流的盒子，但是不会压住下面标准流的文字（图片）但是绝对定位（固定定位）会压住下面标准流的所有内容</p>
<p>浮动之所以不会压住下面文字是因为浮动最初的目的是为了做文字环绕效果</p>
<h2 id="元素里的显示和隐藏"><a href="#元素里的显示和隐藏" class="headerlink" title="元素里的显示和隐藏"></a>元素里的显示和隐藏</h2><p>display 显示隐藏元素 但是不保留位置 隐藏元素不想要原来位置，用none，否则用block</p>
<p>visibility显示隐藏元素 但是保留原来的位置,visible为元素可见，hidden为元素隐藏</p>
<p>overflow 溢出显示隐藏 但是只是对于溢出的部分处理,scoll:溢出的部分显示滚动条，visible:溢出部分可见,hidden:溢出部分不可见,auto:没溢出则不显示滚动条，溢出则超出部分显示滚动条。</p>
<h2 id="用户界面样式"><a href="#用户界面样式" class="headerlink" title="用户界面样式"></a>用户界面样式</h2><h3 id="鼠标样式cursor"><a href="#鼠标样式cursor" class="headerlink" title="鼠标样式cursor"></a>鼠标样式cursor</h3><p><code>li &#123;cursor: pointer; &#125;</code></p>
<p><code>default 默认小白鼠标</code></p>
<p><code>pointer 小手</code></p>
<p><code>move 移动</code></p>
<p><code>text 文本</code></p>
<p><code>not-allowed 禁止</code></p>
<h3 id="vertical-align实现行内块和文字居中对齐"><a href="#vertical-align实现行内块和文字居中对齐" class="headerlink" title="vertical-align实现行内块和文字居中对齐"></a>vertical-align实现行内块和文字居中对齐</h3><p><code>vertical-align:middle</code></p>
<h4 id="解决图片底部默认空白空隙：图片底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐"><a href="#解决图片底部默认空白空隙：图片底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐" class="headerlink" title="解决图片底部默认空白空隙：图片底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐"></a>解决图片底部默认空白空隙：图片底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐</h4><h5 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h5><p>1.给图片添加vertical-align:middle或者top或者bottom</p>
<p>2.把图片转为块级元素 display:block</p>
<h3 id="单行文字溢出显示省略号"><a href="#单行文字溢出显示省略号" class="headerlink" title="单行文字溢出显示省略号"></a>单行文字溢出显示省略号</h3><p><code>white-space:nomal:如果文字显示不开自动换行</code></p>
<p><code>white-space:nowrap:如果文字显示不开强制一行内显示</code></p>
<p><code>overflow:hidden(溢出部分隐藏)</code></p>
<p><code>text-overflow:ellipsis(文字溢出部分用省略号显示)</code></p>
<h3 id="多行文本溢出显示省略号"><a href="#多行文本溢出显示省略号" class="headerlink" title="多行文本溢出显示省略号"></a>多行文本溢出显示省略号</h3><p>​    <code>width: 150px;</code></p>
<p>​      <code>height: 65px;</code></p>
<p>​      <code>background-color: pink;</code></p>
<p>​      <code>margin: 100px auto;</code></p>
<p>​      <code>overflow: hidden;</code></p>
<p>​      <code>text-overflow: ellipsis;</code></p>
<p>​      <code>display: -webkit-box;</code></p>
<p>​      <code>/* 从第几行开始省略 */</code></p>
<p>​      <code>-webkit-line-clamp: 3;</code></p>
<p>​      <code>-webkit-box-orient: vertical;</code></p>
<h2 id="常见布局技巧"><a href="#常见布局技巧" class="headerlink" title="常见布局技巧"></a>常见布局技巧</h2><h4 id="margin负值使用"><a href="#margin负值使用" class="headerlink" title="margin负值使用"></a>margin负值使用</h4><p>让每个盒子margin往左移动-1px，正好压住相邻盒子的边框</p>
<p>鼠标经过盒子提高当前盒子层级（如果没有定位，则加相对定位（保留位置）如果都有定位则用z-index)</p>
<h4 id="文字围绕浮动元素"><a href="#文字围绕浮动元素" class="headerlink" title="文字围绕浮动元素"></a>文字围绕浮动元素</h4><p>三角形制作</p>
<p><code>weight:0;</code></p>
<p><code>height:0;</code></p>
<p><code>border-color:transparent red transparent transprent;</code></p>
<p><code>border-style:solid;</code></p>
<p><code>border-width:22px 8px 0 0;(上面的宽，右边的小一些)</code></p>
<h2 id="HTML新标签"><a href="#HTML新标签" class="headerlink" title="HTML新标签"></a>HTML新标签</h2><p>header:头部标签</p>
<p>nav：导航标签</p>
<p>article:内容标签</p>
<p>section:定义文档某个区域</p>
<p>aside:侧边栏标签</p>
<p>footer：尾部标签</p>
<p>主要针对搜索引擎，这些新标签页面中可以使用多次，在IE9中，需要把这些元素转换为块级元素</p>
<h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频<video></h3><p>用mp4格式</p>
<video>
</video>

<p>autoplay:自动播放</p>
<p>controls:向用户使用播放控件</p>
<p>width:设置播放器宽度</p>
<p>height:设置高度</p>
<p>loop:是否循环播放</p>
<p>src：url（视频url地址）</p>
<p>poster:加载等待的画面图片</p>
<p>muted：静音播放</p>
<h3 id="新增input表单"><a href="#新增input表单" class="headerlink" title="新增input表单"></a>新增input表单</h3><p>type=”email”</p>
<p>type=”url”</p>
<p>type=”date”</p>
<p>type=”time”</p>
<p>type=”month”</p>
<p>type=”week”</p>
<p>type=”numbers”</p>
<p>type=”tel”</p>
<p>type=”search”</p>
<p>type=”color”</p>
<p>input属性</p>
<p>required=”requied”表示该内容不能为空，必填</p>
<p>placeholder=”placeholder”提示文本，表单提示信息</p>
<p>autofocus=”autofocus”自动聚焦属性，页面加载完成自动聚焦到指定表单</p>
<p>autocomplete：默认为on，当用户键入字段时基于之前键入的值显示出字段，关闭为off</p>
<p>multiple:可以多选文件提交</p>
<h3 id="新增选择器"><a href="#新增选择器" class="headerlink" title="新增选择器"></a>新增选择器</h3><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><p>E[att]选择具有att属性的E元素</p>
<p>E[att=”val”]选择具有att属性且属性值等于val的E元素</p>
<p>E[att^=”val”]选择具有att属性且属性值以val开头</p>
<p>E[att$=”val”]选择具有att属性且属性值中含有val的E元素</p>
<h4 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h4><p>E:first-child:匹配父元素的第一个子元素</p>
<p>E:last-child:匹配父元素的最后一个元素</p>
<p>E:nth-child(n)匹配父元素的第n个元素</p>
<p>E:nth-child(even)匹配父元素的第偶数个元素，odd则第奇数个元素</p>
<p>E:nth-child(n)，从0开始计算，但是第0个元素或者超出元素个数会被忽略</p>
<p>nth-child(2n):偶数，2n+1:奇数 5n:5 10 15… </p>
<p>n+5:从第5个开始到最后</p>
<p>-n+5：前5个（包含第5个）</p>
<p>nth-of-type():会把指定孩子排序号，执行的时候先看E指定的元素，之后根据E回去看是第几个孩子</p>
<p>nth-child:对于父元素里面所有孩子进行排序选择，先找到第n个孩子，然后看着是否和E匹配</p>
<p>无序列表用nth-child比较多</p>
<p>类选择器，属性选择器和伪类选择器权重为10</p>
<h4 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h4><p>::before:在元素内部的前面插入内容</p>
<p>::after:在元素内部的后面插入内容</p>
<ul>
<li>before和after创建一个元素，属于行内元素</li>
<li>新创建的这个元素在文档树中找不到，因此称为伪元素</li>
<li>语法：element::before{},</li>
<li>before和after必须有content属性</li>
<li>伪元素和标签选择器一样，权重为1</li>
</ul>
<h5 id="伪元素选择器：清除浮动"><a href="#伪元素选择器：清除浮动" class="headerlink" title="伪元素选择器：清除浮动"></a>伪元素选择器：清除浮动</h5><p>.clearfix:after {</p>
<p>content:’’;</p>
<p>display:block;//插入的元素必须是块级</p>
<p>height:0;//不要看见这个元素</p>
<p>clear:both;</p>
<p>visibility:hidden;//不要看见这个元素</p>
<p>}</p>
<p>.clearfix:before,.clearfix:after {</p>
<p>content:’’;</p>
<p>diaplay:table;//元素在一行显示且转化为块级元素</p>
<p>}</p>
<h3 id="CSS盒子模型"><a href="#CSS盒子模型" class="headerlink" title="CSS盒子模型"></a>CSS盒子模型</h3><p>box-sizing:content-box，盒子大小为width+padding+border(CSS3之前默认)</p>
<p>box-sizing:border-box,盒子大小为width</p>
<p>如果盒子模型我们改为了box-sizing：border-box，那padding和border就不会撑大盒子（前提padding和border不会超过width宽度）</p>
<h3 id="CSS过渡（重点）"><a href="#CSS过渡（重点）" class="headerlink" title="CSS过渡（重点）"></a>CSS过渡（重点）</h3><p>transition:要过渡的属性  花费时间   运动曲线  何时开始</p>
<p>1属性：想要变化的CSS属性，宽度高度 背景颜色内外边距都可以 如果想要所有属性都变化过度则用all</p>
<p>2花费时间：单位是秒（必需写单位</p>
<p>3运动曲线默认为ease</p>
<p>4何时开始：单位是秒 可以设置延迟触发时间 默认是0s</p>
<h1 id="CSS-filter属性"><a href="#CSS-filter属性" class="headerlink" title="CSS filter属性"></a>CSS filter属性</h1><p>修改图片的颜色为黑白</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">img&#123;filter:grayscale(100%)&#125;</span><br></pre></td></tr></table></figure>































]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
  </entry>
  <entry>
    <title>toggle</title>
    <url>/2022/01/03/toggle/</url>
    <content><![CDATA[<h1 id="DOMTokenList-toggle"><a href="#DOMTokenList-toggle" class="headerlink" title="DOMTokenList.toggle()"></a>DOMTokenList.toggle()</h1><p>DOMTokenList接口的toggle()方法从列表中删除一个给定的标记并返回false,如果标记不存在，则添加并且函数返回true</p>
<blockquote>
<p>tokenList.toggle(token,force);</p>
</blockquote>
<h4 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h4><p>token:标记列表中你想探查并切换的DOMSring</p>
<p>force(可选):Boolean值，设置后会将方法变成单向操作，如果设置为false，则会删除标记列表中匹配的给定标记，且不会再添加，如设置为true，则将在标记中添加给定标记，且不会再度删除</p>
<h4 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h4><p>为布尔值</p>
<h1 id="eg"><a href="#eg" class="headerlink" title="eg"></a>eg</h1><p>HTML</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;a b&quot;</span>&gt;</span>classList is &#x27;a b&#x27;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> span = <span class="built_in">document</span>.querySelector(<span class="string">&quot;span&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> classes = span.classList;</span><br><span class="line">span.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = classes.toggle(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(result) &#123;</span><br><span class="line">    span.textContent = <span class="string">&quot;&#x27;c&#x27; added; classList is now &#x27;&quot;</span> + classes + <span class="string">&quot;&#x27;.&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    span.textContent = <span class="string">&quot;&#x27;c&#x27; removed; classList is now &#x27;&quot;</span> + classes + <span class="string">&quot;&#x27;.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2022/01/06/Promise/</url>
    <content><![CDATA[<h1 id="期约状态机"><a href="#期约状态机" class="headerlink" title="期约状态机"></a>期约状态机</h1><p>Promise可以通过 new 操作符来实例化。创建新期约时需要传入<br>执行器（executor）函数作为参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在把一个期约实例传给 console.log()时，控制台输出（可能因浏览器不同而略有差异）表明该实例处于待定（pending）状态。如前所述，期约是一个有状态的对象，可能处于如下 3 种状态之一：</p>
<ul>
<li><p><strong>待定</strong>（pending）是期约的最初始状态。在待定状态下，<strong>期约可以落定（settled）为代表成功的兑现（fulfilled）状态，或者代表失败的拒绝（rejected）状态。</strong>无论落定为哪种状态都是不可逆的。只要从待定转换为兑现或拒绝，期约的状态就不再改变。而有时候也称为“解决”，resolved）</p>
</li>
<li><p><strong>兑现</strong>（fulfilled)每个期约只要状态切换为兑现，就会有一个私有的内部值（value）</p>
</li>
<li><p><strong>拒绝</strong>（rejected）如果期约被拒绝，程序就会期待期约状态改变时可以拿到拒绝的理由</p>
<h2 id="期约用途"><a href="#期约用途" class="headerlink" title="期约用途"></a>期约用途</h2><p>期约主要有两大用途。首先是抽象地表示一个异步操作。期约的状态代表期约是否完成。某些情况下，这个状态机就是期约可以提供的最有用的信息。</p>
</li>
</ul>
<h1 id="通过执行函数控制期约状态"><a href="#通过执行函数控制期约状态" class="headerlink" title="通过执行函数控制期约状态"></a>通过执行函数控制期约状态</h1><p>期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：<strong>初始化期约的异步行为和控制状态的最终转换</strong>。其中，控制期约状态的转换是<br>通过调用它的两个函数参数实现的。这两个函数参数通常都命名为 resolve()和 reject()。调用resolve()会把状态切换为兑现，调用 reject()会把状态切换为拒绝。另外，调用 reject()也会抛出错误</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>resolve());</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,p1);<span class="comment">//Promise &lt;resolved&gt;</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject());</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;</span></span><br><span class="line"><span class="comment">// Uncaught error (in promise)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在前面的例子中，并没有什么异步操作，因为在初始化期约时，执行器函数已经改变了每个期约的状态，执行器函数是同步执行的。这是因为执行器函数是期约的初始化程序。</p>
<p>添加 setTimeout 可以推迟切换状态：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>));</span><br><span class="line"><span class="comment">// 在 console.log 打印期约实例的时候，还不会执行超时回调（即 resolve()）</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>无论 resolve()和 reject()中的哪个被调用，状态转换都不可撤销了。于是继续修改状态会静默失败，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">resolve();</span><br><span class="line">reject(); <span class="comment">// 没有效果</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p); <span class="comment">// Promise &lt;resolved&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h1><p>下面两个期约实例实际上是一样的：</p>
<blockquote>
<p>let p1 = new Promise((resolve, reject) =&gt; resolve());<br>let p2 = Promise.resolve();</p>
</blockquote>
<p>这个解决的期约的值对应着传给 Promise.resolve()的第一个参数。使用这个静态方法，实际上可以把任何值都转换为一个期约</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,<span class="built_in">Promise</span>.resolve());</span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.resolve(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: 3</span></span><br><span class="line"><span class="comment">// 多余的参数会忽略</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.resolve(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: 4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此，Promise.resolve()可以说是一个幂等方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">7</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p === <span class="built_in">Promise</span>.resolve(p));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p === <span class="built_in">Promise</span>.resolve(<span class="built_in">Promise</span>.resolve(p)));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">//这个幂等性会保留传入期约的状态：</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.resolve(p)); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p === <span class="built_in">Promise</span>.resolve(p)); <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，这个静态方法能够包装任何非期约值，包括错误对象，并将其转换为解决的期约。因此，也可能导致不符合预期的行为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p);</span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: Error: foo</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h1><p>与 Promise.resolve()类似，Promise.reject()会实例化一个拒绝的期约并抛出一个异步错误（这个错误不能通过 try/catch 捕获，而只能通过拒绝处理程序捕获）。下面的两个期约实例实际上是一样的：</p>
<blockquote>
<p>let p1 = new Promise((resolve, reject) =&gt; reject());<br>let p2 = Promise.reject();</p>
</blockquote>
<p>这个拒绝的期约的理由就是传给 Promise.reject()的第一个参数。这个参数也会传给后续的拒绝处理程序：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.reject(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p); <span class="comment">// Promise &lt;rejected&gt;: 3</span></span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, e)); <span class="comment">// 3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关键在于，Promise.reject()并没有照搬 Promise.resolve()的幂等逻辑。如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.reject(<span class="built_in">Promise</span>.resolve()));</span><br><span class="line"><span class="comment">// Promise &lt;rejected&gt;: Promise &lt;resolved&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="同步-异步执行的二元性"><a href="#同步-异步执行的二元性" class="headerlink" title="同步/异步执行的二元性"></a>同步/异步执行的二元性</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(e); <span class="comment">// Error: foo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught (in promise) Error: bar</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一个 try/catch 抛出并捕获了错误，第二个 try/catch 抛出错误却没有捕获到,这里的同步代码之所以没有捕获期约抛出的错误，是因为它没有通过异步模式捕获错误。从这里就可以看出期约真正的异步特性：它们是<strong>同步对象（</strong>在同步执行模式中使用），但也是<strong>异步执行模式</strong><br>的媒介。<br>在前面的例子中，<strong>拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的</strong>。因此，try/catch 块并不能捕获该错误。代码一旦开始以异步模式执行，则唯一与之交互<br>的方式就是使用异步结构——更具体地说，就是期约的方法。</p>
<h1 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h1><p>Promise.prototype.then()是为期约实例添加处理程序的主要方法。这个 then()方法接收最多 两个参数：onResolved 处理程序和 onRejected 处理程序。这两个参数都是<strong>可选</strong>的，如果提供的话，则会在期约分别进入“兑现”和“拒绝”状态时执行。传给 then()的任何<strong>非函数类型的参数都会被静 默忽略</strong>。如果想只提供 onRejected 参数，那就要在 onResolved 参数的位置上传入 undefined。这 样有助于避免在内存中创建多余的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onResolved</span>(<span class="params">id</span>) </span>&#123; </span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, id, <span class="string">&#x27;resolved&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">id</span>) </span>&#123; </span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, id, <span class="string">&#x27;rejected&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">3000</span>)); </span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">3000</span>)); </span><br><span class="line">p1.then(<span class="function">() =&gt;</span> onResolved(<span class="string">&#x27;p1&#x27;</span>), </span><br><span class="line"> <span class="function">() =&gt;</span> onRejected(<span class="string">&#x27;p1&#x27;</span>)); </span><br><span class="line">p2.then(<span class="function">() =&gt;</span> onResolved(<span class="string">&#x27;p2&#x27;</span>), </span><br><span class="line"> <span class="function">() =&gt;</span> onRejected(<span class="string">&#x27;p2&#x27;</span>)); </span><br><span class="line"><span class="comment">//（3 秒后）</span></span><br><span class="line"><span class="comment">// p1 resolved </span></span><br><span class="line"><span class="comment">// p2 rejected</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onResolved</span>(<span class="params">id</span>) </span>&#123; </span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, id, <span class="string">&#x27;resolved&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">id</span>) </span>&#123; </span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, id, <span class="string">&#x27;rejected&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">3000</span>)); </span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">3000</span>)); </span><br><span class="line"><span class="comment">// 非函数处理程序会被静默忽略，不推荐</span></span><br><span class="line">p1.then(<span class="string">&#x27;gobbeltygook&#x27;</span>); </span><br><span class="line"><span class="comment">// 不传 onResolved 处理程序的规范写法</span></span><br><span class="line">p2.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> onRejected(<span class="string">&#x27;p2&#x27;</span>)); </span><br><span class="line"><span class="comment">// p2 rejected（3 秒后</span></span><br></pre></td></tr></table></figure>

<p>Promise.prototype.then()方法返回一个新的期约实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;); </span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1 === p2); <span class="comment">// false </span></span><br></pre></td></tr></table></figure>

<p>这个新期约实例基于 onResovled 处理程序的返回值构建。换句话说，该处理程序的返回值会通过 Promise.resolve()包装来生成新期约。如果没有提供这个处理程序，则 Promise.resolve()就会 包装上一个期约解决之后的值。如果没有显式的返回语句，则 Promise.resolve()会包装默认的返回 值 undefined。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="comment">// 若调用 then()时不传处理程序，则原样向后传</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.then();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;resolved&gt;: foo </span></span><br><span class="line"><span class="comment">// 这些都一样</span></span><br><span class="line"><span class="keyword">let</span> p3 = p1.then(<span class="function">() =&gt;</span> <span class="literal">undefined</span>); </span><br><span class="line"><span class="keyword">let</span> p4 = p1.then(<span class="function">() =&gt;</span> &#123;&#125;); </span><br><span class="line"><span class="keyword">let</span> p5 = p1.then(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve()); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;resolved&gt;: undefined </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p4); <span class="comment">// Promise &lt;resolved&gt;: undefined </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p5); <span class="comment">// Promise &lt;resolved&gt;: undefined </span></span><br><span class="line"><span class="comment">//如果有显式的返回值，则 Promise.resolve()会包装这个值：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些都一样</span></span><br><span class="line"><span class="keyword">let</span> p6 = p1.then(<span class="function">() =&gt;</span> <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> p7 = p1.then(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;bar&#x27;</span>)); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p6); <span class="comment">// Promise &lt;resolved&gt;: bar </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p7); <span class="comment">// Promise &lt;resolved&gt;: bar </span></span><br><span class="line"><span class="comment">// Promise.resolve()保留返回的期约</span></span><br><span class="line"><span class="keyword">let</span> p8 = p1.then(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)); </span><br><span class="line"><span class="keyword">let</span> p9 = p1.then(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.reject()); </span><br><span class="line"><span class="comment">// Uncaught (in promise): undefined </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p8); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p9); <span class="comment">// Promise &lt;rejected&gt;: undefined</span></span><br><span class="line"><span class="comment">//抛出异常会返回拒绝的期约：</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> p10 = p1.then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">&#x27;baz&#x27;</span>; &#125;); </span><br><span class="line"><span class="comment">// Uncaught (in promise) baz </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p10); <span class="comment">// Promise &lt;rejected&gt; baz </span></span><br><span class="line"><span class="comment">//注意，返回错误值不会触发上面的拒绝行为，而会把错误对象包装在一个解决的期约中：</span></span><br><span class="line">... </span><br><span class="line"><span class="keyword">let</span> p11 = p1.then(<span class="function">() =&gt;</span> <span class="built_in">Error</span>(<span class="string">&#x27;qux&#x27;</span>)); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p11); <span class="comment">// Promise &lt;resolved&gt;: Error: qux </span></span><br></pre></td></tr></table></figure>

<p>onRejected 处理程序也与之类似：onRejected 处理程序返回的值也会<strong>被 Promise.resolve() 包装</strong>。乍一看这可能有点违反直觉，但是想一想，onRejected 处理程序的任务不就是捕获异步错误吗？ 因此，拒绝处理程序在捕获错误后不抛出异常是符合期约的行为，应该返回一个解决期约</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="comment">// 调用 then()时不传处理程序则原样向后传</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(); </span><br><span class="line"><span class="comment">// Uncaught (in promise) foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;: foo </span></span><br><span class="line"><span class="comment">// 这些都一样</span></span><br><span class="line"><span class="keyword">let</span> p3 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="literal">undefined</span>); </span><br><span class="line"><span class="keyword">let</span> p4 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> &#123;&#125;); </span><br><span class="line"><span class="keyword">let</span> p5 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve()); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;resolved&gt;: undefined </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p4); <span class="comment">// Promise &lt;resolved&gt;: undefined </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p5); <span class="comment">// Promise &lt;resolved&gt;: undefined </span></span><br><span class="line"><span class="comment">// 这些都一样</span></span><br><span class="line"><span class="keyword">let</span> p6 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> p7 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;bar&#x27;</span>)); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p6); <span class="comment">// Promise &lt;resolved&gt;: bar </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p7); <span class="comment">// Promise &lt;resolved&gt;: bar </span></span><br><span class="line"><span class="comment">// Promise.resolve()保留返回的期约</span></span><br><span class="line"><span class="keyword">let</span> p8 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)); </span><br><span class="line"><span class="keyword">let</span> p9 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">Promise</span>.reject()); </span><br><span class="line"><span class="comment">// Uncaught (in promise): undefined </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p8); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p9); <span class="comment">// Promise &lt;rejected&gt;: undefined </span></span><br><span class="line"><span class="keyword">let</span> p10 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">&#x27;baz&#x27;</span>; &#125;); </span><br><span class="line"><span class="comment">// Uncaught (in promise) baz </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p10); <span class="comment">// Promise &lt;rejected&gt;: baz </span></span><br><span class="line"><span class="keyword">let</span> p11 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">Error</span>(<span class="string">&#x27;qux&#x27;</span>)); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p11); <span class="comment">// Promise &lt;resolved&gt;: Error: qux </span></span><br></pre></td></tr></table></figure>

<h1 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h1><p>Promise.prototype.catch()方法用于<strong>给期约添加拒绝处理程序</strong>。这个方法只接收一个参数： onRejected 处理程序。事实上，这个方法就是一个语法糖，调用它就相当于<strong>调用 Promise.prototype.  then(null, onRejected)</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.reject(); </span><br><span class="line"><span class="keyword">let</span> onRejected = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; </span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;rejected&#x27;</span>); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 这两种添加拒绝处理程序的方式是一样的：</span></span><br><span class="line">p.then(<span class="literal">null</span>, onRejected); <span class="comment">// rejected </span></span><br><span class="line">p.catch(onRejected); <span class="comment">// rejected</span></span><br></pre></td></tr></table></figure>

<p>Promise.prototype.catch()返回一个新的期约实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;); </span><br><span class="line"><span class="keyword">let</span> p2 = p1.catch(); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1 === p2); <span class="comment">// false </span></span><br></pre></td></tr></table></figure>

<h1 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h1><p>Promise.prototype.finally()方法用于给期约添加 onFinally 处理程序，这个处理程序在期 约转换为解决或拒绝状态时都会执行。这个方法可以避免 onResolved 和 onRejected 处理程序中出 现冗余代码。但 onFinally 处理程序没有办法知道期约的状态是解决还是拒绝，所以这个方法主要用清理代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(); </span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject(); </span><br><span class="line"><span class="keyword">let</span> onFinally = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;Finally!&#x27;</span>) </span><br><span class="line">&#125; </span><br><span class="line">p1.finally(onFinally); <span class="comment">// Finally </span></span><br><span class="line">p2.finally(onFinally); <span class="comment">// Finally</span></span><br></pre></td></tr></table></figure>

<p>Promise.prototype.finally()方法返回一个新的期约实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;); </span><br><span class="line"><span class="keyword">let</span> p2 = p1.finally();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1 === p2); <span class="comment">// false </span></span><br></pre></td></tr></table></figure>

<p>这个新期约实例不同于 then()或 catch()方式返回的实例。因为 onFinally 被设计为一个状态 无关的方法，所以在大多数情况下它<strong>将表现为父期约的传递</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="comment">// 这里都会原样后传</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.finally(); </span><br><span class="line"><span class="keyword">let</span> p3 = p1.finally(<span class="function">() =&gt;</span> <span class="literal">undefined</span>); </span><br><span class="line"><span class="keyword">let</span> p4 = p1.finally(<span class="function">() =&gt;</span> &#123;&#125;); </span><br><span class="line"><span class="keyword">let</span> p5 = p1.finally(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve()); </span><br><span class="line"><span class="keyword">let</span> p6 = p1.finally(<span class="function">() =&gt;</span> <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> p7 = p1.finally(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;bar&#x27;</span>)); </span><br><span class="line"><span class="keyword">let</span> p8 = p1.finally(<span class="function">() =&gt;</span> <span class="built_in">Error</span>(<span class="string">&#x27;qux&#x27;</span>)); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;resolved&gt;: foo </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;resolved&gt;: foo </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p4); <span class="comment">// Promise &lt;resolved&gt;: foo </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p5); <span class="comment">// Promise &lt;resolved&gt;: foo </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p6); <span class="comment">// Promise &lt;resolved&gt;: foo </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p7); <span class="comment">// Promise &lt;resolved&gt;: foo </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p8); <span class="comment">// Promise &lt;resolved&gt;: foo </span></span><br><span class="line"><span class="comment">//如果返回的是一个待定的期约，或者 onFinally 处理程序抛出了错误（显式抛出或返回了一个拒绝期约），则会返回相应的期约（待定或拒绝）</span></span><br><span class="line"><span class="comment">// Promise.resolve()保留返回的期约</span></span><br><span class="line"><span class="keyword">let</span> p9 = p1.finally(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)); </span><br><span class="line"><span class="keyword">let</span> p10 = p1.finally(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.reject()); </span><br><span class="line"><span class="comment">// Uncaught (in promise): undefined </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p9); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p10); <span class="comment">// Promise &lt;rejected&gt;: undefined </span></span><br><span class="line"><span class="keyword">let</span> p11 = p1.finally(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">&#x27;baz&#x27;</span>; &#125;); </span><br><span class="line"><span class="comment">// Uncaught (in promise) baz </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p11); <span class="comment">// Promise &lt;rejected&gt;: baz </span></span><br></pre></td></tr></table></figure>

<h1 id="非重入期约方法"><a href="#非重入期约方法" class="headerlink" title="非重入期约方法"></a>非重入期约方法</h1><p>当期约进入<strong>落定状态</strong>时，与该状态相关的处理程序仅仅会被<strong>排期</strong>，而非立即执行。跟在添加这个处 理程序的代码之后的<strong>同步代码</strong>一定会在处理程序之前先执行。即使期约一开始就是与附加处理程序关联 的状态，执行顺序也是这样的。这个特性由 JavaScript 运行时保证，被称为“非重入”（non-reentrancy） 特性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> synchronousResolve; </span><br><span class="line"><span class="comment">// 创建一个期约并将解决函数保存在一个局部变量中</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123; </span><br><span class="line"> synchronousResolve = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;1: invoking resolve()&#x27;</span>); </span><br><span class="line"> resolve(); </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;2: resolve() returns&#x27;</span>); </span><br><span class="line"> &#125;; </span><br><span class="line">&#125;); </span><br><span class="line">p.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;4: then() handler executes&#x27;</span>)); </span><br><span class="line">synchronousResolve(); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;3: synchronousResolve() returns&#x27;</span>); </span><br><span class="line"><span class="comment">// 实际的输出：</span></span><br><span class="line"><span class="comment">// 1: invoking resolve() </span></span><br><span class="line"><span class="comment">// 2: resolve() returns </span></span><br><span class="line"><span class="comment">// 3: synchronousResolve() returns </span></span><br><span class="line"><span class="comment">// 4: then() handler executes</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，即使期约状态变化发生在添加处理程序之后，处理程序也会等到运行的消息队列让 它出列时才会执行。</p>
<h1 id="传递解决值和拒绝理由"><a href="#传递解决值和拒绝理由" class="headerlink" title="传递解决值和拒绝理由"></a>传递解决值和拒绝理由</h1><p>到了落定状态后，期约会提供其解决值（如果兑现）或其拒绝理由（如果拒绝）给相关状态的处理 程序。拿到返回值后，就可以进一步对这个值进行操作。比如，第一次网络请求返回的 JSON 是发送第 二次请求必需的数据，那么第一次请求返回的值就应该传给 onResolved 处理程序继续处理。当然，失 败的网络请求也应该把 HTTP 状态码传给 onRejected 处理程序。</p>
<p>在执行函数中，解决的值和拒绝的理由是分别作为 resolve()和 reject()的第一个参数往后传 的。然后，这些值又会传给它们各自的处理程序，作为 onResolved 或 onRejected 处理程序的唯一 参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(<span class="string">&#x27;foo&#x27;</span>)); </span><br><span class="line">p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value)); <span class="comment">// foo </span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">&#x27;bar&#x27;</span>)); </span><br><span class="line">p2.catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">console</span>.log(reason)); <span class="comment">// bar </span></span><br></pre></td></tr></table></figure>

<p>then()和 catch()的 onRejected 处理程序在语义上相当于 try/catch。出发点都是捕获错误之 后将其隔离，同时不影响正常逻辑执行。为此，onRejected 处理程序的任务应该是在捕获异步错误之 后返回一个解决的期约。下面的例子中对比了同步错误处理与异步错误处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;begin synchronous execution&#x27;</span>); </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"> <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;caught error&#x27;</span>, e); </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;continue synchronous execution&#x27;</span>); </span><br><span class="line"><span class="comment">// begin synchronous execution </span></span><br><span class="line"><span class="comment">// caught error Error: foo </span></span><br><span class="line"><span class="comment">// continue synchronous execution </span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;begin asynchronous execution&#x27;</span>); </span><br><span class="line"> reject(<span class="built_in">Error</span>(<span class="string">&#x27;bar&#x27;</span>)); </span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;caught error&#x27;</span>, e); </span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;continue asynchronous execution&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// begin asynchronous execution </span></span><br><span class="line"><span class="comment">// caught error Error: bar </span></span><br><span class="line"><span class="comment">// continue asynchronous execution </span></span><br></pre></td></tr></table></figure>

<h1 id="期约连锁"><a href="#期约连锁" class="headerlink" title="期约连锁"></a>期约连锁</h1><p>每个后续的处理程序都会等待前一个期约解决，然后实例化一个新期约并返回它。这种结构可以简 洁地将异步任务串行化，解决之前依赖回调的难题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayedResolve</span>(<span class="params">str</span>) </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(str); </span><br><span class="line"> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>); </span><br><span class="line"> &#125;); </span><br><span class="line">&#125;</span><br><span class="line">delayedResolve(<span class="string">&#x27;p1 executor&#x27;</span>) </span><br><span class="line"> .then(<span class="function">() =&gt;</span> delayedResolve(<span class="string">&#x27;p2 executor&#x27;</span>)) </span><br><span class="line"> .then(<span class="function">() =&gt;</span> delayedResolve(<span class="string">&#x27;p3 executor&#x27;</span>)) </span><br><span class="line"> .then(<span class="function">() =&gt;</span> delayedResolve(<span class="string">&#x27;p4 executor&#x27;</span>)) </span><br><span class="line"><span class="comment">// p1 executor（1 秒后）</span></span><br><span class="line"><span class="comment">// p2 executor（2 秒后）</span></span><br><span class="line"><span class="comment">// p3 executor（3 秒后）</span></span><br><span class="line"><span class="comment">// p4 executor（4 秒后）</span></span><br></pre></td></tr></table></figure>

<h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h1><p><code>Promise.all</code>方法用于将多个 Promise 实例，这个静态方法接收一个可迭代对象，将参数转为 Promise 实例，再包装成一个新的 Promise 实例。</p>
<ul>
<li>合成的期约只会在每个包含的期约都解决之后才解决</li>
<li>如果至少有一个包含的期约待定，则合成的期约也会待定。如果有一个包含的期约拒绝，则合成的 期约也会拒绝</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//永远待定</span></span><br><span class="line"><span class="keyword">let</span> p1=<span class="built_in">Promise</span>.all([<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">()=&gt;</span>&#123;&#125;)]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,p1);<span class="comment">//Promise &lt;pending&gt;</span></span><br><span class="line"><span class="comment">//一次拒绝会导致最终期约拒绝</span></span><br><span class="line"><span class="keyword">let</span> p2=<span class="built_in">Promise</span>.all([<span class="built_in">Promise</span>.resolve(),<span class="built_in">Promise</span>.reject(),<span class="built_in">Promise</span>.resolve()]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,p2);<span class="comment">//Promise &lt;rejected&gt;</span></span><br><span class="line"><span class="comment">//Uncaught (in promise) undefined</span></span><br></pre></td></tr></table></figure>

<p>如果所有期约都成功解决，则合成期约的解决值就是所有包含期约解决值的数组，按照迭代器顺序:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([ </span><br><span class="line"> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>), </span><br><span class="line"> <span class="built_in">Promise</span>.resolve(), </span><br><span class="line"> <span class="built_in">Promise</span>.resolve(<span class="number">4</span>) </span><br><span class="line">]); </span><br><span class="line">p.then(<span class="function">(<span class="params">values</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, values)); <span class="comment">// [3, undefined, 4] </span></span><br><span class="line"><span class="comment">// 虽然只有第一个期约的拒绝理由会进入 </span></span><br><span class="line"><span class="comment">// 拒绝处理程序，第二个期约的拒绝也</span></span><br><span class="line"><span class="comment">// 会被静默处理，不会有错误跑掉</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([ </span><br><span class="line"> <span class="built_in">Promise</span>.reject(<span class="number">3</span>), </span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>)) </span><br><span class="line">]); </span><br><span class="line">p.catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, reason)); <span class="comment">// 3 </span></span><br></pre></td></tr></table></figure>

<h1 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h1><p>Promise.race()静态方法返回一个包装期约，是一组集合中最先解决或拒绝的期约的镜像。这个 方法接收一个可迭代对象，返回一个新期约</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解决先发生，超时后的拒绝被忽略</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.race([ </span><br><span class="line"> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>), </span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>)) </span><br><span class="line">]); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;resolved&gt;: 3 </span></span><br><span class="line"><span class="comment">// 拒绝先发生，超时后的解决被忽略</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.race([ </span><br><span class="line"> <span class="built_in">Promise</span>.reject(<span class="number">4</span>), </span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>)) </span><br><span class="line">]); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;: 4 </span></span><br><span class="line"><span class="comment">// 迭代顺序决定了落定顺序</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.race([ </span><br><span class="line"> <span class="built_in">Promise</span>.resolve(<span class="number">5</span>), </span><br><span class="line"> <span class="built_in">Promise</span>.resolve(<span class="number">6</span>), </span><br><span class="line"> <span class="built_in">Promise</span>.resolve(<span class="number">7</span>) </span><br><span class="line">]); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;resolved&gt;: 5</span></span><br></pre></td></tr></table></figure>

<h1 id="串行期约合成"><a href="#串行期约合成" class="headerlink" title="串行期约合成"></a>串行期约合成</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addThree</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x+<span class="number">3</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFive</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x+<span class="number">5</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [addTwo,addThree,addFive].reduce(<span class="function">(<span class="params">promise,fn</span>)=&gt;</span>promise.then(fn),<span class="built_in">Promise</span>.resolve(x));</span><br><span class="line">&#125;</span><br><span class="line">addTen(<span class="number">8</span>).then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure>

<h1 id="done"><a href="#done" class="headerlink" title="done"></a>done</h1><p>Promise 对象的回调链，不管以<code>then</code>方法或<code>catch</code>方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为 Promise 内部的错误不会冒泡到全局）。因此，我们可以提供一个<code>done</code>方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">asyncFunc()</span><br><span class="line">  .then(f1)</span><br><span class="line">  .catch(r1)</span><br><span class="line">  .then(f2)</span><br><span class="line">  .done();</span><br><span class="line"><span class="built_in">Promise</span>.prototype.done=<span class="function"><span class="keyword">function</span>(<span class="params">onResolved,onRejected</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.then(onResolved,onRejected)</span><br><span class="line">            .catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">                <span class="comment">//抛出一个全局错误</span></span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="keyword">throw</span> reason&#125;,<span class="number">0</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h1><p>finally()f方法用于指定不管Promise对象最后状态如何，都会执行的操作，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">server.listen(<span class="number">0</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// run test</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(server.stop);</span><br><span class="line"><span class="built_in">Promise</span>.prototype.finally=<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> P=<span class="built_in">this</span>.constructor;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">            <span class="function"><span class="params">value</span>=&gt;</span>P.resolve(callback()).then(<span class="function">()=&gt;</span>value),</span><br><span class="line">            <span class="function"><span class="params">reason</span>=&gt;</span>P.resolve(callback()).then(<span class="function">()=&gt;</span>&#123;<span class="keyword">throw</span> reason&#125;)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>将图片的加载写成一个Promise，一旦加载完成，Promise的状态发生变化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载图片</span></span><br><span class="line">    <span class="keyword">const</span> preloadImage=<span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> image=<span class="keyword">new</span> Image();</span><br><span class="line">            image.onload=resolve;</span><br><span class="line">            image.onerror=reject;</span><br><span class="line">            image.src=path;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>字符表示</title>
    <url>/2022/01/04/%E5%AD%97%E7%AC%A6%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="JavaScript字符表示"><a href="#JavaScript字符表示" class="headerlink" title="JavaScript字符表示"></a>JavaScript字符表示</h1><p>JavaScript 字符串由 16 位码元（code unit）组成。对多数字符来说，每 16 位码元对应一个字符。换<br>句话说，字符串的 length 属性表示字符串包含多少 16 位码元</p>
<p>JavaScript 字符串使用了两种 Unicode 编码混合的策略：UCS-2 和 UTF-16。对于可以采用 16 位编码<br>的字符（U+0000~U+FFFF），这两种编码实际上是一样的。</p>
<h2 id="查看指定码元"><a href="#查看指定码元" class="headerlink" title="查看指定码元"></a>查看指定码元</h2><h3 id="charCodeAt"><a href="#charCodeAt" class="headerlink" title="charCodeAt()"></a>charCodeAt()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter C&quot;的编码是 U+0063</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charCodeAt(<span class="number">2</span>)); <span class="comment">// 99</span></span><br><span class="line"><span class="comment">// 十进制 99 等于十六进制 63</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">99</span> === <span class="number">0x63</span>); <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个对应关系在扩展到 Unicode 增补字符平面时就不成立了。即 16 位只能唯一表示,65 536 个字符。这对于大多数语言字符集是足够了，在 Unicode 中称为基本多语言平面（BMP）。为了表示更多的字符，Unicode 采用了一个策略，即每个字符使用另外 16 位去选择一个增补平面。这种每个字符使用两个 16 位码元的策略称为代理对。</p>
<h3 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h3><p>为正确解析既包含单码元字符又包含代理对字符的字符串，可以使用 codePointAt()来代替charCodeAt()。跟使用 charCodeAt()时类似，codePointAt()接收 16 位码元的索引并返回该索引位置上的码点（code point）。码点是 Unicode 中一个字符的完整标识。比如，”c”的码点是 0x0063，而”☺”的码点是 0x1F60A。码点可能是 16 位，也可能是 32 位，而 codePointAt()方法可以从指定码元位置识别完整的码点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;ab☺de&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.codePointAt(<span class="number">1</span>)); <span class="comment">// 98</span></span><br><span class="line"><span class="built_in">console</span>.log(message.codePointAt(<span class="number">2</span>)); <span class="comment">// 128522</span></span><br><span class="line"><span class="built_in">console</span>.log(message.codePointAt(<span class="number">3</span>)); <span class="comment">// 56842</span></span><br><span class="line"><span class="built_in">console</span>.log(message.codePointAt(<span class="number">4</span>)); <span class="comment">// 100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="给定UTF-16码原创建字符"><a href="#给定UTF-16码原创建字符" class="headerlink" title="给定UTF-16码原创建字符"></a>给定UTF-16码原创建字符</h2><h3 id="fromCharCode"><a href="#fromCharCode" class="headerlink" title="fromCharCode()"></a>fromCharCode()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unicode &quot;Latin small letter A&quot;的编码是 U+0061</span></span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter B&quot;的编码是 U+0062</span></span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter C&quot;的编码是 U+0063</span></span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter D&quot;的编码是 U+0064</span></span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter E&quot;的编码是 U+0065</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">0x61</span>, <span class="number">0x62</span>, <span class="number">0x63</span>, <span class="number">0x64</span>, <span class="number">0x65</span>)); <span class="comment">// &quot;abcde&quot;</span></span><br><span class="line"><span class="comment">// 0x0061 === 97</span></span><br><span class="line"><span class="comment">// 0x0062 === 98</span></span><br><span class="line"><span class="comment">// 0x0063 === 99</span></span><br><span class="line"><span class="comment">// 0x0064 === 100</span></span><br><span class="line"><span class="comment">// 0x0065 === 101</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>)); <span class="comment">// &quot;abcde&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="fromCodePoint"><a href="#fromCodePoint" class="headerlink" title="fromCodePoint()"></a>fromCodePoint()</h3><p>fromCodePoint()：这个方法接收任意数量的码点，返回对应字符拼接起来的字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">97</span>, <span class="number">98</span>, <span class="number">55357</span>, <span class="number">56842</span>, <span class="number">100</span>, <span class="number">101</span>)); <span class="comment">// ab☺de</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCodePoint(<span class="number">97</span>, <span class="number">98</span>, <span class="number">128522</span>, <span class="number">100</span>, <span class="number">101</span>)); <span class="comment">// ab☺de</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="normalize-规范化"><a href="#normalize-规范化" class="headerlink" title="normalize()规范化"></a>normalize()规范化</h2><p>Unicode提供了 4种规范化形式，可以将类似上面的字符规范化为一致的格式，无论底层字符的代码是什么。这 4种规范化形式是：NFD（Normalization Form D）、NFC（Normalization Form C）、<br>NFKD（Normalization Form KD）和 NFKC（Normalization Form KC）。可以使用 normalize()方法对字符串应用上述规范化形式，使用时需要传入表示哪种形式的字串：”NFD”、”NFC”、”NFKD”或”NFKC”。</p>
<p>通过比较字符串与其调用 normalize()的返回值，就可以知道该字符串是否已经规范化了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x00C5</span>),</span><br><span class="line">a2 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x212B</span>),</span><br><span class="line">a3 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x0041</span>, <span class="number">0x030A</span>);</span><br><span class="line"><span class="comment">// U+00C5 是对 0+212B 进行 NFC/NFKC 规范化之后的结果</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a1.normalize(<span class="string">&quot;NFD&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a1.normalize(<span class="string">&quot;NFC&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a1.normalize(<span class="string">&quot;NFKD&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a1.normalize(<span class="string">&quot;NFKC&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// U+212B 是未规范化的</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a2.normalize(<span class="string">&quot;NFD&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a2.normalize(<span class="string">&quot;NFC&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a2.normalize(<span class="string">&quot;NFKD&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a2.normalize(<span class="string">&quot;NFKC&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// U+0041/U+030A 是对 0+212B 进行 NFD/NFKD 规范化之后的结果</span></span><br><span class="line"><span class="built_in">console</span>.log(a3 === a3.normalize(<span class="string">&quot;NFD&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a3 === a3.normalize(<span class="string">&quot;NFC&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a3 === a3.normalize(<span class="string">&quot;NFKD&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a3 === a3.normalize(<span class="string">&quot;NFKC&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>未规范化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x00C5</span>),</span><br><span class="line">a2 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x212B</span>),</span><br><span class="line">a3 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x0041</span>, <span class="number">0x030A</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a1, a2, a3); <span class="comment">// Å, Å, Å</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a2); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a3); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a3); <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>选择同一种规范化形式可以让比较操作符返回正确的结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x00C5</span>),</span><br><span class="line">a2 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x212B</span>),</span><br><span class="line">a3 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x0041</span>, <span class="number">0x030A</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a1.normalize(<span class="string">&quot;NFD&quot;</span>) === a2.normalize(<span class="string">&quot;NFD&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a2.normalize(<span class="string">&quot;NFKC&quot;</span>) === a3.normalize(<span class="string">&quot;NFKC&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a1.normalize(<span class="string">&quot;NFC&quot;</span>) === a3.normalize(<span class="string">&quot;NFC&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>媒体查询</title>
    <url>/2022/01/03/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>媒体查询常被用于以下目的：</p>
<ul>
<li><p>有条件的通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media"><code>@media</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@import"><code>@import</code></a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/At-rule">at-rules</a> 用<a href="https://developer.mozilla.org/en-US/docs/Web/CSS">CSS</a> 装饰样式。</p>
</li>
<li><p>用<code>media=</code> 属性为<style>,<link>,<source>和其他<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML">HTML</a>元素指定特定的媒体类型。</p>
</li>
</ul>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>媒体类型和任意数量的媒体特性表达式构成。</p>
<p>当媒体类型（如果指定）与在其上显示文档的设备匹配并且所有媒体功能表达式都计算为true时，媒体查询将计算为true。 涉及未知媒体类型的查询始终为false。</p>
<h2 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h2><p>描述设备的一般类别。除非使用 <code>not</code> 或 <code>only</code> 逻辑操作符，媒体类型是可选的，并且会（隐式地）应用 <code>all</code> 类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">all</span><br></pre></td></tr></table></figure>

<p>适用于所有设备。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print</span><br></pre></td></tr></table></figure>

<p>适用于在打印预览模式下在屏幕上查看的分页材料和文档。 （有关特定于这些格式的格式问题的信息，请参阅<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Paged_Media">分页媒体</a>。）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">screen</span><br></pre></td></tr></table></figure>

<p>主要用于屏幕。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">speech</span><br></pre></td></tr></table></figure>

<p>主要用于语音合成器。</p>
<h3 id="定位媒体类型"><a href="#定位媒体类型" class="headerlink" title="定位媒体类型"></a>定位媒体类型</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen, print &#123; ... &#125;</span><br><span class="line"><span class="comment">/*用两个媒体查询来同时定位屏幕和打印设备*/</span></span><br></pre></td></tr></table></figure>

<h2 id="媒体特性"><a href="#媒体特性" class="headerlink" title="媒体特性"></a>媒体特性</h2><p>描述了 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/User_agent">user agent</a>、输出设备，或是浏览环境的具体特征。媒体特性表达式是完全可选的，它负责测试这些特性或特征是否存在、值为多少。每条媒体特性表达式都必须用括号括起来。</p>
<h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p> <code>not</code>, <code>and</code>, 和 <code>only</code> 可用于联合构造复杂的媒体查询，您还可以通过用逗号分隔多个媒体查询，将它们组合为一个规则。</p>
<h4 id="and"><a href="#and" class="headerlink" title="and"></a><code>and</code></h4><p> <code>and</code> 操作符用于将多个媒体查询规则组合成单条媒体查询，当每个查询规则都为真时则该条媒体查询为真，它还用于将媒体功能与媒体类型结合在一起。</p>
<h4 id="not"><a href="#not" class="headerlink" title="not"></a><code>not</code></h4><p><code>not</code>运算符用于否定媒体查询，如果不满足这个条件则返回true，否则返回false。 如果出现在以逗号分隔的查询列表中，它将仅否定应用了该查询的特定查询。 如果使用not运算符，则还必须指定媒体类型。</p>
<p><strong>注意：</strong>在Level 3中，<code>not</code>关键字不能用于否定单个媒体功能表达式，而只能用于否定整个媒体查询。</p>
<h4 id="only"><a href="#only" class="headerlink" title="only"></a><code>only</code></h4><p><code>only</code>运算符仅在整个查询匹配时才用于应用样式，并且对于防止较早的浏览器应用所选样式很有用。 当不使用<code>only</code>时，旧版本的浏览器会将<code>screen and (max-width: 500px)</code>简单地解释为<code>screen</code>，忽略查询的其余部分，并将其样式应用于所有屏幕。 如果使用<code>only</code>运算符，则<em>还必须指定</em>媒体类型。</p>
<h4 id="逗号"><a href="#逗号" class="headerlink" title=", (逗号)"></a><code>,</code> (逗号)</h4><p>逗号用于将多个媒体查询合并为一个规则。 逗号分隔列表中的每个查询都与其他查询分开处理。 因此，如果列表中的任何查询为true，则整个media语句均返回true。 换句话说，列表的行为类似于逻辑或<code>or</code>运算符。</p>
<h3 id="定位媒体特性"><a href="#定位媒体特性" class="headerlink" title="定位媒体特性"></a>定位媒体特性</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*当用户的主要输入机制（例如鼠标）可以悬停在元素上*/</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">hover</span>: <span class="attribute">hover</span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">12450px</span>) &#123; ... &#125;</span><br><span class="line"><span class="comment">/*CSS将适用于任何带有彩色屏幕的设备*/</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">color</span>) &#123; ... &#125;</span><br><span class="line"><span class="comment">/*限制为带有屏幕的设备,宽度至少为30 em的横向的设备*/</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">30em</span>) <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
  </entry>
  <entry>
    <title>json</title>
    <url>/2022/01/04/json/</url>
    <content><![CDATA[<p>把它当成一种数据格式，而不是编程语言。JSON 不属于 JavaScript，<br>它们只是拥有相同的语法而已。JSON 也不是只能在 JavaScript 中使用，它是一种通用数据格式。很多语言都有解析和序列化 JSON 的内置能力。</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><ul>
<li>简单值：字符串、数值、布尔值和 null 可以在 JSON 中出现，就像在 JavaScript 中一样。特殊值 undefined 不可以。</li>
<li>对象：第一种复杂数据类型，对象表示有序键/值对。每个值可以是简单值，也可以是复杂类型。</li>
<li>数组：第二种复杂数据类型，数组表示可以通过数值索引访问的值的有序列表。数组的值可以是任意类型，包括简单值、对象，甚至其他数组。</li>
</ul>
<h2 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h2><p>JavaScript 字符串与 JSON 字符串的主要区别是，JSON 字符串必须使用双引号（单引号会导致语法错误）。布尔值和 null 本身也是有效的 JSON 值</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>与 JavaScript 对象字面量相比，JSON 主要有两处不同。首先，<strong>没有变量声明</strong>（JSON 中没有变量）。其次，<strong>最后没有分号（</strong>不需要，因为不是 JavaScript 语句）。同样，用引号将属性名包围起来才是有效的JSON。属性的值可以是简单值或复杂数据类型值，后者可以在对象中再嵌入对象.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line"><span class="attr">&quot;age&quot;</span>: <span class="number">29</span>,</span><br><span class="line"><span class="attr">&quot;school&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Merrimack College&quot;</span>,</span><br><span class="line"><span class="attr">&quot;location&quot;</span>: <span class="string">&quot;North Andover, MA&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组在 JSON 中使用 JavaScript 的数组字面量形式表示.</p>
<p>JavaScript</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">25</span>, <span class="string">&quot;hi&quot;</span>, <span class="literal">true</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[<span class="number">25</span>,<span class="string">&quot;hi&quot;</span>,<span class="literal">true</span>]</span><br></pre></td></tr></table></figure>

<h1 id="JavaScript序列化为Json"><a href="#JavaScript序列化为Json" class="headerlink" title="JavaScript序列化为Json"></a>JavaScript序列化为Json</h1><p>stringfy()：在序列化 JavaScript 对象时，所有函数和原型成员都会有意地在结果中省略。此外，值为 undefined的任何属性也会被跳过。最终得到的就是所有实例属性均为有效 JSON 数据类型的表</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line"><span class="attr">title</span>: <span class="string">&quot;Professional JavaScript&quot;</span>,</span><br><span class="line"><span class="attr">authors</span>: [</span><br><span class="line"><span class="string">&quot;Nicholas C. Zakas&quot;</span>,</span><br><span class="line"><span class="string">&quot;Matt Frisbie&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">edition</span>: <span class="number">4</span>,</span><br><span class="line"><span class="attr">year</span>: <span class="number">2017</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="built_in">JSON</span>.stringify(book);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果：</p>
<p>{“title”:”Professional JavaScript”,”authors”:[“Nicholas C. Zakas”,”Matt Frisbie”],<br>“edition”:4,”year”:2017}</p>
</blockquote>
<p>还可以接收两个参数。这两个参数可以用于指定其他序列化 JavaScript 对象的方式。第一个参数是<strong>过滤器</strong>，可以是<strong>数组或函数</strong>；第二个参数是用于<strong>缩进结果 JSON 字符串的选项</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line"><span class="attr">title</span>: <span class="string">&quot;Professional JavaScript&quot;</span>,</span><br><span class="line"><span class="attr">authors</span>: [</span><br><span class="line"><span class="string">&quot;Nicholas C. Zakas&quot;</span>,</span><br><span class="line"><span class="string">&quot;Matt Frisbie&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">edition</span>: <span class="number">4</span>,</span><br><span class="line"><span class="attr">year</span>: <span class="number">2017</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="built_in">JSON</span>.stringify(book, [<span class="string">&quot;title&quot;</span>, <span class="string">&quot;edition&quot;</span>]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>如果第二个参数是一个函数，则行为又有不同。提供的函数接收两个参数：属性名（key）和属性值（value）。可以根据这个 key 决定要对相应属性执行什么操作。这个 key 始终是字符串，只是在值<br>不属于某个键/值对时会是空字符串</li>
<li>返回的值就是相应 key 应该包含的结果。注意，返回 undefined 会导致属性被忽略</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line"><span class="attr">title</span>: <span class="string">&quot;Professional JavaScript&quot;</span>,</span><br><span class="line"><span class="attr">authors</span>: [</span><br><span class="line"><span class="string">&quot;Nicholas C. Zakas&quot;</span>,</span><br><span class="line"><span class="string">&quot;Matt Frisbie&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">edition</span>: <span class="number">4</span>,</span><br><span class="line"><span class="attr">year</span>: <span class="number">2017</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="built_in">JSON</span>.stringify(book, <span class="function">(<span class="params">key, value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">switch</span>(key) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;authors&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> value.join(<span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;year&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;edition&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*&#123;&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:&quot;Nicholas C. Zakas,Matt</span></span><br><span class="line"><span class="comment">Frisbie&quot;,&quot;year&quot;:5000&#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>JSON.stringify()方法的第三个参数控制缩进和空格。在这个参数是数值时，表示每一级缩进的空格数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line"><span class="attr">title</span>: <span class="string">&quot;Professional JavaScript&quot;</span>,</span><br><span class="line"><span class="attr">authors</span>: [</span><br><span class="line">	<span class="string">&quot;Nicholas C. Zakas&quot;</span>,</span><br><span class="line">	<span class="string">&quot;Matt Frisbie&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">edition</span>: <span class="number">4</span>,</span><br><span class="line"><span class="attr">year</span>: <span class="number">2017</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="built_in">JSON</span>.stringify(book, <span class="literal">null</span>, <span class="number">4</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>toJSON():在要序列化的对象中添加 toJSON()方法，序列化时会基于这个方法返回适当的 JSON 表示:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line"><span class="attr">title</span>: <span class="string">&quot;Professional JavaScript&quot;</span>,</span><br><span class="line"><span class="attr">authors</span>: [</span><br><span class="line"><span class="string">&quot;Nicholas C. Zakas&quot;</span>,</span><br><span class="line"><span class="string">&quot;Matt Frisbie&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">edition</span>: <span class="number">4</span>,</span><br><span class="line"><span class="attr">year</span>: <span class="number">2017</span>,</span><br><span class="line"><span class="attr">toJSON</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="comment">//箭头函数不能定义toJSON(),因为剪头函数的词法作用域是全局作用域，在这种情况不合适</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.title;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="built_in">JSON</span>.stringify(book);<span class="comment">//book对象返回图书的书名(this.title)</span></span><br></pre></td></tr></table></figure>

<p>toJSON()方法可以与过滤函数一起使用，在把对象传给 JSON.stringify()时会执行如下步骤。</p>
<p>(1) 如果可以获取实际的值，则调用 toJSON()方法获取实际的值，否则使用默认的序列化。<br>(2) 否则，使用默认序列化时，如果提供了第二个参数，则应用过滤。<br>(3) 第(2)步返回的每个值都会相应地进行序列化。<br>(4) 如果提供了第三个参数，则相应地进行缩进。</p>
<h1 id="ES6中堆JSON-stringfy的改造"><a href="#ES6中堆JSON-stringfy的改造" class="headerlink" title="ES6中堆JSON.stringfy的改造"></a>ES6中堆JSON.stringfy的改造</h1><p>UTF-8 标准规定，<code>0xD800</code>到<code>0xDFFF</code>之间的码点，不能单独使用，必须配对使用。比如，<code>\uD834\uDF06</code>是两个码点，但是必须放在一起配对使用，代表字符<code>𝌆</code>。这是为了表示码点大于<code>0xFFFF</code>的字符的一种变通方法。单独使用<code>\uD834</code>和<code>\uDFO6</code>这两个码点是不合法的，或者颠倒顺序也不行，因为<code>\uDF06\uD834</code>并没有对应的字符。</p>
<p><code>JSON.stringify()</code>的问题在于，它可能返回<code>0xD800</code>到<code>0xDFFF</code>之间的单个码点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JSON.stringify(&#x27;\u&#123;D834&#125;&#x27;) // &quot;\u&#123;D834&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>为了确保返回的是合法的 UTF-8 字符，<a href="https://github.com/tc39/proposal-well-formed-stringify">ES2019</a> 改变了<code>JSON.stringify()</code>的行为。如果遇到<code>0xD800</code>到<code>0xDFFF</code>之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JSON.stringify(&#x27;\u&#123;D834&#125;&#x27;) // &quot;&quot;\\uD834&quot;&quot;JSON.stringify(&#x27;\uDF06\uD834&#x27;) // &quot;&quot;\\udf06\\ud834&quot;&quot;</span><br></pre></td></tr></table></figure>

<h1 id="解析选项"><a href="#解析选项" class="headerlink" title="解析选项"></a>解析选项</h1><p>JSON.parse():接收一个参数，这个函数称为还原函数，还原函数接收两个参数，属性名key和属性名value，如果还原函数返回undefined，则结果中删除相应键，如果返回了其他任何值，则该值就会成为相应键的值插入到结果中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line"><span class="attr">title</span>: <span class="string">&quot;Professional JavaScript&quot;</span>,</span><br><span class="line"><span class="attr">authors</span>: [</span><br><span class="line"><span class="string">&quot;Nicholas C. Zakas&quot;</span>,</span><br><span class="line"><span class="string">&quot;Matt Frisbie&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">edition</span>: <span class="number">4</span>,</span><br><span class="line"><span class="attr">year</span>: <span class="number">2017</span>,</span><br><span class="line"><span class="attr">releaseDate</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2017</span>, <span class="number">11</span>, <span class="number">1</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="built_in">JSON</span>.stringify(book);</span><br><span class="line"><span class="keyword">let</span> bookCopy = <span class="built_in">JSON</span>.parse(jsonText,</span><br><span class="line"><span class="function">(<span class="params">key, value</span>) =&gt;</span> key == <span class="string">&quot;releaseDate&quot;</span> ? <span class="keyword">new</span> <span class="built_in">Date</span>(value) : value);</span><br><span class="line">alert(bookCopy.releaseDate.getFullYear());<span class="comment">//对象仙贝序列化为JSON字符串，又被重新解析为一个对象bookCopy,还原函数查找&quot;releaseDate&quot;键，找到后根虎日期字符创建新的Date对象，得到的bookCopy.releaseDate属性又变回Date对象，可以调用其getFullYear()方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>富文本</title>
    <url>/2021/12/13/%E5%AF%8C%E6%96%87%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="富文本编辑"><a href="#富文本编辑" class="headerlink" title="富文本编辑"></a>富文本编辑</h1><p>在空白 HTML 文件中嵌入一个iframe。通过 designMode 属性，可以将这个空白文档变成可以编辑的，实际编辑的则是<body>元素<br>的 HTML。designMode 属性有两个可能的值：”off”（默认值）和”on”。设置为”on”时</p>
<h1 id="富文本交互"><a href="#富文本交互" class="headerlink" title="富文本交互"></a>富文本交互</h1><p>使用 document.execCommand()。这个方法在文档上执行既定<br>的命令，可以实现大多数格式化任务。document.execCommand()可以接收 3 个参数：要执行的命令、表示浏览器是否为命令提供用户界面的布尔值和执行命令必需的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在内嵌窗格中切换粗体文本样式</span></span><br><span class="line">frames[<span class="string">&quot;richedit&quot;</span>].document.execCommand(<span class="string">&quot;bold&quot;</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 在内嵌窗格中切换斜体文本样式</span></span><br><span class="line">frames[<span class="string">&quot;richedit&quot;</span>].document.execCommand(<span class="string">&quot;italic&quot;</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 在内嵌窗格中创建指向 www.wrox.com 的链接</span></span><br><span class="line">frames[<span class="string">&quot;richedit&quot;</span>].document.execCommand(<span class="string">&quot;createlink&quot;</span>, <span class="literal">false</span>,</span><br><span class="line"><span class="string">&quot;http://www.wrox.com&quot;</span>);</span><br><span class="line"><span class="comment">// 在内嵌窗格中为内容添加&lt;h1&gt;标签</span></span><br><span class="line">frames[<span class="string">&quot;richedit&quot;</span>].document.execCommand(<span class="string">&quot;formatblock&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;&lt;h1&gt;&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="富文本选择"><a href="#富文本选择" class="headerlink" title="富文本选择"></a>富文本选择</h1><p>在内嵌窗格中使用 getSelection()方法，可以获得富文本编辑器的选区。这个方法暴露在document 和 window 对象上，返回表示当前选中文本的 Selection 对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> selection = frames[<span class="string">&quot;richedit&quot;</span>].getSelection();</span><br><span class="line"><span class="comment">// 取得选中的文本</span></span><br><span class="line"><span class="keyword">let</span> selectedText = selection.toString();</span><br><span class="line"><span class="comment">// 取得表示选区的范围</span></span><br><span class="line"><span class="keyword">let</span> range = selection.getRangeAt(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 高亮选中的文本</span></span><br><span class="line"><span class="keyword">let</span> span = frames[<span class="string">&quot;richedit&quot;</span>].document.createElement(<span class="string">&quot;span&quot;</span>);</span><br><span class="line">span.style.backgroundColor = <span class="string">&quot;yellow&quot;</span>;</span><br><span class="line">range.surroundContents(span);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="通过表单提交富文本"><a href="#通过表单提交富文本" class="headerlink" title="通过表单提交富文本"></a>通过表单提交富文本</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">form.addEventListener(<span class="string">&quot;submit&quot;</span>,<span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> target=event.target;</span><br><span class="line">   target.elements[<span class="string">&quot;comments&quot;</span>].value=frames[<span class="string">&quot;richedit&quot;</span>].document.body.innerHTML;<span class="comment">//使用内嵌窗格 </span></span><br><span class="line">    <span class="comment">//target.elements[&quot;comments&quot;].value=document.getElementById(&quot;richedit&quot;).innerHTML;//使用contenteditable</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>align-self,align-item,align-content</title>
    <url>/2022/01/03/%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h1 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h1><p>CSS属性 <strong><code>align-self</code></strong> 会对齐当前 grid 或 flex 行中的元素，并覆盖已有的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items"><code>align-items</code></a> 的值。In Grid, it aligns the item inside the <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Grid_Areas">grid area</a>. 在 Flexbox 中，会按照 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Cross_Axis">cross axis</a>（当前 flex 元素排列方向的垂直方向）进行排列。</p>
<h2 id="值"><a href="#值" class="headerlink" title="值"></a>值</h2><p>auto:设置为父元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items"><code>align-items</code></a> 值。</p>
<p>normal:</p>
<p>效果取决于当前的布局模式:</p>
<ul>
<li><p>绝对定位布局中，normal在绝对定位的替代元素上表现为<code>start</code>，在<em>所有其他</em>绝对定位元素上表现为<code>stretch</code>。</p>
</li>
<li><p>在绝对定位的静态元素上表现为<code>stretch</code>。</p>
</li>
<li><p>flex布局中表现为stretch。</p>
</li>
<li><p>在网格布局中表现为stretch,除了有部分比例或者一个固定大小的盒子的效果像<code>start</code>。</p>
</li>
<li><p>在块级和表格单元中无效。</p>
</li>
</ul>
<p>flex-start:对齐到cross-axis的首端</p>
<p>flex-end:对齐到cross-axis的尾端</p>
<p>center:对齐到cross-axis的中间，如果该元素的 cross-size 尺寸大于 flex 容器，将在两个方向均等溢出。</p>
<p>safe:如果元素大小溢出对齐的容器，则将元素改为对齐，就像start</p>
<p>unsafe:无论元素和对齐容器的相对大小如何都遵循给定的对齐值</p>
<h2 id="eg"><a href="#eg" class="headerlink" title="eg"></a>eg</h2><p>HTML</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        Item#1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        Item#2</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        Item#3</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">120px</span>;</span><br><span class="line">  <span class="attribute">background</span>: beige;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">background</span>: cyan;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: flex-end;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h1><p>CSS align-items属性将所有直接子节点上的align-self值设置为一个组。 目前，Flexbox和CSS网格布局支持此属性。在Flexbox中，它控制十字轴上项目的对齐方式，在网格布局中，它控制块轴上项目的对齐方式。</p>
<h1 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h1><p><strong><code>align-content</code></strong> 属性设置了浏览器如何沿着<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout">弹性盒子布局</a>的纵轴和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout">网格布局</a>的主轴在内容项之间和周围分配空间。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基本位置对齐 */</span></span><br><span class="line"><span class="comment">/*align-content不采用左右值 */</span></span><br><span class="line">align-content: center;     <span class="comment">/* 将项目放置在中点 */</span></span><br><span class="line">align-content: start;      <span class="comment">/* 最先放置项目 */</span></span><br><span class="line">align-content: end;        <span class="comment">/* 最后放置项目 */</span></span><br><span class="line">align-content: flex-start; <span class="comment">/* 从起始点开始放置flex元素 */</span></span><br><span class="line">align-content: flex-end;   <span class="comment">/* 从终止点开始放置flex元素 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 默认对齐 */</span></span><br><span class="line">align-content: normal;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基线对齐*/</span></span><br><span class="line">align-content: baseline;</span><br><span class="line">align-content: first baseline;</span><br><span class="line">align-content: last baseline;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分布式对齐 */</span></span><br><span class="line">align-content: space-between; <span class="comment">/* 均匀分布项目</span></span><br><span class="line"><span class="comment">                                 第一项与起始点齐平，</span></span><br><span class="line"><span class="comment">                                 最后一项与终止点齐平 */</span></span><br><span class="line">align-content: space-around;  <span class="comment">/* 均匀分布项目</span></span><br><span class="line"><span class="comment">                                 项目在两端有一半大小的空间*/</span></span><br><span class="line">align-content: space-evenly;  <span class="comment">/* 均匀分布项目</span></span><br><span class="line"><span class="comment">                                 项目周围有相等的空间 */</span></span><br><span class="line">align-content: stretch;       <span class="comment">/* 均匀分布项目</span></span><br><span class="line"><span class="comment">                                 拉伸‘自动’-大小的项目以充满容器 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 溢出对齐 */</span></span><br><span class="line">align-content: safe center;</span><br><span class="line">align-content: unsafe center;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局属性 */</span></span><br><span class="line">align-content: inherit; <span class="comment">/* 继承 */</span></span><br><span class="line">align-content: initial;  <span class="comment">/* 初始值 */</span></span><br><span class="line">align-content: unset; <span class="comment">/* 未设置 */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="justify-items"><a href="#justify-items" class="headerlink" title="justify-items"></a>justify-items</h1><p><strong><code>justify-items</code></strong> 属性为所有盒中的项目定义了默认的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/justify-self"><code>justify-self</code></a> ， 可以使这些项目以默认方式沿适当轴线对齐到每个盒子。</p>
<h1 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h1><p><strong><code>justify-content</code></strong> 属性定义了浏览器之间，如何分配顺着弹性容器主轴(或者网格行轴) 的元素之间及其周围的空间。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Positional alignment */</span></span><br><span class="line">justify-content: center;     <span class="comment">/* 居中排列 */</span></span><br><span class="line">justify-content: start;      <span class="comment">/* Pack items from the start */</span></span><br><span class="line">justify-content: end;        <span class="comment">/* Pack items from the end */</span></span><br><span class="line">justify-content: flex-start; <span class="comment">/* 从行首起始位置开始排列 */</span></span><br><span class="line">justify-content: flex-end;   <span class="comment">/* 从行尾位置开始排列 */</span></span><br><span class="line">justify-content: left;       <span class="comment">/* Pack items from the left */</span></span><br><span class="line">justify-content: right;      <span class="comment">/* Pack items from the right */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Baseline alignment */</span></span><br><span class="line">justify-content: baseline;</span><br><span class="line">justify-content: first baseline;</span><br><span class="line">justify-content: last baseline;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Distributed alignment */</span></span><br><span class="line">justify-content: space-between;  <span class="comment">/* 均匀排列每个元素</span></span><br><span class="line"><span class="comment">                                   首个元素放置于起点，末尾元素放置于终点 */</span></span><br><span class="line">justify-content: space-around;  <span class="comment">/* 均匀排列每个元素</span></span><br><span class="line"><span class="comment">                                   每个元素周围分配相同的空间 */</span></span><br><span class="line">justify-content: space-evenly;  <span class="comment">/* 均匀排列每个元素</span></span><br><span class="line"><span class="comment">                                   每个元素之间的间隔相等 */</span></span><br><span class="line">justify-content: stretch;       <span class="comment">/* 均匀排列每个元素</span></span><br><span class="line"><span class="comment">                                   &#x27;auto&#x27;-sized 的元素会被拉伸以适应容器的大小 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Overflow alignment */</span></span><br><span class="line">justify-content: safe center;</span><br><span class="line">justify-content: unsafe center;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global values */</span></span><br><span class="line">justify-content: inherit;</span><br><span class="line">justify-content: initial;</span><br><span class="line">justify-content: unset;</span><br></pre></td></tr></table></figure>

<h1 id="justify-self"><a href="#justify-self" class="headerlink" title="justify-self"></a>justify-self</h1><h2 id="justify-self-在-Flexbox布局中失效"><a href="#justify-self-在-Flexbox布局中失效" class="headerlink" title="[justify-self 在 Flexbox布局中失效]"></a>[justify-self 在 Flexbox布局中失效]</h2><p>在主轴上，Flexbox将我们的内容作为一个组进行处理。 计算布置子元素所需的空间量，然后剩余空间可用于分配。 <code>justify-content</code>属性控制剩余空间的使用方式。 设置<code>justify-content：flex-end</code>，额外空间放在所有子元素之前，<code>justify-content：space-around</code>，它放在该维度的子元素的两侧，等等。</p>
<p>这意味着在Flexbox中，<code>justify-self</code>属性没有意义，因为我们总是处理移动整个元素组。</p>
<p>在十字轴上，<code>align-self</code>是有意义的，因为我们可能在该维度中的flex容器中有额外的空间，其中单个元素可以移动到开始和结束位置。</p>
]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
  </entry>
  <entry>
    <title>文本框编程</title>
    <url>/2021/12/09/%E6%96%87%E6%9C%AC%E6%A1%86/</url>
    <content><![CDATA[<h1 id="文本框编程"><a href="#文本框编程" class="headerlink" title="文本框编程"></a>文本框编程</h1><h2 id="表示文本框的两种方式"><a href="#表示文本框的两种方式" class="headerlink" title="表示文本框的两种方式"></a>表示文本框的两种方式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> size=<span class="string">&quot;25&quot;</span> maxlength=<span class="string">&quot;50&quot;</span> value=<span class="string">&quot;initial value&quot;</span>&gt;</span><br><span class="line"> <span class="comment">//创建多行文本框</span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;25&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;5&quot;</span>&gt;</span>initial value<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span></span><br><span class="line"><span class="comment">//用使用value属性读写文本框</span></span><br><span class="line"><span class="keyword">let</span> textbox=<span class="built_in">document</span>.forms[<span class="number">0</span>].elements[<span class="string">&quot;textbox1&quot;</span>];</span><br><span class="line">textbox.value=<span class="string">&quot;Some new value&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="选择文本"><a href="#选择文本" class="headerlink" title="选择文本"></a>选择文本</h2><p>select()用于全选文本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> form=<span class="built_in">document</span>.getElementById(<span class="string">&quot;myForm&quot;</span>);</span><br><span class="line"> <span class="keyword">let</span> textbox=form.elements[<span class="number">0</span>];</span><br><span class="line"> textbox.addEventListener(<span class="string">&quot;focus&quot;</span>,<span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">     event.target.select();</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">`Text selected:<span class="subst">$&#123;textbox.value&#125;</span>`</span>);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<p>setSelectionRange()用于部分选择文本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> form=<span class="built_in">document</span>.getElementById(<span class="string">&quot;myForm&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> textbox=form.elements[<span class="number">0</span>];</span><br><span class="line">textbox.addEventListener(<span class="string">&quot;focus&quot;</span>,<span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    event.target.select();</span><br><span class="line">    textbox.setSelectionRange(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Text selected:<span class="subst">$&#123;textbox.value&#125;</span>`</span>);    </span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="屏蔽按键"><a href="#屏蔽按键" class="headerlink" title="屏蔽按键"></a>屏蔽按键</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">textbox.addEventListener(<span class="string">&quot;keypress&quot;</span>,<span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="regexp">/\d/</span>.test(<span class="built_in">String</span>.fromCharCode(event.charCode))&amp;&amp;event.charCode&gt;<span class="number">9</span>&amp;&amp;!event.ctrlKey)&#123;<span class="comment">//屏蔽非数字字符但允许同样触发keypress事件的所有基础按键以及ctrl键</span></span><br><span class="line">        event.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="自动切换"><a href="#自动切换" class="headerlink" title="自动切换"></a>自动切换</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;form method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">        &lt;input type=&quot;text &quot; name=&quot;tel1&quot; id=&quot;textTel1&quot; maxlength=&quot;3&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;tel2&quot; id=&quot;textTel2&quot; maxlength=&quot;3&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;tel3&quot; id=&quot;textTel3&quot; maxlength=&quot;4&quot;&gt;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">     &lt;/form&gt;</span><br><span class="line">     let inputIds=[&quot;textTel1&quot;,&quot;textTel2&quot;,&quot;textTel3&quot;];</span><br><span class="line">for(let id of inputIds)&#123;</span><br><span class="line">    let textbox=document.getElementById(id);</span><br><span class="line">    textbox.addEventListener(&quot;keyup&quot;,(event)=&gt;&#123;</span><br><span class="line">        let target=event.target;</span><br><span class="line">    if(target.value.length==target.maxLength)&#123;</span><br><span class="line">        let form=target.form;</span><br><span class="line">        for(let i=0,len=form.elements.length;i&lt;len;i++)&#123;</span><br><span class="line">            if(form.elements[i]==target)&#123;</span><br><span class="line">                if(form.elements[i+1])&#123;</span><br><span class="line">                    form.elements[i+1].focus();</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>表单</title>
    <url>/2021/12/09/%E8%A1%A8%E5%8D%95/</url>
    <content><![CDATA[<h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><h2 id="禁用表单"><a href="#禁用表单" class="headerlink" title="禁用表单"></a>禁用表单</h2><p>避免多次提交表单可以在第一次点击后禁用表单</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> form=<span class="built_in">document</span>.getElementById(<span class="string">&quot;myForm&quot;</span>);</span><br><span class="line">form.addEventListener(<span class="string">&quot;submit&quot;</span>,<span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> target=event.target;</span><br><span class="line">    <span class="comment">//取得提交按钮</span></span><br><span class="line">    <span class="keyword">let</span> btn=target.elements[<span class="string">&quot;submit-btn&quot;</span>];</span><br><span class="line">    <span class="comment">//禁用提交按钮</span></span><br><span class="line">    btn.disabled=<span class="literal">true</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="focus"><a href="#focus" class="headerlink" title="focus()"></a>focus()</h2><p>把焦点设置到表单字段,这意味着该字段会变成活动字段并可以响应键盘事件,autofocus()会自动为带有该属性的元素设置焦点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> form=<span class="built_in">document</span>.getElementById(<span class="string">&quot;myForm&quot;</span>);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;load&quot;</span>,<span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">     <span class="keyword">let</span> element=form.elements[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">if</span>(element.autofocus!==<span class="literal">true</span>)&#123;</span><br><span class="line">         element.focus();</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">&quot;JS focus&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="表单的公共事件"><a href="#表单的公共事件" class="headerlink" title="表单的公共事件"></a>表单的公共事件</h2>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>表单序列化</title>
    <url>/2021/12/12/%E8%A1%A8%E5%8D%95%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<p>表单在js中可以使用表单字段的type属性连同其name属性和value属性来进行序列化</p>
<ul>
<li><p>字段名和值是 URL 编码的并以和号（&amp;）分隔。</p>
</li>
<li><p> 禁用字段不会发送。</p>
</li>
<li><p>复选框或单选按钮只在被选中时才发送。</p>
</li>
<li><p>类型为”reset”或”button”的按钮不会发送。</p>
</li>
<li><p>多选字段的每个选中项都有一个值。</p>
</li>
<li><p>通过点击提交按钮提交表单时，会发送该提交按钮；否则，不会发送提交按钮。类型为”image”<br>的<input>元素视同提交按钮。</p>
</li>
<li><p>select元素的值是被选中option元素的 value 属性。如果<option>元素没有 value 属<br>性，则该值是它的文本</p>
<p>返回的结果是查询字符串的格式</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serialize</span>(<span class="params">form</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> parts=[];</span><br><span class="line">    <span class="keyword">let</span> optValue;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> field <span class="keyword">of</span> form.elements)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(field.type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;select-one&quot;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;select-multiple&quot;</span>:</span><br><span class="line">                <span class="keyword">if</span>(field.name.length)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">let</span> option <span class="keyword">of</span> field.options)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(option.selected)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(option.hasAttribute)&#123;</span><br><span class="line">                                optValue=(option.hasAttribute(<span class="string">&quot;value&quot;</span>)?option.value:option.text);</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                optValue=(option.attributes[<span class="string">&quot;value&quot;</span>].specified?option.value:option.text);</span><br><span class="line">                            &#125;</span><br><span class="line">                            parts.push(<span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(field.name)&#125;</span>=`</span>+<span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(optValue)&#125;</span>`</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="literal">undefined</span>:<span class="comment">//字段集</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;file&quot;</span>:<span class="comment">//文件输入</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;submit&quot;</span>:<span class="comment">//提交按钮</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;reset&quot;</span>:<span class="comment">//重置按钮</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;button&quot;</span>:<span class="comment">//自定义按钮</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;radio&quot;</span>:<span class="comment">//单选按钮</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;checkbox&quot;</span>:<span class="comment">//复选框</span></span><br><span class="line">                <span class="keyword">if</span>(!field.checked)&#123;<span class="comment">//没被选中，跳出switch，否则进入default分支，将字段的名字和值编码后添加进parts数组</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">                <span class="comment">//不包含没有名字的表单字段</span></span><br><span class="line">                <span class="keyword">if</span>(field.name.length)&#123;</span><br><span class="line">                    parts.push(<span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(field.name)&#125;</span>=`</span>+<span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(field.value)&#125;</span>`</span>)</span><br><span class="line">                &#125;          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parts.join(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>选择框编程</title>
    <url>/2021/12/12/%E9%80%89%E6%8B%A9%E6%A1%86%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="选项处理"><a href="#选项处理" class="headerlink" title="选项处理"></a>选项处理</h1><p>使用选择框的selectedIndex属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  &lt;form method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;location&quot;</span> <span class="attr">id</span>=<span class="string">&quot;selLocation&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Sunnyvalue,CA&quot;</span>&gt;</span>Sunnyvalue<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Los Angeles,CA&quot;</span>&gt;</span>Los Angeles<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Mountain View,CA&quot;</span>&gt;</span>Mountain View<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>China<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">option</span> &gt;</span>Australia<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">     &lt;/form&gt;</span><br><span class="line">     </span><br><span class="line">     <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example3.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> selectbox=<span class="built_in">document</span>.forms[<span class="number">0</span>].elements[<span class="string">&quot;location&quot;</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSelectedOptions</span>(<span class="params">selectbox</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> option <span class="keyword">of</span> selectbox.options)&#123;</span><br><span class="line">        <span class="keyword">if</span>(option.selected)&#123;</span><br><span class="line">            result.push(option);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> selectedOptions=getSelectedOptions(selectbox);</span><br><span class="line"><span class="keyword">let</span> message=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> option <span class="keyword">of</span> selectedOptions)&#123;</span><br><span class="line">    message+=<span class="string">`Selected index:<span class="subst">$&#123;option.index&#125;</span>\n`</span>+<span class="string">`Selected text:<span class="subst">$&#123;option.text&#125;</span>\n`</span>+<span class="string">`Selected value:<span class="subst">$&#123;option.value&#125;</span>\n`</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(message);</span><br></pre></td></tr></table></figure>

<h1 id="添加选项"><a href="#添加选项" class="headerlink" title="添加选项"></a>添加选项</h1><h2 id="动态创建选项"><a href="#动态创建选项" class="headerlink" title="动态创建选项"></a>动态创建选项</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newOption=<span class="built_in">document</span>.createElement(<span class="string">&quot;option&quot;</span>);</span><br><span class="line">newOption.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;Option text&quot;</span>));</span><br><span class="line">newOption.setAttribute(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;Option value&quot;</span>);</span><br><span class="line">selectbox.appendChild(newOption);</span><br></pre></td></tr></table></figure>

<p>使用Option构造函数创建选项,接收两个参数：text和value，用选择框的add方法添加选项</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newOption=<span class="keyword">new</span> Option(<span class="string">&quot;Option text&quot;</span>,<span class="string">&quot;Option value&quot;</span>);</span><br><span class="line">selectbox.add(newOption,<span class="literal">undefined</span>);<span class="comment">//在列表末尾添加选项</span></span><br></pre></td></tr></table></figure>

<h2 id="移除选项"><a href="#移除选项" class="headerlink" title="移除选项"></a>移除选项</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">selectbox.removeChild(selectbox.options[<span class="number">0</span>]);<span class="comment">//移除第一项</span></span><br><span class="line">selectbox.remove(<span class="number">0</span>);<span class="comment">//移除第一项</span></span><br><span class="line">selectbox.options[<span class="number">0</span>]=<span class="literal">null</span>;</span><br><span class="line"><span class="comment">//清除选项框的所有选项</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clearSelectbox</span>(<span class="params">selectbox</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> option <span class="keyword">of</span> selectbox.options)&#123;</span><br><span class="line">        selectbox.remove(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="移动和重排选项"><a href="#移动和重排选项" class="headerlink" title="移动和重排选项"></a>移动和重排选项</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> selectbox1=<span class="built_in">document</span>.getElementById(<span class="string">&quot;selLocations1&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> selectbox2=<span class="built_in">document</span>.getElementById(<span class="string">&quot;selLocations2&quot;</span>);</span><br><span class="line">selectbox2.appendChild(selectbox1.options[<span class="number">0</span>]);<span class="comment">//将选项从第一个选择框移动到另一个选择框</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重排选项</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> selectbox1=<span class="built_in">document</span>.getElementById(<span class="string">&quot;selLocations1&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> optionToMove=selectbox1.options[<span class="number">1</span>];</span><br><span class="line">selectbox1.insertBefore(optionToMove,selectbox1.options[optionToMove.index-<span class="number">1</span>]);<span class="comment">//将要重排的选项移动到它原先位置的前前面</span></span><br><span class="line"><span class="keyword">let</span> selectbox1=<span class="built_in">document</span>.getElementById(<span class="string">&quot;selLocations1&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> optionToMove=selectbox1.options[<span class="number">1</span>];</span><br><span class="line">selectbox1.insertBefore(optionToMove,selectbox1.options[optionToMove.index+<span class="number">2</span>]);<span class="comment">//将要重排的选项移动到它原先位置的后面一位</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
</search>
