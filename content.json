{"meta":{"title":"小七的博客","subtitle":"www.xiaoqi.cn","description":"欢迎来到我的世界!","author":"小七","url":"https://coloey.github.io","root":"/"},"pages":[{"title":"categories","text":"","path":"categories/index.html","date":"11-12","excerpt":""}],"posts":[{"title":"富文本","text":"富文本编辑在空白 HTML 文件中嵌入一个iframe。通过 designMode 属性，可以将这个空白文档变成可以编辑的，实际编辑的则是元素的 HTML。designMode 属性有两个可能的值：”off”（默认值）和”on”。设置为”on”时 富文本交互使用 document.execCommand()。这个方法在文档上执行既定的命令，可以实现大多数格式化任务。document.execCommand()可以接收 3 个参数：要执行的命令、表示浏览器是否为命令提供用户界面的布尔值和执行命令必需的值 12345678910// 在内嵌窗格中切换粗体文本样式frames[&quot;richedit&quot;].document.execCommand(&quot;bold&quot;, false, null);// 在内嵌窗格中切换斜体文本样式frames[&quot;richedit&quot;].document.execCommand(&quot;italic&quot;, false, null);// 在内嵌窗格中创建指向 www.wrox.com 的链接frames[&quot;richedit&quot;].document.execCommand(&quot;createlink&quot;, false,&quot;http://www.wrox.com&quot;);// 在内嵌窗格中为内容添加&lt;h1&gt;标签frames[&quot;richedit&quot;].document.execCommand(&quot;formatblock&quot;, false, &quot;&lt;h1&gt;&quot;); 富文本选择在内嵌窗格中使用 getSelection()方法，可以获得富文本编辑器的选区。这个方法暴露在document 和 window 对象上，返回表示当前选中文本的 Selection 对象 12345678910let selection = frames[&quot;richedit&quot;].getSelection();// 取得选中的文本let selectedText = selection.toString();// 取得表示选区的范围let range = selection.getRangeAt(0);// 高亮选中的文本let span = frames[&quot;richedit&quot;].document.createElement(&quot;span&quot;);span.style.backgroundColor = &quot;yellow&quot;;range.surroundContents(span); 通过表单提交富文本12345form.addEventListener(&quot;submit&quot;,(event)=&gt;&#123; let target=event.target; target.elements[&quot;comments&quot;].value=frames[&quot;richedit&quot;].document.body.innerHTML;//使用内嵌窗格 //target.elements[&quot;comments&quot;].value=document.getElementById(&quot;richedit&quot;).innerHTML;//使用contenteditable&#125;)","path":"2021/12/13/富文本/","date":"12-13","excerpt":"","tags":[]},{"title":"表单序列化","text":"表单在js中可以使用表单字段的type属性连同其name属性和value属性来进行序列化 字段名和值是 URL 编码的并以和号（&amp;）分隔。 禁用字段不会发送。 复选框或单选按钮只在被选中时才发送。 类型为”reset”或”button”的按钮不会发送。 多选字段的每个选中项都有一个值。 通过点击提交按钮提交表单时，会发送该提交按钮；否则，不会发送提交按钮。类型为”image”的元素视同提交按钮。 select元素的值是被选中option元素的 value 属性。如果元素没有 value 属性，则该值是它的文本 返回的结果是查询字符串的格式 1234567891011121314151617181920212223242526272829303132333435363738394041function serialize(form)&#123; let parts=[]; let optValue; for(let field of form.elements)&#123; switch(field.type)&#123; case &quot;select-one&quot;: case &quot;select-multiple&quot;: if(field.name.length)&#123; for(let option of field.options)&#123; if(option.selected)&#123; if(option.hasAttribute)&#123; optValue=(option.hasAttribute(&quot;value&quot;)?option.value:option.text); &#125;else&#123; optValue=(option.attributes[&quot;value&quot;].specified?option.value:option.text); &#125; parts.push(`$&#123;encodeURIComponent(field.name)&#125;=`+`$&#123;encodeURIComponent(optValue)&#125;`); &#125; &#125; &#125; break; case undefined://字段集 case &quot;file&quot;://文件输入 case &quot;submit&quot;://提交按钮 case &quot;reset&quot;://重置按钮 case &quot;button&quot;://自定义按钮 break; case &quot;radio&quot;://单选按钮 case &quot;checkbox&quot;://复选框 if(!field.checked)&#123;//没被选中，跳出switch，否则进入default分支，将字段的名字和值编码后添加进parts数组 break; &#125; default: //不包含没有名字的表单字段 if(field.name.length)&#123; parts.push(`$&#123;encodeURIComponent(field.name)&#125;=`+`$&#123;encodeURIComponent(field.value)&#125;`) &#125; &#125; &#125; return parts.join(&quot;&amp;&quot;);&#125;","path":"2021/12/12/表单序列化/","date":"12-12","excerpt":"","tags":[]},{"title":"DOM编程","text":"DOM编程动态脚本1234567891011function loadScriptString(code)&#123; var script=document.createElement(&quot;script&quot;); script.type=&quot;text/javascript&quot;; try&#123; script.appendChild(document.createTextNode(code));//旧版本的IE浏览器可能出问题 &#125;catch(ex)&#123; script.text=code; &#125; document.body.appendChild(script);&#125;loadScriptString(&quot;function sayHi()&#123;alert(&#x27;hi&#x27;);&#125;&quot;); 动态样式123456789101112function loadStyleString(css)&#123; let style=document.createElement(&quot;style&quot;); style.type=&quot;text/css&quot;; try&#123; style.appendChild(document.createTextNode(css)); &#125;catch(ex)&#123; style.styleSheet.cssText=css; &#125; let head=document.getElementsByTagName(&quot;head&quot;)[0]; head.appendChild(style);&#125;loadStyleString(&quot;body[background-color:red&#125;&quot;); 对于IE，要小心使用styleSheet.cssText,如果重用同一个元素并设置该属性超过一次，则可能导致浏览器崩溃，将cssText设置为空字符串也可能导致浏览器崩溃 表单12345678910111213141516171819let table=document.createElement(&quot;table&quot;);table.border=1;table.width=&quot;100%&quot;;let tbody=document.createElement(&quot;tbody&quot;);table.appendChild(tbody);table.insertRow(0);tbody.rows[0].insertCell(0);tbody.rows[0].cells[0].appendChild(document.createTextNode(&quot;Cell 1,1&quot;));tbody.rows[0].insertCell(1);tbody.rows[0].cells[1].appendChild(document.createTextNode(&quot;Cell 2,1&quot;));table.insertRow(1);tbody.rows[1].insertCell(0);tbody.rows[1].cells[0].appendChild(document.createTextNode(&quot;Cell 1,2&quot;));tbody.rows[1].insertCell(1);tbody.rows[1].cells[1].appendChild(document.createTextNode(&quot;Cell 2,2&quot;));document.body.appendChild(table); NodeList12345let divs=document.getElementsByTagName(&quot;div&quot;);for(let i=0,len=divs.length;i&lt;len;i++)&#123; let div=doocument.createElement(&quot;div&quot;); document.body.appendChild(div);&#125;//避免导致无穷循环 Mutationobserver接口在DOM被修改时异步执行回调，使用MutationObserver可以观察整个文档，DOM树的一部分或某个元素 MutationObserver的实例通过调用MutationObserver构造函数并传入一个回调函数创建 1let observer=new MutationObserver(()=&gt;console.log(&#x27;DOM was mutated&#x27;)); observe()方法接收两个参数：要观察其变化的DOM节点，以及一个MutationObserverInit对象（用于控制观察哪些方面的变化，是一个键值对形式配置选项的字典） 12let observer=new MutationObserver(()=&gt;console.log(&#x27;&lt;body&gt; attributes changed&#x27;));observer.observe(document.body,&#123;attributes:true&#125;); 元素上任何属性发生变化都会被这个MutationObserver实例发现，然后异步执行注册的回调函数,元素后代修改或其他非属性修改不会触发回调进入任务 123456let observer=new MutationObserver(()=&gt;console.log(&#x27;&lt;body&gt; attributes changed&#x27;));observer.observe(document.body,&#123;attributes:true&#125;);document.body.className=&#x27;foo&#x27;;console.log(&#x27;Changed body class&#x27;);//Changed body class//&lt;body&gt; attributes changed 回调与MutationRecord每次回调都会收到一个MutationRecord实例的数组,包含的信息发生了什么变化以及DOM哪一部分受到影响 123456789let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));[observer.observe(document.body,&#123;attributes:true&#125;);document.body.setAttributeNS(&#x27;foo&#x27;,&#x27;bar&#x27;,&#x27;baz&#x27;);//连续修改多个MutationRecord实例，回调函数就会受到包含这些实例的数组，顺序为变化事件的顺序let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));observer.observe(document.body,&#123;attributes:true&#125;);document.body.className=&#x27;foo&#x27;;document.body.className=&#x27;bar&#x27;;//[MutationRecord, MutationRecord] disconnect()方法会停止此后变化事件的回调，也会抛弃已经加入任务队列要异步执行的回调 1234567891011let observer=new MutationObserver(()=&gt;console.log(&#x27;&lt;body&gt;attributes changed&#x27;));observer.observe(document.body,&#123;attributes:true&#125;);document.body.className=&#x27;foo&#x27;;observer.disconnect();document.body.className=&#x27;bar&#x27;;//无日志输出//让已经入队的回调函数执行完毕后再调用disconnect()setTimeout(()=&gt;&#123; observer.disconnect(); document.body.className=&#x27;bar&#x27;;&#125;,0); 复用MutationObserver12345678910let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords.map((x)=&gt;x.target)));let childA=document.createElement(&#x27;div&#x27;); childB=document.createElement(&#x27;span&#x27;);document.body.appendChild(childA);document.body.appendChild(childB);observer.observe(childA,&#123;attributes:true&#125;);observer.observe(childB,&#123;attributes:true&#125;);childA.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);childB.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);//[div, span] 重用MutationObserver调用diaconnect()不会结束MutationObserver的生命，还可以重新使用这个观察者，再将它关联到新的目标结点 MutationObserverInit与观察范围观察属性设置attributes为true,观察所有属性 123456789let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));observer.observe(document.body,&#123;attributes:true&#125;);//添加属性document.body.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);//修改属性document.body.setAttribute(&#x27;foo&#x27;,&#x27;baz&#x27;);//移除属性document.body.removeAttribute(&#x27;foo&#x27;); 用attributeFilter添加白名单属性 123456let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));observer.observe(document.body,&#123;attributeFilter:[&#x27;foo&#x27;]&#125;);//添加白名单属性document.body.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);//添加被排除的属性document.body.setAttribute(&#x27;baz&#x27;,&#x27;qux&#x27;); 在记录中保存属性原来的值 123456let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords.map((x)=&gt;x.oldValue)));observer.observe(document.body,&#123;attributeOldValue:true&#125;);document.body.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);document.body.setAttribute(&#x27;foo&#x27;,&#x27;baz&#x27;);document.body.setAttribute(&#x27;foo&#x27;,&#x27;qux&#x27;);//[null, &#x27;bar&#x27;, &#x27;baz&#x27;] 观察字符数据12345678910111213let observer=new MutationObserver(document.body.firstChild,&#123;characterData:true&#125;);document.body.firstChild.textContent=&#x27;foo&#x27;;//创建要观察的文本节点observer.observe(document.body.firstChild,&#123;characterData:true&#125;);document.body.firstChild.textContent=&#x27;foo&#x27;;document.body.firstChild.textContent=&#x27;bar&#x27;;document.body.firstChild.textContent=&#x27;baz&#x27;;//使用characterDataOldValuelet observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords.map((x)=&gt;x.oldValue)));document.body.firstChild.textContent=&#x27;foo&#x27;;//创建要观察的文本节点observer.observe(document.body.firstChild,&#123;characterDataOldValue:true&#125;);document.body.firstChild.textContent=&#x27;foo&#x27;;document.body.firstChild.textContent=&#x27;bar&#x27;;document.body.firstChild.textContent=&#x27;baz&#x27;; 观察子节点12345678document.body.innerHTML=&#x27;&#x27;;let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));//创建两个初始子节点document.body.appendChild(document.createElement(&#x27;div&#x27;));document.body.appendChild(document.createElement(&#x27;span&#x27;));observer.observe(document.body,&#123;childList:true&#125;);document.body.insertBefore(document.body.lastChild,document.body.firstChild);//发生两次变化，先移除节点再添加节点 观察子树12345document.body.innerHTML=&#x27;&#x27;;let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));document.body.appendChild(document.createElement(&#x27;div&#x27;));observer.observe(document.body,&#123;attributes:true,subtree:true&#125;);document.body.firstChild.setAttribute(&#x27;foo&#x27;,&#x27;baz&#x27;); 异步回调与记录队列takeRecords()方法清空记录队列，取出并·返回其中的所有MutationRecord实例,可以用在希望断开与观察目标的联系，但又希望处理由于disconnect()而被抛弃的记录队列中的MutationRecord实例 12345678let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));observer.observe(document.body,&#123;attributes:true&#125;);document.body.className=&#x27;foo&#x27;;document.body.className=&#x27;bar&#x27;;console.log(observer.takeRecords());console.log(observer.takeRecords());//[MutationRecord, MutationRecord]//[]","path":"2021/12/12/DOM-DOM编程/","date":"12-12","excerpt":"","tags":[]},{"title":"DOM节点层级","text":"Node类型DOM Level 1描述为名为Node的接口，Node接口在JavaScript中被实现为Node类型，所有结点都继承Node类型，因此所有类型都共享相同的基本属性和方法。 节点类型可通过与这些常量比较来确定 12345678//节点类型可通过与这些常量比较确定，如果两者相等，则意味着someNode是一个元素节点if(someNode.nodeType==Node.ELEMENT_NODE)&#123; alert(&quot;Node is an element&quot;);&#125;//nodeName和nodeValue保存着有关节点的信息if(someNode.nodeType==1)&#123; value=someNode.nodeName;//会显示元素的标签名&#125; 节点关系节点与其他节点的关系可形容为家族关系，每个节点有一个childNodes属性其中包含一个NodeList的实例，NodeList是一个类数组对象，它是DOM结构的查询，DOM结构的变化会自动地在NodeList中反映出来，用于存储可以按位置存取的有序节点。可以使用中括号或者item()方法访问它的值 1234let firstChild=someNode.childNodes[0];let secondChild=someNode.childNodes.item(1);let count=someNode.childNodes.length;let arrayofNodes=Array.from(someNode.childNodes); parentNode指向DOM树中的父元素，childNode中所有节点都有同一个父元素，parentNode指向同一个节点，childNodes列表中每个结点都是同一列表中其他节点的同胞节点，使用previousSibling和nextSibling可以在这个列表的节点间导航。 hasChildNodes()节点返回true则说明节点有一个或多个子节点。 ownerDocument属性是一个指向代表整个文档的文档节点的指针 操纵节点appendChild():用于在childNodes列表末尾添加节点，返回新添加的节点。 123let returnedNode=someNode.appendChild(newNode);alert(returnedNode==newNode);//truealert(someNode.lastChild==newNode);//true inserBefore():接收两个参数，要插入的节点和参照节点。要插入的节点会变成参照节点的前一个同胞节点，并被返回 12345678910returnedNode=someNode.insertBefore(newNode,null);alert(newNode==someNode.lastChild);//true//作为新的第一个子节点插入retunedNode=someNode.insertBefore(newNode,someNode.firstChild);alert(returnedNode==newNode);//truealert(newNode==someNode.fiestChild);//true//插入最后一个子节点的前面returnedNode==someNode.insertBefore(newNode,someNode.lastChild);alert(newNode==someNode.childNodes[someNode.childNodes.length-2]);//true replaceChild():接收两个参数，要插入的节点和要替换的节点。要替换的节点被返回并从文档中被移除 1returnedNode=someNode.replaceChild(newNode,someNode.lastChild);//替换最后一个子节点 removeChild():接收一个参数，即要被移除的节点，被移除的节点会被返回 1let formerFirstChild=someNode.removeChild(someNode.firstChild); cloneNode():传入true参数会进行深复制，即复制节点和整个子DOM树；传入false进行浅复制，只会复制该方法的节点。复制返回的节点属于文档所有，但未指定父节点，称为孤儿节点，通过appendChild()和insertBefore()或replaceChild()方法把孤儿节点添加到文档中 normalize():处理文本节点，如果发现空文本节点则将其删除否则如果两个同胞节点相邻则将其合并为一个文本节点 Document类型表示文档节点的类型,document是HTMLDocument的实例（HTMLDocument继承Document）,表示整个HTML页面，document是window对象的属性是一个全局对象。 nodetype等于9 nodeName值为“#document” nodevalue值为null parentNode值为null ownerDocument值为null 子节点可以使DocumentType(最多一个)，Element(最多一个)，ProcessingInstruction或Comment类型 文档子节点documentElement:始终指向HTML页面中的元素 1234567&lt;html&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;let html=document.documentElement;//取得对&lt;html&gt;的引用alert(html===document.childNodes[0]);alert(html===document.firstChild); document.body:直接指向元素，取得对的引用 文档信息title:显示浏览器窗口或标签页的标题栏 URL:包含当前页面的完整URL domain:包含页面的域名 referrer:包含空字符串 123//document.URL=&quot;http://www.wrox.com/WileyCDA/&quot;,document.domain就是www.wrox.comdocument=&quot;wrrox.com&quot;;//成功document=&quot;nczonline.net&quot;;//出错,不能给这个属性设置URL中不包含的值 当页面中包含来自某个不同子域的窗格（)或内嵌窗格()设置document.domain是有用的，比如一个加载自www.wrox.com的页面包含一个内嵌窗格其中的页面加载自p2p.wrox.com，这两个页面包含不同的字符串，内部和外部不能相互访问对方的JavaScript对象，如果每个页面都把document.domain设置为wrox.com,那两个页面就可以相互通信 12document.domain=&quot;wrox.com&quot;;//放松，成功document.doman=&quot;p2p2.wrox.com&quot;;//收紧，失败,一旦放松就不能收紧 定位元素getElementById()：接收一个要获取元素的ID，如果找到这个元素则返回，没找到返回null。参数I必须跟元素在页面中大的id属性完全匹配，包括大小写 12&lt;div id=&quot;myDiv&quot;&gt;ome text&lt;/div&gt;let div=document.getElementById(&quot;myDiv&quot;);//取得对&lt;div&gt;的引用,如果存在多个相同ID的元素则返回在文档中的第一个元素 getElementsByTagName():接收一个参数，即要获取元素的标签名,返回包含0个或多个元素的NodeList，在HTML文档中返回一个HTMLCollection对象 12345678910let images=document.getElementsByTagName(&quot;img&quot;);alert(images.length);//图片数量alert(images[0].src);//第一张图片的src属性alert(images.item(0).src);//通过name属性获得引用&lt;img src=&quot;myImage.gif&quot; name=&quot;myImage&quot;&gt;;let myImage=images.namedItem(&quot;myImage&quot;);//images[&quot;myImage&quot;]//取得文档的所有元素let allElements=document.getElementsByTagName(&quot;*&quot;); getElementsByName():返回具有给定name属性的所有元素，常用于单选按钮 12345678910&lt;fieldset&gt; &lt;legend&gt;Which color do you prefer?&lt;/legend&gt; &lt;ul&gt; &lt;li&gt; &lt;input type=&quot;radio&quot; value=&quot;red&quot; name=&quot;color&quot; id=&quot;colorRed&quot;&gt;&lt;label for=&quot;colorRed&quot;&gt;Red&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;radio&quot; value=&quot;blue&quot; name=&quot;color&quot; id=&quot;colorBlue&quot;&gt;&lt;label for=&quot;colorBlue&quot;&gt;Blue&lt;/label&gt; &lt;/li&gt; let radios=document.getElementsByName(&quot;color&quot;); Element类型 nodeType=1 nodeName值为元素的标签名 nodeValue的值为null parentNode值为Document或Element对象 子节点可以是Element,Text,Comment,ProcessingInstruction等类型 通过nodeName或tagName属性获得元素的标签名 1234567891011121314151617181920//使用对象属性&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt; &lt;script&gt; let div=document.getElementById(&quot;myDiv&quot;); alert(div.tagName);//&quot;DIV&quot; alert(div.tagName==div.nodeName);//true if(element.tagName.toLowerCase()==&quot;div&quot;)&#123; //,HTML中，元素标签名以答谢表示，XML中标签名与代码中的大小写一致，不确定脚本是HTML还是XML运行，推荐将标签名转换为小写形式，适合所有文档 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; HTML元素 id:元素在文档中的唯一标识符 title：包含元素的额外信息，通常以提示条形式展示 lang：元素内容的语言代码 dir：语言的书写方向（ltr从左到右，rtl从右到左) className:相当于class属性，用于指定元素的CSS类 取得属性1234567891011121314151617181920212223//使用对象属性&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;myDiv&quot; class=&quot;bd&quot; title=&quot;Body text&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;2&lt;/div&gt; &lt;script&gt; var div=document.getElementById(&quot;myDiv&quot;); alert(div.id); alert(div.className); alert(div.title); alert(div.lang); alert(div.dir); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;//使用getAttribute()方法alert(div.getAttribute(&quot;class&quot;)); getAttribute()主要用于取得自定义属性的值，其他情况使用对象属性 设置属性setAttribute():接收两个参数，要设置的属性名和属性值,如果属性存在则用指定的值替换原来的值 1234567//直接给对象属性赋值div.id=&quot;someOtherId&quot;//在对象属性上添加自定义属性，不会让它变成元素的属性div.mycolor=&quot;red&quot;;alert(div.getAttribute(&quot;mycolor&quot;));//null//使用setAttribute赋值div.setAttribute(&quot;id&quot;,&quot;someOtherId&quot;); attributes属性attributes属性包含一个NamedNodeMap实例，是一个类似NodeList的“实时”集合，元素的每个属性都表示为一个Attr节点，并保存在NamedNodeMap对象中 attributed属性中的每个节点的nodeName是对应属性的名字，nodeValue是属性的值 12345678function outputAttributes(element)&#123; let pairs=[]; for(let i=0,len=element.attributes.length;i&lt;len;++i)&#123; const attribute=element.attributes[i]; pairs.push(`$&#123;attribute.nodeName&#125;=$&#123;attribute.nodeValue&#125;`); return pairs.join(&quot; &quot;); &#125;&#125; 创建元素document.createElement():一个参数，即要创建元素的标签名 1234let div=document.createElement(&quot;div&quot;);div.id=&quot;myNewDiv&quot;;div.className=&quot;box&quot;;document.body.appendChild(div); Text 类型Text节点由Text类型表示，包含按字面解释的纯文本，也可能包含转义后的HTML字符，Text节点中包含的文本可以通过nodeValue或者data属性访问 nodetype=3 nodeName=”#text” nodeValue值为节点中包含的文本 parentNode值为Element对象 不支持子节点 appendData(text):向节点末尾添加文本text deleteData(offset,count),从位置offset开始删除count个字符 insertData(offset,text),在位置offset插入text； replaceData(offset,count,text)，用text替换从位置offset到offset+count大的文本 splitText(offset),在位置offset将当前文本节点拆分为两个文本节点 substringData(offset,count),提取从位置offset到offset+count的文本 包含文本内容的每个元素最多只能有一个文本节点 创建文本节点document.createTextNode():创建新文本节点，接收一个参数，即要插入节点的文本 123456789let element=document.createElement(&quot;div&quot;);element.className=&quot;message&quot;;let textNode=document.createTextNode(&quot;Hello world!&quot;);element.appendChild(textNode);let anotherTextNode=document.createTextNode(&quot;Yippee&quot;);element.appendChild(anotherTextNode);document.body.appendChild(element); 规范化文本节点合并文本节点1234567891011let element=document.createElement(&quot;div&quot;);element.className=&quot;message&quot;;let textNode=document.createTextNode(&quot;Hello World&quot;);element.appendChild(textNode);let anotherTextNode=document.createTextNode(&quot;Yippee&quot;);element.appendChild(anotherTextNode);document.body.appendChild(element);alert(element.childNodes.length);//2element.normalize();alert(element.childNodes.length);//1alert(element.firstChild.nodeValue); 拆分文本节点12345678910let element=document.createElement(&quot;div&quot;);element.className=&quot;message&quot;;let textNode=document.createTextNode(&quot;Hello World&quot;);element.appendChild(textNode);document.body.appendChild(element);let newNode=element.firstChild.splitText(5);alert(element.fiestChild.nodeValue);//&quot;Hello&quot;alert(newNode.nodeValue);//&quot;world&quot;alert(element.chileNodes.length);//2 Comment类型 nodeType=8 nodeName=”#comment” nodeValue值为注释内容 parentNode值为Document或Element对象 不支持子节点 Comment类型与Text类型继承自同一个基类(CharacterData),因此拥有除splitText之外的Text节点所有的字符串操作方法 CDATASection类型继承Text类型，拥有除splitText之外的Text节点所有的字符串操作方法 DocumentType类型 在DOM Level1中不支持动态创建，只能在解析文档代码时创建，DocumentType对象保存在document.doctype属性中. DocumentType对象有3个属性：name,entities,notations. name是文档名称，entities是这个文档类型描述实体的NameNodeMap,而notations是这个文档类型描述的表示法的NamedNodeMap. 浏览器文档通常是HTML或XHTML类型，所以entities和notations列表为空，只有name属性有用，包含文档类型的名称 DocumentFragment类型 nodeType=11 nodeName=”#document-fragment” nodeValue=null parentNode=null 子节点可以是Element,ProcessingInstruction,Comment,Text,CDATASection 充当其他要被添加的文档节点的仓库 123456789&lt;ul id=&quot;myList&quot;&gt;&lt;/ul&gt;let fragment=document.createDocumentFragment();let ul=document.getElementById(&quot;myList&quot;);for(let i=0;i&lt;3;i++)&#123; let li=document.createElement(&quot;li&quot;); li.appendChild(document.createTextNode(`Item $&#123;i+1&#125;`)); fragment.appendChild(li);&#125;ul.appendChild(fragment); Attr类型属性是存在于元素attributes属性中的节点 nodeType=2 nodeName值为属性名 nodeValue值为属性值 parentNode值为null Attr对象上3个属性 name包含属性名 value包含属性值 specified是一个布尔值，表示属性使用的是默认值和还是被指定的值 12345678let attr=document.createAttribute(&quot;align&quot;);//创建新的Attr节点，参数为属性名attr.value=&quot;left&quot;;element.setAttributeNode(attr);//添加属性节点alert(element.attributes[&quot;align&quot;].value);//返回对应属性节点alert(element.getAttributeNode(&quot;align&quot;).value);//返回对应属性节点alert(element.getAttribute(&quot;align&quot;));//只返回属性值","path":"2021/12/12/DOM-节点层级/","date":"12-12","excerpt":"","tags":[]},{"title":"选择框编程","text":"选项处理使用选择框的selectedIndex属性 123456789101112131415161718192021222324252627282930 &lt;form method=&quot;post&quot;&gt; &lt;select name=&quot;location&quot; id=&quot;selLocation&quot;&gt; &lt;option value=&quot;Sunnyvalue,CA&quot;&gt;Sunnyvalue&lt;/option&gt; &lt;option value=&quot;Los Angeles,CA&quot;&gt;Los Angeles&lt;/option&gt; &lt;option value=&quot;Mountain View,CA&quot;&gt;Mountain View&lt;/option&gt; &lt;option value=&quot;&quot;&gt;China&lt;/option&gt; &lt;option &gt;Australia&lt;/option&gt; &lt;/select&gt; &lt;/form&gt; &lt;script src=&quot;example3.js&quot;&gt;&lt;/script&gt; let selectbox=document.forms[0].elements[&quot;location&quot;];function getSelectedOptions(selectbox)&#123; let result=new Array(); for(let option of selectbox.options)&#123; if(option.selected)&#123; result.push(option); &#125; &#125; return result;&#125;let selectedOptions=getSelectedOptions(selectbox);let message=&quot;&quot;;for(let option of selectedOptions)&#123; message+=`Selected index:$&#123;option.index&#125;\\n`+`Selected text:$&#123;option.text&#125;\\n`+`Selected value:$&#123;option.value&#125;\\n`;&#125;console.log(message); 添加选项动态创建选项1234let newOption=document.createElement(&quot;option&quot;);newOption.appendChild(document.createTextNode(&quot;Option text&quot;));newOption.setAttribute(&quot;value&quot;,&quot;Option value&quot;);selectbox.appendChild(newOption); 使用Option构造函数创建选项,接收两个参数：text和value，用选择框的add方法添加选项 12let newOption=new Option(&quot;Option text&quot;,&quot;Option value&quot;);selectbox.add(newOption,undefined);//在列表末尾添加选项 移除选项123456789selectbox.removeChild(selectbox.options[0]);//移除第一项selectbox.remove(0);//移除第一项selectbox.options[0]=null;//清除选项框的所有选项function clearSelectbox(selectbox)&#123; for(let option of selectbox.options)&#123; selectbox.remove(0); &#125;&#125; 移动和重排选项1234let selectbox1=document.getElementById(&quot;selLocations1&quot;);let selectbox2=document.getElementById(&quot;selLocations2&quot;);selectbox2.appendChild(selectbox1.options[0]);//将选项从第一个选择框移动到另一个选择框 重排选项 123456let selectbox1=document.getElementById(&quot;selLocations1&quot;);let optionToMove=selectbox1.options[1];selectbox1.insertBefore(optionToMove,selectbox1.options[optionToMove.index-1]);//将要重排的选项移动到它原先位置的前前面let selectbox1=document.getElementById(&quot;selLocations1&quot;);let optionToMove=selectbox1.options[1];selectbox1.insertBefore(optionToMove,selectbox1.options[optionToMove.index+2]);//将要重排的选项移动到它原先位置的后面一位","path":"2021/12/12/选择框编程/","date":"12-12","excerpt":"","tags":[]},{"title":"文本框编程","text":"文本框编程表示文本框的两种方式123456&lt;input type=&quot;text&quot; size=&quot;25&quot; maxlength=&quot;50&quot; value=&quot;initial value&quot;&gt; //创建多行文本框 &lt;textarea rows=&quot;25&quot; cols=&quot;5&quot;&gt;initial value&lt;/textarea&gt;//用使用value属性读写文本框let textbox=document.forms[0].elements[&quot;textbox1&quot;];textbox.value=&quot;Some new value&quot;; 选择文本select()用于全选文本 123456let form=document.getElementById(&quot;myForm&quot;); let textbox=form.elements[0]; textbox.addEventListener(&quot;focus&quot;,(event)=&gt;&#123; event.target.select(); console.log(`Text selected:$&#123;textbox.value&#125;`); &#125;); setSelectionRange()用于部分选择文本 1234567let form=document.getElementById(&quot;myForm&quot;);let textbox=form.elements[0];textbox.addEventListener(&quot;focus&quot;,(event)=&gt;&#123; event.target.select(); textbox.setSelectionRange(0,1); console.log(`Text selected:$&#123;textbox.value&#125;`); &#125;); 屏蔽按键12345textbox.addEventListener(&quot;keypress&quot;,(event)=&gt;&#123; if(!/\\d/.test(String.fromCharCode(event.charCode))&amp;&amp;event.charCode&gt;9&amp;&amp;!event.ctrlKey)&#123;//屏蔽非数字字符但允许同样触发keypress事件的所有基础按键以及ctrl键 event.preventDefault(); &#125;&#125;) 自动切换1234567891011121314151617181920212223242526&lt;form method=&quot;post&quot;&gt; &lt;input type=&quot;text &quot; name=&quot;tel1&quot; id=&quot;textTel1&quot; maxlength=&quot;3&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;tel2&quot; id=&quot;textTel2&quot; maxlength=&quot;3&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;tel3&quot; id=&quot;textTel3&quot; maxlength=&quot;4&quot;&gt; &lt;/form&gt; let inputIds=[&quot;textTel1&quot;,&quot;textTel2&quot;,&quot;textTel3&quot;];for(let id of inputIds)&#123; let textbox=document.getElementById(id); textbox.addEventListener(&quot;keyup&quot;,(event)=&gt;&#123; let target=event.target; if(target.value.length==target.maxLength)&#123; let form=target.form; for(let i=0,len=form.elements.length;i&lt;len;i++)&#123; if(form.elements[i]==target)&#123; if(form.elements[i+1])&#123; form.elements[i+1].focus(); &#125; return; &#125; &#125; &#125; &#125;); &#125;;","path":"2021/12/09/文本框/","date":"12-09","excerpt":"","tags":[]},{"title":"表单","text":"表单禁用表单避免多次提交表单可以在第一次点击后禁用表单 12345678let form=document.getElementById(&quot;myForm&quot;);form.addEventListener(&quot;submit&quot;,(event)=&gt;&#123; let target=event.target; //取得提交按钮 let btn=target.elements[&quot;submit-btn&quot;]; //禁用提交按钮 btn.disabled=true;&#125;) focus()把焦点设置到表单字段,这意味着该字段会变成活动字段并可以响应键盘事件,autofocus()会自动为带有该属性的元素设置焦点 12345678let form=document.getElementById(&quot;myForm&quot;);window.addEventListener(&quot;load&quot;,(event)=&gt;&#123; let element=form.elements[0]; if(element.autofocus!==true)&#123; element.focus(); console.log(&quot;JS focus&quot;); &#125; &#125;) 表单的公共事件","path":"2021/12/09/表单/","date":"12-09","excerpt":"","tags":[]},{"title":"BOM","text":"BOMlocation对象提供当前窗口加载文档的信息，以及通常的导航功能，它既是window的属性也是document的属性。 查询字符串123456789101112131415161718let getQueryStringArgs=function()&#123; //取得没有开头问号的查询字符串 let qs=(location.search.length&gt;0)?location.search.substring(1):&quot;&quot;; let args=&#123;&#125;; for(let item of(qs.split(&#x27;&amp;&#x27;).map(kv=&gt;kv.split(&#x27;=&#x27;))))&#123; let name=item[0]; value=item[1]; if(name.length)&#123; args[name]=value; &#125; &#125; return args;&#125;//qs=&quot;?q=javaScript&amp;num=10&quot;;let args=getQueryStringArgs();alert(args[&quot;q&quot;]);alert(args[&#x27;num&#x27;]); 使用USLSearchParams检查和修改查询字符串 123456789101112let qs=&quot;?q=javaScript&amp;num=10&quot;;let searchParams=new URLSearchParams(qs);alert(searchParams.toString());searchParams.has(&quot;num&quot;);searchParams.get(&quot;num&quot;);searchParams.set(&quot;page&quot;,&quot;3&quot;);alert(searchParams.toString());searchParams.delete(&quot;q&quot;);alert(searchParams.toString());for(let param of searchParams)&#123; console.log(param);&#125; 操作地址通过修改location对象修改浏览器地址，使用assign方法传进一个URL,会导航到新URL同时在浏览器历史记录增加一条记录，下面三种方法功能相同 123location.assign(&quot;http://www.wrox.com&quot;);window.location=&quot;http://www.wrox.com&quot;;location.href=&quot;http://www.wrox.com&quot;; 通过修改location属性可以修改当前加载的页面,hash,search,hostname,pathname.port属性被设置为新值后会修改当前的URL 123456789101112//假设当前URL为http://www.wrox.com/WileyCDA/location.assign(&quot;http://www.wrox.com/WileyCDA&quot;);//把URL修改为http://www.wrox.com/WileyCDA/#section1location.hash=&quot;#section1&quot;;//把URL修改为http://www.wrox.com/WileyCDA/?q=javascriptlocation.search=&quot;?q=javascript&quot;;//把URL修改为http://www.somewhere.com/WileyCDA/location.hostname=&quot;www.somewhere.com&quot;;//把URL修改为http://www.somewhere.com/mydir/location.pathname=&quot;mydir&quot;;//把URL修改为http://www.somewhere.com:8080/WileyCDA/location.port=8080; 以上的修改会在浏览器中增加记录，点击后退即可导航到前一个界面，不希望增加历史记录可以使用replace()方法，reload()可以重新加载当前页面，如果页面自从上次请求后没有修改过，则浏览器可能会从缓存中加载页面，如果想强制从服务器中加载，必须传入true history对象history用来导航历史记录，同时不会暴露用户访问过的URL。 12345678history.go(-1);//后退一页history.go(1);//前进一页history.go(&quot;wrox.com&quot;)//导航到最近的wrox.com页面//go有两个简写方法：back()和forward()history.back();//后退一页history.forward()//前进一页//history的length属性记录历史记录有多少条目if(history.length==1)&#123;//这是用户窗口第一个页面&#125; navigator对象navigator对象通常用来确定浏览器的类型 检测插件123456789101112131415161718192021222324252627282930313233343536function hasPlugin(name)&#123; name=name.toLowerCase(); for(let plugin of window.navigator.plugins)&#123; if(plugin.name.toLowerCase().indexOf(name)&gt;-1)&#123;return true;&#125; &#125; return false;&#125;//alert(hasPlugin(&quot;Flash&quot;));//alert(hasPlugin(&quot;QuickTime&quot;));function hasIEPlugin(name)&#123; try&#123; new ActiveXObject(name); return true; &#125;catch(ex)&#123; return false; &#125;&#125;//在所有浏览器中检测插件function hasFlash()&#123; var result=hasPlugin(&quot;Flash&quot;); if(!result)&#123; result=hasIEPlugin(&quot;ShockwaveFlash.ShockwaveFlash&quot;); &#125;return result;&#125;function hasQuickTime()&#123; var res=hasPlugin(&quot;QuickTime&quot;); if(!res)&#123; res=hasIEPlugin(&quot;QuickTime.QuickTime&quot;); &#125; return res;&#125;alert(hasFlash());alert(hasQuickTime()); 注册处理程序registerProtocolHandler()方法可以把一个网站注册处理为某种特定类型信息应用程序，传入3个参数：要处理的协议（“mailto或ftp),处理该协议的URL，以及应用名称 例如，把一个Web应用程序注册为默认客户端 1navigator.registerProtocolHandler(&quot;mailto&quot;,&quot;http://www.somemailclient.com?cmd=%s&quot;,&quot;Some Mail Client&quot;);","path":"2021/11/25/BOM/","date":"11-25","excerpt":"","tags":[]},{"title":"HTML+CSS","text":"定位：定位总结： static: 不脱标，不能使用边偏移 relative:不脱标（占有位置），可用margin,相对于自身位置移动 absolute:脱标（不占有位置）,不可用margin,带有定位的父级 fixed：脱标（不占有位置），浏览器可视区 sticky:不脱标（占有位置），浏览器可视区 绝对定位特点：如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位 如果祖先元素有定位（相对，绝对，固定定位）则以最近一级的有定位的祖先元素为参考点移动位置 绝对定位不占有原先的位置（脱标） 叠放次序 z-index在使用定位布局时，可以使用z-index来控制盒子的前后次序 语法： 选择器{z-index:1;} 数值可以是正整数，负整数或者0，默认是auto，数值越大，盒子越靠上 如果属性相同，则按照书写顺序，后来居上 数字后面不能加单位 只有定位的盒子才有z-index属性 定位的拓展1.绝对定位盒子居中 left:50% margin-left:-100px; 2.定位特殊性：绝对定位固定定位和浮动相似 行内元素添加绝对或者固定定位，可以直接设置高度和宽度（span) 块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小 脱标的盒子不会触发外边距合并问题 3.绝对定位（固定定位）会完全压住盒子浮动元素只会压住下面标准流的盒子，但是不会压住下面标准流的文字（图片）但是绝对定位（固定定位）会压住下面标准流的所有内容 浮动之所以不会压住下面文字是因为浮动最初的目的是为了做文字环绕效果 元素里的显示和隐藏display 显示隐藏元素 但是不保留位置 隐藏元素不想要原来位置，用none，否则用block visibility显示隐藏元素 但是保留原来的位置,visible为元素可见，hidden为元素隐藏 overflow 溢出显示隐藏 但是只是对于溢出的部分处理,scoll:溢出的部分显示滚动条，visible:溢出部分可见,hidden:溢出部分不可见,auto:没溢出则不显示滚动条，溢出则超出部分显示滚动条。 用户界面样式鼠标样式cursorli &#123;cursor: pointer; &#125; default 默认小白鼠标 pointer 小手 move 移动 text 文本 not-allowed 禁止 vertical-align实现行内块和文字居中对齐vertical-align:middle 解决图片底部默认空白空隙：图片底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐解决方法：1.给图片添加vertical-align:middle或者top或者bottom 2.把图片转为块级元素 display:block 单行文字溢出显示省略号white-space:nomal:如果文字显示不开自动换行 white-space:nowrap:如果文字显示不开强制一行内显示 overflow:hidden(溢出部分隐藏) text-overflow:ellipsis(文字溢出部分用省略号显示) 多行文本溢出显示省略号​ width: 150px; ​ height: 65px; ​ background-color: pink; ​ margin: 100px auto; ​ overflow: hidden; ​ text-overflow: ellipsis; ​ display: -webkit-box; ​ /* 从第几行开始省略 */ ​ -webkit-line-clamp: 3; ​ -webkit-box-orient: vertical; 常见布局技巧margin负值使用让每个盒子margin往左移动-1px，正好压住相邻盒子的边框 鼠标经过盒子提高当前盒子层级（如果没有定位，则加相对定位（保留位置）如果都有定位则用z-index) 文字围绕浮动元素三角形制作 weight:0; height:0; border-color:transparent red transparent transprent; border-style:solid; border-width:22px 8px 0 0;(上面的宽，右边的小一些) HTML新标签header:头部标签 nav：导航标签 article:内容标签 section:定义文档某个区域 aside:侧边栏标签 footer：尾部标签 主要针对搜索引擎，这些新标签页面中可以使用多次，在IE9中，需要把这些元素转换为块级元素 视频用mp4格式 autoplay:自动播放 controls:向用户使用播放控件 width:设置播放器宽度 height:设置高度 loop:是否循环播放 src：url（视频url地址） poster:加载等待的画面图片 muted：静音播放 新增input表单type=”email” type=”url” type=”date” type=”time” type=”month” type=”week” type=”numbers” type=”tel” type=”search” type=”color” input属性 required=”requied”表示该内容不能为空，必填 placeholder=”placeholder”提示文本，表单提示信息 autofocus=”autofocus”自动聚焦属性，页面加载完成自动聚焦到指定表单 autocomplete：默认为on，当用户键入字段时基于之前键入的值显示出字段，关闭为off multiple:可以多选文件提交 新增选择器属性选择器E[att]选择具有att属性的E元素 E[att=”val”]选择具有att属性且属性值等于val的E元素 E[att^=”val”]选择具有att属性且属性值以val开头 E[att$=”val”]选择具有att属性且属性值中含有val的E元素 伪类选择器E:first-child:匹配父元素的第一个子元素 E:last-child:匹配父元素的最后一个元素 E:nth-child(n)匹配父元素的第n个元素 E:nth-child(even)匹配父元素的第偶数个元素，odd则第奇数个元素 E:nth-child(n)，从0开始计算，但是第0个元素或者超出元素个数会被忽略 nth-child(2n):偶数，2n+1:奇数 5n:5 10 15… n+5:从第5个开始到最后 -n+5：前5个（包含第5个） nth-of-type():会把指定孩子排序号，执行的时候先看E指定的元素，之后根据E回去看是第几个孩子 nth-child:对于父元素里面所有孩子进行排序选择，先找到第n个孩子，然后看着是否和E匹配 无序列表用nth-child比较多 类选择器，属性选择器和伪类选择器权重为10 伪元素选择器::before:在元素内部的前面插入内容 ::after:在元素内部的后面插入内容 before和after创建一个元素，属于行内元素 新创建的这个元素在文档树中找不到，因此称为伪元素 语法：element::before{}, before和after必须有content属性 伪元素和标签选择器一样，权重为1 伪元素选择器：清除浮动.clearfix:after { content:’’; display:block;//插入的元素必须是块级 height:0;//不要看见这个元素 clear:both; visibility:hidden;//不要看见这个元素 } .clearfix:before,.clearfix:after { content:’’; diaplay:table;//元素在一行显示且转化为块级元素 } CSS盒子模型box-sizing:content-box，盒子大小为width+padding+border(CSS3之前默认) box-sizing:border-box,盒子大小为width 如果盒子模型我们改为了box-sizing：border-box，那padding和border就不会撑大盒子（前提padding和border不会超过width宽度） CSS过渡（重点）transition:要过渡的属性 花费时间 运动曲线 何时开始 1属性：想要变化的CSS属性，宽度高度 背景颜色内外边距都可以 如果想要所有属性都变化过度则用all 2花费时间：单位是秒（必需写单位 3运动曲线默认为ease 4何时开始：单位是秒 可以设置延迟触发时间 默认是0s CSS filter属性修改图片的颜色为黑白 1img&#123;filter:grayscale(100%)&#125;","path":"2021/11/25/HTML+CSS/","date":"11-25","excerpt":"","tags":[]},{"title":"DOM扩展","text":"Selectors APIquerySelector()接收CSS选择符参数，返回匹配模式的第一个后代元素，如果没有匹配项则返回null 12345678let body=document.querySelector(&quot;body&quot;);//取得id名为myDiv的元素let myDiv=document.querySelector(&quot;#myDiv&quot;);//取得类名为“selector&quot;的第一个元素let selected=document.querySelector(&quot;.selected&quot;);//取得类名为&quot;button&quot;的图片let img=document.querySelector(&quot;img.button&quot;); querySelectorAll()接收一个查询参数，返回所有匹配的节点，即一个NodeList的静态实例 1234567891011//取得id为&#x27;myDiv&#x27;的&lt;div&gt;元素中的所有&lt;em&gt;元素let ems=document.getElementByid(&#x27;myDiv&#x27;).querySelectorAll(&quot;em&quot;);//取得所有类名中包含&#x27;selected&#x27;的元素let selecteds=document.querySelectorAll(&quot;.selected&quot;);//取得所有是&lt;p&gt;元素子元素的&lt;strong&gt;元素let strongs=document.querySelectorAll(&quot;p strong&quot;);for(let strong of strongs)&#123; strong.className=&quot;important&quot;; //strong.item(i).className=&quot;important&quot;; //strong[i].className=&quot;important&quot;;&#125; HTML5getElementsByClassName()接收一个参数，即包含一个或多个类名的字符串，返回类名中包含相应类的元素的NodeList 1234//取得所有类名中包含&#x27;username&#x27;和&#x27;current&#x27;元素let allCurrentUsernames=document.getElementsByClassName(&quot;username current&quot;);//取得id为“myDiv&quot;的元素子树中所有包含&#x27;selected’类的元素let selected=document.getElementById(&quot;myDiv&quot;).getElementsByClassName(&quot;selected&quot;); 这个方法返回以调用它的对象为根元素的子树中所有匹配的元素，在document上调用getElementsByClassName()返回文档中所有匹配的元素，而在特定元素中调用getElementsByClassName()返回该元素后代中匹配的元素 classList属性 add(value) contains(value) remove(value) toggle(value)：如果类名列表中已经存在指定的value，则删除，如果不存在，添加 123456div.classList.remove(&quot;disabled&quot;);div.classList.add(&quot;current&quot;);//检测类名if(div.classList.contains(&quot;bd&quot;)&amp;&amp;!div.classList.contains(&quot;disabled&quot;))&#123; &#125; 焦点管理12345let button=document.getElementById(&quot;myButton&quot;);button.focus();console.log(document.activeElement===button);console.log(document.hasFocus());//true文档已经拥有焦点","path":"2021/11/25/DOM扩展/","date":"11-25","excerpt":"","tags":[]}],"categories":[],"tags":[]}