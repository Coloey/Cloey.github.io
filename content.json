{"meta":{"title":"小柒","subtitle":"www.xiaoqi.cn","description":"欢迎来到我的世界!","author":"小柒","url":"https://coloey.github.io","root":"/"},"pages":[{"title":"categories","date":"2021-11-12T10:10:34.000Z","updated":"2021-11-12T10:12:26.795Z","comments":true,"path":"categories/index.html","permalink":"https://coloey.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"css预编译器","slug":"css预编译器","date":"2022-05-07T09:42:43.000Z","updated":"2022-05-07T10:11:32.526Z","comments":true,"path":"2022/05/07/css预编译器/","link":"","permalink":"https://coloey.github.io/2022/05/07/css%E9%A2%84%E7%BC%96%E8%AF%91%E5%99%A8/","excerpt":"","text":"CSS的弱编程能力，CSS通过”delector-properties”的模式为HTML文档增加样式，但CSS不支持嵌套，运算，变量，复用等。 CSS预编译器原理：提供便捷的语法和特性供开发者编写源代码，随后经过专门的编译工具将源代码转化为CSS语法，最早的CSS预编译器是2007年起源于Ruby on Rails社区的SASS，目前不叫流行的如LESS,Stylus在一定程度上收到SASS影响 CSS预编译器提升了CSS开发效率：1 增强编程能力 2 增强源码可复用性，让CSS开发符合DRY(Don’t repeat yourself)的原则 3 增强源码可维护性 4 更便于解决浏览器兼容性 实现 嵌套 变量 mixin/继承 运算 模块化 嵌套是所有预编译器都支持的语法特性，mixin/继承是为了解决hack和代码复用，变量和运算增强了源码的可编程能力；模块化的支持不仅更利于代码复用，同时提高了源码的可维护性 PostCSSPostCSS鼓励开发者使用规范的CSS原生语法编写源代码，然后配置浏览器需要兼容的浏览器版本，最后经过编译将源码转化为目标浏览器可用的CSS代码。PostCSS提供了丰富的插件用于实现不同场景的编译需求，最常用的比如autoprefix,Sprited等 PostCSS不是另一种CSS预编译器，与SASS LESS等预编译器不冲突，目前普遍方案将CSS预编译与PostCSS综合： 使用CSS预编译器弥补CSS源码的弱编程能力。比如变量，运算，继承等 使用PostCSS处理针对浏览器的需求，比如autoprefix,自动CSS Sprites webpack结合预编译与PostCSS实现CSS构建 123456789101112131415161718192021222324&#123; test:/\\.less$/ use:[&#123; loader:&#x27;style-loader&#x27;, options:&#123;&#125;//style-loader options &#125;, &#123; loader:&#x27;css-loader&#x27;, options:&#123; importLoaders:2//css-loader options &#125; &#125;, &#123; loader:&#x27;postcss-loader&#x27;, options:&#123;&#125;//postcss-loader &#125; &#123; loader:&#x27;less-loader&#x27;, options:&#123;&#125;//less-loader options &#125; ]&#125; css-loader中的importLoaders选项的作用是：用于配置css-loader作用于@import的资源之前需要经过的其他loader的个数，@import用于CSS源码中引用其他模块的关键字，如果你的项目中确定不会涉及到模块化，可以忽略此配置项 如果需要将编译后的css文件独立导出，则需将style-loader替换为extract-text-webpack-plugin 12345678910111213141516171819202122232425262728&#123; test:/\\.less$/ use:ExtractTextPlugin.extract(&#123; use:[&#123; loader:&#x27;style-loader&#x27;, options:&#123;&#125;//style-loader options &#125;, &#123; loader:&#x27;css-loader&#x27;, options:&#123; importLoaders:2//css-loader options &#125; &#125;, &#123; loader:&#x27;postcss-loader&#x27;, options:&#123;&#125;//postcss-loader &#125; &#123; loader:&#x27;less-loader&#x27;, options:&#123;&#125;//less-loader options &#125;], publicPath:&#x27;/&#x27; &#125; &#125;) 区分css-loader和style-loadercss-loader:用于解析css源文件并获得其引用资源，比如@import引用的模块，url()引用的图片等，然后根据webpack配置编译这些资源 style-loader:负责将CSS代码通过style标签插入HTML文档中，所以如果独立导出CSS文件就不再需要style-loader，css-loader必须在style-loader之前执行","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[]},{"title":"vue-router中hash模式和history模式区别","slug":"vue-router中hash模式和history模式区别","date":"2022-05-06T10:26:08.000Z","updated":"2022-05-06T14:31:27.082Z","comments":true,"path":"2022/05/06/vue-router中hash模式和history模式区别/","link":"","permalink":"https://coloey.github.io/2022/05/06/vue-router%E4%B8%ADhash%E6%A8%A1%E5%BC%8F%E5%92%8Chistory%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB/","excerpt":"","text":"vue-router的本质：路由就是SPA（单页应用）的路径管理器，vue-router的单页应用中，则是路径之间的切换，也就是组件的切换，路由模块的本质就是建立起url和页面之间的映射关系 为什么不能用a标签，这是因为Vue左的是单页应用，当你的项目准备打包时，会生成dist文件夹，这里面只有静态资源和一个index.html页面，所有a标签跳转页面不起作用 单页应用的核心之一就是：更新视图而不重新请求页面，vue-router在实现单页面前端路由时，提供两种方式：Hash模式和History模式，根据mode参数来决定使用哪一种 Hash模式vue-router默认hash模式，使用URL的hash模拟一个完整的URL,于是URL改变时，页面不会重新加载，hash(#)是URL的锚点，代表网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载页面，也就是hash出现在URL中（#后面的值），但不会被包含在http请求中，对后端没有影响，因此改变hash不会重新加载页面；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用“后退”按钮，就可以回到上一个位置，所以Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据，hash模式原理是onhashchange事件(监测hash值变化)，可以在window对象上监听这个事件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Router&#123; constructor()&#123; //存储hash与callback键值对 this.routes=&#123;&#125;; //当前hash this.currentUrl=&quot;&quot;; //记录出现过的hash this.history=[]; //作为指针，默认指向this.history的末尾，根据后退前进指向history中不同的hash this.currentIndex=this.history.length-1; this.refresh=this.refresh.bind(this); this.backoff=this.backoff.bind(this) //默认不是后退操作 this.isBack=false window.addEventListener(&#x27;load&#x27;,this.refresh,false) window.addEventListener(&#x27;hashchange&#x27;,this.refresh,false) &#125; route(path,callback)&#123; this.routes[path]=callback||function()&#123;&#125; &#125; refresh()&#123; //不能包括&#x27;#&#x27; this.currentUrl=location.hash.slice(1)||&#x27;/&#x27;; //不是后退操作 if(!this.isBack)&#123; //如果当前指针小于数组总长度，直接截取之前的部分储存下来，避免点击后退按钮后指针后移一位，当再次正常跳转时，指针前进一位， //而在数组中添加新hash路由 //导致指针和路由不匹配 if(this.currentIndex&lt;this.history.length-1)&#123; this.history=this.history.slice(0,this.currentIndex+1) &#125; this.history.push(this.currentUrl) this.currentIndex++; &#125; this.routes[this.currentUrl]() this.isBack=false; &#125; backoff()&#123; this.isBack=true this.currentIndex&lt;=0 ?(this.currentIndex=0) :(this.currentIndex=this.currentIndex-1) //找到后退后的哈希地址 location.hash=`#$&#123;this.history[this.currentIndex]&#125;` //调用后退后的地址对应的函数 this.routes[this.history[this.currentIndex]] &#125;&#125;window.Router=new Routers()const content=document.querySelector(&#x27;body&#x27;)const button=document.querySelector(&#x27;button&#x27;)function changeBgColor(color)&#123; content.style.background=color&#125;Router.route(&#x27;/blue&#x27;,function()&#123; changeBgColor(&#x27;blue&#x27;)&#125;)Router.route(&#x27;/green&#x27;,function()&#123; changeBgColor(&#x27;green&#x27;)&#125;)Router.route(&#x27;/red&#x27;,function()&#123; changeBgColor(&#x27;red&#x27;)&#125;)button.addEventListener(&#x27;click&#x27;,Router.backoff,false) history模式hash模式在url中自带#,比较丑，可以用路由的history模式，只需要在配置路由规则时，加上’mode:history’ 这种模式利用了html5 history Interface中新增的pushState()和replaceState()方法，这两个方法应用于浏览器记录栈，在当前已有的back,forwarc,go基础上，它们提供了对历史记录修改的功能，只是当修改时，虽然改变了当前的URL，但浏览器不会去请求服务器该路径下的资源，一旦刷新就会暴露，显示404，因此这种模式下需要后端的支持，在服务端增加一个覆盖所有情况的候选资源：如果URL匹配不到任何静态资源，就返回一个Index.html页面，这个页面就是app依赖的页面 export const routes=[ ​ {path:”*”,redirect:’/‘} ] history.pushState用于在浏览器中添加历史记录，但不触发跳转，此方法接收三个参数： state:一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数，不需要这个对象时此处就填null title:新页面标题，但是所有浏览器目前都忽略这个值，因此这里填null url:新的网址，必须与当前页面处在同一个域，浏览器的地址栏将显示这个网址 新标准下路由的实现 123456789101112131415161718192021222324252627282930313233343536373839404142class Router&#123; constructor()&#123; this.routes=&#123;&#125;; this.bindPopState(); &#125; init(path)&#123; history.replaceState(&#123;path:path&#125;,null,path) this.routes[path]&amp;&amp;this.routes[path]() &#125; route(path,callback)&#123; this.routes[path]=callback||function()&#123;&#125; &#125; go(path)&#123; history.pushState(&#123;path:path&#125;,null,path) this.routes[path]&amp;&amp;this.routes[path]() &#125; _bindPopState()&#123; window.addEventListener(&#x27;popstate&#x27;,e=&gt;&#123; const path=e.state&amp;&amp;e.state.path; this.routes[path]&amp;&amp;this.routes[path]() &#125;) &#125;&#125;window.Router = new Routers();Router.init(location.pathname);const content = document.querySelector(&#x27;body&#x27;);const ul = document.querySelector(&#x27;ul&#x27;);function changeBgColor(color) &#123; content.style.backgroundColor = color;&#125;Router.route(&#x27;/&#x27;, function() &#123; changeBgColor(&#x27;yellow&#x27;);&#125;);Router.route(&#x27;/blue&#x27;, function() &#123; changeBgColor(&#x27;blue&#x27;);&#125;);Router.route(&#x27;/green&#x27;, function() &#123; changeBgColor(&#x27;green&#x27;);&#125;);","categories":[],"tags":[]},{"title":"浏览器工作原理","slug":"浏览器工作原理","date":"2022-05-05T15:35:02.000Z","updated":"2022-05-05T16:11:19.202Z","comments":true,"path":"2022/05/05/浏览器工作原理/","link":"","permalink":"https://coloey.github.io/2022/05/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","excerpt":"","text":"一、 Chrome架构：仅仅打开了一个页面，为什么有4个进程？线程 VS 进程 多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。 那什么又是进程呢？一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。 从图中看出，线程是依附于进程的，而进程中使用多线程并行能提高运算效率 总结： 进程中的任一线程执行出错，都会导致整个进程的崩溃 线程之间共享进程中的数据。 3. 当一个进程关闭之后，操作系统会回收进程所占用的内存 \\4. 进程之间的内容相互隔离 目前浏览器的多进程架构 最新的chrome浏览器包括： 1个浏览器主进程，1个GPU进程，1个网络进程，多个渲染进程和多个插件进程。 分析这几个进程的功能： 浏览器进程： 主要负责界面展示，用户交互，子进程管理，同时提供存储等功能。 渲染进程： 核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。 GPU进程 主要是用来实现 3D，CSS等效果 网络进程 主要负责页面的网络资源加载 插件进程 主要是负责插件的进程，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响 多进程架构带来优缺点： 优点： 提高了稳定性、流畅性和安全性 缺点：更高的资源占用，更复杂的体系架构 二、 TCP协议：如何保证页面文件能被完整送达浏览器？在衡量 Web 页面性能的时候有一个重要的指标叫 “FP（First Paint）” ，是指 从页面加载到首次开始绘制的时长 。这个指标直接影响了用户的跳出率，更快的页面响应意味着更多的 PV、更高的参与度，以及更高的转化率。那什么影响 FP 指标呢？其中一个重要的因素是网络加载速度。 一个数据包的“旅程” IP: 把数据包送达目的主机 2. UDP：把数据包送达应用程序 增加了UDP传输层 \\3. TCP：把数据完整地送达应用程序 UDP的问题: 数据包在传输过程中容易丢失； 大文件会被拆成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而UDP协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。 TCP的特点： 对于数据包丢失的情况，TCP提供重传机制； TCP引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。 一个完整的TCP连接的生命周期: 总结： 互联网中的数据是通过数据包来传输的，数据包在传输过程中容易丢失或出错。 IP 负责把数据包送达目的主机。 UDP 负责把数据包送达具体应用。 而 TCP 保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接。 三、HTTP请求流程： 为什么很多站点第二次打开速度会很快？HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础 浏览器发起 HTTP 请求的流程 构建请求 1GET /index.html HTTP1.1 查找缓存 浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。 准备IP地址和端口 第一步浏览器会请求 DNS 返回域名对应的 IP。当然浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。 等待 TCP 队列 Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。 建立 TCP 连接 发送 HTTP 请求 浏览器是如何发送请求信息给服务器的？ 首先浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。 服务端处理 HTTP 请求流程 返回请求 1curl -i https://time.geekbang.org/ 注意这里加上了-i是为了返回响应行、响应头和响应体的数据 i. 首先服务器会返回 响应行，包括协议和状态码。 ii. 然后发送响应头，包括 服务器生成返回数据的时间 返回的数据类型（JSON、HTML、流媒体等类型，），以及服务端要在客户端保存的cookie等信息 iii. 发送响应体，包含了HTML的实际内容 断开连接 通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了： Connection:Keep-Alive 那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。 重定向 curl -I geekbang.org 注意这里输入的参数是-I，和-i不一样，-I表示只需要获取响应头和响应行数据，而不需要获取响应体的数据，最终返回的数据如下图所示： 从图中知道，301告诉浏览器重定向，网址是 Location 字段的内容 问题解答： 为什么很多站点第二次打开速度会很快？ 如果第二次页面打开很快，主要是第一次加载页面过程中，缓存了一些耗时的数据。（DNS 缓存和页面资源缓存） 缓存处理的过程： 图中知： 第一次请求时，http response header，浏览器是通过响应头中的Cache-Control字段来设置是否缓存该资源。 如果缓存过期了，浏览器则会继续发起网络请求，并且在 HTTP 请求头中带上： 1If-None-Match:&quot;4f80f-13c-3a1xb12a&quot; 没更新 =&gt; 304 更新了 =&gt; 最新的资源文件 简单说，DNS被缓存，节省查询解析时间 静态资源缓存在了本地，使用了本地副本，节省了时间 登录状态是如何保持的？ 用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用 POST 方法提交用户登录信息给服务器。 服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set-Cookie 字段里，如下所示，然后把响应头发送给浏览器。 1Set-Cookie: UID=3431uad; 浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有 Set-Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。比如把UID=3431uad保持到本地。 当用户再次访问时，浏览器会发起 HTTP 请求，但在发起请求之前，浏览器会读取之前保存的 Cookie 数据，并把数据写进请求头里的 Cookie 字段里（如下所示），然后浏览器再将请求头发送给服务器。 服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的“Cookie”字段信息，当查找到包含UID=3431uad的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。 浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了。 简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保存到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。 附图： 从图中可以看到，浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接。 四、 导航流程： 从输入URL到页面显示，这中间发生了什么？ 浏览器进程、渲染进程和网络进程的主要职责： 浏览器进程主要负责用户交互、子进程管理和文件存储等功能 网络进程是面向渲染进程和浏览器进程等提供网络下载功能。 渲染进程的主要职责是把从网络下载的HTML、Javascript、css、图片等资源解析为可以显示和交互的页面。 简单小结： 用户输入URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL 用户输入完内容，按下回车键，浏览器导航栏显示loading状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得 浏览器进程浏览器构建请求行信息，会通过进程间通信（IPC）将URL请求发送给网络进程 GET /index.html HTTP1.1 网络进程获取到URL，先去本地缓存中查找是否有缓存文件，如果有，拦截请求，直接200返回；否则，进入网络请求过程 网络进程请求:第一步进行DNS解析，返回域名对应的IP和端口号，如果之前DNS数据缓存服务缓存过当前域名信息，就会直接返回缓存信息；否则，发起请求获取根据域名解析出来的IP和端口号，如果没有端口号，http默认80，https默认443。如果是https请求，还需要建立TLS连接。 Chrome 有个机制，同一个域名同时最多只能建立 6 个TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于6个，会直接建立TCP连接。 TCP三次握手建立连接，http请求加上TCP头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输 网络层在数据包上加上IP头部——包括源IP地址和目的IP地址，继续向下传输到底层 底层通过物理网络传输给目的服务器主机 目的服务器主机网络层接收到数据包，解析出IP头部，识别出数据部分，将解开的数据包向上传输到传输层 目的服务器主机传输层获取到数据包，解析出TCP头部，识别端口，将解开的数据包向上传输到应用层 应用层HTTP解析请求头和请求体，如果需要重定向，HTTP直接返回HTTP响应数据的状态code301或者302，同时在请求头的Location字段中附上重定向地址，浏览器会根据code和Location进行重定向操作；如果不是重定向，首先服务器会根据 请求头中的If-None-Match 的值来判断请求的资源是否被更新，如果没有更新，就返回304状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了；否则，返回新数据，200的状态码，并且如果想要浏览器缓存数据的话，就在相应头中加入字段： Cache-Control:Max-age=2000 响应数据又顺着应用层——传输层——网络层——底层——网络层——传输层——应用层的顺序返回到网络进程 数据传输完成，TCP四次挥手断开连接。如果，浏览器或者服务器在HTTP头部加上如下信息，TCP就一直保持连接。保持TCP连接可以省下下次需要建立连接的时间，提高资源加载速度 Connection:Keep-Alive 网络进程将获取到的数据包进行解析，根据响应头中的Content-type来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是text/html类型，就通知浏览器进程获取到文档准备渲染 浏览器进程获取到通知，根据当前页面B是否是从页面A打开的并且和页面A是否是同一个站点（根域名和协议一样就被认为是同一个站点），如果满足上述条件，就复用之前网页的进程，否则，新创建一个单独的渲染进程 浏览器进程会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程 浏览器进程收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新web页面，此时的web页面是空白页 渲染进程对文档进行页面解析和子资源加载，HTML 通过HTM 解析器转成DOM Tree（二叉树类似结构的东西），CSS按照CSS 规则和CSS解释器转成CSSOM TREE，两个tree结合，形成render tree（不包含HTML的具体元素和元素要画的具体位置），通过Layout可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来 笔记： curl -I + URL的命令是接收服务器返回的响应头的信息 12curl -I http://time.geekbang.org/复制代码 同一站点（same-site） 协议/根域名相同 例如： 1234https://time.geekbang.orghttps://www.geekbang.orghttps://www.geekbang.org:8080复制代码 他们都属于是同一站点，因为它们的协议都是HTTPS,而且根域名也都是 geekbang.org process-per-site-instance 策略： 如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程 五、 渲染流程：HTML、CSS和 Javascript,是如何变成页面的？按照渲染的时间顺序，流水线分为如下几个子阶段： 构建Dom树 =&gt; 样式计算 =&gt; 布局阶段 =&gt; 分层 =&gt; 绘制 =&gt; 分块 =&gt; 栅格化 =&gt; 合成 1. 构建DOM树 2. 样式计算 把CSS转换为浏览器能够理解的结构 转换样式表中的属性值，使其标准化 计算出 DOM 树中每个节点的具体样式（css继承和层叠规则） 3.布局阶段 创建布局树 为了构建布局树，浏览器大体上完成了下面这些工作： 遍历DOM树中的所有的可见节点，并把这些节点添加到布局树中； 而不可见节点会被布局树忽略掉。 布局计算 4. 分层 渲染引擎会为哪些特定的节点创建新的图层呢？ 拥有层叠上下文属性的元素会被提升为单独的一层。 需要剪裁（clip）的地方也会被创建为图层 5. 图层绘制 6. 栅格化（raster）操作是指将图块转换为位图 从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。 7. 合成和显示图块都被光栅化后，合成线程生成一个绘制图块的命令“DrawQuad”，然后将命令提交给浏览器进程。 浏览器进程里的viz组件，用来接受合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后在将内存显示在屏幕上 渲染流水线大总结 结合上图，一个完整的渲染进程大致可总结为如下： 渲染进程将HTML内容转换为能够读懂的DOM树结构 渲染引擎将css样式表转化为浏览器可以理解的styleSheets,计算出DOM节点的样式 创建 布局树，并计算元素的布局信息。 对布局树进行分层，并生成分层树 为每个图层生成绘制列表，并将其提交到合成线程。 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。 浏览器进程根据 DrawQuad消息生成页面，并显示到显示器上。 拓展：重排：通过 JavaScript 或者 CSS 修改元素的几何位置属性，重排需要更新完整的渲染流水线，所以开销也是最大的。 重绘：重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。 合成阶段：使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。 减少重排重绘, 方法很多： 使用 class 操作样式，而不是频繁操作 style 避免使用 table 布局 批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React Debounce （window resize，scroll） 事件 对 dom 属性的读写要分离 will-change: transform 做优化 作者：小样儿吧你链接：https://juejin.cn/post/6896238768324509703来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://coloey.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[]},{"title":"ajax","slug":"ajax","date":"2022-05-05T07:41:40.000Z","updated":"2022-05-05T10:18:10.633Z","comments":true,"path":"2022/05/05/ajax/","link":"","permalink":"https://coloey.github.io/2022/05/05/ajax/","excerpt":"","text":"是什么AJAX全称是Async JavaScript and XML,即异步的JavaScript和XML，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页 实现过程实现Ajax异步交互需要服务器逻辑进行配合，需要完成以下步骤： 创建Ajax的核心对象XMLHttpRequest对象 通过XMLHttpRequest对象的open()方法与服务器建立连接 构建请求所需的数据内容，并通过XMLHttpRequest对象的send()方法发送给服务器端 通过XMLHttpRequest对象提供的onreadystatechange事件监听服务端你的通信状态 接受并处理服务端向客户端响应的数据结果 将处理结果更新到HTML页面中 创建XMLHttpReauest对象通过XMLHttpRequest()构造函数用于初始化一个XMLHttpRequest实例对象 1const xhr=new XMLHttpRequest() 与服务器端建立连接通过XMLHttpRequest对象的open()方法与服务器建立连接 1xhr.open(method,url,[async][,user][,password]) method:表示当前请求方式，常见的有GET,POST url:服务端地址 async:布尔值，表示用于异步执行操作，默认为true user:可选的用户名用于认证用途，默认为null password:可选的密码用于认证用途，默认为null 给服务端发送数据通过XMLHttpRequest对象的send()方法，将客户端页面的数据发送给服务端 1xhr.send([body]) body:在XHR请求中要发送的数据体，如果不传递数据则为null 如果使用GET请求发送数据，需要注意： 将请求数据添加到open()方法的url地址中 发送请求数据的send()方法中参数设置为null 绑定onreadystatechange事件 onreadystatechange事件用于监听服务器端的通信状态，主要监听的属性为XMLHttpRequest.readyState,关于XMLHttpRequest.readyState属性有五个状态 只要readyState属性值一变化，就会触发一次readyStatechange事件，XMLHttpRequest.reponseText属性用于接收服务器端的响应结果 封装1234567891011121314151617181920212223242526272829303132function ajax(options)&#123; //创建一个XMLHttpRequest对象 const xhr=new XHRHttpRequest() //初始化参数内容 options=options||&#123;&#125; options.type=(options||&#x27;GET&#x27;).toUpperCase options.dataType=options.dataType||&#x27;json&#x27; const params=options.data //发送请求 if(options.type===&#x27;GET&#x27;)&#123; xhr.open(&#x27;GET&#x27;,options.url+&quot;?&quot;+params,true) xhr.send(null) &#125;else if(options.type===&#x27;POST&#x27;)&#123; xhr.open(&#x27;POST&#x27;,options.url,true) xhr.send(params) &#125; //接收请求 xhr.onreadystatechange=function()&#123; if(xhr.readyState===4)&#123; let status=xhr.status if(status&gt;=200&amp;&amp;status&lt;300)&#123; options.success&amp;&amp;options.success(xhr.responseText,xhr,responseXML) &#125;else&#123; options.fail&amp;&amp;options.fail(status) &#125; &#125; &#125;&#125; 使用 123456789101112ajax(&#123; type:&#x27;post&#x27;, dataType:&#x27;json&#x27;, data:&#123;&#125;, url:&#x27;https://xxx&#x27;, success:function(text,xml)&#123; console.log(text) &#125;, fail:function(status)&#123; console.log(status) &#125;&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"Vue3响应式原理","slug":"Vue3响应式原理","date":"2022-05-04T03:59:43.000Z","updated":"2022-05-04T05:20:48.925Z","comments":true,"path":"2022/05/04/Vue3响应式原理/","link":"","permalink":"https://coloey.github.io/2022/05/04/Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"","text":"一、Vue 3 响应式使用1 实现单个值的响应式在普通 JS 代码执行中，并不会有响应式变化，比如在控制台执行下面代码： 12345let price = 10, quantity = 2;const total = price * quantity;console.log(`total: $&#123;total&#125;`); // total: 20price = 20;console.log(`total: $&#123;total&#125;`); // total: 20 从这可以看出，在修改 price 变量的值后， total 的值并没有发生改变。 那么如何修改上面代码，让 total 能够自动更新呢？我们其实可以将修改 total 值的方法保存起来，等到与 total 值相关的变量（如 price 或 quantity 变量的值）发生变化时，触发该方法，更新 total 即可。我们可以这么实现： 12345678910111213let price = 10, quantity = 2, total = 0;const dep = new Set(); // ① const effect = () =&gt; &#123; total = price * quantity &#125;;const track = () =&gt; &#123; dep.add(effect) &#125;; // ②const trigger = () =&gt; &#123; dep.forEach( effect =&gt; effect() )&#125;; // ③track();console.log(`total: $&#123;total&#125;`); // total: 0trigger();console.log(`total: $&#123;total&#125;`); // total: 20price = 20;trigger();console.log(`total: $&#123;total&#125;`); // total: 40 上面代码通过 3 个步骤，实现对 total 数据进行响应式变化： ① 初始化一个 Set 类型的 dep 变量，用来存放需要执行的副作用（ effect 函数），这边是修改 total 值的方法； ② 创建 track() 函数，用来将需要执行的副作用保存到 dep 变量中（也称收集副作用）； ③ 创建 trigger() 函数，用来执行 dep 变量中的所有副作用； 在每次修改 price 或 quantity 后，调用 trigger() 函数执行所有副作用后， total 值将自动更新为最新值。 2 实现单个对象的响应式通常，我们的对象具有多个属性，并且每个属性都需要自己的 dep。我们如何存储这些？比如： 1let product = &#123; price: 10, quantity: 2 &#125;; 从前面介绍我们知道，我们将所有副作用保存在一个 Set 集合中，而该集合不会有重复项，这里我们引入一个 Map 类型集合（即 depsMap ），其 key 为对象的属性（如： price 属性）， value 为前面保存副作用的 Set 集合（如： dep 对象），大致结构如下图： 12345678910111213141516171819202122232425let product = &#123; price: 10, quantity: 2 &#125;, total = 0;const depsMap = new Map(); // ① const effect = () =&gt; &#123; total = product.price * product.quantity &#125;;const track = key =&gt; &#123; // ② let dep = depsMap.get(key); if(!dep) &#123; depsMap.set(key, (dep = new Set())); &#125; dep.add(effect);&#125;const trigger = key =&gt; &#123; // ③ let dep = depsMap.get(key); if(dep) &#123; dep.forEach( effect =&gt; effect() ); &#125;&#125;;track(&#x27;price&#x27;);console.log(`total: $&#123;total&#125;`); // total: 0effect();console.log(`total: $&#123;total&#125;`); // total: 20product.price = 20;trigger(&#x27;price&#x27;);console.log(`total: $&#123;total&#125;`); // total: 40 上面代码通过 3 个步骤，实现对 total 数据进行响应式变化： ① 初始化一个 Map 类型的 depsMap 变量，用来保存每个需要响应式变化的对象属性（key 为对象的属性， value 为前面 Set 集合）； ② 创建 track() 函数，用来将需要执行的副作用保存到 depsMap 变量中对应的对象属性下（也称收集副作用）； ③ 创建 trigger() 函数，用来执行 dep 变量中指定对象属性的所有副作用； 这样就实现监听对象的响应式变化，在 product 对象中的属性值发生变化， total 值也会跟着更新。 3 实现多个对象的响应式如果我们有多个响应式数据，比如同时需要观察对象 a 和对象 b 的数据，那么又要如何跟踪每个响应变化的对象？ 这里我们引入一个 WeakMap 类型的对象，将需要观察的对象作为 key ，值为前面用来保存对象属性的 Map 变量。代码如下： 12345678910111213141516171819202122232425262728293031let product = &#123; price: 10, quantity: 2 &#125;, total = 0;const targetMap = new WeakMap(); // ① 初始化 targetMap，保存观察对象const effect = () =&gt; &#123; total = product.price * product.quantity &#125;;const track = (target, key) =&gt; &#123; // ② 收集依赖 let depsMap = targetMap.get(target); if(!depsMap)&#123; targetMap.set(target, (depsMap = new Map())); &#125; let dep = depsMap.get(key); if(!dep) &#123; depsMap.set(key, (dep = new Set())); &#125; dep.add(effect);&#125;const trigger = (target, key) =&gt; &#123; // ③ 执行指定对象的指定属性的所有副作用 const depsMap = targetMap.get(target); if(!depsMap) return; let dep = depsMap.get(key); if(dep) &#123; dep.forEach( effect =&gt; effect() ); &#125;&#125;;track(product, &#x27;price&#x27;);console.log(`total: $&#123;total&#125;`); // total: 0effect();console.log(`total: $&#123;total&#125;`); // total: 20product.price = 20;trigger(product, &#x27;price&#x27;);console.log(`total: $&#123;total&#125;`); // total: 40 上面代码通过 3 个步骤，实现对 total 数据进行响应式变化： ① 初始化一个 WeakMap 类型的 targetMap 变量，用来要观察每个响应式对象； ② 创建 track() 函数，用来将需要执行的副作用保存到指定对象（ target ）的依赖中（也称收集副作用）； ③ 创建 trigger() 函数，用来执行指定对象（ target ）中指定属性（ key ）的所有副作用； 这样就实现监听对象的响应式变化，在 product 对象中的属性值发生变化， total 值也会跟着更新。 大致流程如下图： 二、Proxy 和 Reflect在上一节内容中，介绍了如何在数据发生变化后，自动更新数据，但存在的问题是，每次需要手动通过触发 track() 函数搜集依赖，通过 trigger() 函数执行所有副作用，达到数据更新目的。 这一节将来解决这个问题，实现这两个函数自动调用。 1. 如何实现自动操作这里我们引入 JS 对象访问器的概念，解决办法如下： 在读取（GET 操作）数据时，自动执行 track() 函数自动收集依赖； 在修改（SET 操作）数据时，自动执行 trigger() 函数执行所有副作用； 那么如何拦截 GET 和 SET 操作？接下来看看 Vue2 和 Vue3 是如何实现的： 在 Vue2 中，使用 ES5 的 Object.defineProperty() 函数实现； 在 Vue3 中，使用 ES6 的 Proxy 和 Reflect API 实现； 需要注意的是：Vue3 使用的 Proxy 和 Reflect API 并不支持 IE。 Object.defineProperty() 函数这边就不多做介绍，可以阅读文档，下文将主要介绍 Proxy 和 Reflect API。 2. 如何使用 Reflect通常我们有三种方法读取一个对象的属性： 使用 . 操作符：leo.name ； 使用 [] ： leo[&#39;name&#39;] ； 使用 Reflect API： Reflect.get(leo, &#39;name&#39;) 。 这三种方式输出结果相同。 3. 如何使用 ProxyProxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。语法如下 1const p = new Proxy(target, handler) 参数如下： target : 要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。 handler : 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为 12345678910let product = &#123; price: 10, quantity: 2 &#125;;let proxiedProduct = new Proxy(product, &#123; get(target, key)&#123; console.log(&#x27;正在读取的数据：&#x27;,key); return target[key]; &#125;&#125;)console.log(proxiedProduct.price); // 正在读取的数据： price// 10 然后结合 Reflect 使用，只需修改 get 函数： 1234 get(target, key, receiver)&#123; console.log(&#x27;正在读取的数据：&#x27;,key); return Reflect.get(target, key, receiver);&#125; 输出结果还是一样。 接下来增加 set 函数，来拦截对象的修改操作： 12345678910111213141516let product = &#123; price: 10, quantity: 2 &#125;;let proxiedProduct = new Proxy(product, &#123; get(target, key, receiver)&#123; console.log(&#x27;正在读取的数据：&#x27;,key); return Reflect.get(target, key, receiver); &#125;, set(target, key, value, receiver)&#123; console.log(&#x27;正在修改的数据：&#x27;, key, &#x27;,值为：&#x27;, value); return Reflect.set(target, key, value, receiver); &#125;&#125;)proxiedProduct.price = 20;console.log(proxiedProduct.price); // 正在修改的数据： price ,值为： 20// 正在读取的数据： price// 20 4. 修改 track 和 trigger 函数通过上面代码，我们已经实现一个简单 reactive() 函数，用来将普通对象转换为响应式对象。但是还缺少自动执行 track() 函数和 trigger() 函数，接下来修改上面代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const targetMap = new WeakMap();let total = 0;const effect = () =&gt; &#123; total = product.price * product.quantity &#125;;const track = (target, key) =&gt; &#123; let depsMap = targetMap.get(target); if(!depsMap)&#123; targetMap.set(target, (depsMap = new Map())); &#125; let dep = depsMap.get(key); if(!dep) &#123; depsMap.set(key, (dep = new Set())); &#125; dep.add(effect);&#125;const trigger = (target, key) =&gt; &#123; const depsMap = targetMap.get(target); if(!depsMap) return; let dep = depsMap.get(key); if(dep) &#123; dep.forEach( effect =&gt; effect() ); &#125;&#125;;const reactive = (target) =&gt; &#123; const handler = &#123; get(target, key, receiver)&#123; console.log(&#x27;正在读取的数据：&#x27;,key); const result = Reflect.get(target, key, receiver); track(target, key); // 自动调用 track 方法收集依赖 return result; &#125;, set(target, key, value, receiver)&#123; console.log(&#x27;正在修改的数据：&#x27;, key, &#x27;,值为：&#x27;, value); const oldValue = target[key]; const result = Reflect.set(target, key, value, receiver); if(oldValue != result)&#123; trigger(target, key); // 自动调用 trigger 方法执行依赖 &#125; return result; &#125; &#125; return new Proxy(target, handler);&#125;let product = reactive(&#123;price: 10, quantity: 2&#125;); effect();console.log(total); product.price = 20;console.log(total); // 正在读取的数据： price// 正在读取的数据： quantity// 20// 正在修改的数据： price ,值为： 20// 正在读取的数据： price// 正在读取的数据： quantity// 40 三、activeEffect 和 ref在上一节代码中，还存在一个问题： track 函数中的依赖（ effect 函数）是外部定义的，当依赖发生变化， track 函数收集依赖时都要手动修改其依赖的方法名。 比如现在的依赖为 foo 函数，就要修改 track 函数的逻辑，可能是这样： 12345const foo = () =&gt; &#123; /**/ &#125;;const track = (target, key) =&gt; &#123; // ② // ... dep.add(foo);&#125; 1. 引入 activeEffect 变量接下来引入 activeEffect 变量，来保存当前运行的 effect 函数。 123456let activeEffect = null;const effect = eff =&gt; &#123; activeEffect = eff; // 1. 将 eff 函数赋值给 activeEffect activeEffect(); // 2. 执行 activeEffect activeEffect = null;// 3. 重置 activeEffect&#125; 然后在 track 函数中将 activeEffect 变量作为依赖： 12345678910111213const track = (target, key) =&gt; &#123; if (activeEffect) &#123; // 1. 判断当前是否有 activeEffect let depsMap = targetMap.get(target); if (!depsMap) &#123; targetMap.set(target, (depsMap = new Map())); &#125; let dep = depsMap.get(key); if (!dep) &#123; depsMap.set(key, (dep = new Set())); &#125; dep.add(activeEffect); // 2. 添加 activeEffect 依赖 &#125;&#125; 123effect(() =&gt; &#123; total = product.price * product.quantity&#125;); 这样就可以解决手动修改依赖的问题，这也是 Vue3 解决该问题的方法 2. 引入 ref 方法熟悉 Vue3 Composition API 的朋友可能会想到 Ref，它接收一个值，并返回一个响应式可变的 Ref 对象，其值可以通过 value 属性获取。 ref：接受一个内部值并返回一个响应式且可变的 ref 对象。ref 对象具有指向内部值的单个 property .value。 官网的使用示例如下： 12345const count = ref(0)console.log(count.value) // 0count.value++console.log(count.value) // 1 我们有 2 种方法实现 ref 函数： 使用 rective 函数1const ref = intialValue =&gt; reactive(&#123;value: intialValue&#125;); 使用对象的属性访问器（计算属性）属性方式去包括：getter 和 setter。 1234567891011121314const ref = raw =&gt; &#123; const r = &#123; get value()&#123; track(r, &#x27;value&#x27;); return raw; &#125;, set value(newVal)&#123; raw = newVal; trigger(r, &#x27;value&#x27;); &#125; &#125; return r;&#125; 四、完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081const targetMap=new WeakMap()let activeEffect=nullfunction effect(eff)&#123; activeEffect=eff activeEffect() activeEffect=null&#125;function track(target,key)&#123; if(activeEffect)&#123; let depsMap=targetMap.get(target) if(!depsMap)&#123; targetMap.set(target,(depsMap=new Map())) &#125; let dep=depsMap.get(key) if(!dep)&#123; depsMap.set(key,(dep=new Set())) &#125; dep.add(activeEffect) &#125;&#125;function trigger(target,key)&#123; const depsMap=targetMap.get(target) if(!depsMap)return const dep=depsMap.get(key) if(dep)&#123; dep.forEach(effect=&gt;&#123; effect() &#125;) &#125;&#125;function reactive(target)&#123; const handler=&#123; get(target,key,receiver)&#123; let res=Reflect.get(target,key,receiver) track(target,key)//if reactive property is Get inside then tarck the effect to rerun on SET,add the effect to the dep return res &#125;, set(target,key,value,receiver)&#123; let oldValue=target[key] let res=Reflect.set(target,key,value,receiver) if(res&amp;&amp;oldValue!=value) &#123; trigger(target,key)//if this reactive property has effects to rerun on SET,trigger them &#125; return res &#125; &#125; return new Proxy(target,handler)&#125;function ref(raw)&#123; const r=&#123; get value()&#123; track(r,&#x27;value&#x27;) return raw &#125;, set value(newval)&#123; raw=newval trigger(r,&#x27;value&#x27;) &#125; &#125; return r;&#125;let product=reactive(&#123;prie:5,quantity:2&#125;)let salePrice=ref(0)let total=0effect(()=&gt;&#123; salePrice.value=product.price*0.9&#125;)effect(()=&gt;&#123; total=salePrice.value*product.quantity&#125;)console.log(`Before updated quantity total=$&#123;total&#125; salePrice=$&#123;salePrice.value&#125;`)product.quantity=3console.log(`After updated quantity total=$&#123;total&#125; salePrice=$&#123;salePrice.value&#125;`)product.price=10console.log(`After updated quantity total=$&#123;total&#125; salePrice=$&#123;salePrice.value&#125;`)","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"Vue3性能提升的几个方面","slug":"Vue3性能提升的几个方面","date":"2022-05-03T08:54:35.000Z","updated":"2022-05-03T09:14:13.809Z","comments":true,"path":"2022/05/03/Vue3性能提升的几个方面/","link":"","permalink":"https://coloey.github.io/2022/05/03/Vue3%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E9%9D%A2/","excerpt":"","text":"编译阶段： diff算法优化 静态提升 事件监听缓存 SSR优化 diff算法优化vue3在diff算法中相比vue2增加了静态标记 作用是为了会发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较。已经标记静态结点的p标签在diff过程中不会比较，把性能进一步提高 关于静态类型： 123456789101112131415export const enum PatchFlags &#123; TEXT = 1,// 动态的文本节点 CLASS = 1 &lt;&lt; 1, // 2 动态的 class STYLE = 1 &lt;&lt; 2, // 4 动态的 style PROPS = 1 &lt;&lt; 3, // 8 动态属性，不包括类名和样式 FULL_PROPS = 1 &lt;&lt; 4, // 16 动态 key，当 key 变化时需要完整的 diff 算法做比较 HYDRATE_EVENTS = 1 &lt;&lt; 5, // 32 表示带有事件监听器的节点 STABLE_FRAGMENT = 1 &lt;&lt; 6, // 64 一个不会改变子节点顺序的 Fragment KEYED_FRAGMENT = 1 &lt;&lt; 7, // 128 带有 key 属性的 Fragment UNKEYED_FRAGMENT = 1 &lt;&lt; 8, // 256 子节点没有 key 的 Fragment NEED_PATCH = 1 &lt;&lt; 9, // 512 DYNAMIC_SLOTS = 1 &lt;&lt; 10, // 动态 solt HOISTED = -1, // 特殊标志是负整数表示永远不会用作 diff BAIL = -2 // 一个特殊的标志，指代差异算法&#125; 静态提升Vue3中堆不参与更新得元素，会做静态提升，只会被创建一次，在渲染时直接复用，这样就免去了重复的创建节点，大型应用会受益于这个改动，免去重复的创建操作，优化了运行时候的内存占用 123&lt;span&gt;你好&lt;/span&gt;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; 没有做静态提升之前 123456export function render(_ctx, _cache, $props, $setup, $data, $options) &#123; return (_openBlock(), _createBlock(_Fragment, null, [ _createVNode(&quot;span&quot;, null, &quot;你好&quot;), _createVNode(&quot;div&quot;, null, _toDisplayString(_ctx.message), 1 /* TEXT */) ], 64 /* STABLE_FRAGMENT */))&#125; 做了静态提升后 12345678910const _hoisted_1 = /*#__PURE__*/_createVNode(&quot;span&quot;, null, &quot;你好&quot;, -1 /* HOISTED */)export function render(_ctx, _cache, $props, $setup, $data, $options) &#123; return (_openBlock(), _createBlock(_Fragment, null, [ _hoisted_1, _createVNode(&quot;div&quot;, null, _toDisplayString(_ctx.message), 1 /* TEXT */) ], 64 /* STABLE_FRAGMENT */))&#125;// Check the console for the AST 静态内容_hosted_1被放置在render函数外，每次渲染的时候只要取_hosted_即可，同时_hosted_1被打上PatchFlag,静态标记为-1，特殊标记是负整数表示永远不会用于Diff 事件监听缓存默认情况下绑定事件行为会被认为是动态绑定，所以每次都会去追踪它的变化 123&lt;div&gt; &lt;button @click = &#x27;onClick&#x27;&gt;点我&lt;/button&gt;&lt;/div&gt; 没开启事件监听器缓存 123456export const render = /*#__PURE__*/_withId(function render(_ctx, _cache, $props, $setup, $data, $options) &#123; return (_openBlock(), _createBlock(&quot;div&quot;, null, [ _createVNode(&quot;button&quot;, &#123; onClick: _ctx.onClick &#125;, &quot;点我&quot;, 8 /* PROPS */, [&quot;onClick&quot;]) // PROPS=1&lt;&lt;3,// 8 //动态属性，但不包含类名和样式 ]))&#125;) 开启事件监听器缓存 1234567export function render(_ctx, _cache, $props, $setup, $data, $options) &#123; return (_openBlock(), _createBlock(&quot;div&quot;, null, [ _createVNode(&quot;button&quot;, &#123; onClick: _cache[1] || (_cache[1] = (...args) =&gt; (_ctx.onClick(...args))) &#125;, &quot;点我&quot;) ]))&#125; 开启缓存后，没有了静态标记，也就是说下次diff算法的时候直接使用 SSR优化当静态内容大到一定量级，会用createStaticVNode方法在客户端生成一个static node,这些静态node,会被直接innerHtml,就不需要创建对象，任何根据对象渲染 123456789div&gt; &lt;div&gt; &lt;span&gt;你好&lt;/span&gt; &lt;/div&gt; ... // 很多个静态属性 &lt;div&gt; &lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 编译后 1234567891011import &#123; mergeProps as _mergeProps &#125; from &quot;vue&quot;import &#123; ssrRenderAttrs as _ssrRenderAttrs, ssrInterpolate as _ssrInterpolate &#125; from &quot;@vue/server-renderer&quot;export function ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) &#123; const _cssVars = &#123; style: &#123; color: _ctx.color &#125;&#125; _push(`&lt;div$&#123; _ssrRenderAttrs(_mergeProps(_attrs, _cssVars)) &#125;&gt;&lt;div&gt;&lt;span&gt;你好&lt;/span&gt;...&lt;div&gt;&lt;span&gt;你好&lt;/span&gt;&lt;div&gt;&lt;span&gt;$&#123; _ssrInterpolate(_ctx.message) &#125;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;`)&#125; 源码体积相比Vue2,Vue3整体体积变小，除了移除一些不常用API，最重要的是Tree shaking,任何一个函数，如ref,reactive,computed,仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小 响应式系统vue2采用的是defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter,setter,实现响应式,而vue3采用proxy重写响应式系统，因为proxy可以对整个对象进行监听，所有不需要深度遍历 可以监听动态属性的添加 可以监听到数组索引和数组length属性 可以监听删除属性","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"Vue diff算法","slug":"Vue-diff算法","date":"2022-05-03T07:53:37.000Z","updated":"2022-05-03T08:27:20.755Z","comments":true,"path":"2022/05/03/Vue-diff算法/","link":"","permalink":"https://coloey.github.io/2022/05/03/Vue-diff%E7%AE%97%E6%B3%95/","excerpt":"","text":"一、是什么diss算法是一种同层的树节点进行比较的高效算法 两个特点： 比较只会在同层级进行，不会跨层级比较 在diff比较过程中，循环会从两边向中间比较 diff 算法的在很多场景下都有应用，在 vue 中，作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较 二、比较方式diff整体策略为：深度优先，同层比较 比较只会在同层级进行, 不会跨层级比较 比较的过程中，循环从两边向中间收拢 下面举个vue通过diff算法更新的例子： 新旧VNode节点如下图所示： 第一次循环后，发现旧节点D与新节点D相同，直接复用旧节点D作为diff后的第一个真实节点，同时旧节点endIndex移动到C，新节点的 startIndex 移动到了 C 第二次循环后，同样是旧节点的末尾和新节点的开头(都是 C)相同，同理，diff 后创建了 C 的真实节点插入到第一次创建的 B 节点后面。同时旧节点的 endIndex 移动到了 B，新节点的 startIndex 移动到了 E 第三次循环中，发现E没有找到，这时候只能直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。同时新节点的 startIndex 移动到了 A。旧节点的 startIndex 和 endIndex 都保持不动 第四次循环中，发现了新旧节点的开头(都是 A)相同，于是 diff 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。同时旧节点的 startIndex 移动到了 B，新节点的 startIndex 移动到了 B 第五次循环中，情形同第四次循环一样，因此 diff 后创建了 B 真实节点 插入到前一次创建的 A 节点后面。同时旧节点的 startIndex 移动到了 C，新节点的 startIndex 移动到了 F 新节点的 startIndex 已经大于 endIndex 了，需要创建 newStartIdx 和 newEndIdx 之间的所有节点，也就是节点F，直接创建 F 节点对应的真实节点放到 B 节点后面 三、原理分析当数据发生改变时，set方法会调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图 源码位置：src/core/vdom/patch.js 12345678910111213141516171819202122232425262728293031323334353637function patch(oldVnode, vnode, hydrating, removeOnly) &#123; if (isUndef(vnode)) &#123; // 没有新节点，直接执行destory钩子函数 if (isDef(oldVnode)) invokeDestroyHook(oldVnode) return &#125; let isInitialPatch = false const insertedVnodeQueue = [] if (isUndef(oldVnode)) &#123; isInitialPatch = true createElm(vnode, insertedVnodeQueue) // 没有旧节点，直接用新节点生成dom元素 &#125; else &#123; const isRealElement = isDef(oldVnode.nodeType) if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; // 判断旧节点和新节点自身一样，一致执行patchVnode patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly) &#125; else &#123; // 否则直接销毁及旧节点，根据新节点生成dom元素 if (isRealElement) &#123; if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123; oldVnode.removeAttribute(SSR_ATTR) hydrating = true &#125; if (isTrue(hydrating)) &#123; if (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123; invokeInsertHook(vnode, insertedVnodeQueue, true) return oldVnode &#125; &#125; oldVnode = emptyNodeAt(oldVnode) &#125; return vnode.elm &#125; &#125;&#125; patch函数前两个参数位为oldVnode 和 Vnode ，分别代表旧的节点和新节点，主要做了四个判断： 没有新节点，直接触发旧节点的destory钩子 没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 createElm 旧节点和新节点自身一样，通过 sameVnode 判断节点是否一样，一样时，直接调用 patchVnode 去处理这两个节点 旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点 下面主要讲的是patchVnode部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) &#123; // 如果新旧节点一致，什么都不做 if (oldVnode === vnode) &#123; return &#125; // 让vnode.el引用到现在的真实dom，当el修改时，vnode.el会同步变化 const elm = vnode.elm = oldVnode.elm // 异步占位符 if (isTrue(oldVnode.isAsyncPlaceholder)) &#123; if (isDef(vnode.asyncFactory.resolved)) &#123; hydrate(oldVnode.elm, vnode, insertedVnodeQueue) &#125; else &#123; vnode.isAsyncPlaceholder = true &#125; return &#125; // 如果新旧都是静态节点，并且具有相同的key // 当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上 // 也不用再有其他操作 if (isTrue(vnode.isStatic) &amp;&amp; isTrue(oldVnode.isStatic) &amp;&amp; vnode.key === oldVnode.key &amp;&amp; (isTrue(vnode.isCloned) || isTrue(vnode.isOnce)) ) &#123; vnode.componentInstance = oldVnode.componentInstance return &#125; let i const data = vnode.data if (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) &#123; i(oldVnode, vnode) &#125; const oldCh = oldVnode.children const ch = vnode.children if (isDef(data) &amp;&amp; isPatchable(vnode)) &#123; for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode) if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode) &#125; // 如果vnode不是文本节点或者注释节点 if (isUndef(vnode.text)) &#123; // 并且都有子节点 if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; // 并且子节点不完全一致，则调用updateChildren if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly) // 如果只有新的vnode有子节点 &#125; else if (isDef(ch)) &#123; if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &#x27;&#x27;) // elm已经引用了老的dom节点，在老的dom节点上添加子节点 addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) // 如果新vnode没有子节点，而Oldvnode有子节点，直接删除老的oldCh &#125; else if (isDef(oldCh)) &#123; removeVnodes(elm, oldCh, 0, oldCh.length - 1) // 如果老节点是文本节点 &#125; else if (isDef(oldVnode.text)) &#123; nodeOps.setTextContent(elm, &#x27;&#x27;) &#125; // 如果新vnode和老vnode是文本节点或注释节点 // 但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以 &#125; else if (oldVnode.text !== vnode.text) &#123; nodeOps.setTextContent(elm, vnode.text) &#125; if (isDef(data)) &#123; if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode) &#125; &#125; patchVnode主要做了几个判断： 新节点是否是文本节点，如果是，则直接更新dom的文本内容为新节点的文本内容 新节点和旧节点如果都有子节点，则处理比较更新子节点 只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新DOM，并且添加进父节点 只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把DOM 删除 子节点不完全一致，则调用updateChildren 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123; let oldStartIdx = 0 // 旧头索引 let newStartIdx = 0 // 新头索引 let oldEndIdx = oldCh.length - 1 // 旧尾索引 let newEndIdx = newCh.length - 1 // 新尾索引 let oldStartVnode = oldCh[0] // oldVnode的第一个child let oldEndVnode = oldCh[oldEndIdx] // oldVnode的最后一个child let newStartVnode = newCh[0] // newVnode的第一个child let newEndVnode = newCh[newEndIdx] // newVnode的最后一个child let oldKeyToIdx, idxInOld, vnodeToMove, refElm // removeOnly is a special flag used only by &lt;transition-group&gt; // to ensure removed elements stay in correct relative positions // during leaving transitions const canMove = !removeOnly // 如果oldStartVnode和oldEndVnode重合，并且新的也都重合了，证明diff完了，循环结束 while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; // 如果oldVnode的第一个child不存在 if (isUndef(oldStartVnode)) &#123; // oldStart索引右移 oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left // 如果oldVnode的最后一个child不存在 &#125; else if (isUndef(oldEndVnode)) &#123; // oldEnd索引左移 oldEndVnode = oldCh[--oldEndIdx] // oldStartVnode和newStartVnode是同一个节点 &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; // patch oldStartVnode和newStartVnode， 索引左移，继续循环 patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] // oldEndVnode和newEndVnode是同一个节点 &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; // patch oldEndVnode和newEndVnode，索引右移，继续循环 patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] // oldStartVnode和newEndVnode是同一个节点 &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right // patch oldStartVnode和newEndVnode patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue) // 如果removeOnly是false，则将oldStartVnode.eml移动到oldEndVnode.elm之后 canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)) // oldStart索引右移，newEnd索引左移 oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] // 如果oldEndVnode和newStartVnode是同一个节点 &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left // patch oldEndVnode和newStartVnode patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue) // 如果removeOnly是false，则将oldEndVnode.elm移动到oldStartVnode.elm之前 canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm) // oldEnd索引左移，newStart索引右移 oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] // 如果都不匹配 &#125; else &#123; if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 尝试在oldChildren中寻找和newStartVnode的具有相同的key的Vnode idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx) // 如果未找到，说明newStartVnode是一个新的节点 if (isUndef(idxInOld)) &#123; // New element // 创建一个新Vnode createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm) // 如果找到了和newStartVnodej具有相同的key的Vnode，叫vnodeToMove &#125; else &#123; vnodeToMove = oldCh[idxInOld] /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !vnodeToMove) &#123; warn( &#x27;It seems there are duplicate keys that is causing an update error. &#x27; + &#x27;Make sure each v-for item has a unique key.&#x27; ) &#125; // 比较两个具有相同的key的新节点是否是同一个节点 //不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。 if (sameVnode(vnodeToMove, newStartVnode)) &#123; // patch vnodeToMove和newStartVnode patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue) // 清除 oldCh[idxInOld] = undefined // 如果removeOnly是false，则将找到的和newStartVnodej具有相同的key的Vnode，叫vnodeToMove.elm // 移动到oldStartVnode.elm之前 canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm) // 如果key相同，但是节点不相同，则创建一个新的节点 &#125; else &#123; // same key but different element. treat as new element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm) &#125; &#125; // 右移 newStartVnode = newCh[++newStartIdx] &#125; &#125; while循环主要处理了以下五种情景： 当新老 VNode 节点的 start 相同时，直接 patchVnode ，同时新老 VNode 节点的开始索引都加 1 当新老 VNode 节点的 end相同时，同样直接 patchVnode ，同时新老 VNode 节点的结束索引都减 1 当老 VNode 节点的 start 和新 VNode 节点的 end 相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldEndVnode 的后面，同时老 VNode 节点开始索引加 1，新 VNode 节点的结束索引减 1 当老 VNode 节点的 end 和新 VNode 节点的 start 相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldStartVnode 的前面，同时老 VNode 节点结束索引减 1，新 VNode 节点的开始索引加 1 如果都不满足以上四种情形，那说明没有相同的节点可以复用，则会分为以下两种情况： 从旧的 VNode 为 key 值，对应 index 序列为 value 值的哈希表中找到与 newStartVnode 一致 key 的旧的 VNode 节点，再进行patchVnode ，同时将这个真实 dom 移动到 oldStartVnode 对应的真实 dom 的前面 调用 createElm 创建一个新的 dom 节点放到当前 newStartIdx 的位置 小结 当数据发生改变时，订阅者watcher就会调用patch给真实的DOM打补丁 通过isSameVnode进行判断，相同则调用patchVnode方法 ```patchVnode 1234567891011 做了以下操作： - 找到对应的真实`dom`，称为`el` - 如果都有文本节点且不相等，将`el`文本节点设置为`Vnode`的文本节点 - 如果`oldVnode`有子节点而`VNode`没有，则删除`el`子节点 - 如果`oldVnode`没有子节点而`VNode`有，则将`VNode`的子节点真实化后添加到`el` - 如果两者都有子节点，则执行`updateChildren`函数比较子节点- ``` updateChildren 主要做了以下操作： 设置新旧VNode的头尾指针 新旧头尾指针进行比较，循环向中间靠拢，根据情况调用patchVnode进行patch重复流程、调用createElem创建一个新节点，从哈希表寻找 key一致的VNode 节点再分情况操作","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"Composition API 与Options API","slug":"Composition-API-与Options-API","date":"2022-05-03T06:46:26.000Z","updated":"2022-05-03T06:46:26.485Z","comments":true,"path":"2022/05/03/Composition-API-与Options-API/","link":"","permalink":"https://coloey.github.io/2022/05/03/Composition-API-%E4%B8%8EOptions-API/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"强缓存和协商缓存","slug":"强缓存和协商缓存","date":"2022-05-02T14:40:35.000Z","updated":"2022-05-02T15:05:25.812Z","comments":true,"path":"2022/05/02/强缓存和协商缓存/","link":"","permalink":"https://coloey.github.io/2022/05/02/%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/","excerpt":"","text":"这里说的缓存是指浏览器（客户端）在本地磁盘中对访问过的资源保存的副本文件。 浏览器缓存主要有以下几个优点： 减少重复数据请求，避免通过网络再次加载资源，节省流量。 降低服务器的压力，提升网站性能。 加快客户端加载网页的速度， 提升用户体验。 浏览器缓存分为强缓存和协商缓存，两者有两个比较明显的区别： 如果浏览器命中强缓存，则不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，即客户端与服务器之间存在一次通信。 在 chrome 中强缓存（虽然没有发出真实的 http 请求）的请求状态码返回是 200 (from cache)；而协商缓存如果命中走缓存的话，请求的状态码是 304 (not modified)。 不同浏览器的策略不同，在 Fire Fox中，from cache 状态码是 304. 请求流程浏览器在第一次请求后缓存资源，再次请求时，会进行下面两个步骤： 浏览器会获取该缓存资源的 header 中的信息，根据 response header 中的 expires 和 cache-control 来判断是否命中强缓存，如果命中则直接从缓存中获取资源。 如果没有命中强缓存，浏览器就会发送请求到服务器，这次请求会带上 IF-Modified-Since 或者 IF-None-Match, 它们的值分别是第一次请求返回 Last-Modified或者 Etag，由服务器来对比这一对字段来判断是否命中。如果命中，则服务器返回 304 状态码，并且不会返回资源内容，浏览器会直接从缓存获取；否则服务器最终会返回资源的实际内容，并更新 header 中的相关缓存字段。 强缓存强缓存是根据返回头中的 Expires 或者 Cache-Control 两个字段来控制的，都是表示资源的缓存有效时间。 Expires 是 http 1.0 的规范，值是一个GMT 格式的时间点字符串，比如 Expires:Mon,18 Oct 2066 23:59:59 GMT 。这个时间点代表资源失效的时间，如果当前的时间戳在这个时间之前，则判定命中缓存。有一个缺点是，失效时间是一个绝对时间，如果服务器时间与客户端时间偏差较大时，就会导致缓存混乱。而服务器的时间跟用户的实际时间是不一样是很正常的，所以 Expires 在实际使用中会带来一些麻烦。 Cache-Control这个字段是 http 1.1 的规范，一般常用该字段的 max-age 值来进行判断，它是一个相对时间，比如 .Cache-Control:max-age=3600 代表资源的有效期是 3600 秒。并且返回头中的 Date 表示消息发送的时间，表示当前资源在 Date ~ Date +3600s 这段时间里都是有效的。不过我在实际使用中常常遇到设置了 max-age 之后，在 max-age 时间内重新访问资源却会返回 304 not modified ，这是由于服务器的时间与本地的时间不同造成的。当然 Cache-Control 还有其他几个值可以设置， 不过相对来说都很少用了： no-cache 不使用本地缓存。需要使用协商缓存。 no-store直接禁止浏览器缓存数据，每次请求资源都会向服务器要完整的资源， 类似于 network 中的 disabled cache。 public 可以被所有用户缓存，包括终端用户和 cdn 等中间件代理服务器。 private 只能被终端用户的浏览器缓存。 如果 Cache-Control与 Expires 同时存在的话， Cache-Control 的优先级高于 Expires 。 协商缓存协商缓存是由服务器来确定缓存资源是否可用。 主要涉及到两对属性字段，都是成对出现的，即第一次请求的响应头带上某个字, Last-Modified 或者 Etag，则后续请求则会带上对应的请求字段 If-Modified-Since或者 If-None-Match，若响应头没有 Last-Modified 或者 Etag 字段，则请求头也不会有对应的字段。 Last-Modified/If-Modified-Since 二者的值都是 GMT 格式的时间字符串， Last-Modified 标记最后文件修改时间， 下一次请求时，请求头中会带上 If-Modified-Since 值就是 Last-Modified 告诉服务器我本地缓存的文件最后修改的时间，在服务器上根据文件的最后修改时间判断资源是否有变化， 如果文件没有变更则返回 304 Not Modified ，请求不会返回资源内容，浏览器直接使用本地缓存。当服务器返回 304 Not Modified 的响应时，response header 中不会再添加的 Last-Modified 去试图更新本地缓存的 Last-Modified， 因为既然资源没有变化，那么 Last-Modified 也就不会改变；如果资源有变化，就正常返回返回资源内容，新的 Last-Modified 会在 response header 返回，并在下次请求之前更新本地缓存的 Last-Modified，下次请求时，If-Modified-Since会启用更新后的 Last-Modified。 Etag/If-None-Match， 值都是由服务器为每一个资源生成的唯一标识串，只要资源有变化就这个值就会改变。服务器根据文件本身算出一个哈希值并通过 ETag字段返回给浏览器，接收到 If-None-Match 字段以后，服务器通过比较两者是否一致来判定文件内容是否被改变。与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于在服务器上ETag 重新计算过，response header中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。 HTTP 中并没有指定如何生成 ETag，可以由开发者自行生成，哈希是比较理想的选择。 ETag的出现，主要是为了解决 Last-Modified 无法解决的一些问题： 某些服务器不能精确得到文件的最后修改时间， 这样就无法通过最后修改时间来判断文件是否更新了。 某些文件的修改非常频繁，在秒以下的时间内进行修改. Last-Modified只能精确到秒。 一些文件的最后修改时间改变了，但是内容并未改变。 我们不希望客户端认为这个文件修改了","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"HTTP","slug":"计算机网络/HTTP","permalink":"https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/"}],"tags":[]},{"title":"浏览器垃圾回收机制","slug":"浏览器垃圾回收机制","date":"2022-05-02T08:04:33.000Z","updated":"2022-05-02T08:29:52.291Z","comments":true,"path":"2022/05/02/浏览器垃圾回收机制/","link":"","permalink":"https://coloey.github.io/2022/05/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","excerpt":"","text":"标记清理 变量进入上下文，会加上标记，证明其存在于该上下文 将所有在上下文中的变量以及上下文中被访问引用的变量标记去掉，表明这些变量活跃有用 在此之后再被加上标记的变量标记为准备删除的变量，原因是任何在上下文中的变量都访问不到它们 执行内存清理，销毁标记的所有非活跃值并回收之前被占用的内存 引用计数引用计数策略相对而言不常用，弊端较多，其思路对每个值记录它被引用的次数，通过最后对次数的判断（引用数为0）来决定是否保留，具体规则： 声明一个变量，赋予它一个引用值，计数+1 同一值被赋予另外一个变量，引用+1 保存对该值引用的变量被其他值覆盖，引用+1 引用为0，回收内存 局限：容易造成循环引用 123456function problem()&#123; let a=new Object() let b=new Object() a.c=b; b.d=a;&#125; a和b通过各自的属性相互引用，意味着它们的引用数都为2，在函数结束后，这两个对象不再作用域内，在引用计数策略下，a和b在函数结束后还会存在，因为它们的引用数永远捕获变为0，如果函数被多次调用就会导致大量内存永远不会被释放。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"浏览器事件循环机制和Node中的事件循环机制","slug":"浏览器事件循环机制和Node中的事件循环机制","date":"2022-05-02T03:58:28.000Z","updated":"2022-05-02T16:00:45.534Z","comments":true,"path":"2022/05/02/浏览器事件循环机制和Node中的事件循环机制/","link":"","permalink":"https://coloey.github.io/2022/05/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E5%92%8CNode%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/","excerpt":"","text":"浏览器的事件循环机制：是什么JavaScript 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事 为什么要这么设计，跟JavaScript的应用场景有关 JavaScript 初期作为一门浏览器脚本语言，通常用于操作 DOM ，如果是多线程，一个线程进行了删除 DOM ，另一个添加 DOM，此时浏览器该如何处理？ 为了解决单线程运行阻塞问题，JavaScript用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop） 事件循环（Event Loop）在JavaScript中，所有的任务都可以分为 同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行 异步任务：异步执行的任务，比如ajax网络请求，setTimeout 定时函数等 从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就是事件循环 宏任务与微任务如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子： 1234567891011121314console.log(1)setTimeout(()=&gt;&#123; console.log(2)&#125;, 0)new Promise((resolve, reject)=&gt;&#123; console.log(&#x27;new Promise&#x27;) resolve()&#125;).then(()=&gt;&#123; console.log(&#x27;then&#x27;)&#125;)console.log(3) 如果按照上面流程图来分析代码，我们会得到下面的执行步骤： console.log(1) ，同步任务，主线程中执行 setTimeout() ，异步任务，放到 Event Table，0 毫秒后console.log(2) 回调推入 Event Queue 中 new Promise ，同步任务，主线程直接执行 .then ，异步任务，放到 Event Table console.log(3)，同步任务，主线程执行 所以按照分析，它的结果应该是 1 =&gt; &#39;new Promise&#39; =&gt; 3 =&gt; 2 =&gt; &#39;then&#39; 但是实际结果是：1=&gt;&#39;new Promise&#39;=&gt; 3 =&gt; &#39;then&#39; =&gt; 2 出现分歧的原因在于异步任务执行顺序，事件队列其实是一个“先进先出”的数据结构，排在前面的事件会优先被主线程读取 例子中 setTimeout回调事件是先进入队列中的，按理说应该先于 .then 中的执行，但是结果却偏偏相反 原因在于异步任务还可以细分为微任务与宏任务 微任务一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前 常见的微任务有： Promise.then MutaionObserver Object.observe（已废弃；Proxy 对象替代） process.nextTick（Node.js） 宏任务宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合 常见的宏任务有： script (可以理解为外层同步代码) setTimeout/setInterval UI rendering/UI事件 postMessage、MessageChannel setImmediate、I/O（Node.js） 按照这个流程，它的执行机制是： 执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中 当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完 回到上面的题目 1234567891011console.log(1)setTimeout(()=&gt;&#123; console.log(2)&#125;, 0)new Promise((resolve, reject)=&gt;&#123; console.log(&#x27;new Promise&#x27;) resolve()&#125;).then(()=&gt;&#123; console.log(&#x27;then&#x27;)&#125;)console.log(3) 流程如下 1234567// 遇到 console.log(1) ，直接打印 1// 遇到定时器，属于新的宏任务，留着后面执行// 遇到 new Promise，这个是直接执行的，打印 &#x27;new Promise&#x27;// .then 属于微任务，放入微任务队列，后面再执行// 遇到 console.log(3) 直接打印 3// 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 &#x27;then&#x27;// 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 2 async与awaitasync 是异步的意思，await 则可以理解为等待 放到一起可以理解async就是用来声明一个异步方法，而 await 是用来等待异步方法执行 asyncasync函数返回一个promise对象，下面两种方法是等效的 12345678function f() &#123; return Promise.resolve(&#x27;TEST&#x27;);&#125;// asyncF is equivalent to f!async function asyncF() &#123; return &#x27;TEST&#x27;;&#125; await正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值 123456async function f()&#123; // 等同于 // return 123 return await 123&#125;f().then(v =&gt; console.log(v)) // 123 不管await后面跟着的是什么，await都会阻塞后面的代码 123456789101112async function fn1 ()&#123; console.log(1) await fn2() console.log(2) // 阻塞&#125;async function fn2 ()&#123; console.log(&#x27;fn2&#x27;)&#125;fn1()console.log(3) 上面的例子中，await 会阻塞下面的代码（即加入微任务队列），先执行 async 外面的同步代码，同步代码执行完，再回到 async 函数中，再执行之前阻塞的代码 所以上述输出结果为：1，fn2，3，2 Node中的事件循环机制事件循环分为6个阶段： timers:执行timer的回调，即setTimeout,setInterval里面的回调函数 I/O事件回调阶段：执行延迟到下一个循环迭代的I/O阶段，即上一轮循环中未被执行的一些I/O回调 idle,prepare(闲置阶段):仅内部使用 poll(轮询阶段)：检查新的I/O事件，执行与I/O相关的回调，（几乎所有情况下，除了关闭的回调函数，那些由计时器和setImmediate（）调度的之外），其余情况node将在适当的时候在此阻塞 check(检查阶段)：setImmediate()回调函数在这里执行 close callback（关闭事件回调阶段）：一些关闭的回调函数，如socket.on(‘close’,…) 除了上述6个阶段，还存在process.nextTick,其不属于事件循环的任何一个阶段，它属于该阶段与下阶段之间的过渡，即本阶段执行结束，进入下一个阶段前要执行的回调，类似插队 在Node中，同样存在宏任务和微任务，与浏览器的事件循环相似 微任务： next tick queue:process.nextTick other queue:Promise的then回调，queueMicrotask 宏任务： timer queue:setTimeout,setInterval poll queue:IO事件 check queue:setImmediate close queue:close事件 执行顺序： next tick microtask queue other microtask queue timer queue poll queue check queue close queue 12345678910111213141516171819202122232425262728293031323334353637async function async1() &#123; console.log(&#x27;async1 start&#x27;) await async2() console.log(&#x27;async1 end&#x27;)&#125;async function async2() &#123; console.log(&#x27;async2&#x27;)&#125;console.log(&#x27;script start&#x27;)setTimeout(function () &#123; console.log(&#x27;setTimeout0&#x27;)&#125;, 0)setTimeout(function () &#123; console.log(&#x27;setTimeout2&#x27;)&#125;, 300)setImmediate(() =&gt; console.log(&#x27;setImmediate&#x27;));process.nextTick(() =&gt; console.log(&#x27;nextTick1&#x27;));async1();process.nextTick(() =&gt; console.log(&#x27;nextTick2&#x27;));new Promise(function (resolve) &#123; console.log(&#x27;promise1&#x27;) resolve(); console.log(&#x27;promise2&#x27;)&#125;).then(function () &#123; console.log(&#x27;promise3&#x27;)&#125;)console.log(&#x27;script end&#x27;) 分析过程： 先找到同步任务，输出script start 遇到第一个 setTimeout，将里面的回调函数放到 timer 队列中 遇到第二个 setTimeout，300ms后将里面的回调函数放到 timer 队列中 遇到第一个setImmediate，将里面的回调函数放到 check 队列中 遇到第一个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行 执行 async1函数，输出 async1 start 执行 async2 函数，输出 async2，async2 后面的输出 async1 end进入微任务，等待下一轮的事件循环 遇到第二个，将其里面的回调函数放到本轮同步任务执行完毕后执行 遇到 new Promise，执行里面的立即执行函数，输出 promise1、promise2 then里面的回调函数进入微任务队列 遇到同步任务，输出 script end 执行下一轮回到函数，先依次输出 nextTick 的函数，分别是 nextTick1、nextTick2 然后执行微任务队列，依次输出 async1 end、promise3 执行timer 队列，依次输出 setTimeout0 接着执行 check 队列，依次输出 setImmediate 300ms后，timer 队列存在任务，执行输出 setTimeout2 执行结果如下： 12345678910111213script startasync1 startasync2promise1promise2script endnextTick1nextTick2async1 endpromise3setTimeout0setImmediatesetTimeout2 最后有一道是关于setTimeout与setImmediate的输出顺序 1234567setTimeout(() =&gt; &#123; console.log(&quot;setTimeout&quot;);&#125;, 0);setImmediate(() =&gt; &#123; console.log(&quot;setImmediate&quot;);&#125;); 输出情况： 1234567情况一：setTimeoutsetImmediate情况二：setImmediatesetTimeout 分析下流程： 外层同步代码一次性全部执行完，遇到异步API就塞到对应的阶段 遇到setTimeout，虽然设置的是0毫秒触发，但实际上会被强制改成1ms，时间到了然后塞入times阶段 遇到setImmediate塞入check阶段 同步代码执行完毕，进入Event Loop 先进入times阶段，检查当前时间过去了1毫秒没有，如果过了1毫秒，满足setTimeout条件，执行回调，如果没过1毫秒，跳过 跳过空的阶段，进入check阶段，执行setImmediate回调 这里的关键在于这1ms，如果同步代码执行时间较长，进入Event Loop的时候1毫秒已经过了，setTimeout先执行，如果1毫秒还没到，就先执行了setImmediate","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"箭头函数和普通函数区别","slug":"箭头函数和普通函数区别","date":"2022-05-02T03:21:43.000Z","updated":"2022-05-02T03:37:43.528Z","comments":true,"path":"2022/05/02/箭头函数和普通函数区别/","link":"","permalink":"https://coloey.github.io/2022/05/02/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB/","excerpt":"","text":"箭头函数和普通函数区别 语法更加简洁清晰 箭头函数不会创建自己的this 所以它不会有自己的this,它只会从自己的作用域链的上一层继承this，作用域链包括全局作用域，块作用域和函数作用域 箭头函数继承而来的this指向永远不变 对象obj的方法b时用箭头函数定义的，这个函数中的this永远指向它定义时所处的全局环境中的this,即使这个函数是作为对象obj的方法调用，它依然指向window对象 call()/apply()/bind()无法改变箭头函数中this得指向 call()/apply()/bind()方法可以用来动态修改this的指向，但由于箭头函数的this定义时就已经确定且永远不会改变，所以使用这些犯法永远也改变不了箭头函数this的指向，但是代码也不会报错 箭头函数不能用作构造函数调用 构造函数的new原理： 箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。 new操作符的实现步骤如下： 1、创建一个空的简单JavaScript对象（即{}）； 2、为步骤1新创建的对象添加属性__proto__，将该属性链接至构造函数的原型对象 ； 3、将步骤1新创建的对象作为this的上下文 ； 4、如果该函数没有返回对象，则返回this。 所以，上面的第二、三步，箭头函数都是没有办法执行的。 箭头函数不能用作Generator函数，不能使用yield关键字","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"tree shaking","slug":"tree-shaking","date":"2022-05-01T14:15:55.000Z","updated":"2022-05-02T15:28:56.323Z","comments":true,"path":"2022/05/01/tree-shaking/","link":"","permalink":"https://coloey.github.io/2022/05/01/tree-shaking/","excerpt":"","text":"tree shaking如何工作的呢？虽然 tree shaking 的概念在 1990 就提出了，但直到 ES6 的 ES6-style 模块出现后才真正被利用起来。 在ES6以前，我们可以使用CommonJS引入模块：require()，这种引入是动态的，也意味着我们可以基于条件来导入需要的代码 但是CommonJS规范无法确定在实际运行前需要或者不需要某些模块，所以CommonJS不适合tree-shaking机制。在 ES6 中，引入了完全静态的导入语法：import。 因为tree shaking只能在静态modules下工作。ECMAScript 6 模块加载是静态的,因此整个依赖树可以被静态地推导出解析语法树。所以在 ES6 中使用 tree shaking 是非常容易的。 tree shaking的原理是什么? ES6 Module引入进行静态分析，故而编译的时候正确判断到底加载了哪些模块 静态分析程序流，判断哪些模块和变量未被使用或者引用，进而删除对应代码 使用将文件标记为无副作用(side-effect-free)在一个纯粹的 ESM 模块世界中，识别出哪些文件有副作用很简单。然而，我们的项目无法达到这种纯度，所以，此时有必要向 webpack 的 compiler 提供提示哪些代码是“纯粹部分”。 这种方式是通过 package.json 的 &quot;sideEffects&quot; 属性来实现的。 1234&#123; &quot;name&quot;: &quot;your-project&quot;, &quot;sideEffects&quot;: false&#125; 如同上面提到的，如果所有代码都不包含副作用，我们就可以简单地将该属性标记为 false，来告知 webpack，它可以安全地删除未用到的 export 导出。 「副作用」的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export。举例说明，例如 polyfill，它影响全局作用域，并且通常不提供 export。 压缩输出通过如上方式，我们已经可以通过 import 和 export 语法，找出那些需要删除的“未使用代码(dead code)”，然而，我们不只是要找出，还需要在 bundle 中删除它们。为此，我们将使用 -p(production) 这个 webpack 编译标记，来启用 uglifyjs 压缩插件。 注意，--optimize-minimize 标记也会在 webpack 内部调用 UglifyJsPlugin。 从 webpack 4 开始，也可以通过 &quot;mode&quot; 配置选项轻松切换到压缩输出，只需设置为 &quot;production&quot;。 webpack.config.js 1234567891011const path = require(&#x27;path&#x27;);module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;bundle.js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;)- &#125;+ &#125;,+ mode: &quot;production&quot;&#125;; 注意，也可以在命令行接口中使用 --optimize-minimize 标记，来使用 UglifyJSPlugin。为了学会使用 tree shaking，你必须…… 使用 ES2015 模块语法（即 import 和 export）。 在项目 package.json 文件中，添加一个 “sideEffects” 入口。 引入一个能够删除未引用代码(dead code)的压缩工具(minifier)（例如 UglifyJSPlugin）。","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"前端工程化/webpack","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack/"}],"tags":[]},{"title":"HMR","slug":"HMR","date":"2022-05-01T09:42:46.000Z","updated":"2022-05-07T13:04:50.817Z","comments":true,"path":"2022/05/01/HMR/","link":"","permalink":"https://coloey.github.io/2022/05/01/HMR/","excerpt":"","text":"是什么HMR 全称是Hot Module Replacement,理解为模块热替换，指在应用程序运行过程中，替换，添加，删除模块，而无需重新刷新整个应用。 例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失，如果使用HME，就可以实现只将修改的模块实时替换至应用中，不必完全舒心整个应用。 在webpack中配置热模块： webpack.config.js 1234567const webpack=require(&#x27;webpack&#x27;)module.exports=&#123; ... devServer:&#123; hot:true &#125;&#125; 通过上述这种配置，如果我们修改并保存CSS文件，确实能够以不刷新地形式更新到页面中，但是，当我们修改并保存js文件之后，页面依旧舒刷新了，这里并没有触发热模块，所以，HMR并不像Webpack的其他特性一样可以开箱即用，需要取指定那些模块发生更新时进行HMR 12345if(module.hot)&#123; module.hot.accept(&#x27;./util.js&#x27;,()=&gt;&#123; console.log(&#x27;utils.js更新了&#x27;) &#125;)&#125; 实现原理 Webpack Compile:将JS源代码编译成bundle.js HMR Server:用来将热更新的文件输出给HMR Runtime Bundle Server:静态资源文件服务器，提供文件访问路径 HMR Runtime:socket服务器，会被注入到浏览器，更新文件的变化 bundle.js:构建输出的文件 在HMR Runtime和HMR Server之间建立websocket，即图上4号线，用于实时更新文件变化 分成两个阶段： 启动阶段为1-2-A-B 在编写未经过webpack打包的源码后，Webpack Compile将源码和HMR Runtime一起编译成bundle文件，传输Bundle Server静态资源服务器 更新阶段为1-2-3-4 当某一个文件或者模块发生变化时，webpack监听到文件变化对文件重新编译打包，编译生成唯一的hash值，这个hash值用来作为下一次热更新的标识，根据变化的内容生成两个补丁文件:manifest(包含了hash和chunkId,用来说明变化的内容)和chunk.js模块，由于socket服务器在HMR Runtime和HMR Server之间建立websocket链接，单文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的hash值，如下图的h属性，做为下一次热更新的标识 在浏览器接收到这条消息之前，浏览器已经在上一次socket消息中记住了此时的hash标识，这时候我们会创建一个ajax去服务端请求获取到变化内容的manifest文件 manifest文件包含重新build生成的hash值，以及变化的模块，对应上图的c属性,浏览器根据manifest文件获取模块变化的内容，从而触发render流程，实现局部模块更新 总结关于webpack热模块更新总结： 通过webpack-dev-server创建两个服务器，提供静态资源的服务(express)和Socket服务 express server负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析） socket server是一个websocket的长连接，双方可以通信 当socket server监听到对应的模块发生变化时，会生成两个文件.json(manifest文件)和.js文件(update chunk) 通过长连接，socket server可以直接将这两个文件主动发送给客户端（浏览器） 浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"前端工程化/webpack","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack/"}],"tags":[]},{"title":"手写object.freeze","slug":"手写object-freeze","date":"2022-04-30T14:04:32.000Z","updated":"2022-04-30T14:12:45.297Z","comments":true,"path":"2022/04/30/手写object-freeze/","link":"","permalink":"https://coloey.github.io/2022/04/30/%E6%89%8B%E5%86%99object-freeze/","excerpt":"","text":"object.freeze()=不可扩展（preventExtensions)+不可配置(configurable:false)+不可写(writable:fasle) object.seal()=不可扩展+不可配置 preventExtensions=不可添加属性+不可改__proto__ 123456789101112131415161718192021222324252627const _objectFreeze = object =&gt; &#123; // 补全代码 //Object.defineProperty(object,) const props=Object.getOwnPropertyNames(object); props.forEach(prop=&gt;&#123; const des=Object.getOwnPropertyDescriptor(object,prop); if(des.get||des.set)&#123; Object.defineProperty(object,prop,&#123; configurable:false,//小写 writable:false, get:des.get, set:des.set &#125;) &#125;else&#123; Object.defineProperty(object,prop,&#123; configurable:false, writable:false, &#125;) &#125; &#125;) return Object.preventExtensions(object); &#125; 数据属性的值不可更改，访问器属性（有getter和setter）也同样（但由于是函数调用，给人的错觉是还是可以修改这个属性）。如果一个属性的值是个对象，则这个对象中的属性是可以修改的，除非它也是个冻结对象。数组作为一种对象，被冻结，其元素不能被修改。没有数组元素可以被添加或移除。 这个方法返回传递的对象，而不是创建一个被冻结的副本。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"常见正则表达式","slug":"常见正则表达式","date":"2022-04-30T07:23:53.000Z","updated":"2022-04-30T08:32:15.128Z","comments":true,"path":"2022/04/30/常见正则表达式/","link":"","permalink":"https://coloey.github.io/2022/04/30/%E5%B8%B8%E8%A7%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"匹配邮箱： {username@hostname.com|edu|info) 1/^[A-Za-z0-9]+([-.][A-Za-z0-9]+)*@[A-Za-z0-9]+(\\.[A-Za-z0-9]+)*\\.[A-Za-z]&#123;2,6&#125;$/ 用户名可以包含点号和连字符，但是用户名以字符开头因此用/\\w+[-.\\w+]*,但是\\w会匹配ASCII字母和数字，但有些系统中\\w能够匹配非ASCII字母，，因此将\\w换成[-A-Za-z0-9],结尾的域名一般在2-6个字符 匹配URL 比如匹配http或者https开头的url 1/^((http|https)):\\/\\/)?[-A-Za-z0-9]+(\\.[A-Za-z0-9]+)*\\.[A-Za-z]&#123;2,6&#125;[a-zA-Z0-9_:\\@&amp;?=+,.!~%*\\$]*(?&lt;![.,?!])$/ 主机名仍然为[A-Za-z0-9]+(.[A-Za-z0-9]+)*.[A-Za-z]{2,6}，路径名[a-zA-Z0-9_:@&amp;?=+,.!~%*$]*可有可无，结尾不能是./?!这些符号 或者 根据题目要求判断参数URL是否合法。首先URL结构一般包括协议、主机名、主机端口、路径、请求信息、哈希，而本题协议已给出为HTTP(S)，使用正则匹配URL，核心步骤有： 首先必须是以http(s)开头并且可以不包含协议头部信息 主机名可以使用”-“符号，所以两种情况都要判断，包含”-“或不包含”-“ 顶级域名很多，直接判断”.”之后是否为字母即可 最后判断端口、路径和哈希，这些参数可有可无 参考答案： 1234const _isUrl = url =&gt; &#123; return /^((http|https):\\/\\/)?(([A-Za-z0-9]+-[A-Za-z0-9]+|[A-Za-z0-9]+)\\.)+([A-Za-z]+)(:\\d+)?(\\/.*)?(\\?.*)?(#.*)?$/.test(url)&#125; 匹配手机号 手机号一般是1开头，第二位只能是3-9，最多9个数字 1/^1[3-9]\\d&#123;9&#125;$&#125;","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://coloey.github.io/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"tags":[]},{"title":"DOM事件","slug":"DOM事件","date":"2022-04-29T15:07:41.000Z","updated":"2022-05-02T15:47:58.141Z","comments":true,"path":"2022/04/29/DOM事件/","link":"","permalink":"https://coloey.github.io/2022/04/29/DOM%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"Dom事件流 DOM2事件流分为3个阶段：事件捕获，到达目标和事件冒泡，事件捕获最先发生，为提前拦截事件提供了可能，然后，实际的目标元素接收到事件后，最后一个阶段是冒泡，最迟要在这个阶段响应事件。 实际目标（div元素）在补货阶段不会接收到事件，这是因为捕获阶段从document到html到body就结束，下一个阶段，即会在div元素上触发事件的‘到达目标阶段，通常在事处理中被认为是事件冒泡的第一部分，然后，冒泡阶段开始，事件反转传播到文档 事件处理程序 HTML事件处理程序: 这种交互能力是通过为onclick属性指定JavaScript代码值实现。 showMessage()函数时单独在script元素中定义，也可以在外部文件定义，作为事件处理程序的代码可以访问全局作用域中的一切 123456&lt;script&gt; function showMessage()&#123; console.log(&#x27;hello world&#x27;)&#125; &lt;/script&gt;&lt;input type=&#x27;button&#x27; value=&#x27;Click me&#x27; onclick=&quot;showMessage()&quot;/&gt; DOM0事件处理程序 每个元素（包括window和document）都有通常小写的事件处理程序属性，比如onclick,只要把这个属性赋值为一个函数即可 12345let btn=document.getElementById(&#x27;myBtn&#x27;);btn.onclick=function()&#123; console.log(this.id)//myBtn &#125; 所赋函数被视为元素的方法，因此，事件处理程序会在元素的作用域中运行，即this等于元素以这种方式添加事件处理程序时注册在事件流的冒泡阶段 通过将事件处理程序属性的值设置为null，可以移除通过Dom0添加的事件处理程序 DOM2事件处理程序 DOM2 Events为事件处理程序的赋值和移除定义了两个方法：addEventListener()和removeEventListener(),它们接收3个参数：事件名，事件处理函数和一个布尔值，true表示在捕获阶段调用事件处理程序，false(默认值)表示在冒泡阶段调用事件处理程序 1234let btn=document.getElementById(&quot;myBtn&quot;)btn.addEventListener(&#x27;click&#x27;,()=&gt;&#123; console.log(this.id)&#125;,false) 使用DOM2的主要优势是可以为同一个事件添加多个事件处理程序 通过addEventListener()添加的事件处理程序通过removeEventListener()移除要传入与添加时同样的参数，因此无法使用addEventListener()添加的匿名函数移除 12345678let btn=document.getElementById(&quot;myBtn&quot;)btn.addEventListener(&#x27;click&#x27;,()=&gt;&#123; console.log(this.id)&#125;,false)btn.removeEventListener(&#x27;click&#x27;,()=&gt;&#123; console.log(this.id)&#125;,false)//没有效果 123456let handler=()=&gt;&#123; console.log(this.id)&#125;let btn=document.getElementById(&quot;myBtn&quot;)btn.addEventListener(&#x27;click&#x27;,handler,false);btn.removeEventListener(&#x27;click&#x27;,handler,false)//有效果 事件对象 DOM事件对象 event对象时传给事件处理程序唯一参数 在事件处理程序内部，this对象始终等于currentTarget的值，而target只包含事件的实际目标，如果事件处理程序直接添加在了意图目标，则this,currentTarget,target的值一样 如果添加在父结点上，则不一样 12345document.body.onclick=function(e)&#123; console.log(e.currentTarget===document.body);//true console.log(this===document.body)//true console.log(e.target===document.getElementById(&#x27;myBtn&#x27;))//true&#125; this和currentTarget等于document.body:它是注册事件处理程序的元素 target属性等于按钮本身：按钮时click的真正目标 由于按钮本身没有注册事件处理程序，因此click事件冒泡到document.body，触发了在它上面注册的处理程序 type属性可以处理多个事件 preventDefault()方法用于阻止特定事件的默认动作，比如链接的默认行为是在被单击时导航到href属性指定的URL，阻止这个导航可以在onclick事件处理程序中取消，通过preventDefault()取消默认行为，事件对象的cancleable属性被设为true stopPropagation()方法用于立即阻止事件流在DOM结构中传播，取消后序事件的捕获或冒泡。 123456789let btn=document.getElementById(&quot;myBtn&quot;)btn.addEventListener(&#x27;click&#x27;,()=&gt;&#123; console.log(this.id) event.stopPropagation();&#125;)document.body.onclick=function()&#123; console.log(&#x27;body click&#x27;)&#125; 由于click事件不会传播到document.body，因此onclick事件处理程序永远不会执行 eventPhase用于确定事件流所处阶段，如果事件处理程序在捕获阶段被调用，则eventphase等于1，到达目标阶段为2，冒泡阶段为3 123456789101112let btn=document.getElementById(&#x27;myBtn&#x27;)btn.onclick=function(e)&#123; console.log(e.eventPhase);//2&#125;document.body.addEventListener(&#x27;click&#x27;,(e)=&gt;&#123; console.log(e.eventPhase);//1&#125;)document.body.onclick=function(e)&#123; console.log(e.eventPhase);//3 &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"深拷贝与浅拷贝","slug":"深拷贝与浅拷贝","date":"2022-04-29T10:16:43.000Z","updated":"2022-05-01T03:01:24.502Z","comments":true,"path":"2022/04/29/深拷贝与浅拷贝/","link":"","permalink":"https://coloey.github.io/2022/04/29/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"一、数据类型存储前面文章我们讲到，JavaScript中存在两大数据类型： 基本类型 引用类型 基本类型数据保存在在栈内存中 引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中 二、浅拷贝浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝 如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址 即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址 下面简单实现一个浅拷贝 123456789function shallowClone(obj)&#123; let newObj=&#123;&#125;; for(let prop in obj)&#123; if(obj.hasOwnProperty(prop))&#123; newObj.prop=obj.prop; &#125; &#125; return newObj;&#125; 在JavaScript中，存在浅拷贝的现象有： Object.assign Array.prototype.slice(), Array.prototype.concat() 使用拓展运算符实现的复制 Object.assign()123456789101112var obj = &#123; age: 18, nature: [&#x27;smart&#x27;, &#x27;good&#x27;], names: &#123; name1: &#x27;fx&#x27;, name2: &#x27;xka&#x27; &#125;, love: function () &#123; console.log(&#x27;fx is a great girl&#x27;) &#125;&#125;var newObj = Object.assign(&#123;&#125;, fxObj); slice()12345const fxArr = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]const fxArrs = fxArr.slice(0)fxArrs[1] = &quot;love&quot;;console.log(fxArr) // [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]console.log(fxArrs) // [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;] concat()12345const fxArr = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]const fxArrs = fxArr.concat()fxArrs[1] = &quot;love&quot;;console.log(fxArr) // [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]console.log(fxArrs) // [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;] 拓展运算符12345const fxArr = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]const fxArrs = [...fxArr]fxArrs[1] = &quot;love&quot;;console.log(fxArr) // [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]console.log(fxArrs) // [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;] 三、深拷贝深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性 常见的深拷贝方式有： _.cloneDeep() jQuery.extend() JSON.stringify() 手写循环递归 _.cloneDeep()12345678const _ = require(&#x27;lodash&#x27;);const obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3]&#125;;const obj2 = _.cloneDeep(obj1);console.log(obj1.b.f === obj2.b.f);// false jQuery.extend()12345678const $ = require(&#x27;jquery&#x27;);const obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3]&#125;;const obj2 = $.extend(true, &#123;&#125;, obj1);console.log(obj1.b.f === obj2.b.f); // false JSON.stringify()1const obj2=JSON.parse(JSON.stringify(obj1)); 但是这种方式存在弊端，会忽略undefined、symbol和函数,而且无法深拷贝循环引用 12345678const obj = &#123; name: &#x27;A&#x27;, name1: undefined, name3: function() &#123;&#125;, name4: Symbol(&#x27;A&#x27;)&#125;const obj2 = JSON.parse(JSON.stringify(obj));console.log(obj2); // &#123;name: &quot;A&quot;&#125; 循环递归这里用WeakMap原因：WeakMap的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。 关于WeakMap看 []: https://www.bookstack.cn/read/es6-3rd/spilt.4.docs-set-map.md 12345678910111213141516171819202122232425262728293031323334const cloneDeep1 = (target, hash = new WeakMap()) =&gt; &#123; // 对于传入参数处理 if (typeof target !== &#x27;object&#x27; || target === null) &#123; return target; &#125; // 哈希表中存在直接返回 if (hash.has(target)) return hash.get(target); const cloneTarget = Array.isArray(target) ? [] : &#123;&#125;; hash.set(target, cloneTarget); // 针对Symbol属性 const symKeys = Object.getOwnPropertySymbols(target); if (symKeys.length) &#123; symKeys.forEach(symKey =&gt; &#123; if (typeof target[symKey] === &#x27;object&#x27; &amp;&amp; target[symKey] !== null) &#123; cloneTarget[symKey] = cloneDeep1(target[symKey]); &#125; else &#123; cloneTarget[symKey] = target[symKey]; &#125; &#125;) &#125; for (const i in target) &#123; if (Object.prototype.hasOwnProperty.call(target, i)) &#123; cloneTarget[i] = typeof target[i] === &#x27;object&#x27; &amp;&amp; target[i] !== null ? cloneDeep1(target[i], hash) : target[i]; &#125; &#125; return cloneTarget;&#125; 小结前提为拷贝类型为引用类型的情况下： 浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址 深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"line-height原理","slug":"line-height原理","date":"2022-04-29T06:06:50.000Z","updated":"2022-05-02T15:51:52.431Z","comments":true,"path":"2022/04/29/line-height原理/","link":"","permalink":"https://coloey.github.io/2022/04/29/line-height%E5%8E%9F%E7%90%86/","excerpt":"","text":"一、line-height是什么line-height 属性设置行间的距离（行高），说的直白一点，就是设置两段段文本之间的距离如果我们把一段文本的line-height设置为父容器的高度就可以实现文本垂直居中了。 二、分析其原理首先来看个图 如图，每一行文字，可看成由上间距、文本内容、下间距构成，根据行高的标准定义，行高等于两条基线之间的距离，即第一行的3-4+上下间距+第二行的1-2+2-3，因为css中每一行的上间距和下间距肯定是相等的，所以代换一下，行高就等于它本身的上间距+下间距+文本高度。因此，我们也可以把行高记为，行高就是一行的高度，这一行的高度中包含了上下两个间距和文本内容本身。而文本内容在每一行中都是居中的，所以利用这个原理，就可以实现垂直居中。 看个例子： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .container &#123; width: 100px; height: 200px; line-height: 200px; margin: 0 auto; border: 1px solid red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; 哈哈哈 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 如上图所示。本例子中，我们设置div的高度为200px，然后里面有一行文本，我们设置了行高为200px，设置完200px后，文字本身16px不会改变，变的是它的上间距和下间距。正如上图所描述的那样。我想到这，你就应该明白了line-height为什么可以使其垂直居中了。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"}],"tags":[]},{"title":"解决canvas中获取跨域图片数据问题","slug":"解决canvas中获取跨域图片数据问题","date":"2022-04-27T16:02:36.000Z","updated":"2022-04-28T08:15:03.471Z","comments":true,"path":"2022/04/28/解决canvas中获取跨域图片数据问题/","link":"","permalink":"https://coloey.github.io/2022/04/28/%E8%A7%A3%E5%86%B3canvas%E4%B8%AD%E8%8E%B7%E5%8F%96%E8%B7%A8%E5%9F%9F%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/","excerpt":"","text":"为什么 canvas 认为跨域图片数据为 污染的数据当请求跨域图片数据，而未满足跨域请求资源的条件时。如果canvas使用未经跨域允许的图片的原始数据，这些是不可信的数据，可能会暴露页面的数据。 请求图片资源 - 同域Request Headers带有cookie。图片数据是被canvas信任的。 请求图片资源 - 跨域默认情况下，直接请求跨域图片。因为不符合跨域请求资源的条件，图片数据是不被canvas信任的。 为了解决图片跨域资源共享的问题， 元素提供了支持的属性：crossOrigin，该属性一共有两个值可选：anonymous 和 use-credentials，下面列举了两者的使用场景，以及满足的条件。 (anonymous:匿名的) anonymous use-credentials 用途 匿名请求跨域图片资源，不会发送证书（比如cookie等） 具名请求跨域图片资源，会携带证书数据 Request Headers origin origin、cookie Response headers Access-Control-Allow-Origin Access-Control-Allow-Origin、Access-Control-Allow-Credentials 所需条件 Access-Control-Allow-Origin 字段值需要包含请求域。 Access-Control-Allow-Origin 字段值需要包含请求域，且不能为通配符 *。Access-Control-Allow-Credentials 字段值需要为 true，表明允许请求发送证书数据。 123456789const canvas=document.createElement(&#x27;canvas&#x27;);const context=canvas.getContext(&#x27;2d&#x27;);const img=new Image();img.crossOrigin=&#x27;anonymous&#x27;;img.onload=()=&gt;&#123; context.drawImage(this,0,0); context.getImageData(0,0,img.width,img.height);&#125;img.src=&quot;https://b.com/a.png&quot;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"图片懒加载","slug":"图片懒加载","date":"2022-04-25T09:07:16.000Z","updated":"2022-04-27T15:41:55.061Z","comments":true,"path":"2022/04/25/图片懒加载/","link":"","permalink":"https://coloey.github.io/2022/04/25/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/","excerpt":"","text":"实现图片懒加载 懒加载是一种网页性能优化方式，提升用户体验，比如懒加载图片，进入页面时，我们只请求可视区域的图片资源 总结： 全部加载会影响用户体验 浪费用户的流量，有些用户不想全部看完，全部加载会耗费大量流量 实现方式： html实现 最简单的实现方式给img标签加上 loading=”lazy” 1&lt;img src=&quot;./example.jpg&quot; loading=&quot;lazy&quot;&gt; js实现原理 通过js监听页面的滚动 使用js实现的原理主要是判断当前图片是否到了可视区域： 拿到所有图片的dom 遍历每个图片判断当前图片是否到达了可视区域范围 如果到了就设置图片的src属性 绑定window的scroll事件，对其进行事件监听 在页面初始化时，img图片的src放在data-src属性上，当匀速处于可视区范围，就把data-src赋值给src属性，完成图片加载 1234567891011121314151617181920212223242526&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Lazyload&lt;/title&gt; &lt;style&gt; img &#123; display: block; margin-bottom: 50px; height: 200px; width: 400px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/1.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/2.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/3.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/4.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/5.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/6.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/7.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/8.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/9.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/10.jpg&quot; /&gt; &lt;/body&gt;&lt;/html&gt; 先获取所有图片的dom,通过document.body.clientHeight获取可视区高度，在使用element.getBoundingClientRect()直接得到元素相对浏览器的top值，遍历每个图片判断图片是否到达了可视区域 12345678910111213function lazyLoad()&#123; let viewHeight=document.body.clientHeight;//获取可视区高度 let imgs=document.querySelectorAll(&quot;img[data-src]&quot;) imgs.forEach(item=&gt;&#123; if(item.data-src==&#x27;&#x27;)return; let rect=item.getBoundingClientRect(); if(rect.top&lt;viewHeight&amp;&amp;rect.bottom&gt;=0)&#123; item.src=item.data-src item.removeAttribute(&#x27;data-src&#x27;) &#125; &#125;) &#125; 这样存在性能问题，因为scroll事件会在很短事件内触发多次，严重影响页面性能，为了提高网页性能，我们需要一个节流函数来控制函数的多次触发，在一段时间内只执行一次回调 12345678910111213function throttle(fn,delay)&#123; let timer=null; return function(fn,...args)&#123; const context=this; if(!temer)&#123; timer=setTimeout(()=&gt;&#123; fn.apply(context,args); timer=null; &#125;) &#125; &#125;&#125; scroll 1window.addEventListener(&quot;scroll&quot;,throttle(lazyload,200)) 拓展： IntersectionObserver通过上面例子的实现，我们要实现懒加载都需要去监听 scroll 事件，尽管我们可以通过函数节流的方式来阻止高频率的执行函数，但是我们还是需要去计算 scrollTop，offsetHeight 等属性，有没有简单的不需要计算这些属性的方式呢，答案就是 IntersectionObserver。 IntersectionObserver 是一个比较新的 API，可以自动”观察”元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。我们来看一下它的用法 []: https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver 12345678910111213141516171819202122const imgs=document.querySelectorAll(&quot;img[data-src]&quot;);const config=&#123; rootMargin:&#x27;0px&#x27;, threshold:0&#125;let observer=new IntersectionObserver((entries,self)=&gt;&#123; entries.forEach((entry)=&gt;&#123; if(entry.isIntersecting)&#123; let img=entry.target; let realsrc=img.dataset.src; if(src)&#123; img.src=realsrc; img.removeAttribute(&#x27;data-src&#x27;) &#125; self.unobserve(entry.target);//解除观察 &#125; &#125;)&#125;,config)imgs.forEach((image)=&gt;&#123; observer.observe(image)&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"object.create()和new区别","slug":"object-create-和new区别","date":"2022-04-25T02:44:18.000Z","updated":"2022-05-01T01:54:53.464Z","comments":true,"path":"2022/04/25/object-create-和new区别/","link":"","permalink":"https://coloey.github.io/2022/04/25/object-create-%E5%92%8Cnew%E5%8C%BA%E5%88%AB/","excerpt":"","text":"Object.create()123456Object.creat=function(o)&#123; var F=function()&#123;&#125;; F.prototype=o; return new F(); &#125; 内部定义一个新对象，并且让F.prototype对象赋值为引进的对象/函数o,并return一个新的对象 new1234567function(o,...args)&#123; var o1=&#123;&#125;; o1.__proto__=o.prototype; var res=o.call(o1,args); return res typeof Object?res:o1; &#125; 区别：12345678var Base=function()&#123; this.a=2;&#125;var o1=new Base();var o2=Object.create(Base);console.log(o1.a);//2console.log(o2.a);//undefined Object.create失去了原来对象属性的访问：F创建后函数调用结束后被销毁，o2直接指向Base构造函数，o2没有指向它的prototype，因此o2.consructor不能通过prototype对找到构造函数，所以是undefined,但是如果Base是一个对象，则o2.a值为2，因为o2的[[Prototype]]指向了对象Base 12345678var Base = function () &#123; this.a = 2&#125;Base.prototype.a = 3;var o1 = new Base();var o2 = Object.create(Base);console.log(o1.a); // 2console.log(o2.a); // undefined 这里Base.prototype.a会去找它的[[Prototype]]上看是否有a，没有就重新设置了一个a，值为3，**而实际上o1.constructor通过默认的[[Prototype]]委托指向Base.prototype,进而委托到constructor指向的构造函数。所以这里的o1.a=2;o2.a仍旧是undefined，因为o2直接指向的是Base,没有指向它的prototype 小结小结 比较 new Object.create 构造函数 保留原构造函数属性 丢失原构造函数属性 原型链 原构造函数prototype属性 原构造函数/（对象）本身 作用对象 function function和object","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"new 原理","slug":"new-原理","date":"2022-04-24T15:50:57.000Z","updated":"2022-04-24T15:56:45.459Z","comments":true,"path":"2022/04/24/new-原理/","link":"","permalink":"https://coloey.github.io/2022/04/24/new-%E5%8E%9F%E7%90%86/","excerpt":"","text":"一、是什么在JavaScript中，new操作符用于创建一个给定构造函数的实例对象 例子 123456789101function Person(name, age)&#123;2 this.name = name;3 this.age = age;4&#125;5Person.prototype.sayName = function () &#123;6 console.log(this.name)7&#125;8const person1 = new Person(&#x27;Tom&#x27;, 20)9console.log(person1) // Person &#123;name: &quot;Tom&quot;, age: 20&#125;10t.sayName() // &#x27;Tom&#x27; 从上面可以看到： new 通过构造函数 Person 创建出来的实例可以访问到构造函数中的属性 new 通过构造函数 Person 创建出来的实例可以访问到构造函数原型链中的属性（即实例与构造函数通过原型链连接了起来） 现在在构建函数中显式加上返回值，并且这个返回值是一个原始类型 1234561function Test(name) &#123;2 this.name = name3 return 14&#125;5const t = new Test(&#x27;xxx&#x27;)6console.log(t.name) // &#x27;xxx&#x27; 可以发现，构造函数中返回一个原始值，然而这个返回值并没有作用 下面在构造函数中返回一个对象 123456781function Test(name) &#123;2 this.name = name3 console.log(this) // Test &#123; name: &#x27;xxx&#x27; &#125;4 return &#123; age: 26 &#125;5&#125;6const t = new Test(&#x27;xxx&#x27;)7console.log(t) // &#123; age: 26 &#125;8console.log(t.name) // &#x27;undefined&#x27; 从上面可以发现，构造函数如果返回值为一个对象，那么这个返回值会被正常使用 二、流程从上面介绍中，我们可以看到new关键字主要做了以下的工作： 创建一个新的对象obj 将对象与构建函数通过原型链连接起来 将构建函数中的this绑定到新建的对象obj上 根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理 举个例子： 12345671function Person(name, age)&#123;2 this.name = name;3 this.age = age;4&#125;5const person1 = new Person(&#x27;Tom&#x27;, 20)6console.log(person1) // Person &#123;name: &quot;Tom&quot;, age: 20&#125;7t.sayName() // &#x27;Tom&#x27; 手写new 操作符123456function my new(Func,..args)&#123; const obj=&#123;&#125;; obj.__proto__=Func.prototype; let result=Func.apply(obj,args); return result instanceOf Object?result:obj&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"实现node中的EventEmitter","slug":"实现node中的EventEmitter","date":"2022-04-24T14:08:59.000Z","updated":"2022-04-30T14:48:00.373Z","comments":true,"path":"2022/04/24/实现node中的EventEmitter/","link":"","permalink":"https://coloey.github.io/2022/04/24/%E5%AE%9E%E7%8E%B0node%E4%B8%AD%E7%9A%84EventEmitter/","excerpt":"","text":"一、是什么我们了解到，Node 采用了事件驱动机制，而EventEmitter 就是Node实现事件驱动的基础 在EventEmitter的基础上，Node 几乎所有的模块都继承了这个类，这些模块拥有了自己的事件，可以绑定／触发监听器，实现了异步操作 Node.js 里面的许多对象都会分发事件，比如 fs.readStream 对象会在文件被打开的时候触发一个事件 这些产生事件的对象都是 events.EventEmitter 的实例，这些对象有一个 eventEmitter.on() 函数，用于将一个或多个函数绑定到命名事件上 二、使用方法Node 的events模块只提供了一个EventEmitter类，这个类实现了Node异步事件驱动架构的基本模式——观察者模式 在这种模式中，被观察者(主体)维护着一组其他对象派来(注册)的观察者，有新的对象对主体感兴趣就注册观察者，不感兴趣就取消订阅，主体有更新的话就依次通知观察者们 基本代码如下所示： 1234567891011const EventEmitter = require(&#x27;events&#x27;)class MyEmitter extends EventEmitter &#123;&#125;const myEmitter = new MyEmitter()function callback() &#123; console.log(&#x27;触发了event事件！&#x27;)&#125;myEmitter.on(&#x27;event&#x27;, callback)myEmitter.emit(&#x27;event&#x27;)myEmitter.removeListener(&#x27;event&#x27;, callback); 通过实例对象的on方法注册一个名为event的事件，通过emit方法触发该事件，而removeListener用于取消事件的监听 关于其常见的方法如下： emitter.addListener/on(eventName, listener) ：添加类型为 eventName 的监听事件到事件数组尾部 emitter.prependListener(eventName, listener)：添加类型为 eventName 的监听事件到事件数组头部 emitter.emit(eventName[, …args])：触发类型为 eventName 的监听事件 emitter.removeListener/off(eventName, listener)：移除类型为 eventName 的监听事件 emitter.once(eventName, listener)：添加类型为 eventName 的监听事件，以后只能执行一次并删除 emitter.removeAllListeners([eventName])： 移除全部类型为 eventName 的监听事件 三、实现过程通过上面的方法了解，EventEmitter是一个构造函数，内部存在一个包含所有事件的对象 12345class EventEmitter &#123; constructor() &#123; this.events = &#123;&#125;; &#125;&#125; 其中events存放的监听事件的函数的结构如下： 12345&#123; &quot;event1&quot;: [f1,f2,f3]， &quot;event2&quot;: [f4,f5]， ...&#125; 然后开始一步步实现实例方法，首先是emit，第一个参数为事件的类型，第二个参数开始为触发事件函数的参数，实现如下： 12345emit(type, ...args) &#123; this.events[type].forEach((item) =&gt; &#123; Reflect.apply(item, this, args); &#125;);&#125; 当实现了emit方法之后，然后实现on、addListener、prependListener这三个实例方法，都是添加事件监听触发函数，实现也是大同小异 1234567891011121314151617on(type, handler) &#123; if (!this.events[type]) &#123; this.events[type] = []; &#125; this.events[type].push(handler);&#125;addListener(type,handler)&#123; this.on(type,handler)&#125;prependListener(type, handler) &#123; if (!this.events[type]) &#123; this.events[type] = []; &#125; this.events[type].unshift(handler);&#125; 紧接着就是实现事件监听的方法removeListener/on 12345678910removeListener(type, handler) &#123; if (!this.events[type]) &#123; return; &#125; this.events[type] = this.events[type].filter(item =&gt; item !== handler);&#125;off(type,handler)&#123; this.removeListener(type,handler)&#125; 最后再来实现once方法， 再传入事件监听处理函数的时候进行封装，利用闭包的特性维护当前状态，通过fired属性值判断事件函数是否执行过 123456789101112131415161718once(type, handler) &#123; this.on(type, this._onceWrap(type, handler, this)); &#125; _onceWrap(type, handler, target) &#123; const state = &#123; fired: false, handler, type , target&#125;; const wrapFn = this._onceWrapper.bind(state); state.wrapFn = wrapFn; return wrapFn; &#125; _onceWrapper(...args) &#123; if (!this.fired) &#123; this.fired = true; Reflect.apply(this.handler, this.target, args); this.target.off(this.type, this.wrapFn); &#125; &#125; 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243class EventEmitter &#123; constructor()&#123; this.events=&#123;&#125;; &#125; on(type,handler)&#123; if(!this.events[type])&#123; this.events[type]=[] &#125; this.events[type].push(handler) &#125; addListener(type,handler)&#123; this.on(type,handler) &#125; prependListener(type,handler)&#123; if(!this.events[type])&#123; this.events[type]=[] &#125; this.events[type].unshift(handler) &#125; removeListener(type,handler)&#123; if(!this.events[type])&#123; return; &#125; this.events[type]=this.events[type].filter(item=&gt;item!==handler) &#125; off(type,handler)&#123; this.removeListener(type,handler) &#125; emit(type,...args)&#123; this.events[type].forEach(item=&gt;&#123; Reflect.apply(item,this,args); &#125;) &#125; once(type,handler)&#123; //把监听器注销，即利用闭包，在内部函数中销毁了外部函数的引用 let temp=(...args)=&gt;&#123; handler(args); this.off(type,temp) &#125; this.on(event,temp) &#125;&#125;","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"}],"tags":[]},{"title":"防抖节流","slug":"防抖节流","date":"2022-04-24T09:49:35.000Z","updated":"2022-04-24T10:09:28.696Z","comments":true,"path":"2022/04/24/防抖节流/","link":"","permalink":"https://coloey.github.io/2022/04/24/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/","excerpt":"","text":"是什么本质上是优化高频率执行代码的一种手段 如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能 为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用throttle（节流）和debounce（防抖）的方式来减少调用频率 定义 节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效 防抖: n 秒后再执行该事件，若在 n 秒内被重复触发，则重新计时 节流：用时间戳实现： 12345678910function throttled(fn,delay=500)&#123; let oldTime=new Date.now(); return function(...args)&#123; let newTime=new Date.now(); if(newTime-oldTime&gt;=delay)&#123; fn.apply(this,args); oldTime=new Date.now(); &#125; &#125;&#125; 用定时器实现 1234567891011function throttled(fn,delay=500)&#123; let timer=null; return function(..args)&#123; if(!timer)&#123; timer=setTimeout(()=&gt;&#123; fn.apply(this,args); timer=null; &#125;,delay) &#125; &#125;&#125; 防抖：123456789function debounce(fn,delay=500)&#123; let timer; return function(...args)&#123; if(timer)clearTimeout(timer); timer=setTimeout(()=&gt;&#123; fn.apply(this,args);//每次执行，都先清除该计时器，然后下面重新开始计数，即不执行 debounce 一段时间 wait 后，setTimeout 里面的代码才会执行 &#125;,delay) &#125;&#125; 立即执行的防抖函数 1234567891011121314function debounce(fn,delay=500,immediate)&#123; let timer; return function(...args)&#123; if(immediate)&#123; immediate=!immediate; fn.apply(this,args); &#125;else&#123; if(timer)clearTimeout(timer); timer=setTimeout(()=&gt;&#123; fn.apply(this,args); &#125;,delay) &#125; &#125;&#125; 区别相同点： 都可以通过使用 setTimeout 实现 目的都是，降低回调执行频率。节省计算资源 不同点： 函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout 和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能 函数防抖关注一定时间连续触发的事件，因为会清除定时器，只在最后执行一次，而函数节流一段时间内只执行一次,不会清除定时器，因此会在隔一段时间执行一次。 例如，都设置时间频率为500ms，在2秒时间内，频繁触发函数，节流，每隔 500ms 就执行一次。防抖，则不管调动多少次方法，在2s后，只会执行一次 应用场景防抖在连续的事件，只需触发一次回调的场景有： 搜索框搜索输入。只需用户最后一次输入完，再发送请求 手机号、邮箱验证输入检测 窗口大小resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。 节流在间隔一段时间执行一次回调的场景有： 滚动加载，加载更多或滚到底部监听 搜索框，搜索联想功能","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"浏览器的回流和重绘","slug":"浏览器的回流和重绘","date":"2022-04-24T07:35:30.000Z","updated":"2022-05-02T15:59:04.707Z","comments":true,"path":"2022/04/24/浏览器的回流和重绘/","link":"","permalink":"https://coloey.github.io/2022/04/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/","excerpt":"","text":"是什么在HTML中，每个元素可以理解为一个盒子，在浏览器解析过程中，会涉及到回流和重绘： 回流：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置 重绘：当计算好盒模型的位置，大小及其他属性后，浏览器根据每个盒子特性进行绘制 解析HTML,生成DOM树，解析CSS，生成CSSOM树 将DOM树和CSSOM树结合，生成渲染树Render Tree Layout(回流)：根据生成的渲染树，进行回流(Layout),得到节点的几何信息（位置，大小） Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素 Display:将像素发送给GPU，展示在页面上 当我们对DOM的修改引发了DOM几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性，然后再将计算的结果绘制出来），即回流。 当对DOM的修改导致样式变化（color或background-color)却为影响几何属性，浏览器不需要重新计算元素的几何苏醒，直接为该元素绘制新的样式，这里仅仅触发重绘。 如何触发要想减少回流和重绘的次数，首先要了解回流和重绘是如何触发的 回流触发时机回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流，如下面情况： 添加或删除可见的DOM元素 元素的位置发生变化 元素的尺寸发生变化（包括外边距，内边框，边框大小，高度，宽度等） 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代 页面一开始渲染（不可避免） 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小） 还有一些容易被忽略的操作：获取一些特定属性的值 offsetTop,offsetLetf,offsetWidth,offsetHeight,scrollTop,scrollLeft,scrollWidth,scrollHeight,clientTop,clientLeft,clientWidth,clientHeight 这些属性有一个共性，就是需要通过即时计算得到，因此浏览器为了获取这些值，也会进行回流，除此之外getComputedStyle方法的原理也一样 重绘触发时机：触发回流一定会触发重绘 引起重绘·的一些其他行为： 颜色修改 阴影修改 浏览器优化机制由于每次重排都会造成额外的计算消耗，因此大多数浏览器会通过队列化修改并批量执行来优化重排过程，浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列 当获取布局信息操作时，会强制队列刷新，包括前面讲到的offsetTop等方法都会返回最新的数据，因此浏览器不得不清空队列，触发回流重绘来返回正确的值 如何减少 如果设定元素的样式，通过修改元素的class类型（尽可能在DOM树的最里层） 避免设置多项内联样式 应用元素的动画，使用position属性为fixed或absolute的元素 避免使用table布局，table布局中每个元素的大小以及内容的改动，都会导致整个table的重新计算 对于那些复杂动画，对其设置position:fixed/absolute,尽可能地使元素脱离文档流，从而减少对其他元素的影响 使用css3硬件加速，可以让transform,opacity,filters这些动画不会引起回流重绘 避免使用CSS的JavaScript表达式 在使用JavaScript动态插入多个节点时，可以使用DocumentFragment,创建最后一次插入，就能避免多次的渲染性能 例如，多次修改一个元素布局时， 123456const el=document.getElementById(&quot;el&quot;)for(let i=0;i&lt;10;i++)&#123; el.style.top=el.offsetTop+10+&quot;px&quot;; el.style.left=el.offsetleft+10+&quot;px&quot;&#125; 每次循环都需要获取多次offset属性，比较糟糕，可以使用变量的形式缓存起来，待计算完毕再提交给浏览器发出重计算请求 123456789const el=document.getElementById(&quot;el&quot;)//先缓存offsetLeft和offsetTop的值let offLeft=el.offsetLeft,offTop=el.offsetTopfor(let i=0;i&lt;10;i++)&#123; offLeft+=10 offTop+=10&#125;el.styel.left=offLeft+&quot;px&quot;;el.style.top=offTop+&quot;px&quot; 我们还可避免修改样式，使用类名去合并样式 12345const container=document.getElementById(&quot;container&quot;)container.style.width=&#x27;100px&#x27;container.style.height = &#x27;200px&#x27;container.style.border = &#x27;10px solid red&#x27;container.style.color = &#x27;red&#x27; 使用类名去合并样式 1234567891011121&lt;style&gt;2 .basic_style &#123;3 width: 100px;4 height: 200px;5 border: 10px solid red;6 color: red;7 &#125;8&lt;/style&gt;9&lt;script&gt;10 const container = document.getElementById(&#x27;container&#x27;)11 container.classList.add(&#x27;basic_style&#x27;)12&lt;/script&gt; 前者每次单独操作，都去触发一次渲染树更改（新浏览器不会）， 都去触发一次渲染树更改，从而导致相应的回流与重绘过程 合并之后，等于我们将所有的更改一次性发出 我们还可以通过通过设置元素属性display: none，将其从页面上去掉，然后再进行后续操作，这些后续操作也不会触发回流与重绘，这个过程称为离线操作 12345const container = document.getElementById(&#x27;container&#x27;)container.style.width = &#x27;100px&#x27;container.style.height = &#x27;200px&#x27;container.style.border = &#x27;10px solid red&#x27;container.style.color = &#x27;red&#x27; 离线操作后 12345678let container = document.getElementById(&#x27;container&#x27;)container.style.display = &#x27;none&#x27;container.style.width = &#x27;100px&#x27;container.style.height = &#x27;200px&#x27;container.style.border = &#x27;10px solid red&#x27;container.style.color = &#x27;red&#x27;...（省略了许多类似的后续操作）container.style.display = &#x27;block&#x27;","categories":[{"name":"浏览器渲染机制","slug":"浏览器渲染机制","permalink":"https://coloey.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"}],"tags":[]},{"title":"解决相邻inline-block之间的间隔","slug":"解决相邻inline-block之间的间隔","date":"2022-04-23T15:35:04.000Z","updated":"2022-04-23T15:44:17.596Z","comments":true,"path":"2022/04/23/解决相邻inline-block之间的间隔/","link":"","permalink":"https://coloey.github.io/2022/04/23/%E8%A7%A3%E5%86%B3%E7%9B%B8%E9%82%BBinline-block%E4%B9%8B%E9%97%B4%E7%9A%84%E9%97%B4%E9%9A%94/","excerpt":"","text":"转载自 zhangxinxu from http://www.zhangxinxu.com 一、现象描述真正意义上的inline-block水平呈现的元素间，换行显示或空格分隔的情况下会有间距. 我们使用CSS更改非inline-block水平元素为inline-block水平，也会有该问题： 12345space a &#123; display: inline-block; padding: .5em 1em; background-color: #cad5eb;&#125; 12345&lt;div class=&quot;space&quot;&gt; &lt;a href=&quot;##&quot;&gt;惆怅&lt;/a&gt; &lt;a href=&quot;##&quot;&gt;淡定&lt;/a&gt; &lt;a href=&quot;##&quot;&gt;热血&lt;/a&gt;&lt;/div&gt; 这种表现是符合规范的应该有的表现。 元素被当成行内元素排版的时候，元素之间的空白符（空格、回车换行等）都会被浏览器处理，根据white-space的处理方式（默认是normal，合并多余空白），原来HTML代码中的回车换行被转成一个空白符，在字体不为0的情况下，空白符占据一定宽度，所以inline-block的元素之间就出现了空隙。这些元素之间的间距会随着字体的大小而变化，当行内元素font-size:16px时，间距为8px。 二、方法之移除空格元素间留白间距出现的原因就是标签段之间的空格，因此，去掉HTML中的空格，自然间距就木有了。考虑到代码可读性，显然连成一行的写法是不可取的，我们可以： 12345&lt;div class=&quot;space&quot;&gt; &lt;a href=&quot;##&quot;&gt;惆怅&lt;/a &gt;&lt;a href=&quot;##&quot;&gt;淡定&lt;/a &gt;&lt;a href=&quot;##&quot;&gt;热血&lt;/a&gt;&lt;/div&gt; 12345&lt;div class=&quot;space&quot;&gt; &lt;a href=&quot;##&quot;&gt;惆怅&lt;/a&gt;&lt;!-- --&gt;&lt;a href=&quot;##&quot;&gt;淡定&lt;/a&gt;&lt;!-- --&gt;&lt;a href=&quot;##&quot;&gt;热血&lt;/a&gt;&lt;/div&gt; 使用margin负值12341.space a &#123;2 display: inline-block;3 margin-right: -3px;4&#125; margin负值的大小与上下文的字体和文字大小相关 使用font-size:0类似下面的代码： 1234561.space &#123;2 font-size: 0;3&#125;4.space a &#123;5 font-size: 12px;6&#125; 这个方法，基本上可以解决大部分浏览器下inline-block元素之间的间距(IE7等浏览器有时候会有1像素的间距)。 使用letter-spacing 类似下面的代码： 1234561.space &#123;2 letter-spacing: -3px;3&#125;4.space a &#123;5 letter-spacing: 0;6&#125; 使用word-spacing类似下面代码： 1234561.space &#123;2 word-spacing: -6px;3&#125;4.space a &#123;5 word-spacing: 0;6&#125; 一个是字符间距(letter-spacing)一个是单词间距(word-spacing)，大同小异。据我测试，word-spacing的负值只要大到一定程度，其兼容性上的差异就可以被忽略。因为，貌似，word-spacing即使负值很大，也不会发生重叠。 与上面demo一样的效果，这里就不截图展示了。如果您使用Chrome浏览器，可能看到的是间距依旧存在。确实是有该问题，原因我是不清楚，不过我知道，可以添加display: table;或display:inline-table;让Chrome浏览器也变得乖巧。 12341.space &#123;2 display: inline-table;3 word-spacing: -6px;4&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"}],"tags":[]},{"title":"实现flex盒子最后一行左对齐","slug":"实现flex盒子最后一行左对齐","date":"2022-04-23T10:03:51.000Z","updated":"2022-04-23T15:05:53.977Z","comments":true,"path":"2022/04/23/实现flex盒子最后一行左对齐/","link":"","permalink":"https://coloey.github.io/2022/04/23/%E5%AE%9E%E7%8E%B0flex%E7%9B%92%E5%AD%90%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C%E5%B7%A6%E5%AF%B9%E9%BD%90/","excerpt":"","text":"问题：在CSS flex布局中，justify-content属性可以控制列表的水平对齐方式，例如space-between值可以实现两端对齐。 但是，如果最后一行的列表的个数不满，则就会出现最后一行没有完全垂直对齐的问题。 解决： 每一行固定列数：方法一：模拟space-between和间隙也就是我们不使用justify-content:space-between声明在模拟两端对齐效果。中间的gap间隙我们使用margin进行控制。 例如： 12345678910111213141516171819202122232425262728&lt;style&gt; .container &#123; display: flex; flex-wrap: wrap; &#125; .list &#123; width: 24%; height: 100px; background-color: skyblue; margin-top: 15px; &#125; .list:not(:nth-child(4n)) &#123; /* 100%-24%*4=4%,4%/3分配给不是4的倍数的盒子 */ margin-right: calc(4%/3) &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;list&quot;&gt;&lt;/div&gt; &lt;div class=&quot;list&quot;&gt;&lt;/div&gt; &lt;div class=&quot;list&quot;&gt;&lt;/div&gt; &lt;div class=&quot;list&quot;&gt;&lt;/div&gt; &lt;div class=&quot;list&quot;&gt;&lt;/div&gt; &lt;div class=&quot;list&quot;&gt;&lt;/div&gt; &lt;div class=&quot;list&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 方法二：根据个数最后一个元素动态margin由于每一列的数目都是固定的，因此，我们可以计算出不同个数列表应当多大的margin值才能保证完全左对齐。 例如，假设每行4个元素，结果最后一行只有3个元素，则最后一个元素的margin-right大小是“列表宽度+间隙大小”的话，那最后3个元素也是可以完美左对齐的。 然后，借助树结构伪类数量匹配技术，我们可以知道最后一行有几个元素。 例如： .list:last-child:nth-child(4n - 1)说明最后一行，要么3个元素，要么7个元素…… .list:last-child:nth-child(4n - 2)说明最后一行，要么2个元素，要么6个元素…… 在本例中，一行就4个元素，因此，我们可以有如下CSS设置： 1234567891011121314151617181920.container &#123; display: flex; flex-wrap: wrap; &#125; .list &#123; width: 24%; height: 100px; background-color: skyblue; margin-top: 15px; /* 每个的margin-right默认为4%/3 */ margin-right: calc(4%/4); &#125; /* 最后一行3个 则最后一个的margin-right特殊设置*/ .list:last-child:nth-child(4n-1) &#123; margin-right: calc(24%+4%/3) &#125; /* 最后一行两个 */ .list:last-child:nth-child(4n-2)&#123; margin-right: calc(48%+8%/3) ; &#125; 子项宽度不固定最后一项margin-right:auto12345678910111213.container &#123; display:flex; justify-content: space-between; flex-wrap: wrap;&#125;.list &#123; bacground-color: skyblue; margin: 10px;&#125;/*最后一项margin-right:auto,让margin-right占据剩余空间*/.list:last-child &#123; margin-right:auto;&#125; 创建伪元素占据剩余空间1234567891011121314.container &#123; display: flex; justify-content: space-between; flex-wrap: wrap; &#125; .list &#123; height: 100px; background-color: skyblue; margin: 10px; &#125; .container::after &#123; content:&#x27;&#x27;; flex:1; &#125; 如果每一行列数不固定如果每一行的列数不固定，则上面的这些方法均不适用，需要使用其他技巧来实现最后一行左对齐。 这个方法其实很简单，也很好理解，就是使用足够的空白标签进行填充占位，具体的占位数量是由最多列数的个数决定的，例如这个布局最多7列，那我们可以使用7个空白标签进行填充占位，最多10列，那我们需要使用10个空白标签。 如下HTML示意： 123456789101&lt;div class=&quot;container&quot;&gt;2 &lt;div class=&quot;list&quot;&gt;&lt;/div&gt;3 &lt;div class=&quot;list&quot;&gt;&lt;/div&gt;4 &lt;div class=&quot;list&quot;&gt;&lt;/div&gt;5 &lt;div class=&quot;list&quot;&gt;&lt;/div&gt;6 &lt;div class=&quot;list&quot;&gt;&lt;/div&gt;7 &lt;div class=&quot;list&quot;&gt;&lt;/div&gt;8 &lt;div class=&quot;list&quot;&gt;&lt;/div&gt;9 &lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;10&lt;/div&gt; 相关CSS如下，实现的关键就是占位的&lt;i&gt;元素宽度和margin大小设置得和.list列表元素一样即可，其他样式都不需要写。 123456789101112131415161.container &#123;2 display: flex;3 justify-content: space-between;4 flex-wrap: wrap;5 margin-right: -10px;6&#125;7.list &#123;8 width: 100px; height:100px;9 background-color: skyblue;10 margin: 15px 10px 0 0;11&#125;12/* 和列表一样的宽度和margin值 */13.container &gt; i &#123;14 width: 100px;15 margin-right: 10px;16&#125; 由于&lt;i&gt;元素高度为0，因此，并不会影响垂直方向上的布局呈现。 如果列数不固定HTML又不能调整然而有时候，由于客观原因，前端重构人员没有办法去调整html结构，同时布局的列表个数又不固定，这个时候该如何实现我们最后一行左对齐效果呢？ 我们不妨可以试试使用Grid布局。 Grid布局天然有gap间隙，且天然格子对齐排布，因此，实现最后一行左对齐可以认为是天生的效果。 CSS代码如下： 1234567891011121314&lt;style&gt; .container &#123; display: grid; justify-content: space-between; grid-template-columns: repeat(auto-fill,100px); grid-gap: 10px; &#125; .list &#123; width: 100px; height: 100px; background-color: skyblue; margin-top: 5px; &#125; &lt;/style&gt; 这几种实现方法点评首先最后一行需要左对齐的布局更适合使用CSS grid布局实现，但是，repeat()函数兼容性有些要求，IE浏览器并不支持。如果项目需要兼容IE，则此方法需要斟酌。 然后，适用范围最广的方法是使用空的元素进行占位，此方法不仅适用于列表个数不固定的场景，对于列表个数固定的场景也可以使用这个方法。但是有些人代码洁癖，看不惯这种空的占位的html标签，则可以试试一开始的两个方法，一是动态计算margin，模拟两端对齐，另外一个是根据列表的个数，动态控制最后一个列表元素的margin值实现左对齐。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"}],"tags":[]},{"title":"实现水平垂直居中","slug":"实现水平垂直居中","date":"2022-04-23T09:10:33.000Z","updated":"2022-04-23T13:59:01.571Z","comments":true,"path":"2022/04/23/实现水平垂直居中/","link":"","permalink":"https://coloey.github.io/2022/04/23/%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/","excerpt":"","text":"我们在布局一个页面时，通常都会用到水平居中和垂直居中，处理水平居中很好处理，不外乎就是设定margin:0 auto;或是text-align:center;,就可以轻松解决掉水平居中的问题，但一直以来最麻烦对齐问题就是「垂直居中」，以下将介绍几种单纯利用CSS垂直居中的方式，只需要理解背后的原理就可以轻松应用。 下面为公共代码： 1234567891011121&lt;div class=&quot;box&quot;&gt;2 &lt;div class=&quot;small&quot;&gt;small&lt;/div&gt;3&lt;/div&gt;1.box &#123;2 width: 300px;3 height: 300px;4 background: #ddd;5&#125;6.small &#123;7 background: red;8&#125;9 absolute + margin实现方法一： 12345678910111.box &#123;2 position: relative;3&#125;4.small &#123;5 position: absolute;6 top: 50%;7 left: 50%;8 margin: -50px 0 0 -50px;9 width: 100px;10 height: 100px;11&#125; 方法二： margin:auto会自动去计算子元素和父元素之间的边距，并设为居中。所以就会实现上下左右都居中。 1.在普通内容流中，margin:auto的效果等同于margin:0 auto,左右会去极端剩余空间平均分配，而上下默认都为0； 2.position:absolute使绝对定位块跳出了内容流，内容流中的其余部分渲染时绝对定位部分不进行渲染。 3.为块区域设置top: 0; left: 0; bottom: 0; right: 0;将给浏览器重新分配一个边界框，此时该块将填充其父元素的所有可用空间，所以margin 垂直方向上有了可分配的空间。 4.再设置margin 垂直方向上下为auto，即可实现垂直居中。（注意高度得设置）。 123456789101112131.box &#123;2 position: relative;3&#125;4.small &#123;5 position: absolute;6 top: 0;7 right: 0;8 bottom: 0;9 left: 0;10 margin: auto;11 width: 100px;12 height: 100px;13&#125; absolute + calc 实现123456789101.box &#123;2 position: relative;3&#125;4.small &#123;5 position: absolute;6 top: calc(50% - 50px);7 left: calc(50% - 50px);8 width: 100px;9 height: 100px;10&#125; absolute + transform 实现1234567891011121.box &#123;2 position: relative;3&#125;4.small &#123;5 position: absolute;6 top: 50%;7 left: 50%;8 transform: translate3d(-50%,-50%,0);9 width: 100px;10 height: 100px;11&#125;12 转行内元素1234567891011.box &#123; line-height:300px; text-align: center;&#125;.small &#123; padding: 6px 10px; display:inline-block; font-size:16px; vertical-aligin: middle; line-height: 16px;&#125; vertical-align:在W3C官方中对 vertical-align做了下面的解释：This property affects the vertical positioning inside a line box of the boxes generated by an inline-level element.事实上，一个Box中由很多行很多元素组成，vertical-align只作用于在同一行内的元素，它的垂直并不是相对于整个Box而言的。如果把 vertical-align:middle 放到一个单元格元素，即table的td元素中，它的垂直居中显示是没任何问题的，因为它表示相对于改行的垂直高度居中显示。而在我设定的div块中并不只存在一行，因此它无法识别默认显示在顶部。 为了解决这个问题，我找到了两种方法。一个是我们可以设置元素style中的 line-heght 值为其父元素的height值，这样 vertical-align:middle 就会使元素内容垂直居中。 另外还有种方法，就是将要设置垂直居中的元素的父元素style属性添加 display:table-cell 将其作为单元格显示，这样使用 vertical-align:middle 也可以实现垂直居中 转行内元素并且使用table-cell12345678910111213.box &#123; display: table-cell; height: 300px; width: 300px; text-align: center; background: green; vertical-align: middle; &#125; .small &#123; padding: 6px 10px; display:inline-block; background-color: aliceblue; &#125; flex方法一： 123451.box &#123;2 display: flex;3 justify-content: center;4 align-items: center;5&#125; 方法二： 12345671.box &#123;2 display: flex;3 justify-content: center;4&#125;5.small &#123;6 align-self: center;7&#125; grid布局123456789101112131415.box &#123; display: grid; height: 300px; width: 300px; justify-items: center; align-items: center; background-color: #000; &#125; .small &#123; width: 100px; height: 100px; background-color: #fff; &#125; 方法二： 12345671.box &#123;2 display: grid;3&#125;4.small &#123;5 justify-self: center;6 align-self: center;7&#125; 方法三： 123456781.box &#123;2 display: grid;3 justify-items: center;4&#125;5.small &#123;6 align-self: center;7&#125;8 方法四： 1234567复制1.box &#123;2 display: grid;3 align-items: center;4&#125;5.small &#123;6 justify-self: center;7&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"}],"tags":[]},{"title":"BFC","slug":"BFC","date":"2022-04-23T03:15:31.000Z","updated":"2022-05-02T15:49:06.314Z","comments":true,"path":"2022/04/23/BFC/","link":"","permalink":"https://coloey.github.io/2022/04/23/BFC/","excerpt":"","text":"一、常见定位方案在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案: 普通流 (normal flow) 在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。 浮动 (float) 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。 绝对定位 (absolute positioning) 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。 二、BFC 概念Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 那么 BFC 是什么呢？ BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。 **具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。** 通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 定位方案： 内部的Box会在垂直方向上一个接一个放置。 Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠。 每个元素的margin box 的左边，与包含块border box的左边相接触。 BFC的区域不会与float box重叠。 BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。 计算BFC的高度时，浮动元素也会参与计算。 三、触发 BFC只要元素满足下面任一条件即可触发 BFC 特性： html 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) 四、BFC 特性及应用1. 同一个 BFC 下外边距会发生折叠 123456789101112&lt;head&gt;div&#123; width: 100px; height: 100px; background: lightblue; margin: 100px;&#125;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; 从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。 首先这不是 CSS 的 bug，我们可以理解为一种规范，如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。 123456789101112131415&lt;div class=&quot;container&quot;&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;container&quot;&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;.container &#123; overflow: hidden;&#125;p &#123; width: 100px; height: 100px; background: lightblue; margin: 100px;&#125; 这时候，两个盒子边距就变成了 200px 2. BFC 可以包含浮动的元素（清除浮动） 我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子 123&lt;div style=&quot;border: 1px solid #000;&quot;&gt; &lt;div style=&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;&gt;&lt;/div&gt;&lt;/div&gt; 由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。 123&lt;div style=&quot;border: 1px solid #000;overflow: hidden&quot;&gt; &lt;div style=&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;&gt;&lt;/div&gt;&lt;/div&gt; 效果如图： 3. BFC 可以阻止元素被浮动元素覆盖 先来看一个文字环绕效果： 123&lt;div style=&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;&gt;我是一个左浮动的元素&lt;/div&gt;&lt;div style=&quot;width: 200px; height: 200px;background: #eee&quot;&gt;我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;&lt;/div&gt; 这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden，就会变成： 这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。 我是一个左浮动的元素 我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"}],"tags":[]},{"title":"js 和css如何影响DOM数构建","slug":"js-和css如何影响DOM数构建","date":"2022-04-22T16:00:11.000Z","updated":"2022-04-22T16:02:05.926Z","comments":true,"path":"2022/04/23/js-和css如何影响DOM数构建/","link":"","permalink":"https://coloey.github.io/2022/04/23/js-%E5%92%8Ccss%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8DDOM%E6%95%B0%E6%9E%84%E5%BB%BA/","excerpt":"","text":"先做个总结，然后再进行具体的分析： CSS不会阻塞DOM的解析，但是会影响JAVAScript的运行，javaSscript会阻止DOM树的解析，最终css（CSSOM）会影响DOM树的渲染，也可以说最终会影响渲染树的生成。 接下来我们先看javascript对DOM树构建和渲染是如何造成影响的，分成三种类型来讲解： JavaScript脚本在html页面中123456789101&lt;html&gt;2 &lt;body&gt;3 &lt;div&gt;1&lt;/div&gt;4 &lt;script&gt;5 let div1 = document.getElementsByTagName(&#x27;div&#x27;)[0]6 div1.innerText = &#x27;time.geekbang&#x27;7 &lt;/script&gt;8 &lt;div&gt;test&lt;/div&gt;9 &lt;/body&gt;10&lt;/html&gt; 两段div中间插入一段JavaScript脚本，这段脚本的解析过程就有点不一样了。 当解析到script脚本标签时，HTML解析器暂停工作，javascript引擎介入，并执行script标签中的这段脚本。 因为这段javascript脚本修改了DOM中第一个div中的内容，所以执行这段脚本之后，div节点内容已经修改为time.geekbang了。脚本执行完成之后，HTML解析器回复解析过程，继续解析后续的内容，直至生成最终的DOM。 html页面中引入javaScript文件123456789101//foo.js2let div1 = document.getElementsByTagName(&#x27;div&#x27;)[0]3div1.innerText = &#x27;time.geekbang&#x27;1&lt;html&gt;2 &lt;body&gt;3 &lt;div&gt;1&lt;/div&gt;4 &lt;script type=&quot;text/javascript&quot; src=&#x27;foo.js&#x27;&gt;&lt;/script&gt;5 &lt;div&gt;test&lt;/div&gt;6 &lt;/body&gt;7&lt;/html&gt; 这段代码的功能还是和前面那段代码是一样的，只是把内嵌JavaScript脚本修改成了通过javaScript文件加载。 其整个执行流程还是一样的，执行到JAVAScript标签时，暂停整个DOM的解析，执行javascript代码，不过这里执行javascript时，需要现在在这段代码。这里需要重点关注下载环境，因为javascript文件的下载过程会阻塞DOM解析，而通常下载又是非常耗时的，会受到网络环境、javascript文件大小等因素的影响。 优化机制： 谷歌浏览器做了很多优化，其中一个主要的优化就是预解析操作。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析HTML文件中包含的JavaScript、CSS等相关文件，解析到相关文件之后，会开启一个预解析线程，用来分析HTML文件中包含的javascprit、css等相关文件、解析到相关文件之后，预解析线程会提前下载这些文件。 再回到 DOM 解析上，我们知道引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。 另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码，使用方式如下所示： 12&lt;script async type=&quot;text/javascript&quot; src=&#x27;foo.js&#x27;&gt;&lt;/script&gt;&lt;script defer type=&quot;text/javascript&quot; src=&#x27;foo.js&#x27;&gt;&lt;/script&gt; async和defer区别： async：脚本并行加载，加载完成之后立即执行，执行时机不确定，仍有可能阻塞HTML解析，执行时机在load事件派发之前。 defer：脚本并行加载，等待HTML解析完成之后，按照加载顺序执行脚本，执行时机DOMContentLoaded事件派发之前。 html页面中有css样式123456789101112131415161//theme.css2div &#123;color:blue&#125;1&lt;html&gt;2&lt;head&gt;3 &lt;style src=&#x27;theme.css&#x27;&gt;&lt;/style&gt;4&lt;/head&gt;5&lt;body&gt;6 &lt;div&gt;1&lt;/div&gt;7 &lt;script&gt;8 let div1 = document.getElementsByTagName(&#x27;div&#x27;)[0]9 div1.innerText = &#x27;time.geekbang&#x27; // 需要 DOM10 div1.style.color = &#x27;red&#x27; // 需要 CSSOM11 &lt;/script&gt;12 &lt;div&gt;test&lt;/div&gt;13&lt;/body&gt;14&lt;/html&gt; 该示例中，JavaScript 代码出现了 div1.style.color = ‘red’ 的语句，它是用来操纵 CSSOM 的，所以在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。 而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行CSS 文件下载，解析操作，再执行 JavaScript 脚本。所以说 JavaScript 脚本是依赖样式表的，这又多了一个阻塞过程。 总结：通过上面三点的分析，我们知道了 JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞js的执行。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"}],"tags":[]},{"title":"数组的常用方法","slug":"数组的常用方法","date":"2022-04-22T15:40:09.000Z","updated":"2022-04-22T15:42:13.610Z","comments":true,"path":"2022/04/22/数组的常用方法/","link":"","permalink":"https://coloey.github.io/2022/04/22/%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"一、操作方法数组基本操作可以归纳为 增、删、改、查，需要留意的是哪些方法会对原数组产生影响，哪些方法不会 下面对数组常用的操作方法做一个归纳 增下面前三种是对原数组产生影响的增添方法，第四种则不会对原数组产生影响 push() unshift() splice() concat() push()push()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度 1231let colors = []; // 创建一个数组2let count = colors.push(&quot;red&quot;, &quot;green&quot;); // 推入两项3console.log(count) // 2 unshift()unshift()在数组开头添加任意多个值，然后返回新的数组长度 1231let colors = new Array(); // 创建一个数组2let count = colors.unshift(&quot;red&quot;, &quot;green&quot;); // 从数组开头推入两项3alert(count); // 2 splice传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组 12341let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];2let removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;)3console.log(colors) // red,yellow,orange,green,blue4console.log(removed) // [] concat()首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组 12341let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];2let colors2 = colors.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]);3console.log(colors); // [&quot;red&quot;, &quot;green&quot;,&quot;blue&quot;]4console.log(colors2); // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;] 删下面三种都会影响原数组，最后一项不影响原数组： pop() shift() splice() slice() pop()pop() 方法用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项 12341let colors = [&quot;red&quot;, &quot;green&quot;]2let item = colors.pop(); // 取得最后一项3console.log(item) // green4console.log(colors.length) // 1 shift()shift()方法用于删除数组的第一项，同时减少数组的 length 值，返回被删除的项 12341let colors = [&quot;red&quot;, &quot;green&quot;]2let item = colors.shift(); // 取得第一项3console.log(item) // red4console.log(colors.length) // 1 splice()传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组 12341let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];2let removed = colors.splice(0,1); // 删除第一项3console.log(colors); // green,blue4console.log(removed); // red，只有一个元素的数组 slice()slice() 用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组 1234561let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];2let colors2 = colors.slice(1);3let colors3 = colors.slice(1, 4);4console.log(colors) // red,green,blue,yellow,purple5concole.log(colors2); // green,blue,yellow,purple6concole.log(colors3); // green,blue,yellow 改即修改原来数组的内容，常用splice splice()传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响 12341let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];2let removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); // 插入两个值，删除一个元素3console.log(colors); // red,red,purple,blue4console.log(removed); // green，只有一个元素的数组 查即查找元素，返回元素坐标或者元素值 indexOf() includes() find() indexOf()返回要查找的元素在数组中的位置，如果没找到则返回-1 121let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];2numbers.indexOf(4) // 3 includes()返回要查找的元素在数组中的位置，找到返回true，否则false 121let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];2numbers.includes(4) // true find()返回第一个匹配的元素 12345678910111const people = [2 &#123;3 name: &quot;Matt&quot;,4 age: 275 &#125;,6 &#123;7 name: &quot;Nicholas&quot;,8 age: 299 &#125;10];11people.find((element, index, array) =&gt; element.age &lt; 28) // // &#123;name: &quot;Matt&quot;, age: 27&#125; 二、排序方法数组有两个方法可以用来对元素重新排序： reverse() sort() reverse()顾名思义，将数组元素方向排列 1231let values = [1, 2, 3, 4, 5];2values.reverse();3alert(values); // 5,4,3,2,1 sort()sort()方法接受一个比较函数，用于判断哪个值应该排在前面 1234567891011121function compare(value1, value2) &#123;2 if (value1 &lt; value2) &#123;3 return -1;4 &#125; else if (value1 &gt; value2) &#123;5 return 1;6 &#125; else &#123;7 return 0;8 &#125;9&#125;10let values = [0, 1, 5, 10, 15];11values.sort(compare);12alert(values); // 0,1,5,10,15 三、转换方法常见的转换方法有： join()join() 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串 1231let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];2alert(colors.join(&quot;,&quot;)); // red,green,blue3alert(colors.join(&quot;||&quot;)); // red||green||blue 四、迭代方法常用来迭代数组的方法（都不改变原数组）有如下： some() every() forEach() filter() map() some()对数组每一项都运行传入的函数，如果有一项函数返回 true ，则这个方法返回 true 1231let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];2let someResult = numbers.every((item, index, array) =&gt; item &gt; 2);3console.log(someResult) // true every()对数组每一项都运行传入的函数，如果对每一项函数都返回 true ，则这个方法返回 true 1231let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];2let everyResult = numbers.every((item, index, array) =&gt; item &gt; 2);3console.log(everyResult) // false forEach()对数组每一项都运行传入的函数，没有返回值 12341let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];2numbers.forEach((item, index, array) =&gt; &#123;3 // 执行某些操作4&#125;); filter()对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回 1231let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];2let filterResult = numbers.filter((item, index, array) =&gt; item &gt; 2);3console.log(filterResult); // 3,4,5,4,3 map()对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组 123复制1let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];2let mapResult = numbers.map((item, index, array) =&gt; item * 2);3console.log(mapResult) // 2,4,6,8,10,8,6,4,2","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"实现两栏，三栏布局等","slug":"实现两栏，三栏布局等","date":"2022-04-20T14:38:41.000Z","updated":"2022-04-23T03:08:38.964Z","comments":true,"path":"2022/04/20/实现两栏，三栏布局等/","link":"","permalink":"https://coloey.github.io/2022/04/20/%E5%AE%9E%E7%8E%B0%E4%B8%A4%E6%A0%8F%EF%BC%8C%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E7%AD%89/","excerpt":"","text":"两栏布局实现思路也非常的简单： 使用 float 左浮左边栏 右边模块使用 margin-left 撑出内容块做内容展示 为父级元素添加BFC，防止下方元素飞到上方内容 12345678910111213141516171819202122232425262728&lt;style&gt; body &#123; /* 设置最小宽度，防止挤压使中间内容消失 */ min-width: 600px; &#125; .box &#123; /* 添加BFC */ overflow: hidden; &#125; .left &#123; float: left; width: 200px; height: 400px; background-color: gray; &#125; .right &#123; margin-left:210px; background-color: red; height: 200px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;left&quot;&gt;左&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; flex弹性布局1234567891011121314151&lt;style&gt;2 .box&#123;3 display: flex;4 &#125;5 .left &#123;6 width: 100px;7 &#125;8 .right &#123;9 flex: 1;10 &#125;11&lt;/style&gt;12&lt;div class=&quot;box&quot;&gt;13 &lt;div class=&quot;left&quot;&gt;左边&lt;/div&gt;14 &lt;div class=&quot;right&quot;&gt;右边&lt;/div&gt;15&lt;/div&gt; flex可以说是最好的方案了，代码少，使用简单 注意的是，flex容器的一个默认属性值:align-items: stretch; 这个属性导致了列等高的效果。 为了让两个盒子高度自动，需要设置: align-items: flex-start 三栏布局实现三栏布局中间自适应的布局方式有： 两边使用 float，中间使用 margin 两边使用 absolute，中间使用 margin 两边使用 float 和负 margin display: table 实现 flex实现 grid网格布局 两边使用 float，中间使用 margin需要将中间的内容放在html结构最后，否则右侧会呈在中间内容的下方 实现代码如下： 123456789101112131415161718192021222324252627282930311&lt;style&gt;2 .wrap &#123;3 background: #eee;4 overflow: hidden; &lt;!-- 生成BFC，计算高度时考虑浮动的元素 --&gt;5 padding: 20px;6 height: 200px;7 &#125;8 .left &#123;9 width: 200px;10 height: 200px;11 float: left;12 background: coral;13 &#125;14 .right &#123;15 width: 120px;16 height: 200px;17 float: right;18 background: lightblue;19 &#125;20 .middle &#123;21 margin-left: 220px;22 height: 200px;23 background: lightpink;24 margin-right: 140px;25 &#125;26&lt;/style&gt;27&lt;div class=&quot;wrap&quot;&gt;28 &lt;div class=&quot;left&quot;&gt;左侧&lt;/div&gt;29 &lt;div class=&quot;right&quot;&gt;右侧&lt;/div&gt;30 &lt;div class=&quot;middle&quot;&gt;中间&lt;/div&gt;31&lt;/div&gt; 原理如下： 两边固定宽度，中间宽度自适应。 利用中间元素的margin值控制两边的间距 宽度小于左右部分宽度之和时，右侧部分会被挤下去 这种实现方式存在缺陷： 主体内容是最后加载的。 右边在主体内容之前，如果是响应式设计，不能简单的换行展示 两边使用 absolute，中间使用 margin基于绝对定位的三栏布局：注意绝对定位的元素脱离文档流，相对于最近的已经定位的祖先元素进行定位。无需考虑HTML中结构的顺序 12345678910111213141516171819202122232425262728293031323334353637383940411&lt;style&gt;2 .container &#123;3 position: relative;4 &#125;5 6 .left,7 .right,8 .main &#123;9 height: 200px;10 line-height: 200px;11 text-align: center;12 &#125;1314 .left &#123;15 position: absolute;16 top: 0;17 left: 0;18 width: 100px;19 background: green;20 &#125;2122 .right &#123;23 position: absolute;24 top: 0;25 right: 0;26 width: 100px;27 background: green;28 &#125;2930 .main &#123;31 margin: 0 110px;32 background: black;33 color: white;34 &#125;35&lt;/style&gt;3637&lt;div class=&quot;container&quot;&gt;38 &lt;div class=&quot;left&quot;&gt;左边固定宽度&lt;/div&gt;39 &lt;div class=&quot;right&quot;&gt;右边固定宽度&lt;/div&gt;40 &lt;div class=&quot;main&quot;&gt;中间自适应&lt;/div&gt;41&lt;/div&gt; 两边使用 float 和负 margin12345678910111213141516171819202122232425262728293031323334353637381&lt;style&gt;2 .left,3 .right,4 .main &#123;5 height: 200px;6 line-height: 200px;7 text-align: center;8 &#125;910 .main-wrapper &#123;11 float: left;12 width: 100%;13 &#125;1415 .main &#123;16 margin: 0 110px;17 background: black;18 color: white;19 &#125;2021 .left,22 .right &#123;23 float: left;24 width: 100px;25 margin-left: -100%;26 background: green;27 &#125;2829 .right &#123;30 margin-left: -100px; /* 同自身宽度 */31 &#125;32&lt;/style&gt;3334&lt;div class=&quot;main-wrapper&quot;&gt;35 &lt;div class=&quot;main&quot;&gt;中间自适应&lt;/div&gt;36&lt;/div&gt;37&lt;div class=&quot;left&quot;&gt;左边固定宽度&lt;/div&gt;38&lt;div class=&quot;right&quot;&gt;右边固定宽度&lt;/div&gt; 实现过程： 中间使用了双层标签，外层是浮动的，以便左中右能在同一行展示 左边通过使用负 margin-left:-100%，相当于中间的宽度，所以向上偏移到左侧 右边通过使用负 margin-left:-100px，相当于自身宽度，所以向上偏移到最右侧,相对于最左边偏移自身的宽度，因此到最右侧 缺点： 增加了 .main-wrapper 一层，结构变复杂 使用负 margin，调试也相对麻烦 使用 display: table 实现 标签用于展示行列数据，不适合用于布局。但是可以使用 display: table 来实现布局的效果 123456789101112131415161718192021222324252627282930313233341&lt;style&gt;2 .container &#123;3 height: 200px;4 line-height: 200px;5 text-align: center;6 display: table;7 table-layout: fixed;8 width: 100%;9 &#125;1011 .left,12 .right,13 .main &#123;14 display: table-cell;15 &#125;1617 .left,18 .right &#123;19 width: 100px;20 background: green;21 &#125;2223 .main &#123;24 background: black;25 color: white;26 width: 100%;27 &#125;28&lt;/style&gt;2930&lt;div class=&quot;container&quot;&gt;31 &lt;div class=&quot;left&quot;&gt;左边固定宽度&lt;/div&gt;32 &lt;div class=&quot;main&quot;&gt;中间自适应&lt;/div&gt;33 &lt;div class=&quot;right&quot;&gt;右边固定宽度&lt;/div&gt;34&lt;/div&gt; 实现原理： 层通过 display: table设置为表格，设置 table-layout: fixed`表示列宽自身宽度决定，而不是自动计算。 内层的左中右通过 display: table-cell设置为表格单元。 左右设置固定宽度，中间设置 width: 100% 填充剩下的宽度 使用flex实现利用flex弹性布局，可以简单实现中间自适应 代码如下： 12345678910111213141516171819202122232425262728293031style&gt; .main &#123; display: flex; height: 200px; justify-content: space-between; line-height: 200px; text-align: center; &#125; .left &#123; flex:1; background-color: green; &#125; .right &#123; flex:1; background-color: green; &#125; .middle &#123; flex:5; background-color: black; color:white; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;left&quot;&gt;左边固定宽度&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;中间自适应&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右边固定宽度&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 实现过程： 仅需将容器设置为display:flex;， 盒内元素两端对其，将中间元素设置为100%宽度，或者设为flex:1，即可填充空白 盒内元素的高度撑开容器的高度 优点： 结构简单直观 可以结合 flex的其他功能实现更多效果，例如使用 order属性调整显示顺序，让主体内容优先加载，但展示在中间 grid网格布局代码如下： 12345678910111213141516171819202122232425262728293031复制1&lt;style&gt;2 .wrap &#123;3 display: grid;4 width: 100%;5 grid-template-columns: 300px auto 300px;6 &#125;78 .left,9 .right,10 .middle &#123;11 height: 100px;12 &#125;1314 .left &#123;15 background: coral;16 &#125;1718 .right &#123;19 width: 300px;20 background: lightblue;21 &#125;2223 .middle &#123;24 background: #555;25 &#125;26&lt;/style&gt;27&lt;div class=&quot;wrap&quot;&gt;28 &lt;div class=&quot;left&quot;&gt;左侧&lt;/div&gt;29 &lt;div class=&quot;middle&quot;&gt;中间&lt;/div&gt;30 &lt;div class=&quot;right&quot;&gt;右侧&lt;/div&gt;31&lt;/div&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"wepack proxy的原理","slug":"wepack-proxy的原理","date":"2022-04-20T14:22:14.000Z","updated":"2022-05-02T15:50:18.997Z","comments":true,"path":"2022/04/20/wepack-proxy的原理/","link":"","permalink":"https://coloey.github.io/2022/04/20/wepack-proxy%E7%9A%84%E5%8E%9F%E7%90%86/","excerpt":"","text":"一、是什么webpack proxy，即webpack提供的代理服务 基本行为就是接收客户端发送的请求后转发给其他服务器 其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制） 想要实现代理首先需要一个中间服务器，webpack中提供服务器的工具为webpack-dev-server webpack-dev-serverwebpack-dev-server是 webpack 官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起 目的是为了提高开发者日常的开发效率，只适用在开发阶段 关于配置方面，在webpack配置对象属性中通过devServer属性提供，如下： 12345678910111213141516171// ./webpack.config.js2const path = require(&#x27;path&#x27;)34module.exports = &#123;5 // ...6 devServer: &#123;7 contentBase: path.join(__dirname, &#x27;dist&#x27;),8 compress: true,9 port: 9000,10 proxy: &#123;11 &#x27;/api&#x27;: &#123;12 target: &#x27;https://api.github.com&#x27;13 &#125;14 &#125;15 // ...16 &#125;17&#125; devServetr里面proxy则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配 属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为 /api，值为对应的代理匹配规则，对应如下： target：表示的是代理到的目标地址 pathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除，可以使用pathRewrite secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false changeOrigin：它表示是否更新代理后请求的 headers 中host地址 二、工作原理proxy工作原理实质上是利用http-proxy-middleware 这个http代理中间件，实现请求转发给其他服务器 举个例子： 在开发阶段，本地地址为http://localhost:3000，该浏览器发送一个前缀带有/api标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中 1234567891const express = require(&#x27;express&#x27;);2const proxy = require(&#x27;http-proxy-middleware&#x27;);34const app = express();56app.use(&#x27;/api&#x27;, proxy(&#123;target: &#x27;http://www.example.org&#x27;, changeOrigin: true&#125;));7app.listen(3000);89// http://localhost:3000/api/foo/bar -&gt; http://www.example.org/api/foo/bar 三、跨域在开发阶段， webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上 所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题 通过设置webpack proxy实现代理请求后，相当于浏览器与服务端中添加一个代理者 当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地 在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据 注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"前端工程化/webpack","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack/"}],"tags":[]},{"title":"Object.defineProperty和Proxy区别","slug":"Object-defineProperty和Proxy区别","date":"2022-04-20T06:17:15.000Z","updated":"2022-04-20T13:07:36.341Z","comments":true,"path":"2022/04/20/Object-defineProperty和Proxy区别/","link":"","permalink":"https://coloey.github.io/2022/04/20/Object-defineProperty%E5%92%8CProxy%E5%8C%BA%E5%88%AB/","excerpt":"","text":"一、Object.defineProperty定义：Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象 为什么能实现响应式通过defineProperty 两个属性，get及set get 属性的 getter 函数，当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值 set 属性的 setter 函数，当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined 下面通过代码展示： 定义一个响应式函数defineReactive 1234567891011121314151617181function update() &#123;2 app.innerText = obj.foo3&#125;45function defineReactive(obj, key, val) &#123;6 Object.defineProperty(obj, key, &#123;7 get() &#123;8 console.log(`get $&#123;key&#125;:$&#123;val&#125;`);9 return val10 &#125;,11 set(newVal) &#123;12 if (newVal !== val) &#123;13 val = newVal14 update()15 &#125;16 &#125;17 &#125;)18&#125; 调用defineReactive，数据发生变化触发update方法，实现数据响应式 123451const obj = &#123;&#125;2defineReactive(obj, &#x27;foo&#x27;, &#x27;&#x27;)3setTimeout(()=&gt;&#123;4 obj.foo = new Date().toLocaleTimeString()5&#125;,1000) 在对象存在多个key情况下，需要进行遍历 123456781function observe(obj) &#123;2 if (typeof obj !== &#x27;object&#x27; || obj == null) &#123;3 return4 &#125;5 Object.keys(obj).forEach(key =&gt; &#123;6 defineReactive(obj, key, obj[key])7 &#125;)8&#125; 如果存在嵌套对象的情况，还需要在defineReactive中进行递归 1234567891011121314151function defineReactive(obj, key, val) &#123;2 observe(val)3 Object.defineProperty(obj, key, &#123;4 get() &#123;5 console.log(`get $&#123;key&#125;:$&#123;val&#125;`);6 return val7 &#125;,8 set(newVal) &#123;9 if (newVal !== val) &#123;10 val = newVal11 update()12 &#125;13 &#125;14 &#125;)15&#125; 当给key赋值为对象的时候，还需要在set属性中进行递归 1234561set(newVal) &#123;2 if (newVal !== val) &#123;3 observe(newVal) // 新值是对象的情况4 notifyUpdate()5 &#125;6&#125; 上述例子能够实现对一个对象的基本响应式，但仍然存在诸多问题 现在对一个对象进行删除与添加属性操作，无法劫持到 12345671const obj = &#123;2 foo: &quot;foo&quot;,3 bar: &quot;bar&quot;4&#125;5observe(obj)6delete obj.foo // no ok7obj.jar = &#x27;xxx&#x27; // no ok 当我们对一个数组进行监听的时候，并不那么好使了 12345671const arrData = [1,2,3,4,5];2arrData.forEach((val,index)=&gt;&#123;3 defineProperty(arrData,index,val)4&#125;)5arrData.push() // no ok6arrData.pop() // no ok7arrDate[0] = 99 // ok 可以看到数据的api无法劫持到，从而无法实现数据响应式， 所以在Vue2中，增加了set、delete API，并且对数组api方法进行一个重写 还有一个问题则是，如果存在深层的嵌套对象关系，需要深层的进行监听，造成了性能的极大问题 小结 检测不到对象属性的添加和删除 数组API方法无法监听到 需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题 二、proxyProxy的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了 在ES6系列中，我们详细讲解过Proxy的使用，就不再述说了 下面通过代码进行展示： 定义一个响应式方法reactive 1234567891011121314151617181920212223241 function reactive(obj) &#123;2 if (typeof obj !== &#x27;object&#x27; &amp;&amp; obj != null) &#123;3 return obj4 &#125;5 // Proxy相当于在对象外层加拦截6 const observed = new Proxy(obj, &#123;7 get(target, key, receiver) &#123;8 const res = Reflect.get(target, key, receiver)9 console.log(`获取$&#123;key&#125;:$&#123;res&#125;`)10 return res11 &#125;,12 set(target, key, value, receiver) &#123;13 const res = Reflect.set(target, key, value, receiver)14 console.log(`设置$&#123;key&#125;:$&#123;value&#125;`)15 return res16 &#125;,17 deleteProperty(target, key) &#123;18 const res = Reflect.deleteProperty(target, key)19 console.log(`删除$&#123;key&#125;:$&#123;res&#125;`)20 return res21 &#125;22 &#125;)23 return observed24&#125; 测试一下简单数据的操作，发现都能劫持 12345678910111const state = reactive(&#123;2 foo: &#x27;foo&#x27;3&#125;)4// 1.获取5state.foo // ok6// 2.设置已存在属性7state.foo = &#x27;fooooooo&#x27; // ok8// 3.设置不存在属性9state.dong = &#x27;dong&#x27; // ok10// 4.删除属性11delete state.dong // ok 再测试嵌套对象情况，这时候发现就不那么 OK 了 1234561 const state = reactive(&#123;2 bar: &#123; a: 1 &#125;3&#125;)45// 设置嵌套对象属性6 state.bar.a = 10 // no ok 如果要解决，需要在get之上再进行一层代理 123456789101112131function reactive(obj) &#123;2 if (typeof obj !== &#x27;object&#x27; &amp;&amp; obj != null) &#123;3 return obj4 &#125;5 // Proxy相当于在对象外层加拦截6 const observed = new Proxy(obj, &#123;7 get(target, key, receiver) &#123;8 const res = Reflect.get(target, key, receiver)9 console.log(`获取$&#123;key&#125;:$&#123;res&#125;`)10 return isObject(res) ? reactive(res) : res11 &#125;,12 return observed13&#125; 三、总结Object.defineProperty只能遍历对象属性进行劫持 123456781function observe(obj) &#123;2 if (typeof obj !== &#x27;object&#x27; || obj == null) &#123;3 return4 &#125;5 Object.keys(obj).forEach(key =&gt; &#123;6 defineReactive(obj, key, obj[key])7 &#125;)8&#125; Proxy直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的 1234567891011121314151617181920212223241function reactive(obj) &#123;2 if (typeof obj !== &#x27;object&#x27; &amp;&amp; obj != null) &#123;3 return obj4 &#125;5 // Proxy相当于在对象外层加拦截6 const observed = new Proxy(obj, &#123;7 get(target, key, receiver) &#123;8 const res = Reflect.get(target, key, receiver)9 console.log(`获取$&#123;key&#125;:$&#123;res&#125;`)10 return res11 &#125;,12 set(target, key, value, receiver) &#123;13 const res = Reflect.set(target, key, value, receiver)14 console.log(`设置$&#123;key&#125;:$&#123;value&#125;`)15 return res16 &#125;,17 deleteProperty(target, key) &#123;18 const res = Reflect.deleteProperty(target, key)19 console.log(`删除$&#123;key&#125;:$&#123;res&#125;`)20 return res21 &#125;22 &#125;)23 return observed24&#125; Proxy可以直接监听数组的变化（push、shift、splice） 1231const obj = [1,2,3]2const proxtObj = reactive(obj)3obj.psuh(4) // ok Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等，这是Object.defineProperty不具备的 正因为defineProperty自身的缺陷，导致Vue2在实现响应式过程需要实现其他的方法辅助（如重写数组方法、增加额外set、delete方法） 123456789101112131// 数组重写2const originalProto = Array.prototype3const arrayProto = Object.create(originalProto)4[&#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;splice&#x27;, &#x27;reverse&#x27;, &#x27;sort&#x27;].forEach(method =&gt; &#123;5 arrayProto[method] = function () &#123;6 originalProto[method].apply(this.arguments)7 dep.notice()8 &#125;9&#125;);1011// set、delete12Vue.set(obj,&#x27;bar&#x27;,&#x27;newbar&#x27;)13Vue.delete(obj),&#x27;bar&#x27;) Proxy 不兼容IE，也没有 polyfill, defineProperty 能支持到IE9 使用场景 拦截和监视外部对对象的访问 降低函数或类的复杂度 在复杂操作前对操作进行校验或对所需资源进行管理 保障数据类型的准确性 1234567891011let numericDataStore=&#123;count:0,amount:1234,total:14&#125;numericDataStore=new Proxy(numericDataStore,&#123; set(target,key,value,proxy)&#123; if(typeof value!=&#x27;number&#x27;)&#123; throw Error(&quot;属性只能是Number类型&quot;) &#125; return Reflect.set(target,key,value,proxy) &#125;&#125;);numericDataStore.count=&quot;foo&quot;numericDataStore.count=33; 实现观察者模式 123456789//观察者模式，观察者函数都放在Set集合，当修改obj的值，会在set函数中拦截，自动执行Set所有的观察者const queueObservers=new Set();const observe=fn=&gt;queueObservers.add(fn)//将观察者函数加入队列const observable=obj=&gt;new Proxy(obj,&#123;set&#125;);//返回一个原始对象的Proxy代理，拦截赋值操作，触发充当观察者的每个函数function set(target,key,value,receiver)&#123; const res=Reflect.set(target,key,value,receiver); queueObservers.forEach(observer=&gt;observer());//触发充当观察者的每个函数 return res;&#125; 声明一个私有的apiKey,便于api这个对象内部的方法调用，但不希望外部也能够访问api._apiKey 1234567891011121314151617181920let api=&#123; _apiKey:&#x27;123456def&#x27;&#125;const RESTRICTED=[&#x27;_apiKey&#x27;]api=new Proxy(api,&#123; get(target,key,proxy)&#123; if(RESTRICTED.indexOf(key)&gt;-1)&#123; throw Error(`$&#123;key&#125;不可访问`) &#125; return Reflect.get(target,key,proxy) &#125;, set(target,key,value,proxy)&#123; if(RESTRICTED.indexOf(key)&gt;-1)&#123; throw Error(`$&#123;key&#125;不可修改`) &#125; return Reflect.set(target,key,value,proxy) &#125;&#125;)console.log(api._apiKey);api._apiKey=&#x27;12345&#x27;;//上述都抛出错误","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"Proxy","slug":"Proxy","date":"2022-04-20T00:25:25.000Z","updated":"2022-04-30T14:30:29.359Z","comments":true,"path":"2022/04/20/Proxy/","link":"","permalink":"https://coloey.github.io/2022/04/20/Proxy/","excerpt":"","text":"代理就是一种由你创建的特殊对象，它“封装”另一个普通对象，或者说挡在这个普通对象前面，你可以在代理对象上注册特殊的处理函数（trap),代理上执行各种操作的时候会调用这个程序 123456789101112var obj=&#123;a:1&#125;, handles=&#123; get(target,key,context)&#123; //target==obj,context==pobj,key为属性名 console.log(&quot;accessing&quot;,key); return Reflect.get(target,key,context) &#125; &#125;pobj=new Proxy(obj,handlers);obj.a;//1pobj.a;//acessing:a//1 这里的映射是有意对称的，每个代理处理函数在对应的元编程任务执行的时候进行拦截，而每个Reflefct工具在一个对象上执行相应的元编程任务，每个代理函数都有一个自动调用相应的Reflect工具的默认定义。 一、介绍定义： 用于定义基本操作的自定义行为 本质： 修改的是程序默认形为，就形同于在编程语言层面上做修改，属于元编程(meta programming) 元编程（Metaprogramming，又译超编程，是指某类计算机程序的编写，这类计算机程序编写或者操纵其它程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作 一段代码来理解 12345671#!/bin/bash2# metaprogram3echo &#x27;#!/bin/bash&#x27; &gt;program4for ((I=1; I&lt;=1024; I++)) do5 echo &quot;echo $I&quot; &gt;&gt;program6done7chmod +x program 这段程序每执行一次能帮我们生成一个名为program的文件，文件内容为1024行echo，如果我们手动来写1024行代码，效率显然低效 元编程优点：与手工编写全部代码相比，程序员可以获得更高的工作效率，或者给与程序更大的灵活度去处理新的情形而无需重新编译 Proxy 亦是如此，用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等） 二、用法Proxy为 构造函数，用来生成 Proxy 实例 11var proxy = new Proxy(target, handler) 参数target表示所要拦截的目标对象（任何类型的对象，包括原生数组，函数，甚至另一个代理）） handler通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为 handler解析关于handler拦截属性，有如下： get(target,propKey,receiver)：拦截对象属性的读取 set(target,propKey,value,receiver)：拦截对象属性的设置 has(target,propKey)：拦截propKey in proxy的操作，返回一个布尔值 deleteProperty(target,propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值 ownKeys(target)：拦截Object.keys(proxy)、for...in等循环，返回一个数组 getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象 defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc），返回一个布尔值 preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值 getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象 isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值 setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值 apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作 construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作 Reflect若需要在Proxy内部调用对象的默认行为，建议使用Reflect，其是ES6中操作对象而提供的新 API 基本特点： 只要Proxy对象具有的代理方法，Reflect对象全部具有，以静态方法的形式存在 修改某些Object方法的返回结果，让其变得更合理（定义不存在属性行为的时候不报错而是返回false） 让Object操作都变成函数行为 下面我们介绍proxy几种用法： get()get接受三个参数，依次为目标对象、属性名和 proxy 实例本身，最后一个参数可选 12345678910111var person = &#123;2 name: &quot;张三&quot;3&#125;;45var proxy = new Proxy(person, &#123;6 get: function(target, propKey) &#123;7 return Reflect.get(target,propKey)8 &#125;9&#125;);1011proxy.name // &quot;张三&quot; get能够对数组增删改查进行拦截，下面是试下你数组读取负数的索引 1234567891011121314151617181function createArray(...elements) &#123;2 let handler = &#123;3 get(target, propKey, receiver) &#123;4 let index = Number(propKey);5 if (index &lt; 0) &#123;6 propKey = String(target.length + index);7 &#125;8 return Reflect.get(target, propKey, receiver);9 &#125;10 &#125;;1112 let target = [];13 target.push(...elements);14 return new Proxy(target, handler);15&#125;1617let arr = createArray(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;);18arr[-1] // c 注意：如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则会报错 1234567891011121314151617181const target = Object.defineProperties(&#123;&#125;, &#123;2 foo: &#123;3 value: 123,4 writable: false,5 configurable: false6 &#125;,7&#125;);89const handler = &#123;10 get(target, propKey) &#123;11 return &#x27;abc&#x27;;12 &#125;13&#125;;1415const proxy = new Proxy(target, handler);1617proxy.foo18// TypeError: Invariant check failed set()set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身 假定Person对象有一个age属性，该属性应该是一个不大于 200 的整数，那么可以使用Proxy保证age的属性值符合要求 12345678910111213141516171819202122231let validator = &#123;2 set: function(obj, prop, value) &#123;3 if (prop === &#x27;age&#x27;) &#123;4 if (!Number.isInteger(value)) &#123;5 throw new TypeError(&#x27;The age is not an integer&#x27;);6 &#125;7 if (value &gt; 200) &#123;8 throw new RangeError(&#x27;The age seems invalid&#x27;);9 &#125;10 &#125;1112 // 对于满足条件的 age 属性以及其他属性，直接保存13 obj[prop] = value;14 &#125;15&#125;;1617let person = new Proxy(&#123;&#125;, validator);1819person.age = 100;2021person.age // 10022person.age = &#x27;young&#x27; // 报错23person.age = 300 // 报错 如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用 1234567891011121314151const obj = &#123;&#125;;2Object.defineProperty(obj, &#x27;foo&#x27;, &#123;3 value: &#x27;bar&#x27;,4 writable: false,5&#125;);67const handler = &#123;8 set: function(obj, prop, value, receiver) &#123;9 obj[prop] = &#x27;baz&#x27;;10 &#125;11&#125;;1213const proxy = new Proxy(obj, handler);14proxy.foo = &#x27;baz&#x27;;15proxy.foo // &quot;bar&quot; 注意，严格模式下，set代理如果没有返回true，就会报错 12345678910111&#x27;use strict&#x27;;2const handler = &#123;3 set: function(obj, prop, value, receiver) &#123;4 obj[prop] = receiver;5 // 无论有没有下面这一行，都会报错6 return false;7 &#125;8&#125;;9const proxy = new Proxy(&#123;&#125;, handler);10proxy.foo = &#x27;bar&#x27;;11// TypeError: &#x27;set&#x27; on proxy: trap returned falsish for property &#x27;foo&#x27; deleteProperty()deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除 12345678910111213141516171var handler = &#123;2 deleteProperty (target, key) &#123;3 invariant(key, &#x27;delete&#x27;);4 Reflect.deleteProperty(target,key)5 return true;6 &#125;7&#125;;8function invariant (key, action) &#123;9 if (key[0] === &#x27;_&#x27;) &#123;10 throw new Error(`无法删除私有属性`);11 &#125;12&#125;1314var target = &#123; _prop: &#x27;foo&#x27; &#125;;15var proxy = new Proxy(target, handler);16delete proxy._prop17// Error: 无法删除私有属性 注意，目标对象自身的不可配置（configurable）的属性，不能被deleteProperty方法删除，否则报错 Reflect.apply()静态方法 **Reflect**.apply() 通过指定的参数列表发起对目标(target)函数的调用。 1Reflect.apply(target, thisArgument, argumentsList) 参数 target 目标函数。 thisArgument target函数调用时绑定的this对象。 argumentsList target函数调用时传入的实参列表，该参数应该是一个类数组的对象。 返回值返回值是调用完带着指定参数和 this 值的给定的函数后返回的结果。 可取消代理普通代理总是陷入到目标对象，并且在创建之后不能修改——只要还保持着对这个代理的引用，代理的机制就将维持下去，如果你想要的创建一个在你想要停止它作为代理时便可以被停止的代理，可以创建可取消代理。（revocable proxy) 1234567891011121314var obj=&#123;a:1&#125;,handlers=&#123; get(target,key,context)&#123; console.log(&#x27;accessing:&#x27;,key); return target[key]; &#125;&#125;;var p=Proxy.revocable(obj,handlers);//返回一个有两个属性proxy和revoke的对象const pobj=p.proxy;const prevoke=p.revoke;console.log(pobj.a);prevoke();//代理被取消后，任何对它的访问都会抛出错误pobj.a()//Uncaught TypeError: Cannot perform &#x27;get&#x27; on a proxy that has been revoked 可取消代理可能的应用场景:在应用中把代理分发到第三方，其中管理你的模型数据，而不是给出真实模型本身的引用。如果你的模型对象改变或被替换，就可以使分发出去的代理失效，这样第三方就可以知晓变化并请求更新到这个模型的引用。 使用代理：代理在前:代理与目标交流，首先与代理交互，通过与代理交互来增加某些特殊的规则，这些是message本身没有的。 123456789101112131415161718192021222324var messages=[],handlers=&#123; get(target,key)&#123; if(typeof target[key]==&#x27;string&#x27;)&#123; return target[key].replace(/[^w]/g,&quot;&quot;);//过滤标点符号 &#125; return target[key];//所有其他的传递下去 &#125;, set(target,key,val)&#123; //设定唯一字符串，改为小写 if(typeof val==&#x27;string&#x27;)&#123;//值为字符串，且是唯一值添加元素 if(target.indexOf(val)==-1)&#123; target.push(val.toLowerCase()); &#125; &#125; return true; &#125;&#125;var messages_proxy=new Proxy(messages,handlers);messages_proxy.push(&#x27;heLLo...&#x27;,42,&quot;wOrlD!!&quot;,&quot;WoRld!!&quot;);messages_proxy.forEach(val=&gt;&#123; console.log(val);&#125;)messages.forEach(v=&gt;console.log(v));//hello... world!! world!! 代理在后：让目标与代理交流，而不是代理与目标交流。代理只能与主对象交互，实现方式就是把proxy对象放到主对象的[[Prototype]]链中 123456789101112131415161718var handlers=&#123; get(target,key,context)&#123; return function()&#123; context.speak(key+&quot;!&quot;) &#125; &#125;&#125;,catchall=new Proxy(&#123;&#125;,handlers),greeter=&#123; speak(who=&quot;someone&quot;)&#123; console.log(&quot;hello&quot;,who) &#125;&#125;Object.setPrototypeOf(greeter,catchall);//将代理设置为目标对象的__proto___greeter.speak();greeter.speak(&quot;world&quot;);greeter.everyone();//检查[[Prototype]]链会查看catchall是否有everyone属性，然厚代理的get()处理函数介入并返回一个用访问的属性名(&quot;everyone&quot;)调用speak()函数 访问不存在的属性名抛出错误代理在前12345678910111213141516171819202122232425262728var obj=&#123; a:1, foo()&#123; console.log(&quot;a:&quot;,this.a) &#125;&#125;,handlers=&#123; get(target,key,context)&#123; if(Reflect.has(target,key))&#123; return Reflect.get(target,key,context) &#125; else&#123; throw Error(&quot;no such property/method&quot;) &#125; &#125;, set(target,key,val,context)&#123; if(Reflect.has(target,key))&#123; return Reflect.set(target,key,val,context) &#125;else&#123; throw Error(&quot;no such property/method&quot;) &#125; &#125;&#125;,pobj=new Proxy(obj,handlers)pobj.a=3;pobj.foo();pobj.b=4;//Uncaught Error: no such property/method 代理在后：1234567891011121314151617181920var handlers=&#123; get()&#123; throw &quot;no such property/method&quot; &#125;, set()&#123; throw &quot;no such property/method&quot; &#125;&#125;var pobj=new Proxy(&#123;&#125;,handlers);var obj=&#123; a:1, foo()&#123; console.log(&quot;a:&quot;,this.a) &#125;&#125;Object.setPrototypeOf(obj,pobj);obj.a=3;obj.foo();obj.b=4;//Uncaught Error: no such property/methodxxc 代理实现多个[[Prototype]]链接12345678910111213141516171819202122232425262728293031323334353637383940var obj1=&#123; name:&quot;obj-1&quot;, foo()&#123; console.log(&quot;obj1.foo&quot;,this.name) &#125;&#125;,obj2=&#123; name:&quot;obj-2&quot;, foo()&#123; console.log(&quot;obj2.foo&quot;,this.name) &#125;, bar()&#123; console.log(&quot;obj2.bar&quot;,this.name) &#125; &#125;,handlers=&#123; get(target,key,context)&#123; if(Reflect.has(target,key))&#123; return Reflect.get(target,key,context) &#125;else&#123; //伪装多个[[Prototype]] for(let p of target[Symbol.for(&quot;[[Prototype]]&quot;)])&#123; if(Reflect.has(p,key))&#123; return Reflect.get(p,key,context) &#125; &#125; &#125; &#125;&#125;,obj3=new Proxy(&#123; name:&quot;obj3&quot;, baz()&#123; this.foo(); this.bar() &#125;&#125;,handlers)//伪装多个[[Prototype]]的链接obj3[Symbol.for(&quot;[[Prototype]]&quot;)]=[obj1,obj2];obj3.baz();//obj1.foo:obj-3//obj2.var:obj-3","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"宽松相等和严格相等","slug":"宽松相等和严格相等","date":"2022-04-18T15:14:28.000Z","updated":"2022-04-18T16:12:57.633Z","comments":true,"path":"2022/04/18/宽松相等和严格相等/","link":"","permalink":"https://coloey.github.io/2022/04/18/%E5%AE%BD%E6%9D%BE%E7%9B%B8%E7%AD%89%E5%92%8C%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89/","excerpt":"","text":"区别：==允许在相等比较中做强制类型转换而===不允许 1234var a=42;var b=&quot;42&quot;;a===b;//false;a==b;//true ES5中定义： 如果Type(x)是数字，Type(y)是字符串，则返回x==ToNumber(y)的结果 如果Type(x)是字符串，Type(y)是数字，则返回ToNumber(x)==y的结果 其他类型和布尔类型之间的相等比较1234var a=&#x27;42&#x27;;var b=true;a==b;//false//ToNumber()将b转为1，变成&#x27;42&#x27;==1,又把&#x27;42&#x27;转为42就出现不相等 规范： 1.如果Type(x)是布尔类型，则返回ToNumber(x)==y的结果 2.如果Type(y)是布尔类型，则返回x==ToNumber(y)的结果 这个结果是错误的，因为’42‘本身是真值，要避免==true,==false 123456var a=&#x27;42&#x27;;//不要这样用，不成立if(a==true)if(a)if(!!a)if(Boolean(a)) null和undefined之间的相等比较规范： 如果x为null,y为undefined,则结果为true 如果x为undefined,y为null，则结果为true 因此判断a是否是null或者undefined时直接判断a==null即可 对象和非对象的相等比较规范： 如果Type(x)是字符串或者数字，Type(y)是对象，则返回x==ToPrimitive(y)的结果 如果Type(x)是对象，Type(y)是字符串或数字，则返回ToPrimitive(x)==y的结果 1234567891011121314151617var a=42;var b=[42];a==b;//true,变成42==&#x27;42&#x27;=&gt;42==42var a=&quot;abc&quot;;var b=Object(a);a===b;//falsea==b;//true,b通过ToPrimitive强制类型转换为&quot;abc&quot;//没有对应封装对象，null和undefined不能被封装，下面返回falsevar a==null;var b=Object(a);a==b;//falsevar a=undefined;var b=Object(a);a==b;//falsevar a=NAN;var b=Object(a);a==b;//false,因为NAN==NAN本身是false","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"运算符与类型转换","slug":"运算符与类型转换","date":"2022-04-18T13:46:10.000Z","updated":"2022-05-02T16:07:54.808Z","comments":true,"path":"2022/04/18/运算符与类型转换/","link":"","permalink":"https://coloey.github.io/2022/04/18/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"显示类型转换 显示转换，即我们很清楚可以看到这里发生了类型的转变，常见的方法有： Number() parseInt() String() Boolean() Number()将任意类型的值转化为数值 先给出类型转换规则： 12345678910111213141516171819202122232425Number(324) // 324// 字符串：如果可以被解析为数值，则转换为相应的数值Number(&#x27;324&#x27;) // 324// 字符串：如果不可以被解析为数值，返回 NaNNumber(&#x27;324abc&#x27;) // NaN// 空字符串转为0Number(&#x27;&#x27;) // 0// 布尔值：true 转成 1，false 转成 0Number(true) // 1Number(false) // 0// undefined：转成 NaNNumber(undefined) // NaN// null：转成0Number(null) // 0// 对象：通常转换成NaN(除了只包含单个数值的数组)Number(&#123;a: 1&#125;) // NaNNumber([1, 2, 3]) // NaNNumber([5]) // 5 从上面可以看到，Number转换的时候是很严格的，只要有一个字符无法转成数值，整个字符串就会被转为NaN parseInt()parseInt相比Number，就没那么严格了，parseInt函数逐个解析字符，遇到不能转换的字符就停下来 11parseInt(&#x27;32a3&#x27;) //32 String()可以将任意类型的值转化成字符串 给出转换规则图： 123456789101112131415161718// 数值：转为相应的字符串String(1) // &quot;1&quot;//字符串：转换后还是原来的值String(&quot;a&quot;) // &quot;a&quot;//布尔值：true转为字符串&quot;true&quot;，false转为字符串&quot;false&quot;String(true) // &quot;true&quot;//undefined：转为字符串&quot;undefined&quot;String(undefined) // &quot;undefined&quot;//null：转为字符串&quot;null&quot;String(null) // &quot;null&quot;//对象String(&#123;a: 1&#125;) // &quot;[object Object]&quot;String([1, 2, 3]) // &quot;1,2,3&quot; Boolean()可以将任意类型的值转为布尔值，转换规则如下： 12345678Boolean(undefined) // falseBoolean(null) // falseBoolean(0) // falseBoolean(NaN) // falseBoolean(&#x27;&#x27;) // falseBoolean(&#123;&#125;) // trueBoolean([]) // trueBoolean(new Boolean(false)) // true “|”运算符它仅执行ToInt32转换 12340|=0//00|NAN;//00|Infinity;//00|-Infinity;//0 以上字符无法以32位格式呈现，他们都来自64位IEE754标准，因此ToInt返回0 “~”运算符它首先将值转为32位数字，然后执行字位操作“非”，对每一位进行反转，也就是返回2的补码，x相当于-(x+1)，-(x+1)唯一能够得到0的x值时-1，也就是说如果x为-1，和一些数字值连在一起就会返回假值，其他情况返回真值 而-1是一个“哨位值”,即在各个类型中被赋予了特殊含义的值，如indexOf(),在字符串中找到指定字符返回子字符串所在位置，否则返回-1 1234567891011var a=&quot;Hello world&quot;;~a.indexOf(&quot;lo&quot;);//-4if(~a.indexOf(&quot;lo&quot;))&#123;//true //找到匹配 &#125;~a.indexOf(&quot;ol&quot;);//0,假值!~a.indexOf(&quot;ol&quot;);//trueif(!~a.indexOf(&quot;ol&quot;))&#123;//true //没有找到匹配&#125; 隐式类型转换在隐式转换中，我们可能最大的疑惑是 ：何时发生隐式转换？ 我们这里可以归纳为两种情况发生隐式转换的场景： 比较运算（==、!=、&gt;、&lt;）、if、while需要布尔值地方 算术运算（+、-、*、/、%） 除了上面的场景，还要求运算符两边的操作数不是同一类型 自动转换为布尔值在需要布尔值的地方，就会将非布尔值的参数自动转为布尔值，系统内部会调用Boolean函数 可以得出个小结： undefined null false +0 -0 NaN “” 除了上面几种会被转化成false，其他都换被转化成true 自动转换成字符串遇到预期为字符串的地方，就会将非字符串的值自动转为字符串 具体规则是：先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串 常发生在+运算中，一旦存在字符串，则会进行字符串拼接操作 123456781&#x27;5&#x27; + 1 // &#x27;51&#x27;2&#x27;5&#x27; + true // &quot;5true&quot;3&#x27;5&#x27; + false // &quot;5false&quot;4&#x27;5&#x27; + &#123;&#125; // &quot;5[object Object]&quot;5&#x27;5&#x27; + [] // &quot;5&quot;6&#x27;5&#x27; + function ()&#123;&#125; // &quot;5function ()&#123;&#125;&quot;7&#x27;5&#x27; + undefined // &quot;5undefined&quot;8&#x27;5&#x27; + null // &quot;5null&quot; 自动转换成数值除了+有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值 12345678910111&#x27;5&#x27; - &#x27;2&#x27; // 32&#x27;5&#x27; * &#x27;2&#x27; // 103true - 1 // 04false - 1 // -15&#x27;1&#x27; - 1 // 06&#x27;5&#x27; * [] // 07false / &#x27;5&#x27; // 08&#x27;abc&#x27; - 1 // NaN9null + 1 // 110undefined + 1 // NaNnull`转为数值时，值为`0` 。`undefined`转为数值时，值为`NaN ||和&amp;&amp;在JS中||和&amp;&amp;返回的是两个操作数中的一个 ||和&amp;&amp;首先会对第一个操作数(a和c)执行条件判断，如果其不是布尔值，就进行TooBoolean强制类型转换，然后再进行条件判断 对于||: 如果条件判断结果为true返回第一个操作数，为false则返回第二个操作数的值。 &amp;&amp;则相反，如果条件判断结果为true返回第二个操作数，如果为fakse返回第一个操作数 a||b相当于a?a:b; a&amp;&amp;b相当于a?b:a 常见的用|| 123456function foo(a,b)&#123; a=a||&quot;hello&quot;;//检查变量a如果未赋值则赋值一个默认值hello b=b||&quot;world&quot;; console.log(a+&quot; &quot;+b);&#125; &amp;&amp;： 12345function foo()&#123;&#125;var a=42;a&amp;&amp;foo();//foo()只有在条件判断a通过时才会调用foo();如果条件判断未通过，则a&amp;&amp;foo()就会终止","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"真值假值","slug":"真值假值","date":"2022-04-18T10:06:31.000Z","updated":"2022-04-18T10:10:57.615Z","comments":true,"path":"2022/04/18/真值假值/","link":"","permalink":"https://coloey.github.io/2022/04/18/%E7%9C%9F%E5%80%BC%E5%81%87%E5%80%BC/","excerpt":"","text":"假值： undefined null false +0 -0 NAN “ “ 假值列表以外的其他对象为真值 假值对象 封装了假值的对象为true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"原生构造函数的原型","slug":"原生构造函数的原型","date":"2022-04-18T09:34:33.000Z","updated":"2022-04-18T09:39:24.328Z","comments":true,"path":"2022/04/18/原生构造函数的原型/","link":"","permalink":"https://coloey.github.io/2022/04/18/%E5%8E%9F%E7%94%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9E%8B/","excerpt":"","text":"Js为基本数据类型提供了封装对象，称为原生函数（String,Number,Boolean等） 原生构造函数都有自己的prototype对象，这些对象包含其对应子类型所特有的行为特征 有些原生原型不是普通对象 123456console.log(typeof Function.prototype)//functionconsole.log(typeof RegExp.prototype)//objectconsole.log(Function.prototype);//空函数console.log(Array.prototype.length);//0,空数组console.log(RegExp.prototype.toString())//&quot;/?:/&quot;空正则表达式","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"Symbol","slug":"Symbol","date":"2022-04-18T09:11:47.000Z","updated":"2022-04-18T09:30:23.603Z","comments":true,"path":"2022/04/18/Symbol/","link":"","permalink":"https://coloey.github.io/2022/04/18/Symbol/","excerpt":"","text":"Symbol是具有唯一性的特殊标识符，符号可以用作属性名，但无论是在代码还是控制开发台都无法查看和访问它的值，只会显示Symbol(Symbol.create)类似的值 ES6中有预定义的符号，以Symbol的静态属性形式出现，如Symbol.create,Symbol.iterator，可以这样使用： 1obj[Symbol.iterator]=function()&#123;&#125; 可以使用Symbol(…)原生构造函数来自定义符号，但是不能用new 1234567var mysym=Symbol(&quot;my on symbol&quot;)console.log(mysym.toString())//Symbol(my on symbol)console.log(typeof mysym);//symbolvar a=&#123;&#125;a[mysym]=&quot;foorbar&quot;console.log(Object.getOwnPropertySymbols(a));//通常用来命名私有或特殊属性，替代下划线(_)前缀的属性//[Symbol(my on symbol)] Symbol不是对象，是一种简单的标量基本类型","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"小数安全问题","slug":"小数安全问题","date":"2022-04-18T04:04:53.000Z","updated":"2022-04-18T04:10:33.394Z","comments":true,"path":"2022/04/18/小数安全问题/","link":"","permalink":"https://coloey.github.io/2022/04/18/%E5%B0%8F%E6%95%B0%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/","excerpt":"","text":"二进制浮点数中0.1和0.2并不精确，它们相加的结果并非刚好等于0.3,所以结果为false,可以设置一个误差范围值，通常称为机器精度，对于javaScript来说，通常是2^-52 从ES6开始，该值定义为Number.EPSILON 123456function numberCloseEnoughToEqual(n1,n2)&#123; return Math.abs(n1-n2)&lt;Number.EPSILON&#125;var a=0.1+0.2;var b=0.3;console.log(numberCloseEnoughToEqual(a,b));","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"异步函数策略","slug":"异步函数策略","date":"2022-04-16T03:35:37.000Z","updated":"2022-04-18T09:12:08.897Z","comments":true,"path":"2022/04/16/异步函数策略/","link":"","permalink":"https://coloey.github.io/2022/04/16/%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%AD%96%E7%95%A5/","excerpt":"","text":"实现sleep123456789async function sleep(delay)&#123; return new Promise((resolve)=&gt;setTimeout(resolve,delay)); &#125; async function foo()&#123; const t0=Date.now(); await sleep(1500);//暂停1500ms,await会期望等到一个实现thenable接口的对象，没有的话也会将其包装为promise console.log(Date.now()-t0); &#125; 实现平行加速promise没有按顺序执行，但是await按顺序接收到每个promise的值 1234567891011121314151617181920async function randomDelay(id)&#123; const delay=Math.random()*1000; return new Promise((resolve)=&gt;setTimeout(()=&gt;&#123; console.log(`$&#123;id&#125; finished`); resolve() &#125;,delay)) &#125; async function foo()&#123; const t0=Date.now() const p0=randomDelay(0); const p1=randomDelay(1); const p2=randomDelay(2); const p3=randomDelay(3); await p0; await p1; await p2; await p3; setTimeout(console.log,0,`$&#123;Date.now()-t0&#125; ms elapsed`) &#125; foo(); 12345678910111213141516async function randomDelay(id)&#123; const delay=Math.random()*1000; return new Promise((resolve)=&gt;setTimeout(()=&gt;&#123; console.log(`$&#123;id&#125; finished`); resolve(id) &#125;,delay)) &#125; async function foo()&#123; const t0=Date.now() const promises=Array(5).fill(null).map((key,index)=&gt;randomDelay(index)); for(const p of promises)&#123; console.log(`awaited $&#123;await p&#125;`) &#125; setTimeout(console.log,0,`$&#123;Date.now()-t0&#125; ms elapsed`) &#125; foo(); Promise.all原理只有传入的所有Promise都完成，返回promise才能完成，如果有任何promise被拒绝，返回的主promise就立即拒绝（抛弃任何其他promise的结果），如果全部完成，你会得到一个数组，其中包含传入的所有promise的完成值，对于拒绝的情况，你只会的到第一个拒绝promise的拒绝理由值，这种模式成为门，所有人到齐了才开门,传入空数组会立即完成 12345678910111213Promise.all=function(promises)&#123; const res=[]; return new Promise((resolve,reject)=&gt;&#123; promises.forEach(promise=&gt;&#123; promise.then((value,index)=&gt;&#123; res[idx]=value;//解析promise里面的值 if(res.length==promises.length)&#123; resolve(res) &#125; &#125;,reason=&gt;reject(reason)) &#125;) &#125;) &#125; 例： 12345678910111213141516171819 function runAsync (x) &#123; const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000)) return p&#125;function runReject (x) &#123; const p = new Promise((res, rej) =&gt; setTimeout(() =&gt; rej(`Error: $&#123;x&#125;`, console.log(x)), 1000 * x)) return p&#125;Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)]) .then(res =&gt; console.log(res)) .catch(err =&gt; console.log(err))// 1s后输出13// 2s后输出2Error: 2// 4s后输出4 Promise.race():只有第一个决议的promise取胜，并且决议结果成为返回promise的决议。其他任务虽然会继续进行，但是race已经不管那些任务的结果了，不能传入空数组，传入空数组promise.race()会挂住，且永远不会决议 1234567891011function runAsync (x) &#123; const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000)) return p&#125;Promise.race([runAsync(1), runAsync(2), runAsync(3)]) .then(res =&gt; console.log(&#x27;result: &#x27;, res)) .catch(err =&gt; console.log(err))//1&#x27;result: &#x27; 123 Promise.race()原理:1234567891011121314151617181920Promise.race=function(promises)&#123; promises=Array.from(promises); return new Promise((resolve,reject)=&gt;&#123; if(promises.length===0)&#123; return;//空数组挂起 &#125; else&#123; for(let i=0;i&lt;promises.length;i++)&#123; Promise.resolve(promises[i]).then((data)=&gt;&#123; resolve(data); return;//只会返回第一个先resolve的，其他resolve的race不管 &#125;,(err)=&gt;&#123; reject(err); return; &#125;) &#125; &#125; &#125;)&#125; Promise.resolve()原理12345678910111213Promsie.resolve=function(param)&#123; if(param instanceof Promise)return param;//如果param本身是promise,则直接返回 return new Promise((resolve,reject)=&gt;&#123; if(param &amp;&amp;typeof param===&#x27;object&#x27;&amp;&amp; typeof param.then===&#x27;function&#x27;)&#123;//如果param是个对象并且param是thenable setTimeout(()=&gt;&#123;//则返回的promise会跟随这个thenable的对象，采用最终状态 param.then(resolve,reject); &#125;) &#125;else&#123; resolve(param)//如果param是值，则直接以该值为成功状态返回 &#125; &#125;)&#125; Promise.reject()12345Promise.reject=function(reason)&#123; return new Promise((resolve,reject)=&gt;&#123; return reject(reason) &#125;)&#125; Promise.catch()123Promsie.prototype.catch=function(onRejected)&#123; return this.then(null,onRejected);//catch后可以继续.then因此调用this.then后可以返回一个新的promise继续.then&#125; Promise.finally():1234567891011Promise.prototype.finally=function(cb)&#123; return this.then((value)=&gt;&#123; return Promise.resolve(callback).then(()=&gt;&#123; return value;//finally后可以继续.then因此调用this.then后可以返回一个新的promise继续.then &#125;) &#125;,(err)=&gt;&#123; return Promise.resolve(callback).then(()=&gt;&#123; throw err; &#125;) &#125;)&#125; 每隔一秒打印1,2,3123const arr=[1,2,3]; arr.reduce( (p,x)=&gt;p.then(()=&gt;new Promise(resolve=&gt;setTimeout(()=&gt;resolve(console.log(x)),1000))),Promise.resolve()) 一秒后打印出1，2,3 123arr.reduce( (p,x)=&gt;p.then(new Promise(resolve=&gt;setTimeout(resolve(console.log(x)),1000))),Promise.resolve() ) 红绿灯交替闪烁123456789101112131415161718192021222324252627282930function red()&#123; console.log(&quot;red&quot;) &#125; function yellow()&#123; console.log(&quot;yellow&quot;) &#125; function green()&#123; console.log(&quot;green&quot;) &#125; const light=(time,cb)=&gt;&#123; return new Promise(resolve=&gt;&#123; setTimeout(()=&gt;&#123; cb(); resolve(); &#125;,time) &#125;) &#125; const step=function()&#123; Promise.resolve() .then(()=&gt;&#123; return light(3000,red) &#125;) .then(()=&gt;&#123; return light(2000,yellow) &#125;) .then(()=&gt;&#123; return light(1000,green) &#125;)&#125; step(); mergepromise 123456789101112131415161718192021222324252627282930313233343536const time = (timer) =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve() &#125;, timer) &#125;)&#125;const ajax1 = () =&gt; time(2000).then(() =&gt; &#123; console.log(1); return 1&#125;)const ajax2 = () =&gt; time(1000).then(() =&gt; &#123; console.log(2); return 2&#125;)const ajax3 = () =&gt; time(1000).then(() =&gt; &#123; console.log(3); return 3&#125;)function mergePromise (promises) &#123; // 在这里写代码 let data=[] let promise=Promise.resolve(); promises.forEach(ajax=&gt;&#123; //第一次then是调用ajax,第二次then是解析ajax的结果 promise=promise.then(ajax).then(res=&gt;&#123;data.push(res);return data&#125;)//把每次结果返回 &#125;) return promise; &#125;mergePromise([ajax1, ajax2, ajax3]).then(data =&gt; &#123; console.log(&quot;done&quot;); console.log(data); // data 为 [1, 2, 3]&#125;); 异步加载图片 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function loadImage(url)&#123; return new Promise((resolve,reject)=&gt;&#123; const img=new Image(); img.onload=function()&#123; console.log(&quot;一张图片加载完成&quot;) resolve(img) &#125; img.onerror=function()&#123; reject(new Error(&quot;Cannot load&quot;+url)); &#125; img.src=url; &#125;)&#125;var urls = [ &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting1.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting2.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting3.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting4.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting5.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn6.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn7.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn8.png&quot;,];function limitedLoad(urls,handler,limit)&#123; let sequence=[...urls]; let promises=sequence.splice(0,limit).map((url,index)=&gt;&#123; return handler(url).then(index=&gt;&#123; return index;//调用loadImage返回最先加载完成的那张照片下标 &#125;) &#125;) return sequence.reduce( (p,url)=&gt;&#123; return p.then(()=&gt;&#123;return Promise.race(promises)&#125;)//得到第一张加载完成的图片的下标 .then(fastIndex=&gt;&#123;promises[fastIndex]=handler(url).then(()=&gt;&#123;return fastIndex&#125;)&#125;)//将已经加载完成的照片的位置替换为为加载的照片 .catch(err=&gt;&#123;console.error(err)&#125;) &#125;,Promise.resolve())//初始为Promise.resolve() .then(()=&gt;&#123;return Promise.all(promises)&#125;)//最后3个用Promise.all加载&#125;limitedLoad(urls,loadImage,3).then(res=&gt;&#123; console.log(&quot;图片全部加载完成&quot;) console.log(res)&#125;).catch(err=&gt;&#123; console.error(err)&#125;) 判断图片是否加载延迟12345678910111213141516171819202122232425function loadImage(url)&#123; return new Promise((resolve,reject)=&gt;&#123; const img=new Image(); img.onload=function()&#123; console.log(&quot;一张图片加载完成&quot;) resolve(img) &#125; img.onerror=function()&#123; reject(new Error(&quot;Cannot load&quot;+url)); &#125; img.src=url; &#125;)&#125;function timeout()&#123; var p=new promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; reject(&#x27;图片超时&#x27;) &#125;,5000) &#125;)&#125;Promise.race([loadImage(),timeout()]).then((data)=&gt;&#123; console.log(data);&#125;).catch((err)=&gt;&#123; console.log(err)&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"面向对象的原型模式和对象关联区别","slug":"面向对象的原型模式和对象关联区别","date":"2022-04-15T08:10:58.000Z","updated":"2022-04-15T08:57:12.807Z","comments":true,"path":"2022/04/15/面向对象的原型模式和对象关联区别/","link":"","permalink":"https://coloey.github.io/2022/04/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94%E5%8C%BA%E5%88%AB/","excerpt":"","text":"面向对象的原型模式：1234567891011121314151617function Foo(who)&#123; this.me=who &#125; Foo.prototype.identify=function()&#123; return &quot;I am &quot;+this.me &#125; function Bar(who)&#123; Foo.call(this,who) &#125; Bar.prototype=Object.create(Foo.prototype); Bar.prototype.speak=function()&#123; alert(&quot;Hello&quot;+this.identify()+&quot;.&quot;) &#125; var b1=new Bar(&quot;b1&quot;); var b2=new Bar(&quot;b2&quot;); b1.speak(); b2.speak(); 对象关联的委托模式123456789101112131415Foo=&#123; init:function(who)&#123;this.me=who&#125;, identify:function()&#123;return &quot;I am &quot;+this.me&#125; &#125; Bar=Object.create(Foo); Bar.speak=function()&#123; alert(&quot;Hello&quot;+this.identify()+&quot;.&quot;) &#125; var b1=Object.create(Bar) b1.init(&quot;b1&quot;); var b2=Object.create(Bar) b2.init(&quot;b2&quot;); b1.speak(); b2.speak(); 类设计模式1234567891011121314151617181920212223class Foo&#123; constructor(who)&#123; var me=who &#125; identify()&#123; return &quot;I am &quot;+this.me &#125; &#125; class Bar extends Foo&#123; constructor(who)&#123; super();//这里super指的是父类的构造函数，相当于Foo.prototype.constructor.call(this);this指的是子类Bar this.me=who &#125; speak()&#123; alert(&quot;hello&quot;+super.identify())//这里super作为对象，指的是父类的原型对象，相当于Foo.prototype &#125; &#125; var b1=new Bar(&#x27;b1&#x27;); b1.speak(); var b2=new Bar(&#x27;b2&#x27;); b2.speak();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"prototype,__proto__与costructor","slug":"prototype-proto-与costructor","date":"2022-04-15T05:21:41.000Z","updated":"2022-05-02T15:57:23.976Z","comments":true,"path":"2022/04/15/prototype-proto-与costructor/","link":"","permalink":"https://coloey.github.io/2022/04/15/prototype-proto-%E4%B8%8Ecostructor/","excerpt":"","text":"本文转载自（ []: https://blog.csdn.net/cc18868876837/article/details/81211729） 文章目录 前言 _ _ proto _ _ 属性 prototype属性 constructor属性 总结提示：不要排斥，静下心来，认真读完，你就搞懂了！(可以先看一下最后的总结部分再回过头来完整看完) 前言 作为一名前端工程师，必须搞懂JS中的prototype、_proto__与constructor属性，相信很多初学者对这些属性存在许多困惑，容易把它们混淆，本文旨在帮助大家理清它们之间的关系并彻底搞懂它们。这里说明一点，__proto__属性的两边是各由两个下划线构成（这里为了方便大家看清，在两下划线之间加入了一个空格： proto _，读作“dunder proto”，“double underscore proto”的缩写），实际上，该属性在ES标准定义中的名字应该是[[Prototype]]，具体实现是由浏览器代理自己实现，谷歌浏览器的实现就是将[[Prototype]]命名为__proto__，大家清楚这个标准定义与具体实现的区别即可（名字有所差异，功能是一样的），可以通过该方式检测引擎是否支持这个属性：Object.getPrototypeOf({proto: null}) === null。本文基于谷歌浏览器（版本 72.0.3626.121）的实验结果所得。 现在正式开始！ 让我们从如下一个简单的例子展开讨论，并配以相关的图帮助理解： 1234function Foo() &#123;...&#125;;let f1 = new Foo(); 以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。这里稍微补充一下new操作符将函数作为构造器进行调用时的过程：函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用，详细请看：详解JavaScript中的new操作符。虽然是简简单单的两行代码，然而它们背后的关系却是错综复杂的，如下图所示： 看到这图别怕，让我们一步步剖析，彻底搞懂它们！ 图的说明：右下角为图例，红色箭头表示__proto__属性指向、绿色箭头表示prototype属性的指向、棕色实线箭头表示本身具有的constructor属性的指向，棕色虚线箭头表示继承而来的constructor属性的指向；蓝色方块表示对象，浅绿色方块表示函数（这里为了更好看清，Foo()仅代表是函数，并不是指执行函数Foo后得到的结果，图中的其他函数同理）。图的中间部分即为它们之间的联系，图的最左边即为例子代码。 __ proto __ 属性 首先，我们需要牢记两点： ①____proto____和constructor属性是对象所独有的；② prototype属性是函数所独有的。但是由于JS中函数也是一种对象，所以函数也拥有__proto__和constructor属性，这点是致使我们产生困惑的很大原因之一。上图有点复杂，我们把它按照属性分别拆开，然后进行分析： 第一，这里我们仅留下 proto 属性，它是对象所独有的，可以看到__proto__属性都是由一个对象指向一个对象，即指向它们的原型对象（也可以理解为父对象），那么这个属性的作用是什么呢？它的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的__proto__属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点），由以上这种通过__proto__属性来连接对象直到null的一条链即为我们所谓的原型链。 其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠__proto__继承而来的。 prototype属性 第二，接下来我们看 prototype 属性： prototype属性，别忘了一点，就是我们前面提到要牢记的两点中的第二点，它是函数所独有的，（除了Object基本类型），它是从一个函数指向一个对象。它的含义是函数的原型对象，也就是这个函数（其实所有函数都可以作为构造函数)所创建的实例的原型对象，由此可知：f1.proto === Foo.prototype，它们两个完全一样。那prototype属性的作用又是什么呢？它的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。 constructor属性 最后，我们来看一下 constructor 属性： constructor属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数（本身拥有或继承而来，继承而来的要结合__proto__属性查看会更清楚点，如下图所示），从上图中可以看出Function这个对象比较特殊，它的构造函数就是它自己（因为Function可以看成是一个函数，也可以是一个对象)，所有函数和对象最终都是由Function构造函数得来，所以constructor属性的终点就是Function这个函数。 感谢网友的指出，这里解释一下上段中“每个对象都有构造函数”这句话。这里的意思是每个对象都可以找到其对应的constructor，因为创建对象的前提是需要有constructor，而这个constructor可能是对象自己本身显式定义的或者通过proto在原型链中找到的。而单从constructor这个属性来讲，只有prototype对象才有。每个函数在创建的时候，JS会同时创建一个该函数对应的prototype对象，而函数创建的对象.proto === 该函数.prototype，该函数.prototype.constructor===该函数本身，故通过函数创建的对象即使自己没有constructor属性，它也能通过__proto__找到对应的constructor，所以任何对象最终都可以找到其构造函数（null如果当成对象的话，将null除外）。如下： 总结 总结一下： 我们需要牢记两点： ①__proto__和constructor属性是对象所独有的； ② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。__proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.proto === Foo.prototype。constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。 本文就此结束了，希望对那些对JS中的prototype、__proto__与constructor属性有困惑的同学有所帮助。 最后，感谢这两篇博文，本文中的部分内容参考自这两篇博文： 一张图理解prototype、proto和constructor的三角关系prototype和__proto__的关系是什么？小彩蛋：实现继承（相对完美、优雅） 123456789101112131415161718192021222324function inherit(Child, Parent) &#123; // 继承原型上的属性 Child.prototype = Object.create(Parent.prototype) // 修复 constructor Child.prototype.constructor = Child // 存储超类 Child.super = Parent // 静态属性继承 if (Object.setPrototypeOf) &#123; // setPrototypeOf es6 Object.setPrototypeOf(Child, Parent) &#125; else if (Child.__proto__) &#123; // __proto__ es6 引入，但是部分浏览器早已支持 Child.__proto__ = Parent &#125; else &#123; // 兼容 IE10 等陈旧浏览器 // 将 Parent 上的静态属性和方法拷贝一份到 Child 上，不会覆盖 Child 上的方法 for (var k in Parent) &#123; if (Parent.hasOwnProperty(k) &amp;&amp; !(k in Child)) &#123; Child[k] = Parent[k] &#125; &#125; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"类","slug":"类","date":"2022-04-15T02:03:02.000Z","updated":"2022-04-15T14:21:17.594Z","comments":true,"path":"2022/04/15/类/","link":"","permalink":"https://coloey.github.io/2022/04/15/%E7%B1%BB/","excerpt":"","text":"类构造函数方法名constructor会告诉解释器在使用new操作符创建类的新实例时，应该调用这个函数，构造函数的定义不是必须的，不定义构造函数相当于将构造函数定义为空函数 使用new调用类的构造函数会执行如下操作： 在内存中创建一个新对象 这个新对象内部的[[Prototype]]即__proto__指针被赋值为构造函数的prototype属性 构造函数内部的this被赋值为这个新对象（即this指向新对象） 执行构造函数内部的代码（给新对象添加属性） 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象 12345class Person&#123; &#125; let p1=new Person(); console.log(p1.__proto__===Person.prototype);//true 默认情况下，类构造函数会在执行后返回this对象，构造函数返回的对象会被用作实例化的对象，如果没用引用新创建的this对象，那么这个对象会被销毁。不过，如果，返回的不是this对象，而是其他对象，那么这个对象不会通过instanceof操作符检测出跟类有关联。 123456789101112131415class Person&#123; constructor(override)&#123; this.foo=&quot;foo&quot;; if(override)&#123; return &#123; bar:&quot;bar&quot; &#125; &#125; &#125; &#125; let p1=new Person(),p2=new Person(true); console.log(p1) console.log(p1 instanceof Person); console.log(p2);//没有引用构造函数创建的this对象，对象被销毁而返回的其他对象与类没有关系 console.log(p2 instanceof Person) 类构造函数与普通构造函数区别调用类构造函数必须使用new操作符，而普通构造函数如果不使用new调用，那么就会以全局的this作为内部对象，调用类构造函数没有使用new则会抛出错误 1let p3=Person();//TypeError 类构造函数在实例化后，可以在实例上引用它 1234class Person&#123;&#125;let p1=new Person();//使用对类构造函数的引用创建一个新实例let p2=new p1.constructor(); 把类当成特殊的函数123class Person&#123;&#125;console.log(Person);//class Person&#123;&#125;console.log(typeof Person)//function 类标识符有prototype属性，而这个原型也有一个constructor属性指向类自身 1234class Person&#123; &#125; console.log(Person===Person.prototype.constructor);//true 使用instanceof检查一个对象和类构造函数，以确定对象是不是类的实例。 12let p=new Person();console.log(p instanceof Person)//true 类本身具有和普通构造函数一样的行为，在类的上下文中，类本身使用new调用时就被当做构造函数，类中的constructor方法不会被当做构造函数， 123456789101112class Person&#123; &#125; let p1=new Person(); console.log(p1 instanceof Person);//true console.log(p1.constructor=== Person);//true console.log(p1 instanceof Person.constructor)//false let p2=new Person.constructor(); console.log(p2 instanceof Person)//false console.log(p2 .constructor=== Person);//false console.log(p2 instanceof Person.constructor)//true 实例，原型和类成员实例成员每次通过new调用类标识符时都会执行类构造函数，可以为新创建的实例this添加自有属性。每个实例都对应一个唯一的成员对象，所有成员都不会在原型上共享 123456789101112class Person&#123; constructor()&#123; this.name=new String(&#x27;Jack&#x27;); this.sayName=()=&gt;console.log(this.name); &#125; sayAge(age)&#123; console.log(age) &#125; &#125; let p1=new Person(),p2=new Person(); console.log(p1.name===p2.name)//false console.log(p1.sayAge(18)===p2.sayAge(19))//true 原型方法为了在实例间共享方法，类定义语法在类块中定义的方法作为原型方法 12 //在类块中定义的所有内容都会定义在类的原型上console.log(p1.sayAge===Person.prototype.sayAge);//true 可以把方法定义在类构造函数或者类块中，但不能在类块给原型添加原始值或对象作为成员数据,但是可以在类块外部手动添加成员数据 1Person.greeting=&quot;My name is&quot; 类方法等同于对象属性因此可以使用字符串，符号或计算的值作为键, 也支持获取和设置访问器 12345678910111213141516171819202122232425const symbolKey=Symbol(&#x27;symbolkey&#x27;);class Person()&#123; stringKey()&#123; console.log(&#x27;invoked stringKey&#x27;) &#125; [symbolKey]()&#123; console.log(&#x27;invoked symbolKey&#x27;) &#125; [&#x27;computed&#x27;+&#x27;Key&#x27;]()&#123; console.log(&#x27;invoked computedKey&#x27;) &#125; set name(newvalue)&#123; this.name_=newName; &#125; get name()&#123; return this.name_ &#125;&#125;let p=new Person()p.stringKey();p[symbolKey]();p.computedKey();p.name=&#x27;jake&#x27;;console.log(p.name);//Jake 静态类方法这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例 与原型成员类似，静态成员每个类上只能有一个 静态类成员在类定义中使用static关键字作为前缀，在静态成员中，this引用类自身，其他所有约定跟原型成员一样，静态类方法适合作为实例工厂 12345678910111213class Person&#123; constructor()&#123; this.name=new String(&#x27;Jack&#x27;); this.sayName=()=&gt;console.log(this.name); &#125; sayAge(age)&#123; console.log(age) &#125; static create()&#123; return new Person(Math.floor(Math.random()*100)) &#125; &#125; console.log(Person.create())//Person &#123;name: String, sayName: ƒ&#125;name: String &#123;&#x27;Jack&#x27;&#125;sayName: ()=&gt;console.log(this.name)[[Prototype]]: Object 关于继承[]: https://www.bookstack.cn/read/es6-3rd/spilt.1.docs-class-extends.md 关于super[]: https://www.bookstack.cn/read/es6-3rd/spilt.3.docs-class-extends.md 抽象基类通过new.target保存通过new关键字调用的类或函数，在普通函数中调用new.target返回undefined,通过在实例化时检测new.target是不是抽象基类，可以阻止对抽象基类的实例化 1234567891011class Vehicle&#123; constructor()&#123; console.log(new.target); if(new.target===Vehicle)&#123; throw new Error(&#x27;Vehicle cannot be directly instantiated&#x27;) &#125; &#125; &#125; class Bus extends Vehicle&#123;&#125; new Bus(); new Vehicle()//testIframe.html:193 Uncaught Error: Vehicle cannot be directly instantiated 继承内置类型1234567891011class SuperArray extends Array&#123; shuffle()&#123; for(let i=this.length-1;i&gt;=0;i--)&#123; let j=Math.floor(Math.random(0,i+1));//0-i+1向下取整 [this[i],this[j]]=[this[j],this[i]] &#125; &#125; &#125; let a=new SuperArray(1,2,3,4,5); a.shuffle() console.log(a);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"async 和defer","slug":"async-和defer","date":"2022-04-15T00:51:47.000Z","updated":"2022-04-15T01:02:46.471Z","comments":true,"path":"2022/04/15/async-和defer/","link":"","permalink":"https://coloey.github.io/2022/04/15/async-%E5%92%8Cdefer/","excerpt":"","text":"script元素包含async属性和defer属性： async:可选，表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载，只对外部脚本文件有效，标记过async的脚本并不保证能按照它们出现的次序执行 defer:可选，表示脚本可以延迟到文档完全被解析和渲染后再执行，相当于告诉浏览器立即下载，延迟执行，且按照顺序执行 只对外部脚本有效，在IE7及更早版本中，对行内脚本也可以指定这个属性 如果把script标签放在head标签里，意味着必须把所有JavaScript代码都下载，加息和解释完成后，才能渲染压面页面在浏览器解析到body的其实标签时开始渲染。因此现代Web通常把js引用放在body元素中页面内容后面这样页面就会在处理js代码之前完全渲染页面","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"组合继承和原型继承","slug":"继承方式","date":"2022-04-14T10:11:28.000Z","updated":"2022-05-01T02:29:50.331Z","comments":true,"path":"2022/04/14/继承方式/","link":"","permalink":"https://coloey.github.io/2022/04/14/%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/","excerpt":"","text":"组合继承综合了原型链和盗用构造函数，将两者优点结合，使用原型链继承原型上的属性和方法，通过盗用构造函数继承实例属性，这样既可以把方法定义在原型上实现重用，又可以让每个实例都有自己的属性 1234567891011121314151617181920212223242526function SuperType(name)&#123; this.name=name; this.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; &#125; SuperType.prototype.sayName=function()&#123; console.log(this.name);//不能用箭头函数，因为箭头函数没有this绑定，会向上找到全局上下文 &#125; function SubType(name,age) &#123; SuperType.call(this,name);//SuperType的构造函数绑定SubType的构造函数,自定义实例属性，第二次调用SuperType this.age=age;&#125;//继承原型上的方法，让SubType的原型指向SuperType的实例,第一次调用SuperType，SubType的constructor会委托到SuperType.prototype上的constructor，进而指向SuperTypeSubType.prototype=new SuperType();SubType.prototype.sayAge=function()&#123; console.log(this.age);&#125;let instance1=new SubType(&#x27;Ann&#x27;,29);instance1.colors.push(&quot;balck&quot;);console.log(instance1.colors);instance1.sayName();instance1.sayAge();let instance2=new SubType(&quot;Greg&quot;,27);console.log(instance2.colors);instance2.sayName();instance2.sayAge(); 原型式继承12345678910111213//object.create()function object(o)&#123; function F()&#123;&#125;;//创建一个构造函数 F.prototype=o;//构造函数的原型指向参数对象o return new F();//返回F对象实例&#125;let person=&#123; name:&quot;Ann&quot;, friends:[&quot;Mary&quot;,&quot;Harry&quot;,&quot;Van&quot;]&#125;let anotherPerson=object(person);anotherPerson.friends.push(&quot;Mike&quot;);console.log(person.friends);// [&#x27;Mary&#x27;, &#x27;Harry&#x27;, &#x27;Van&#x27;, &#x27;Mike&#x27;] object()函数创建一个临时构造函数，将传入对象赋值给这个构造函数原型，然后返回这个临时类型的一个实例。本质上，object()是对传入的对象执行了一次浅复制，anotherperson.proto=person,如果person是构造函数，则anotherperson的[[Prototype]]将没有指向的prototype对象，也就无法通过prototype对象找到constructor进而使用construcor上面的方法和属性 这里的object函数相当与object.create() 12345678let person=&#123; name:&quot;Ann&quot;, friends:[&quot;Mary&quot;,&quot;Harry&quot;,&quot;Van&quot;]&#125;let anotherPerson=object。create(person);anotherPerson.friends.push(&quot;Mike&quot;);console.log(person.friends);// [&#x27;Mary&#x27;, &#x27;Harry&#x27;, &#x27;Van&#x27;, &#x27;Mike&#x27;] 原型式继承适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。 寄生式继承与原型式继承比较接近的一种继承方式是寄生式继承 12345678910111213function createAnother(original)&#123; let clone=Object.create(original);//通过调用函数创建一个新对象 clone.sayHi=function()&#123;//以某种方式增强这个对象 console.log(&quot;hi&quot;); &#125; return clone;//返回这个对象&#125;let person=&#123; name:&quot;Ann&quot;, friends:[&quot;Mary&quot;,&quot;Harry&quot;,&quot;Van&quot;]&#125;let anotherPerson=createAnother(person);anotherPerson.sayHi(); 寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景。痛过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。 寄生式组合继承1234567891011121314151617181920212223242526function inheritPrototype(subType,superType)&#123;//参数分别是子类和父类的构造函数 let prototype=Object.create(superType.prototype);//先复制父类的原型对象 prototype.constructor=subType;//增强对象，让新的原型对象的构造函数指向子类构造函数 subType.prototype=prototype;//赋值对象，让子类原型指向新的原型&#125;function SuperType(name)&#123; this.name=name; this.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];&#125; SuperType.prototype.sayName=function()&#123; console.log(this.name);//不能用箭头函数，因为箭头函数没有this绑定，会向上找到全局上下文 &#125; function SubType(name,age) &#123; SuperType.call(this,name);//SuperType的构造函数绑定SubType的构造函数,调用Supertype() this.age=age; &#125;inheritPrototype(SubType,SuperType);SubType.prototype.sayAge=function()&#123; console.log(this.age); &#125; let instance1=new SubType(&#x27;Ann&#x27;,29); instance1.colors.push(&quot;balck&quot;); console.log(instance1.colors); instance1.sayName(); instance1.sayAge(); 另一种写法： 12345678910111213function SuperType(name)&#123; this.name=name; this.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];&#125; SuperType.prototype.sayName=function()&#123; console.log(this.name);//不能用箭头函数，因为箭头函数没有this绑定，会向上找到全局上下文 &#125; function SubType(name,age) &#123; SuperType.call(this,name);//SuperType的构造函数绑定SubType的构造函数,调用Supertype() this.age=age; &#125;SubType.prototype=Object.create(SuperType.prototype)SubType.prototype.constructor=Subtype 寄生式组合继承基本模式： 先创建父类原型的一个副本prototype 给prototype设置constructor属性为subType,增强对象，解决由于重写原型导致默认constructor丢失问题 将新创建的对象赋值给子类型的原型 只调用一次SuperType构造函数，效率最高","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"执行上下文和作用域","slug":"执行上下文和作用域","date":"2022-04-14T08:21:59.000Z","updated":"2022-04-14T08:45:20.666Z","comments":true,"path":"2022/04/14/执行上下文和作用域/","link":"","permalink":"https://coloey.github.io/2022/04/14/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"","text":"执行上下文有全局上下文和函数上下文，块级上下文： 上下文中的代码在执行时，会创建变量对象的一个作用域链，这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序，代码正在执行的上下文的变量对象始终位于作用域链的最前端，如果上下文时函数，则其活动对象用作变量对象，作用域链中的下一个变量对象来自包含上下文…以此类推至全局上下文，全局上下文变量对象始终是作用域链的最后一个变量对象（window) 作用域链增强执行上下文主要有全局上下文和函数上下文两种（eval()调用内部存在第三种上下文），但有其他方式增强作用域链， try/catch语句中的catch块 with语句 这两种情况会在作用域链的前端添加一个变量对象，对with语句来说，会向作用域链前端添加指定对象，对catch语句，会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明 1234567function buildUrl()&#123; let qs=&quot;?debug=true&quot;; with(location)&#123; let url=href+qs; &#125; return url;&#125; with语句将location对象作为上下文，因此location会被添加到作用域链的前端","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"原始值与引用值及确定类型","slug":"原始值与引用值及确定类型","date":"2022-04-14T07:04:04.000Z","updated":"2022-04-14T08:21:25.400Z","comments":true,"path":"2022/04/14/原始值与引用值及确定类型/","link":"","permalink":"https://coloey.github.io/2022/04/14/%E5%8E%9F%E5%A7%8B%E5%80%BC%E4%B8%8E%E5%BC%95%E7%94%A8%E5%80%BC%E5%8F%8A%E7%A1%AE%E5%AE%9A%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"原始值和引用值ECMAScript变量可以包含两种不同类型的数据：原始值和引用值，原始值就是最简单的数据：Undefined,Null,Boolean,Number,String,Symbol,保存原始值的变量是按值访问的，因为我们操作的就是存储在变量中的实际值。 引用值是保存在内存中的对象，JavaScript不允许直接访问内存位置，操作对象时，实际上操作的对该对象的引用，而非实际的对象本身，因此，保存引用值的变量是按引用访问的。 区别动态属性引用值可以随时添加，修改删除属性。 而原始值不能有属性，原始值的初始化只使用原始字面量形式，如果使用new关键字则JavaScript会创建一个Object类型的实例， 12345678let name1=&quot;Nicholas&quot;;let name2=new String(&quot;Matt&quot;);name1.age=27;name2.age=26;console.log(name1.age);//undefinedconsole.log(name2.age);//26console.log(typeof name1);//stringconsole.log(typeof name2);//object 复制值通过变量把一个原始值赋值到另一个变量时，原始值会被复制得到新变量的位置。 12let num1=5;let num2=num1; num1和num2相互独立，num2是num1的副本 当把引用值从一个变量赋值给另一个变量时，存储在变量中的值也会被复制到新变量所在位置，区别在于：这里复制的值时一个指针，它指向存储在堆内存中的对象。两个变量实际上指向同一个对象。 1234let obj1=new Object();let obj2=obj1;obj1.name=&quot;Nic&quot;;console.log(obj2.name);//Nic 传递参数ECMAScript中所有函数的参数都是按值传递，这意味着函数外的值会被复制到函数内部参数中，就像一个变量赋值到另一个变量一样，如果是原始值，那么就跟原始值变量的复制一样，如果是引用值就和引用值的变量复制一样。 123456789function addTen(num)&#123;//count的值被复制到参数num,函数内部num+10但不会影响函数外部的原始变量count num+=10; return num; &#125;let count=20;let res=addTen(count);console.log(count);//20，没有变化console.log(res);//30 如果是对象： 12345678function setName(obj)&#123; obj.name=&quot;Nic&quot;；//此时多了一个obj指针指向person,将name改为Nic obj=new Object();//又创建一个指针，指向内存其他位置 obj.name=&quot;Greg&quot;;//函数调用结束，obj被销毁&#125;let person=new Object();setName(person);console.log(person.name);//&#x27;Nic&#x27; typeoftypeof用来判断一个变量是否为原始类型，即判断一个变量是否为字符串，数字，布尔值或undefined的最好方式，值为对象null,那么typeof返回Object typeof虽然对原始值很有用，但是对引用值用处不大，我们通常关心一个值是不是对象，而是想知道它是什么类型的对象。 instanceof如果变量是给定引用类型的实例，则instanceof操作符返回true 1console.log(person instanceof Object);//变量person是Object吗 按照定义所有引用值都是Object的实例，因此通过instanceof检测的任何引用值和Object构造函数都会返回true。如果，使用instanceof检测原始值，则始终会返回false,因为原始值不是对象。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"原始值与引用值及确定类型","slug":"确定类型","date":"2022-04-14T07:04:04.000Z","updated":"2022-05-02T14:42:33.431Z","comments":true,"path":"2022/04/14/确定类型/","link":"","permalink":"https://coloey.github.io/2022/04/14/%E7%A1%AE%E5%AE%9A%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"原始值和引用值ECMAScript变量可以包含两种不同类型的数据：原始值和引用值，原始值就是最简单的数据：Undefined,Null,Boolean,Number,String,Symbol,保存原始值的变量是按值访问的，因为我们操作的就是存储在变量中的实际值。 引用值是保存在内存中的对象，JavaScript不允许直接访问内存位置，操作对象时，实际上操作的对该对象的引用，而非实际的对象本身，因此，保存引用值的变量是按引用访问的。 区别动态属性引用值可以随时添加，修改删除属性。 而原始值不能有属性，原始值的初始化只使用原始字面量形式，如果使用new关键字则JavaScript会创建一个Object类型的实例， 12345678let name1=&quot;Nicholas&quot;;let name2=new String(&quot;Matt&quot;);name1.age=27;name2.age=26;console.log(name1.age);//undefinedconsole.log(name2.age);//26console.log(typeof name1);//stringconsole.log(typeof name2);//object 复制值通过变量把一个原始值赋值到另一个变量时，原始值会被复制得到新变量的位置。 12let num1=5;let num2=num1; num1和num2相互独立，num2是num1的副本 当把引用值从一个变量赋值给另一个变量时，存储在变量中的值也会被复制到新变量所在位置，区别在于：这里复制的值时一个指针，它指向存储在堆内存中的对象。两个变量实际上指向同一个对象。 1234let obj1=new Object();let obj2=obj1;obj1.name=&quot;Nic&quot;;console.log(obj2.name);//Nic 传递参数ECMAScript中所有函数的参数都是按值传递，这意味着函数外的值会被复制到函数内部参数中，就像一个变量赋值到另一个变量一样，如果是原始值，那么就跟原始值变量的复制一样，如果是引用值就和引用值的变量复制一样。 123456789function addTen(num)&#123;//count的值被复制到参数num,函数内部num+10但不会影响函数外部的原始变量count num+=10; return num; &#125;let count=20;let res=addTen(count);console.log(count);//20，没有变化console.log(res);//30 如果是对象： 12345678function setName(obj)&#123; obj.name=&quot;Nic&quot;；//此时多了一个obj指针指向person,将name改为Nic obj=new Object();//又创建一个指针，指向内存其他位置 obj.name=&quot;Greg&quot;;//函数调用结束，obj被销毁&#125;let person=new Object();setName(person);console.log(person.name);//&#x27;Nic&#x27; typeoftypeof用来判断一个变量是否为原始类型，即判断一个变量是否为字符串，数字，布尔值或undefined的最好方式，值为对象null,那么typeof返回Object typeof虽然对原始值很有用，但是对引用值用处不大，我们通常关心一个值是不是对象，而是想知道它是什么类型的对象。 instanceof如果变量是给定引用类型的实例，则instanceof操作符返回true 1console.log(person instanceof Object);//变量person是Object吗 按照定义所有引用值都是Object的实例，因此通过instanceof检测的任何引用值和Object构造函数都会返回true。如果，使用instanceof检测原始值，则始终会返回false,因为原始值不是对象。 对象标识和相等判定ES6之前： 12console.log(+0===-0);//truecosole.log(NAN===NAN);//false ES6中的object.is()与===很像，但同时考虑了上述边界情形，这个方法接收两个参数： 1234console.log(Object.is(true,1));//falseconsole.log(Object.is(&#123;&#125;,&#123;&#125;));//falseconsole.log(Object.is(+0,-0));//falseconsole.log(Object.is(NAN,NAN));//true 检查超过两个值是否相等 1234function recursiveEqual(x,...rest)&#123; return Object.is(x,rest[0])||(rest.length&lt;2||recursiveEqual(...rest)); &#125; constructor:constructor两个作用， 判断数据的类型 对象实例通过prototype对象上的constructor访问它的构造函数，因此如果改变prototype对象，constructor就不能用来判断数据类型 123456console.log((2).constructor === Number); // trueconsole.log((true).constructor === Boolean); // trueconsole.log((&#x27;str&#x27;).constructor === String); // trueconsole.log(([]).constructor === Array); // trueconsole.log((function() &#123;&#125;).constructor === Function); // trueconsole.log((&#123;&#125;).constructor === Object); // true 12345678function Fn()&#123;&#125;; Fn.prototype = new Array(); var f = new Fn(); console.log(f.constructor===Fn); // falseconsole.log(f.constructor===Array); // true Object.prototype.toString.call()Object.prototype.toString.call()使用Object对象的原型方法toString来判断数据类型 12345678910var a = Object.prototype.toString; console.log(a.call(2));console.log(a.call(true));console.log(a.call(&#x27;str&#x27;));console.log(a.call([]));console.log(a.call(function()&#123;&#125;));console.log(a.call(&#123;&#125;));console.log(a.call(undefined));console.log(a.call(null)); 注意：同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是因为toString是Object的原型方法，而Array,function等类型作为Object的实例，都重写了toString()方法，不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString()方法，（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"原型模式","slug":"原型模式","date":"2022-04-13T14:03:03.000Z","updated":"2022-05-02T16:03:58.907Z","comments":true,"path":"2022/04/13/原型模式/","link":"","permalink":"https://coloey.github.io/2022/04/13/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"构造函数构造函数也是函数，与普通函数唯一区别就是调用方式不同。任何函数只要使用new操作符调用就是构造函数，而不适用new操作符调用的函数就是普通函数。 理解原型只要创建一个函数，就会按照特定的规则为这个函数创建一个prototype属性（指向原型对象），默认情况下，所有原型对象会自动获得一个名为constructor指向Person 123456789101112131415161718192021222324function Person()&#123;&#125; console.log(typeof Person.prototype); console.log(Person.prototype); //正常原型链都会终止于Object的原型对象 //Object原型的原型是null console.log(Person.prototype.__proto__===Object.prototype);//true console.log(Person.prototype.__proto__.constructor===Object);//true console.log(Person.prototype.__proto__.__proto__===null);//true console.log(Person.prototype.__proto__);//true let person1=new Person(),person2=new Person(); //构造函数，原型对象和实例是3个完全不同的对象 console.log(person1!==Person);//true console.log(person1!==Person.prototype);//true console.log(Person.prototype!==Person);//true //实例通过__proto__链接到原型对象，它实际上指向隐藏特性[[Prototype]] //实例与构造函数没有联系，与原型对象有直接联系 console.log(person1.__proto__===Person.prototype); console.log(person1.__proto__.constructor===Person); //同一个构造函数创建的两个实例共享同一个原型对象 console.log(person1.__proto__===person2.__proto__); //instanceof检查实例的原型链中是否包含指定构造函数的原型 console.log(person1 instanceof Person);//true console.log(person1 instanceof Object);//true console.log(Person.prototype instanceof Object);//true Person构造函数，Person原型对象和Person现有实例的关系如上：Person.prototype指向原型对象，因此Person.prototye.constructor指回Person构造函数。原型对象包含constructor属性和其他后来添加的属性。Person的两个实例person1,person2有一个内部属性指回Person.prototype,而且两者和构造函数没有直接联系。person1.sayName()可以正常调用，这是由于对象属性查找机制的原因 虽然不是所有实现都对外暴露[[Prototype]]，但可以使用isPrototypeOf()方法确定两个对象之间的关系，本质上isPrototypeOf()会在传入参数的[[Prototype]]指向调用它的对象时返回true 12console.log(Person.prototype.isprototypeOf(person1));//trueconsole.log(Person.prototype.isprototypeOf(person2));//true Object类型有一个方法叫Object.getPrototypeOf(),返回参数的内部特性[[Prototype]]的值 12console.log(Object.getPrototypeOf(person1)==Person.prototype);//trueconsole.log(Object.getPrototypeOf(person1).name); 使用Object.getPrototypeOf()可以取得一个对象的原型 Object类型还有一个setPrototypeOf()方法，可以向实例的私有特性[[Prototype]]写入一个新值，这样就可以重写一个对象的原型继承关系 12345678910let biped=&#123; numLegs:2 &#125;; let person=&#123; name:&#x27;Matt&#x27; &#125;; Object.setPrototypeOf(person,biped); console.log(person.name); console.log(person.numLegs); console.log(Object.getPrototypeOf(person)===biped); Object.setPrototypeOf()可能会严重影响代码性能，会涉及所有访问了哪些修改过[[Prototype]]的对象的代码 可以通过Object.create()创建一个新对象，同时为其指定原型 12345678let biped=&#123; numLegs:2&#125;;let person=Object.create(biped);person.name=&#x27;Matt&#x27;;console.log(person.name);console.log(person.numLegs);console.log(Object.getPrototypeOf(person)===biped);//true 原型层级通过对象访问属性时会按照这个属性名称开始搜索，搜索开始于对象实例本身，如果在实例上发现给定的名称，则返回该名称对应值，如果没有找到这个属性，则搜索会沿着指针进入原型对象，在原型对象找到属性后返回对应值。 比如foo不直接存在于myObject中而是存在于原型链上层时，myObject.foo=”bar”会出现三种情况： 如果在[[Prototype]]链上层存在名为foo的普通数据访问属性，并且writable:true,那就会直接在myObject中添加一个名为foo的新属性，它是屏蔽属性 如果在[[Prototype]]链上层存在foo,但是它是被标记为只读(writable:false)，那么无法修改已有属性或者在myObject上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。不会发生屏蔽 如果在[[Prototype]]链上层存在foo并且它是一个setter，那就一定会调用这个setter,foo不会添加到myObject，也不会重新定义foo这个setter。 当属性被屏蔽时，可以使用delete删除实例上的这个属性。 1234567891011function Person()&#123;&#125;Person.prototype.name=&#x27;Nicholas&#x27;;Person.prototype.age=29;let person1=new Person();let person2=new Person();person1.name=&quot;Greg&quot;;console.log(person1.name);//&quot;Greg&quot;,来自实例console.log(person2.name);//Nicholas,来自原型delete person1.name;console.log(person1.name);//Nicholas,来自原型 hasOwnProperty()hasOwnProperty()方法用于确定某个属性是在实例上还是原型对象上。这个方法继承自Object，会在属性存在于调用它的对象实例善时返回true in操作符in操作符会在可以通过对象访问指定属性时返回true，无论该属性是在实例上还是在原型上 因此如果要确定某个属性是否在原型上可以同时使用hasOwnProperty()和in操作符 123function hasPrototypeProperty(object,name)&#123; return !Object.hasOwnProperty(name)&amp;&amp;(name in object)&#125; 原型的问题弱化了向构造函数传递初始化参数的能力，会导致所有实例默认取得属性相同的值，以及它的共享特性： 1234567891011121314151617function Person()&#123; Person.prototype=&#123; constructor:Person, name:&#x27;nic&#x27;, age:29, job:&quot;Software Engineer&quot;, friends:[&#x27;Coloey&#x27;,&#x27;Amy&#x27;], sayName()&#123; console.log(this.name) &#125; &#125; &#125; let person1=new Person(); let person2=new Person(); person1.friends.push(&#x27;Van&#x27;); console.log(person1.friends===person2.friends);//true 不同实例应有不同的副本。 原型链原型链是ECMAScript的主要继承方式 1234567891011121314151617function SuperType()&#123; this.property=true; &#125; SuperType.prototype.getSuperValue=function()&#123; return this.property; &#125; function SubType()&#123; this.subproperty=false; &#125; //继承SuperType SubType.prototype=new SuperType(); SubType.prototype.getSubValue=function()&#123; return this.subproperty; &#125; let instance=new SubType(); console.log(instance.getSuperValue());//true console.log(instance.property)//true SubType.prototype是SuperType的实例，因此SubType.prototype指向SuperType.prototype,注意，getSuperValue()方法还在SuperType.prototype对象上，而property是一个实例属性，SubType.prototype是SuperType的实例，因此property存在它上面，由于SubType.prototype的constructor属性被重写指向SuperType,所以instance.constructor也指向SuperType. 原型与继承关系使用instanceOf操作符，如果一个实例的原型链出现过相应构造函数则instanceOf返回true 12console.log(instance instanceof Object);console.loh(instance instanceof SubType); 使用**isPrototypeOf()**方法，原型链上的每个原型都可以调用这个方法，只要原型链上包含这个原型就返回true 123console.log(Object.prototype.isPrototypeOf(instance));//true console.log(SuperType.prototype.isPrototypeOf(instance));//true console.log(SubType.prototype.isPrototypeOf(instance));//true 以对象字面量的方式创建原型方法会破坏之前的原型链： 1234567891011121314151617181920212223function SuperType()&#123; this.property=true; &#125; SuperType.prototype.getSuperValue=function()&#123; return this.property; &#125; function SubType()&#123; this.subproperty=false; &#125; //继承SuperType SubType.prototype=new SuperType();//通过对象字面量添加新方法，会导致上一行无效 SubType.prototype=&#123; getSubValue()&#123; return this.subproperty; &#125;, someOtherMethod()&#123; return false; &#125; &#125; let instance=new SubType(); console.log(instance.getSuperValue());//出错 原型链的问题就是会在原型中包含的引用值会在实例间共享。 1234567891011function SuperType()&#123; this.color=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;] &#125; function SubType()&#123; &#125; SubType.prototype=new SuperType(); let intance1=new SubType(); intance1.color.push(&quot;black&quot;); console.log(intance1.color); let instance2=new SubType(); console.log(instance2.color); 盗用构造函数12345678910111213function SuperType()&#123; this.color=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;] &#125; function SubType()&#123; //继承SuperType SuperType.call(this); &#125; //SubType.prototype=new SuperType(); let intance1=new SubType(); intance1.color.push(&quot;black&quot;); console.log(intance1.color); let instance2=new SubType(); console.log(instance2.color); 使用call()，SuperType构造函数在为SubType的实例创建的新对象的上下文中执行了，相当于新的SubType对象上运行了SuperType()函数的所有初始化代码 传递参数：123456789101112function SuperType(arr)&#123; this.color=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;] arr.forEach(item=&gt;this.color.push(item)); &#125; function SubType()&#123; //继承SuperType SuperType.call(this,[&#x27;black&#x27;]); &#125; let intance1=new SubType(); console.log(intance1.color);//[&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27;] let instance2=new SubType(); console.log(instance2.color);//[&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27;] 问题：也是使用构造函数模式自定义类型的问题：必须在构造函数中定义方法，因此函数不能重用，此外，子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"遍历","slug":"遍历","date":"2022-04-13T09:33:34.000Z","updated":"2022-04-13T09:56:49.229Z","comments":true,"path":"2022/04/13/遍历/","link":"","permalink":"https://coloey.github.io/2022/04/13/%E9%81%8D%E5%8E%86/","excerpt":"","text":"for…in 用来遍历对象的可枚举属性列表 forEach(…)用来遍历数组中的所有普值并忽略回调函数的返回值 for…of直接遍历值，会首先向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来遍历所有返回值 自定义对象迭代器 1234567891011121314151617181920212223242526272829var myObject=&#123; a:2, b:3 &#125;; Object.defineProperty(myObject,Symbol.iterator,&#123; enumerable:false, writable:false, configurable:true, value:function()&#123; var o=this; var idx=0; var ks=Object.keys(o);//获取Object对象所有键值 return&#123; next:function()&#123;//next是一个函数 return&#123; value:o[ks[idx++]], done:(idx&gt;ks.length) &#125; &#125; &#125; &#125; &#125;) var it=myObject[Symbol.iterator](); it.next(); it.next(); it.next(); for(let v of myObject)&#123; console.log(v); &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"Object","slug":"Object","date":"2022-04-13T09:25:11.000Z","updated":"2022-04-13T09:25:12.130Z","comments":true,"path":"2022/04/13/Object/","link":"","permalink":"https://coloey.github.io/2022/04/13/Object/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"理解this","slug":"理解this","date":"2022-04-13T07:56:41.000Z","updated":"2022-05-02T03:20:59.790Z","comments":true,"path":"2022/04/13/理解this/","link":"","permalink":"https://coloey.github.io/2022/04/13/%E7%90%86%E8%A7%A3this/","excerpt":"","text":"判断this指向： 由new调用？绑定到新创建的对象 由call或者apply（获得bind)调用?)绑定到指定对象 由上下文对象调用，绑定到那个上下文对象 默认：严格模式下绑定undefined否则绑定全局对象 箭头函数例外，会根据当前词法作用域来决定this,会绑定第一个在作用域链上找到的标识符。 this 的指向在 ES5 中，其实 this 的指向，始终坚持一个原理：this 永远指向最后调用它的那个对象，来，跟着我朗读三遍：this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象。记住这句话，this 你已经了解一半了。 下面我们来看一个最简单的例子：例 1： 12345678910var name = &quot;windowsName&quot;;function a() &#123; var name = &quot;Cherry&quot;; console.log(this.name); // windowsName console.log(&quot;inner:&quot; + this); // inner: Window&#125;a();console.log(&quot;outer:&quot; + this) // outer: Window复制代码 这个相信大家都知道为什么 log 的是 windowsName，因为根据刚刚的那句话“this 永远指向最后调用它的那个对象”，我们看最后调用 a 的地方 a();，前面没有调用的对象那么就是全局对象 window，这就相当于是 window.a()；注意，这里我们没有使用严格模式，如果使用严格模式的话，全局对象就是 undefined，那么就会报错 Uncaught TypeError: Cannot read property &#39;name&#39; of undefined。 再看下这个例子：例 2： 12345678var name = &quot;windowsName&quot;;var a = &#123; name: &quot;Cherry&quot;, fn : function () &#123; console.log(this.name); // Cherry &#125;&#125;a.fn();复制代码 在这个例子中，函数 fn 是对象 a 调用的，所以打印的值就是 a 中的 name 的值。是不是有一点清晰了呢~ 我们做一个小小的改动：例 3： 12345678var name = &quot;windowsName&quot;; var a = &#123; name: &quot;Cherry&quot;, fn : function () &#123; console.log(this.name); // Cherry &#125; &#125; window.a.fn();复制代码 这里打印 Cherry 的原因也是因为刚刚那句话“this 永远指向最后调用它的那个对象”，最后调用它的对象仍然是对象 a。 我们再来看一下这个例子：例 4： 12345678var name = &quot;windowsName&quot;;var a = &#123; // name: &quot;Cherry&quot;, fn : function () &#123; console.log(this.name); // undefined &#125;&#125;window.a.fn();复制代码 这里为什么会打印 undefined 呢？这是因为正如刚刚所描述的那样，调用 fn 的是 a 对象，也就是说 fn 的内部的 this 是对象 a，而对象 a 中并没有对 name 进行定义，所以 log 的 this.name 的值是 undefined。 这个例子还是说明了：this 永远指向最后调用它的那个对象，因为最后调用 fn 的对象是 a，所以就算 a 中没有 name 这个属性，也不会继续向上一个对象寻找 this.name，而是直接输出 undefined。 再来看一个比较坑的例子：例 5： 1234567891011var name = &quot;windowsName&quot;;var a = &#123; name : null, // name: &quot;Cherry&quot;, fn : function () &#123; console.log(this.name); // windowsName &#125;&#125;var f = a.fn;f();复制代码 这里你可能会有疑问，为什么不是 Cherry，这是因为虽然将 a 对象的 fn 方法赋值给变量 f 了，但是没有调用，再接着跟我念这一句话：“this 永远指向最后调用它的那个对象”，由于刚刚的 f 并没有调用，所以 fn() 最后仍然是被 window 调用的。所以 this 指向的也就是 window。 由以上五个例子我们可以看出，this 的指向并不是在创建的时候就可以确定的，在 es5 中，永远是this 永远指向最后调用它的那个对象。 再来看一个例子：例 6： 1234567891011var name = &quot;windowsName&quot;;function fn() &#123; var name = &#x27;Cherry&#x27;; innerFunction(); function innerFunction() &#123; console.log(this.name); // windowsName &#125;&#125;fn()复制代码 读到现在了应该能够理解这是为什么了吧(oﾟ▽ﾟ)o。 怎么改变 this 的指向改变 this 的指向我总结有以下几种方法： 使用 ES6 的箭头函数 在函数内部使用 _this = this 使用 apply、call、bind new 实例化一个对象 例 7： 123456789101112131415161718var name = &quot;windowsName&quot;;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;,100); &#125;&#125;;a.func2() // this.func1 is not a function复制代码 在不使用箭头函数的情况下，是会报错的，因为最后调用 setTimeout 的对象是 window，但是在 window 中并没有 func1 函数。 我们在改变 this 指向这一节将把这个例子作为 demo 进行改造。 箭头函数众所周知，ES6 的箭头函数是可以避免 ES5 中使用 this 的坑的。箭头函数的 this 始终指向函数定义时的 this，而非执行时。箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。箭头函数的绑定无法被修改，new也不可以 例 8 ： 123456789101112131415161718var name = &quot;windowsName&quot;;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( () =&gt; &#123; this.func1() &#125;,100); &#125;&#125;;a.func2() // Cherry复制代码 在函数内部使用 _this = this如果不使用 ES6，那么这种方式应该是最简单的不会出错的方式了，我们是先将调用这个函数的对象保存在变量 _this 中，然后在函数中都使用这个 _this，这样 _this 就不会改变了。例 9： 1234567891011121314151617181920var name = &quot;windowsName&quot;;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; var _this = this; setTimeout( function() &#123; _this.func1() &#125;,100); &#125;&#125;;a.func2() // Cherry复制代码 这个例子中，在 func2 中，首先设置 var _this = this;，这里的 this 是调用 func2 的对象 a，为了防止在 func2 中的 setTimeout 被 window 调用而导致的在 setTimeout 中的 this 为 window。我们将 this(指向变量 a) 赋值给一个变量 _this，这样，在 func2 中我们使用 _this 就是指向对象 a 了。 使用 apply、call、bind使用 apply、call、bind 函数也是可以改变 this 的指向的，原理稍后再讲，我们先来看一下是怎么实现的： 使用 apply例 10： 12345678910111213141516var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.apply(a),100); &#125;&#125;;a.func2() // Cherry复制代码 使用 call例 11： 12345678910111213141516var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.call(a),100); &#125;&#125;;a.func2() // Cherry复制代码 使用 bind例 12： 12345678910111213141516var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.bind(a)(),100); &#125;&#125;;a.func2() // Cherry复制代码 apply、call、bind 区别刚刚我们已经介绍了 apply、call、bind 都是可以改变 this 的指向的，但是这三个函数稍有不同。 在 MDN 中定义 apply 如下； apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数 语法： fun.apply(thisArg, [argsArray]) thisArg：在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。 argsArray：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。浏览器兼容性请参阅本文底部内容。 apply 和 call 的区别其实 apply 和 call 基本类似，他们的区别只是传入的参数不同。 call 的语法为： 1fun.call(thisArg[, arg1[, arg2[, ...]]])复制代码 所以 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。 例 13： 123456789var a =&#123; name : &quot;Cherry&quot;, fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.apply(a,[1,2]) // 3复制代码 例 14： 123456789var a =&#123; name : &quot;Cherry&quot;, fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.call(a,1,2) // 3复制代码 bind 和 apply、call 区别我们先来将刚刚的例子使用 bind 试一下 123456789var a =&#123; name : &quot;Cherry&quot;, fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.bind(a,1,2)复制代码 我们会发现并没有输出，这是为什么呢，我们来看一下 MDN 上的文档说明： bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。 所以我们可以看出，bind 是创建一个新的函数，我们必须要手动去调用： 123456789var a =&#123; name : &quot;Cherry&quot;, fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.bind(a,1,2)() // 3复制代码 ==================================== 更新============================== JS 中的函数调用看到留言说，很多童靴不理解为什么 例 6 的 innerFunction 和 例 7 的 this 是指向 window 的，所以我就来补充一下 JS 中的函数调用。例 6： 1234567891011var name = &quot;windowsName&quot;;function fn() &#123; var name = &#x27;Cherry&#x27;; innerFunction(); function innerFunction() &#123; console.log(this.name); // windowsName &#125;&#125;fn()复制代码 例 7： 123456789101112131415161718var name = &quot;windowsName&quot;;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;,100); &#125;&#125;;a.func2() // this.func1 is not a function复制代码 函数调用的方法一共有 4 种 作为一个函数调用 函数作为方法调用 使用构造函数调用函数 作为函数方法调用函数（call、apply） 作为一个函数调用比如上面的 例 1：例 1： 12345678910var name = &quot;windowsName&quot;;function a() &#123; var name = &quot;Cherry&quot;; console.log(this.name); // windowsName console.log(&quot;inner:&quot; + this); // inner: Window&#125;a();console.log(&quot;outer:&quot; + this) // outer: Window复制代码 这样一个最简单的函数，不属于任何一个对象，就是一个函数，这样的情况在 JavaScript 的在浏览器中的非严格模式默认是属于全局对象 window 的，在严格模式，就是 undefined。 但这是一个全局的函数，很容易产生命名冲突，所以不建议这样使用。 函数作为方法调用所以说更多的情况是将函数作为对象的方法使用。比如例 2：例 2： 12345678var name = &quot;windowsName&quot;;var a = &#123; name: &quot;Cherry&quot;, fn : function () &#123; console.log(this.name); // Cherry &#125;&#125;a.fn();复制代码 这里定义一个对象 a，对象 a 有一个属性（name）和一个方法（fn）。 然后对象 a 通过 . 方法调用了其中的 fn 方法。 然后我们一直记住的那句话“this 永远指向最后调用它的那个对象”，所以在 fn 中的 this 就是指向 a 的。 使用构造函数调用函数 如果函数调用前使用了 new 关键字, 则是调用了构造函数。这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象： 123456789// 构造函数:function myFunction(arg1, arg2) &#123; this.firstName = arg1; this.lastName = arg2;&#125;// This creates a new objectvar a = new myFunction(&quot;Li&quot;,&quot;Cherry&quot;);a.lastName; // 返回 &quot;Cherry&quot;复制代码 这就有要说另一个面试经典问题：new 的过程了，(ಥ_ಥ)这里就简单的来看一下 new 的过程吧：伪代码表示： 12345678var a = new myFunction(&quot;Li&quot;,&quot;Cherry&quot;);new myFunction&#123; var obj = &#123;&#125;; obj.__proto__ = myFunction.prototype; var result = myFunction.call(obj,&quot;Li&quot;,&quot;Cherry&quot;); return typeof result === &#x27;obj&#x27;? result : obj;&#125;复制代码 创建一个空对象 obj; 将新创建的空对象的隐式原型指向其构造函数的显示原型。 使用 call 改变 this 的指向 如果无返回值或者返回一个非对象值，则将 obj 返回作为新对象；如果返回值是一个新对象的话那么直接直接返回该对象。 所以我们可以看到，在 new 的过程中，我们是使用 call 改变了 this 的指向。 作为函数方法调用函数 在 JavaScript 中, 函数是对象。 JavaScript 函数有它的属性和方法。call() 和 apply() 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身 在 JavaScript 严格模式(strict mode)下, 在调用函数时第一个参数会成为 this 的值， 即使该参数不是一个对象。在 JavaScript 非严格模式(non-strict mode)下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代。 这个时候我们再来看例 6：例 6： 1234567891011var name = &quot;windowsName&quot;;function fn() &#123; var name = &#x27;Cherry&#x27;; innerFunction(); function innerFunction() &#123; console.log(this.name); // windowsName &#125;&#125;fn()复制代码 这里的 innerFunction() 的调用是不是属于第一种调用方式：作为一个函数调用（它就是作为一个函数调用的，没有挂载在任何对象上，所以对于没有挂载在任何对象上的函数，在非严格模式下 this 就是指向 window 的） 然后再看一下 例 7：例 7： 123456789101112131415161718var name = &quot;windowsName&quot;;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;,100 ); &#125;&#125;;a.func2() // this.func1 is not a function复制代码 这个简单一点的理解可以理解为“匿名函数的 this 永远指向 window”，你可以这样想，还是那句话this 永远指向最后调用它的那个对象，那么我们就来找最后调用匿名函数的对象，这就很尴尬了，因为匿名函数名字啊，笑哭，所以我们是没有办法被其他对象调用匿名函数的。所以说 匿名函数的 this 永远指向 window。 如果这个时候你要问，那匿名函数都是怎么定义的，首先，我们通常写的匿名函数都是自执行的，就是在匿名函数后面加 () 让其自执行。其次就是虽然匿名函数不能被其他对象调用，但是可以被其他函数调用啊，比如例 7 中的 setTimeout。 转自（作者：sunshine小小倩链接：https://juejin.cn/post/6844903496253177863来源：稀土掘金）","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"理解闭包","slug":"理解闭包","date":"2022-04-13T06:15:41.000Z","updated":"2022-04-13T06:48:13.918Z","comments":true,"path":"2022/04/13/理解闭包/","link":"","permalink":"https://coloey.github.io/2022/04/13/%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/","excerpt":"","text":"123456789function foo()&#123; var a=2; function bar()&#123; console.log(a); &#125; return bar; &#125; var baz=foo(); baz();//2 内部函数bar()能够访问foo()的内部作用域，将bar()函数本身作为值类型传递，调用foo()，我们通常希望整个内部作用域被销毁，然而因为bar()所声明的位置拥有涵盖foo()内部作用域的闭包，使得作用域一直存活，以供bar()在任何时间之后进行引用。内部函数依然持有对外部函数的作用域的引用，这个引用就叫做闭包 总结来说：本质就是上级作用域内变量的生命周期，因为被下级作用域内引用，而没有被释放。就导致上级作用域内的变量，等到下级作用域执行完以后才正常得到释放。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"CSS画三角","slug":"CSS画三角","date":"2022-04-13T03:36:52.000Z","updated":"2022-04-13T06:17:31.861Z","comments":true,"path":"2022/04/13/CSS画三角/","link":"","permalink":"https://coloey.github.io/2022/04/13/CSS%E7%94%BB%E4%B8%89%E8%A7%92/","excerpt":"","text":"1234567891011div &#123; width:0; height:0; border: 10px solid transparent; border-left-color:pink; /*照顾兼容性*/ line-height:0; font-size:0; &#125; margin负值巧妙使用 12345678910111213141516171819202122232425262728&lt;style&gt; ul li &#123; list-style-type: none; float:left; width: 150px; height: 200px; border:1px solid red; margin-left: -1px; &#125; ul li:hover &#123; /* 如果盒子没有定位则添加相对定位使得合资压住所有其他标准流 */ position:relative; border: 1px solid blue; &#125; ul li :hover &#123; /* 如果盒子有定位设置z-index提高盒子层级 */ z-index:1; border: 1px solid blue; &#125; &lt;/style&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"}],"tags":[]},{"title":"清除浮动","slug":"清除浮动","date":"2022-04-13T01:36:28.000Z","updated":"2022-04-13T03:36:27.389Z","comments":true,"path":"2022/04/13/清除浮动/","link":"","permalink":"https://coloey.github.io/2022/04/13/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/","excerpt":"","text":"为什么需要清除浮动由于父级盒子很多情况下，不方便给高度，当时盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会影响下面的盒子，对后面元素排版产生影响。 清除浮动本质 清除浮动的本质是清除浮动元素造成的影响 如果父盒子本身具有高度，则不需要清除浮动 清除浮动之后，父级会根据浮动的子盒子自动检测高度，父级有了高度，就不会影响下面的标准流了 语法： 123选择器: &#123; clear: 属性值;&#125; 属性值 描述 left 不允许左侧有浮动元素 right 不允许右侧有浮动元素 both 同时清除左右两侧浮动 清除浮动策略：闭合浮动 方法： 额外标签法（隔墙法），是 W3C 推荐的方法 父级添加 overflow 属性 父级添加 after 伪元素 父级添加双伪元素 额外标签法也称为隔墙法，是 W3C 推荐的方法。 额外标签法是在最后一个浮动元素末尾添加一个 空块级元素（不能是行内元素），给其赋以属性 clear:both;。 1234&lt;style&gt; clear: both;&lt;/style&gt;&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;Copy to clipboardErrorCopied 优点：通俗易懂，书写方便 缺点：添加许多无意义的标签，结构化差 总结 清除浮动的本质 清除浮动的本质是清除浮动元素脱离标准流造成的影响 清除浮动的策略 闭合浮动，只让浮动在父盒子内部影响，不影响父盒子外面的其他盒子。 使用场景 实际开发中可能会遇到，但是不常用。 父级添加 overflow 属性可以给父级添加 overflow 属性，将其属性设置为 hidden、auto或scroll。 注意是给父元素添加代码： 优点：代码简洁 缺点：无法显示溢出部分 父级添加 after 伪元素实际上也是额外标签法的一种。（相当于在最后一个子元素后面再添加一个元素隔开） 123456789101112.clearfix &#123; content: &quot;&quot;; display: block;//伪元素为行内块元素，要转换为块级元素 height: 0; clear: both; visibility: hidden;&#125;.clearfix &#123; /*IE6、7专有*/ *zoom: 1;&#125; 父级添加双伪元素1234567891011.clearfix::before,.clearfix::after &#123; content: &quot;&quot;;//前后都隔开 display: table;//伪元素为行内块元素，要转换为块级元素&#125;.clearfix::after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125;Copy to clipboardErrorCopied 优点：代码更简洁 缺点：照顾低版本浏览器 代表网站：小米、腾讯 伪元素转化为块级元素原因：根本原因是为了解决clearfix内部非浮动元素margin塌陷问题。 另发现一个新属性display: flow-root，不支持Safari。它可以创建无副作用的BFC。在父级块中使用 display: flow-root 可以创建新的BFC。其作用和clearfix一致。 参考： 为什么需要清除浮动？ 父级没高度 子盒子浮动了 影响下面布局了，应该清除浮动。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"}],"tags":[]},{"title":"HTTPS","slug":"HTTPS","date":"2022-04-12T14:02:46.000Z","updated":"2022-05-07T13:14:10.370Z","comments":true,"path":"2022/04/12/HTTPS/","link":"","permalink":"https://coloey.github.io/2022/04/12/HTTPS/","excerpt":"","text":"HTTP+加密+认证+完整性保护=HTTPSHTTPS是HTTP通信接口部分用SSL和TLS协议代替。 SSL是独立于HTTP的协议 相互交换密钥的公开密钥加密技术共享密钥加密加密和解密用一个密钥的方式，也叫做对称密钥加密 使用两把密钥的公开密钥加密使用非对称的密钥，一把叫做私有密钥，另一把叫做公有密钥，私有密钥不能让任何人知道，公有密钥可以随意发布。 发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密，解密过程是队离散对数的求值。 HTTPS采用混合加密机制 证明公开密钥正确性的证书 HTTPS的安全通信机制 客户端通过发送Client Hello报文开始SSL通信，报文中包含客户端支持的SSL的指定版本，加密组件列表 服务器可进行SSL通信时，会以Server Hello报文作为应答，和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的 之后服务器发送Certificate报文，报文中包含公开密钥证书 最后服务器发送Server Hello Done 报告通知客户端，最初阶段的SSL握手协商部分结束 SSL第一次握手结束后，客户端以Client Key Exchange报文作为回应，报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串，该报文已用步骤3中的公开密钥进行加密 接着客户端继续发送Change Cipher Spec报文，该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密 客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否正确解密该报文作为判定标准 服务器同样发送Change Cipher Spec报文 服务器同样发送Finished报文 服务端和客户端的Finished报文交换完毕后，SSL连接就建立完成。通信会受到SSL保护，从此开始进行应用层协议通信，即发送HTTP请求 SSL缺点： 通信慢 大量消耗CPU及内存资源，导致处理速度慢","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"HTTP","slug":"计算机网络/HTTP","permalink":"https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/"}],"tags":[]},{"title":"WebSocket","slug":"WebSocket","date":"2022-04-12T09:46:11.000Z","updated":"2022-04-12T10:03:19.606Z","comments":true,"path":"2022/04/12/WebSocket/","link":"","permalink":"https://coloey.github.io/2022/04/12/WebSocket/","excerpt":"","text":"初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？ 答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。 举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。 这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用“轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。 轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。 使用浏览器进行全双工通信的WebSocketWebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 其他特点包括： （1）建立在 TCP 协议之上，服务器端的实现比较容易。 （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 （3）减少通信量，只要建立起WebSocket连接，就希望一直保持连接，和http相比，不但每次连接时走开小减少。而且数据格式比较轻量，性能开销小，通信高效。 （4）可以发送文本，也可以发送二进制数据。 （5）没有同源限制，客户端可以与任意服务器通信。 （6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 1ws://example.com:80/some/path 握手请求1Upgrade:websocket Set-WebSocket-Key字段内记录着握手过程中必不可少的键值，Sec-WebSocket-Protocol字段内记录使用的子协议，子协议按WebSocket协议标准在连接分开使用时，定义那些连接的名称 握手响应对于之前的请求，返回状态码101 Switching Protocols的响应","categories":[{"name":"WebSocket","slug":"WebSocket","permalink":"https://coloey.github.io/categories/WebSocket/"}],"tags":[]},{"title":"返回结果的http状态码","slug":"返回结果的http状态码","date":"2022-04-11T11:58:12.000Z","updated":"2022-04-11T13:30:34.582Z","comments":true,"path":"2022/04/11/返回结果的http状态码/","link":"","permalink":"https://coloey.github.io/2022/04/11/%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84http%E7%8A%B6%E6%80%81%E7%A0%81/","excerpt":"","text":"状态码作用：状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果，借助状态码，用户可以知道服务器时正常处理了请求，还是出现了错误。 状态码类别： 类别 原因短语 1xx Informational(信息状态码) 接收的请求正在处理 2xx Success(成功状态码) 请求正常处理完毕 3xx Redirection(重定向状态码) 需要进行附加操作以完成请求 4xx Client Error(客户端错误状态码) 服务器无法处理请求 5xx Server Error(服务器错误状态码) 服务器处理请求出错 2xx成功200 OK表示从客户端发来的请求在服务器端被正常处理了 在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。比如，使用Get方法，对应请求支援的实体会作为响应返回；而使用HEAD方法时，对应请求资源的实体首部不随报文实体作为响应返回。（即在响应中只返回首部，不返回实体主体部分） 204 No Content该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，不允许返回任何实体的主体。比如，当从浏览器中发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新。 一般在只需要从客户端往服务器发送消息，而对客户端不需要发送新消息内容的情况下使用 206 Partial Content该状态码表示客户端进行范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容 3xx重定向3xx响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。 301 Moved Permanently永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应该使用资源现在所指的URI，也就是说，如果已经把资源对应的URI保存为书签，这时应该按Location首部字段提示的URI重新保存。 eg: http://example.com/sample 当指定资源路径的最后忘记添加“/“，就会产生301状态码 302 Found临时性重定向，该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。和301 Moved Permanently状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质。换句话说，已移动的资源对应的URI将来还有可能发生改变。用户把URI保存成书签，但不会像301状态码出现时那样去更新书签，而是仍旧保留返回的302状态码的页面对应的URI。 303 See Other该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。303状态码和302Found状态码有着相同功能。但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。比如，当使用POST方法访问CGI程序，其执行后的处理结果是希望客户端能以GET方法重定向到另一个URI上去时，返回303状态码。 当301,302,303返回响应码时，几乎所有浏览器都会把POST改为GET，并删除请求报文的主体，之后请求会自动再次发送。 301,302标准是禁止将POST改为GET，但实际上大家都这么做。 304 Not Modified该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况，304状态码返回时，不包括任何响应的主体部分。304和重定向没有关系。 307 Temporary Redirect临时重定向。该状态码与302 Found有着相同的含义。尽管302标准禁止POST变为GET，但实际使用时大家并不遵守。307会按照浏览器标准，不会从POST变成GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同情况。 4xx客户端错误4xx的响应结果表明客户端时发生错误的原因所在 400 Bad Request该状态码表示请求报文中存在语法错误，当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像200 Ok一样对待状态码 401 Unauthorized该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。 返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用于质询用户信息，当浏览器初次接收到401响应，会弹出认证用的对话窗口。 403 Forbidden该状态码表明对请求资源的访问被服务器拒绝了。服务端没有给出拒绝的详细理由，但如果做说明，可以在实体的主体部分对原因进行描述。 未获得文件系统的访问授权，访问权限出现某些问题（从未授权的源IP地址试图访问）等列举的情况都可能是发生403的原因。 404 Not Found该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务端拒绝请求且不想说理由时使用。 5xx服务器错误5xx的响应结果表明服务器本身发生错误 500 Internal Server Error表明服务器端在执行请求时发生了错误，也有可能时Web应用存在的bug或某些临时的故障 503 Service Unavailable表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端。 状态码和状况不一致： 不少返回的状态码响应都是错误的，但是用户可能察觉不到这点，比如Web应用程序内部发生错误，状态码依然返回200 OK。","categories":[{"name":"http","slug":"http","permalink":"https://coloey.github.io/categories/http/"}],"tags":[]},{"title":"http请求首部字段","slug":"http请求首部字段","date":"2022-04-11T11:53:59.000Z","updated":"2022-05-02T15:05:47.809Z","comments":true,"path":"2022/04/11/http请求首部字段/","link":"","permalink":"https://coloey.github.io/2022/04/11/http%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5/","excerpt":"","text":"Accept Accept:text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 Accept首部字段通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可用type/subtype这种形式，一次指定多种媒体类型。 文本文件：text/html,text/plain,text/css… application/xhtml+xml,application/xml… 图片文件：image/jpg,image/gif… 视频文件：video/mpeg,video/quicktime… 应用程序使用的二进制文件：application/octet-stream,application/zip… 若想给显示的媒体类型增加优先级，使用q=来额外表示权重值，用分号（；）进行分隔，权重值q范围是0~1,（可精确到小数点后3位，且1为最大值。不指定权重值q时，默认权重为q=1.0 当服务器提供多种内容时，将首先返回权重值最高的媒体类型。 Accept-Charset Accept-Charset:iso-8859-5,unicode-1-1;q=0.8 Accept-Charset首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与各首部字段Accept相同的是可用权重q值来表示相对优先级 该首部字段用于内容协商机制的服务器驱动协商。 Accept-Encoding Accept-Encoding:gzip,deflate Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。 gzip:由文件压缩程序gzip（GNU zip)生成的编码格式，采用LZ77及32为循环冗余校验 compress:由UNIX文件压缩程序compress生成的编码格式，采用的算法LZW deflate:组合使用zlib格式及由deflate压缩算法生成的编码格式 identity:不执行压缩或不会变化的默认编码格式 采用权值q来表示相对优先级，这点与首部字段Accept相同。可用(*)作为通配符，指定任意编码格式 Accept-Language告知服务器用户代理能够处理的自然语言集，以及自然语言集的相对优先级。可一次指定多种自然语言集 按权重q表示相对优先级。 Authorization首部字段Authorization用来告知服务器，用户代理的认证信息，通常想要通过服务器认证的用户代理会在接收待返回的401状态码后，把首部字段Authorization加入到请求中。共用缓存在接收到含有Authorization首部字段的请求时的操作处理会略有差异。 Expect Expect:100-continue 客户端使用首部字段Expect来告知服务器，期望出现的某种特定行为，因服务器无法理解客户端的期望做出回应而发生错误时，会返回417Expectation Failed 客户端可以利用该首部字段，写明所期望的扩展。虽然HTTP/1.1规范只定义100-continue(状态码100Continue之意) From首部字段From用来告知服务器使用用户代理的用户的电子邮件地址。通常使用目的是为了显示搜索引擎用户代理的负责人的电子邮件联系方式。使用代理时，尽可能包含From首部字段 Host首部字段Host会告知服务器，请求的资源所处的互联网主机名和端口号。Host首部字段再HTTP/1.1规范内是唯一一个必须被包含在请求内的首部字段。 请求被发送到服务器时，请求中的主机名会用IP地址直接替换解决，但如果这时相同的IP地址下部署运行着多个域名，那么服务器就无法理解是哪个域名对应的请求。因此，就要使用首部字段Host来明确指出请求的主机名，若服务器未设定主机名，那直接发送空值。 Host: If-Matchif-xxx为条件请求，服务器接收到附带条件请求后，只有判断指定条件为真，才执行请求。 首部字段If-Match，属于附带条件之一，它会告知服务器匹配资源所用的实体标记(ETag)值，这时的服务器无法使用弱ETag值，服务器对比If-Match的字段值与资源的ETag值，仅当两者一致时才执行请求，否则，返回状态码412 Precondition Failed 还可以使用(*)指定If-Match的字段值，针对这种情况，服务器会忽略ETag的值，只要资源存在就处理请求。 If-Modified-Since If-Modified-Since: Thu,15 Apr 2004 00:00:00 GMT 首部字段If-Modified-Since属于附带条件之一，它会告知服务器若If-Modified-Since字段值早于资源的更新时间，则希望能处理该请求，而在If-Modified-Since字段值的日期时间后，如果请求的资源都没有更新，返回状态码304Not Modified的响应 If-Modified-Since用于确认代理或客户端拥有的本地资源的有效性，获取资源的更新时间可通过确认首部字段Last-Modified确定 If-None-Match与If-Match作用相反，用于指定If-None-Match字段值的实体标记（ETag)值与请求资源得到ETag不一致时会告知服务器处理该请求。 在GET或HEAD方法中使用首部字段If-None-Match可获取最新的源，因此这与使用首部字段If-Modified-Since有些类似。 If-RangeIf-Range字段值若是和ETag值或更新的日期时间匹配一致，那么就作为范围请求处理，若不一致返回全部资源 如果不使用If-Range,而是使用If-Match,服务器端的资源如果更新了，那客户端持有的资源中的一部分也会随之无效，服务器端就会以402 Precondition Failed返回，催促客户端再次发请求，与使用If-Range相比，就要花费两倍的功夫。 If-Unmodified-Since与If-Modified-Since作用相反，它的作用是告知服务器，指定的资源只有在字段值内指定的日期时间之后未发生更新得情况下，才能处理请求，如果在指定日期时间后发生了更新，则以状态码412 Precondition Failed作为响应返回 Max-Forwards通过TRACE方法或OPTIONS方法，发送包含首部字段Max-Forwards的请求时，该字段以十进制整数的形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求前，Max-Forwards的值减1后重新复制，当服务器收到Max-Forwards值为0的请求时则不再进行转发，而是直接返回响应。 如果代理服务器由于某些原因导致请求转发失败，客户端也就等不到服务器返回的响应。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"HTTP","slug":"计算机网络/HTTP","permalink":"https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/"}],"tags":[]},{"title":"开发环境","slug":"开发环境","date":"2022-04-11T06:51:43.000Z","updated":"2022-05-07T13:08:25.916Z","comments":true,"path":"2022/04/11/开发环境/","link":"","permalink":"https://coloey.github.io/2022/04/11/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"开发环境中使用source map当 webpack 打包源代码时，可能会很难追踪到 error(错误) 和 warning(警告) 在源代码中的原始位置。例如，如果将三个源文件（a.js, b.js 和 c.js）打包到一个 bundle（bundle.js）中，而其中一个源文件包含一个错误，那么堆栈跟踪就会直接指向到 bundle.js。你可能需要准确地知道错误来自于哪个源文件，所以这种提示这通常不会提供太多帮助。 为了更容易地追踪 error 和 warning，JavaScript 提供了 source maps 功能，可以将编译后的代码映射回原始源代码。如果一个错误来自于 b.js，source map 就会明确的告诉你。 source map 有许多 可用选项，请务必仔细阅读它们，以便可以根据需要进行配置。 对于本指南，我们将使用 inline-source-map 选项，这有助于解释说明示例意图（此配置仅用于示例，不要用于生产环境）： 1234567891011121314151617181920212223242526272829303132333435363738394041const path=require(&#x27;path&#x27;)const HtmlWebpackPlugin=require(&quot;html-webpack-plugin&quot;)module.exports=&#123; entry:&#123; index: &#x27;./src/index.js&#x27;, print:&#x27;./src/print.js&#x27; &#125;, output:&#123; filename:&#x27;[name]bundle.js&#x27;, path:path.resolve(__dirname,&#x27;dist&#x27;), clean:true, publicPath:&#x27;/&#x27;, &#125;, module:&#123; rules:[ &#123; test: /\\.css$/i, use:[&#x27;style-loader&#x27;,&#x27;css-loader&#x27;], &#125;, &#123; test:/\\.(png|jpg|jpeg|svg|gif)$/i, type:&#x27;asset/resource&#x27; &#125;, ] &#125;, devtool:&#x27;inline-source-map&#x27;, devServer:&#123; static:&#x27;./dist&#x27;, &#125;, plugins:[ new HtmlWebpackPlugin(&#123; title:&#x27;Development&#x27;, &#125;) ], mode:&#x27;development&#x27;&#125; 选择开发工具webpack 提供几种可选方式，帮助你在代码发生变化后自动编译代码： webpack’s Watch Mode webpack-dev-server webpack-dev-middleware 多数场景中，你可能需要使用 webpack-dev-server，但是不妨探讨一下以上的所有选项。 使用watch mode你可以指示 webpack “watch” 依赖图中所有文件的更改。如果其中一个文件被更新，代码将被重新编译，所以你不必再去手动运行整个构建。 我们添加一个用于启动 webpack watch mode 的 npm scripts： package.json 12345678910111213141516171819202122&#123; &quot;name&quot;: &quot;webpack-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,+ &quot;watch&quot;: &quot;webpack --watch&quot;, &quot;build&quot;: &quot;webpack&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;html-webpack-plugin&quot;: &quot;^4.5.0&quot;, &quot;webpack&quot;: &quot;^5.4.0&quot;, &quot;webpack-cli&quot;: &quot;^4.2.0&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;lodash&quot;: &quot;^4.17.20&quot; &#125; &#125; 现在，你可以在命令行中运行 npm run watch，然后就会看到 webpack 是如何编译代码。 唯一的缺点是，为了看到修改后的实际效果，你需要刷新浏览器。如果能够自动刷新浏览器就更好了，因此接下来我们会尝试通过 webpack-dev-server 实现此功能。 webpack-dev-serverwebpack-dev-server 为你提供了一个基本的 web server，并且具有 live reloading(实时重新加载) 功能。设置如下： 1npm install --save-dev webpack-dev-server 修改配置文件，告知 dev server，从什么位置查找文件： webpack.config.js 123456789101112131415161718192021222324 const path = require(&#x27;path&#x27;); const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); module.exports = &#123; mode: &#x27;development&#x27;, entry: &#123; index: &#x27;./src/index.js&#x27;, print: &#x27;./src/print.js&#x27;, &#125;, devtool: &#x27;inline-source-map&#x27;,+ devServer: &#123;+ static: &#x27;./dist&#x27;,+ &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &#x27;Development&#x27;, &#125;), ], output: &#123; filename: &#x27;[name].bundle.js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;), clean: true, &#125;, &#125;; 以上配置告知 webpack-dev-server，将 dist 目录下的文件 serve 到 localhost:8080 下。（译注：serve，将资源作为 server 的可访问文件） 我们添加一个可以直接运行 dev server 的 script： package.json 123456&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;watch&quot;: &quot;webpack --watch&quot;,+ &quot;start&quot;: &quot;webpack serve --open&quot;, &quot;build&quot;: &quot;webpack&quot; &#125;, 现在，在命令行中运行 npm start，我们会看到浏览器自动加载页面。如果你更改任何源文件并保存它们，web server 将在编译代码后自动重新加载 webpack-dev-middlewarewebpack-dev-middleware 是一个封装器(wrapper)，它可以把 webpack 处理过的文件发送到一个 server。webpack-dev-server 在内部使用了它，然而它也可以作为一个单独的 package 来使用，以便根据需求进行更多自定义设置。下面是一个 webpack-dev-middleware 配合 express server 的示例。 首先，安装 express 和 webpack-dev-middleware： 1npm install --save-dev express webpack-dev-middleware 调整webpack.config,js 12345678910111213141516171819202122232425 const path = require(&#x27;path&#x27;); const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); module.exports = &#123; mode: &#x27;development&#x27;, entry: &#123; index: &#x27;./src/index.js&#x27;, print: &#x27;./src/print.js&#x27;, &#125;, devtool: &#x27;inline-source-map&#x27;, devServer: &#123; static: &#x27;./dist&#x27;, &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &#x27;Development&#x27;, &#125;), ], output: &#123; filename: &#x27;[name].bundle.js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;), clean: true,+ publicPath: &#x27;/&#x27;, &#125;, &#125;; 我们将会在 server 脚本使用 publicPath，以确保文件资源能够正确地 serve 在 http://localhost:3000 下，稍后我们会指定 port number(端口号)。接下来是设置自定义 express server： 12345678910 webpack-demo |- package.json |- package-lock.json |- webpack.config.js+ |- server.js |- /dist |- /src |- index.js |- print.js |- /node_modules server.js 1234567891011121314151617181920const express = require(&#x27;express&#x27;);const webpack = require(&#x27;webpack&#x27;);const webpackDevMiddleware = require(&#x27;webpack-dev-middleware&#x27;);const app = express();const config = require(&#x27;./webpack.config.js&#x27;);const compiler = webpack(config);// 告知 express 使用 webpack-dev-middleware，// 以及将 webpack.config.js 配置文件作为基础配置。app.use( webpackDevMiddleware(compiler, &#123; publicPath: config.output.publicPath, &#125;));// 将文件 serve 到 port 3000。app.listen(3000, function () &#123; console.log(&#x27;Example app listening on port 3000!\\n&#x27;);&#125;); 现在，添加一个 npm script，以使我们更方便地运行 server： package.json 1234567 &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;watch&quot;: &quot;webpack --watch&quot;, &quot;start&quot;: &quot;webpack serve --open&quot;,+ &quot;server&quot;: &quot;node server.js&quot;, &quot;build&quot;: &quot;webpack&quot; &#125;, 现在，在 terminal(终端) 中执行 npm run server","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"前端工程化/webpack","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack/"}],"tags":[]},{"title":"Vue中封装axios请求","slug":"Vue中封装axios请求","date":"2022-04-11T02:01:47.000Z","updated":"2022-04-11T02:24:02.431Z","comments":true,"path":"2022/04/11/Vue中封装axios请求/","link":"","permalink":"https://coloey.github.io/2022/04/11/Vue%E4%B8%AD%E5%B0%81%E8%A3%85axios%E8%AF%B7%E6%B1%82/","excerpt":"","text":"在src文件夹中新创建一个utils文件夹，创建index.js来实现axios实例，并配置拦截器 index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import axios from &#x27;axios&#x27;import &#123;ElLoading,ElMessage&#125; from &#x27;element-plus&#x27;import router from &quot;../router&quot;import store from &quot;../store&quot;import CHAT from &quot;../client&quot;//const pendingMap=new Map();//axios.defaults.headers.post[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencoded;charset=UTF-8&#x27;;//创建一个axios实例var instance=axios.create(&#123; baseURL:&quot;http://127.0.0.1:3007&quot;, timeout: 10000,//设置超时 headers:&#123; &#x27;Content-Type&#x27;:&#x27;application/x-www-form-urlencoded&#x27;, &#125;&#125;)let loading;//多次请求时let requestCount=0;//显示Loadingconst showLoading=()=&gt;&#123; if(requestCount===0&amp;&amp;!loading)&#123;//第一次发送请求并且没有loading加载loaing loading=ElLoading.service(&#123; text:&#x27;Loading&#x27;, background:&#x27;rgba(0,0,0,0.7)&#x27;, spinner:&#x27;el-icon-loading&#x27;, &#125;) &#125; requestCount++;//多次请求&#125;//隐藏loadingconst hideLoading=()=&gt;&#123; requestCount--; if(requestCount===0)&#123; loading.close()//直到请求都结束Loading才关闭 &#125;&#125;//请求拦截器instance.interceptors.request.use((config)=&gt;&#123; showLoading() //每次发送请求前判断是否存在token如果存在则在header加上token const token=window.localStorage.getItem(&#x27;token&#x27;); token&amp;&amp;(config.headers.Authorization=token) return config;&#125;,(error)=&gt;&#123; Promise.reject(error);&#125;)//响应拦截器instance.interceptors.response.use((response)=&gt;&#123; hideLoading() //响应成功 // console.log(&#x27;拦截器报错&#x27;) // console.log(response) const status=response.data.status; if(status!=1)&#123; switch(status)&#123; case 0: //响应成功后如果是登录成功有token把token存储在本地 if(response.data.token!=undefined)window.localStorage.setItem(&#x27;token&#x27;,response.data.token); break; case 200://获取用户信息成功后存储在localStorage里和store console.log(response.data); store.commit(&quot;saveUserInfo&quot;,(response.data).data); window.localStorage.setItem(&#x27;userInfo&#x27;,JSON.stringify((response.data).data)); break; case 401://登录过期跳转到登录页面 case 201://退出登录清空token跳转登录页面 window.localStorage.removeItem(&#x27;token&#x27;); window.localStorage.removeItem(&#x27;userInfo&#x27;) CHAT.logout(); router.push(&quot;/login&quot;); &#125; if(response.data.message)ElMessage.success(response.data.message) return Promise.resolve(response); &#125; else &#123; ElMessage.error(response.data.message); return Promise.reject(response); &#125; &#125;,(error)=&gt;&#123; console.log(error); //响应错误 if(error.response&amp;&amp;error.response.status)&#123; return Promise.reject(error) &#125; return Promise.reject(error);&#125;)export default instance; request.jsrequest.js中使用axios实例 12345678910111213141516171819202122232425262728import instance from &quot;./index&quot;const axios=(&#123; method, url, data, config&#125;)=&gt;&#123; method=method.toLowerCase(); if(method==&#x27;post&#x27;)&#123; return instance.post(url,data,&#123;...config&#125;) &#125;else if(method==&#x27;get&#x27;)&#123; return instance.get(url,&#123; params:data, ...config &#125;) &#125;else if(method==&#x27;delete&#x27;)&#123; return instance.delete(url,&#123; params:data, ...config &#125;) &#125;else if(method==&#x27;put&#x27;)&#123; return instance.put(url,data,&#123;...config&#125;) &#125;else&#123; console.log(&#x27;未知的方法&#x27;+method) return false &#125;&#125;export default axios api.jsapi.js用来封装各种类型的请求 默认情况下，axios 将 JavaScript 对象序列化为JSON. 要改为以格式发送数据application/x-www-form-urlencoded，我用的是qs.stringfy将数据转换，其他方法可以参考官网 []: https://axios-http.com/docs/urlencoded 1234567891011121314151617181920212223242526272829303132333435363738import axios from &quot;./request&quot;import qs from &quot;qs&quot;export const login=(data)=&gt;&#123; return axios(&#123; url:&#x27;/api/login&#x27;, method:&#x27;post&#x27;, data:qs.stringify(data), &#125;)&#125;export const register=(data)=&gt;&#123; return axios(&#123; url:&#x27;/api/register&#x27;, method:&#x27;post&#x27;, data:qs.stringify(data) &#125;)&#125;export const logout=()=&gt;&#123; return axios(&#123; url:&#x27;/api/logout&#x27;, method:&#x27;post&#x27;, &#125;)&#125;export const getUserInfo=()=&gt;&#123; return axios(&#123; url:&#x27;/my/getUserInfo&#x27;, method:&#x27;get&#x27;, &#125;)&#125;export const updatePassword=(data)=&gt;&#123; return axios(&#123; url:&#x27;/my/updatePassword&#x27;, method:&#x27;post&#x27;, data:qs.stringify(data) &#125;)&#125;","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"Vue","slug":"Node/Vue","permalink":"https://coloey.github.io/categories/Node/Vue/"}],"tags":[]},{"title":"打包资源","slug":"打包资源","date":"2022-04-10T09:30:58.000Z","updated":"2022-05-07T13:08:19.507Z","comments":true,"path":"2022/04/10/打包资源/","link":"","permalink":"https://coloey.github.io/2022/04/10/%E6%89%93%E5%8C%85%E8%B5%84%E6%BA%90/","excerpt":"","text":"打包样式资源1234567891011121314151617181920212223242526272829303132333435363738394041const &#123;resolve&#125; =require(&#x27;path&#x27;)module.exports=&#123; entry:&#x27;./src/index.js&#x27;, //输出 output:&#123; //输出文件名 filename:&#x27;built.js&#x27;, //输出路径,_dirname node.js的变量，代表当前文件的目录绝对路径 path:resolve(__dirname,&#x27;build&#x27;) &#125;, //loader配置 module:&#123; rules:[ //匹配哪些文件 &#123;test:/\\.css$/, //使用哪些loader use:[ //use数组中loader执行顺序从右到左，从下到上一次执行 //创建style标签，将js中的样式资源插入进行，添加到head中生效 &#x27;style-loader&#x27;, //将css文件变成commonjs模块加载到js中，里面内容是样式字符串 &#x27;css-loader&#x27; ]&#125;, &#123; test:/\\.less$/, use:[ &#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;less-loader&#x27;,//将less文件编译成css文件 ] &#125; ] &#125;, plugins:[ ], mode:&#x27;development&#x27;&#125; 打包html资源12345678910111213141516171819202122232425262728293031323334353637383940414243444546const &#123;resolve&#125; =require(&#x27;path&#x27;)const HtmlWebpackPlugin=require(&#x27;html-webpack-plugin&#x27;)module.exports=&#123; entry:&#x27;./src/index.js&#x27;, //输出 output:&#123; //输出文件名 filename:&#x27;built.js&#x27;, //输出路径,_dirname node.js的变量，代表当前文件的目录绝对路径 path:resolve(__dirname,&#x27;build&#x27;) &#125;, //loader配置 module:&#123; rules:[ //匹配哪些文件 &#123;test:/\\.css$/, //使用哪些loader use:[ //use数组中loader执行顺序从右到左，从下到上一次执行 //创建style标签，将js中的样式资源插入进行，添加到head中生效 &#x27;style-loader&#x27;, //将css文件变成commonjs模块加载到js中，里面内容是样式字符串 &#x27;css-loader&#x27; ]&#125;, &#123; test:/\\.less$/, use:[ &#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;less-loader&#x27;,//将less文件编译成css文件 ] &#125; ] &#125;, plugins:[ //html-webpack-plugin默认会创建一个空的HTML,自动引入打包输出的所有资源（js/css） //需求：需要有结构的HTML文件 new HtmlWebpackPlugin(&#123; //模板比对&#x27;src/index.html&#x27;文件，并自动引入打包输出的所有资源(js/css) template:&#x27;./src/index.html&#x27; &#125;) ], mode:&#x27;development&#x27;&#125; 打包图片 html-loader 以相同的方式处理 &lt;img src=&quot;./my-image.png&quot; /&gt;。需要npm i html-wepack-plugin []: https://webpack.docschina.org/loaders/html-loader 12345678910111213141516//处理图片 &#123; test:/\\.(png|svg|jpg|jpeg|gif)$/i, type:&#x27;asset/resource&#x27;, &#125;, //将html导出为字符串 &#123; test:/\\.html$/i, loader:&quot;html-loader&quot;, &#125;, //处理字体 &#123; test:/\\.(woff|woff2|eot|ttf|otf)$/i, type:&#x27;asset/resource&#x27; &#125;, 打包xml,csv文件可以加载的有用资源还有数据，如 JSON 文件，CSV、TSV 和 XML。类似于 NodeJS，JSON 支持实际上是内置的，也就是说 import Data from &#39;./data.json&#39; 默认将正常运行。要导入 CSV、TSV 和 XML，你可以使用 csv-loader 和 xml-loader。让我们处理加载这三类文件： 1npm install --save-dev csv-loader xml-loader 12345678&#123; test: /\\.(csv|tsv)$/i, use: [&#x27;csv-loader&#x27;], &#125;, &#123; test: /\\.xml$/i, use: [&#x27;xml-loader&#x27;], &#125;, 打包toml,yaml,json5通过使用 自定义 parser 替代特定的 webpack loader，可以将任何 toml、yaml 或 json5 文件作为 JSON 模块导入。 1npm install toml yamljs json5 --save-dev 12345678910111213141516171819202122232425 const toml=require(&#x27;toml&#x27;)const yaml=require(&#x27;yamljs&#x27;)const json5=require(&#x27;json5&#x27;)...&#123; test: /\\.toml$/i, type: &#x27;json&#x27;, parser: &#123; parse: toml.parse, &#125;, &#125;, &#123; test: /\\.yaml$/i, type: &#x27;json&#x27;, parser: &#123; parse: yaml.parse, &#125;, &#125;, &#123; test: /\\.json5$/i, type: &#x27;json&#x27;, parser: &#123; parse: json5.parse, &#125;, &#125;, 清理/dist文件在每次构建前清理 /dist 文件夹，这样只会生成用到的文件。让我们使用 output.clean 配置项实现这个需求。 12345678910111213141516171819const path = require(&#x27;path&#x27;); const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); module.exports = &#123; entry: &#123; index: &#x27;./src/index.js&#x27;, print: &#x27;./src/print.js&#x27;, &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &#x27;Output Management&#x27;, &#125;), ], output: &#123; filename: &#x27;[name].bundle.js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;),+ clean: true, &#125;, &#125;;","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"前端工程化/webpack","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack/"}],"tags":[]},{"title":"wepack五个核心概念","slug":"wepack五个核心概念","date":"2022-04-10T04:05:22.000Z","updated":"2022-05-02T15:06:52.430Z","comments":true,"path":"2022/04/10/wepack五个核心概念/","link":"","permalink":"https://coloey.github.io/2022/04/10/wepack%E4%BA%94%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/","excerpt":"","text":"Entry:入口（Entry)指示Webpack以哪个文件为入口起点开始打包 Output: 输出（output)指示Webpack打包后的资源bundle输出到哪里，以及如何命名 Loader:Loader让Webpack能够去处理那些非JavaScript文件（webpack自身只理解JavaScript) loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ Plugins:插件(Plugins)可以用于执行范围更广的任务，插件的范围包括从打包优化到压缩，一直到重新定义环境中的变量等 Mode:模式（Mode）指示Webpack使用相应模式的配置 选项 描述 特点 development 会将process.env.NODE_ENV的值设为development,启用NamedChunksPlugin和NamedModulesPlugin 能让代码在本地调试运行的环境 production 会将 process.env.NODE_ENV 的值设为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin 能让代码优化上线运行的环境 运行指令开发环境webpack ./src/index.js -o ./build/build.js –mode=development:webpack会以./src/index.js为入口打包文件，打包后输出到./build/build.js，整体打包环境，是开发环境 生成环境webpack ./src/index.js-o ./build/build.js –mode=production,webpack会以./src/index.js为入口打包文件，打包后输出到./build/build.js，整体打包环境，是生产环境 结论 webpack能处理js/json资源，不能处理css/img等其他资源 生产环境和开发环境将ES6模块化编译成浏览器能识别的模块化 生产环境比开发环境多一个压缩的js代码","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"前端工程化/webpack","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack/"}],"tags":[]},{"title":"HTTP首部字段","slug":"HTTP通用首部字段","date":"2022-04-09T08:13:43.000Z","updated":"2022-05-02T15:05:35.398Z","comments":true,"path":"2022/04/09/HTTP通用首部字段/","link":"","permalink":"https://coloey.github.io/2022/04/09/HTTP%E9%80%9A%E7%94%A8%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5/","excerpt":"","text":"HTTP报文首部HTTP请求报文由请求行（方法，URI，HTTP版本），HTTP首部字段等部分构成。 HTTP响应报文由状态行（HTTP版本，状态码（数字和原因短语））HTTP首部字段3部分构成。 4种HTTP首部字段类型通用首部字段：请求报文和响应报文都会使用的首部 请求首部字段：从客户端向服务端发送报文时使用的首部，补充了请求的附加内容，客户端信息，响应内容相关优先级等信息 响应首部字段：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息 实体首部字段：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息 HTTP/1.1通用首部字段Cache-Control通过指定首部字段Cache-Control的指令，就能操作缓存的工作机制。 Cache-Control:private,max-age=0,no-cache 缓存请求指令： 指令 参数 说明 no-cache 无 强制向源服务器再次验证 no-store 无 不缓存请求或响应的任何内容 max-age=([秒]) 必需 响应的最大Age值 max-stale=([秒]) 可省略 接收已过期的响应 min-fresh=[秒] 必需 期望在指定时间内的响应仍有效 no-transform 无 代理不接更改媒体类型 only-if-cached 无 从缓存中获取资源 cache-extension 新指令标记（token) 缓存响应指令 指令 参数 说明 public 无 可向任意方提供响应的缓存 private 可省略 仅向特定用户返回响应 no-cache 可省略 缓存前必须先确认其有效性 no-store 无 不缓存请求或响应的任何内容 no-transform 无 代理不接更改媒体类型 must-revalidate 无 可缓存但必须再向服务器进行确认 proxy-revalidate 无 要求中间缓存服务器对缓存的响应有效性再进行确认 max-age=[秒] 必需 响应的最大Age值 s-maxage=[秒] 必需 公共缓存服务器响应的最大Age值 cache-extension - 新指令标记（token) no-cache指令Cache-Control:no-cache 使用no-cache指令的目的是为了防止从缓存中返回过期的资源，缓存会向源服务器进行有效期的确认后处理资源 客户端：发送的请求中包含no-cache指令，则表示客户端将不会接收缓存过的响应。于是“中间”缓存服务器必须把客户端请求转发给源服务器 服务器：如果服务器返回的响应中包含no-cache指令，那么缓存服务器不能对资源进行缓存，源服务器以后也不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作 Cache-Control:no-cache=Location 由服务器返回的响应中，若报文首部字段Cache-Control中对no-cache字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。相反，无参数值的首部字段可以使用缓存。只能在响应指令中指定该参数 no-store指令Cache-Control:no-store 当使用no-store指令时，暗示请求（和对应的响应）或响应中包含机密信息，因此该指令规定缓存不能在本地存储请求或响应的任何一部分 s-maxage指令Cache-Control:s-maxage=604800(单位：秒) s-maxage指令的功能和max-age指令相同，不同点在于s-maxage指令只适用于供多位用户使用的公共缓存服务器，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。 当使用s-maxage指令后，则直接忽略对Expires首部字段及max-age指令的处理 max-age指令Cache-Control:max-age=604800(单位：秒) 客户端：当客户端发送的请求中包含max-age指令时，如果判定缓存时间的数值比·1指定时间的数值更小，那么客户端就接收缓存的资源。当指定的max-age=0，那么缓存服务器通常将请求转发给源服务器 服务端：服务器返回的响应中包含max-age指令，缓存服务器将不对资源的有效性再作确认，而max-zge数值代表资源保存为缓存的最长时间 ⚠应用HTTP/1.1版本的缓存服务器在遇到同时存在Expires首部字段的情况时，会优先处理max-age指令,而忽略Expires首部字段，而HTTP/1.0版本的缓存服务器则相反，max-age指令被忽略 min-fresh指令Cache-Control:min-fresh=60 min-fresh指令要求缓存服务器返回至少还未过指定时间的缓存资源。 max-stale指令Cache-Control:max-stale=3600 使用max-stale指示缓存资源，即使过期也照常接收 如果指令未指定参数值，那么无论过多久，客户端都会接收响应；如果指令中指定了具体数值，那么即使过期，只要仍处于max-stale指定的时间内仍旧会被客户端接收 only-if-cached指令Cache-Control:only-if-cached 表示客户端仅在缓存服务器本地缓存目标资源的情况下才要求其返回。该指令要求服务器不重新加载响应，也不再次确认资源有效性。若请求缓存服务器的本地缓存无响应，则返回状态码504 Gateway Timeout must-revalidate指令Cache-Control:must-revalidate 代理向源服务器再次验证即将返回的响应缓存目前是否仍然有效。如果代理无法连通服务器再次活期有效资源，缓存必须给客户端一条504状态码 使用must-revalidate指令忽略请求的max-stale指令，即使首部使用了max-stale，也不会有效果 proxy-revalidate指令Cache-Control：proxy-revalidate proxy-revalidate要求所有缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性 no-transform指令Cache-Control：no-transform 无论·是在请求还是响应中使用，缓存都不能改变实体主体的媒体类型，这样可防止代理压缩图片等类似操作 Cache-Control扩展cache-control token Cache-Control:private,community=”UCI” 通过cache-extension标记可以扩展Cache-Control首部字段内的指令。如例子，Cache-Control首部字段本身没有community这个指令。借助extensions tokens实现了该指令的添加。如果缓存服务器无法理解这个新指令就会直接忽略 Connection作用： 控制不再转发给代理的首部字段 管理持久连接 Connection:不再转发的首部字段名 控制不再转发给代理的首部字段在客户端发送请求和服务器返回响应内，使用Connection首部字段，可控制不再转发给代理的首部字段 管理持久连接Connection:close HTTP/1.1版本的默认连接是持久连接，为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，指定Connection首部字段为Close HTTP/1.1之前的版本默认连接是非持久连接。因此，如果想要在旧版本的HTTP协议上维持持续连接，则需要指定Connection为Kepp-Alive PragmaPragma是HTTP/1.1之前版本的历史遗留字段，仅作为与HTTP/1.0的向后兼容而定义 Pragma:no-cache 该首部字段属于通用首部字段，但只用在客户端发送请求中。客户端要求所有的中间服务器不返回缓存的资源。所有中间服务器如果都能以HTTP/1.1为基准，那直接采用Cache-Control:no-cache指定缓存的处理方式是最为理想的。但要整体掌握中间服务器使用的HTTP协议版本不现实，发送请求一般同时包含两个首部字段 Cache-Control:no-cache Pragma:no-cache Trailer首部字段Trailer会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在HTTP/1.1版本分块传输编码时 Trailer:Expires —(报文主体)— Expires:Tue,28 Sep 2004 23:59:59 GMT Transfer-Encoding规定了传输报文主体时采用的编码方式 HTTP/1.1的传输编码方式仅对分块传输编码有效 Upgrade Upgrade用于检测HTTP协议及其他协议是否可使用更高的版本进行同心，其参数值用来指定一个完全不同的通信协议 12345678客户端=》服务器GET/index.html HTTP/1.1Upgrade:TLS/1.0Connection:Upgrade服务器=》客户端HTTP/1.1 101 Switching ProtocolsUpgrade:TLS/1.0,HTTP/1.1Connection:Upgrade Connection的值被指定为Upgrade,Upgrade的首部字段产生作用的Upgrade对象仅限于客户端和邻接服务器之间。因此使用首部字段Upgrade时需要额外指定Connection为Upgrade Via使用Via是为了追踪客户端和服务器之间的请求和响应报文的传输路径 报文经过代理或网关时，会现在首部字段Via中附加该服务器的信息，然后再进行转发。Via不仅用于追踪报文的转发，还可避免请求回环的发生，所以必须在经过代理时附加该首部字段内容 WarningHTTP/1.1的Warning首部是从HTTP/1.0的响应首部（Retry-After)演变过来的，该首部会告知用户一些与缓存相关的问题的警告 &amp;eg: Warning:113 gw.hackr.jp:8080 “Heuristic expiration” Tue,03 Jul=&gt;2012 05:09:44 GMT Warning:【警告码】【警告主机：端口号】“【警告内容】”（【日期时间】） HTTP/1.1警告码 警告码 警告内容 说明 110 Response is stale(响应已过期) 代理返回已过期的资源 111 Revalidation failed(再验证失败) 代理验证资源有效性时失败（服务器无法到达等原因 112 Disconnection operation(断开连接操作) 代理与互联网连接故意切断 113 Heuristic expiration(试探性过期) 响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下） 199 Miscellaneous warning(杂项警告) 任意警告内容 214 Transformation applied(使用了转换) 代理对内容编码或媒体类型等执行了某些处理时 299 Miscellaneous persistent warning(持久杂项警告) 任意警告内容","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"HTTP","slug":"计算机网络/HTTP","permalink":"https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/"}],"tags":[]},{"title":"背包问题","slug":"背包问题","date":"2022-04-04T04:01:42.000Z","updated":"2022-04-08T09:19:01.103Z","comments":true,"path":"2022/04/04/背包问题/","link":"","permalink":"https://coloey.github.io/2022/04/04/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","excerpt":"","text":"01背包：有限物品数量 二维01背包问题，两个for循环可以交换顺序，内层for循环方向可以顺序循环 一维01背包问题：因为物品数量有限，内层for循环不能重复取，必须倒序，两个for循环可以交换顺序 完全背包问题：物品可以重复取 二维：for循环可以交换顺序，内层for循环必须顺序，因为物品可以重复取 一维：for循环可以交换顺序，内层for循环必须顺序，因为物品可以重复取 求方法数：dp[j]+=dp[j-nums[i]] 一维：求组合数：先遍历物品再遍历背包 求排列数：先遍历背包再遍历物品","categories":[{"name":"算法","slug":"算法","permalink":"https://coloey.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"前后端身份认证","slug":"前后端身份认证","date":"2022-03-21T06:10:19.000Z","updated":"2022-04-12T09:45:43.489Z","comments":true,"path":"2022/03/21/前后端身份认证/","link":"","permalink":"https://coloey.github.io/2022/03/21/%E5%89%8D%E5%90%8E%E7%AB%AF%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/","excerpt":"","text":"不同身份认证方案：服务端渲染推荐使用Session认证机制 前后端分离推荐使用JWT认证机制 Session认证机制 Cooike:Cookie是存储在用户浏览器中一段不超过4kb的字符串，它由一个名称（Name),y一个值(Value)和几个用于控制Cookie有效期，安全性，使用范围的可选属性组成 不同域名下的Cookie各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的Cookie一同发送到服务器。 Cookie的几大特性： 自动发送 域名独立 过期时限 4kb限制 Cookie在身份认证中的作用： 客户端第一次请求服务器时，服务器通过响应头的形式，向客户端发送一个身份认证的Cookie，客户端会自动将Cookie保存在浏览器中，随后，当客户端浏览器每次请求服务器时浏览器会自动将身份认证相关的Cookie，通过请求头的形式发送给服务器，服务器即可验证客户端身份 Cookie具有不安全性 由于Cookie是存储在浏览器中的，因此浏览器也提供了读写Cookie的API，因此Cookie很容易被伪造，不具有安全性，因此Cookie不能存放重要隐私数据 Session工作原理： 客户端把用户ID和密码等登陆信息放入报文的实体部分，通常是以POST请求发送给服务器，而这时使用HTTPS通信来进行HTML表单画面的显示和用户输入数据的发送 服务器会发放用以识别用户的Session ID,通过验证从客户端送过来的登录信息进行身份认证，人后把用户认证状态与Session ID绑定后记录在服务器端，向客户端返回响应时，会在首部字段Set-Cookie内写入Sessin ID,为避免SessionId被盗，可在Cookie中加入httponly属性 客户端接收到从服务器发来的Session ID后，会将其作为Cookie保存哎本地，下次向服务器发送请求时，浏览器自动发送Cookie,服务器通过验证接收到的Session ID识别用户和其认证状态 Session认证需要配合Cookie实现，由于Cookie默认不支持跨域访问，所以当涉及前端跨域请求后端接口时需要做额外配置。因此当前端请求后端接口不涉及跨域请求时推荐使用Session身份认证机制，否则使用JWT认证 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const express=require(&#x27;express&#x27;);const session=require(&#x27;express-session&#x27;);const cors=require(&#x27;cors&#x27;);const bodyParser=require(&#x27;body-parser&#x27;)//var formParser=require(&#x27;express-formidable&#x27;)const app=express();app.use(cors());app.use( session(&#123; secret:&#x27;xiaoqi&#x27;, resave:false, saveUninitialized:true &#125;))//托管静态页面app.use(express.static(&#x27;./pages&#x27;));//自定义解析Post提交过来的表单数据app.use(bodyParser.urlencoded(&#123;extended:false&#125;))app.use(bodyParser.json())//登录API接口app.post(&#x27;/api/login&#x27;,(req,res)=&gt;&#123; //判断用户提交的登录信息是否正确 console.log(req.body) if(req.body.username!==&quot;admin&quot;||req.body.password!==&quot;888888&quot;)&#123; return res.send(&#123;status:1,msg:&#x27;登录失败&#x27;&#125;) &#125; //登录成功则把信息存储在Session中 console.log(req.body); req.session.user=req.body;//用户登录信息 req.session.islogin=true;//用户登录状态 res.send(&#123;status:0,msg:&#x27;登录成功&#x27;&#125;)&#125;)//获取用户姓名的接口app.get(&#x27;/api/username&#x27;,(req,res)=&gt;&#123; //从Session中获取用户姓名响应给客户端 if(!req.session.islogin)&#123; return res.send(&#123;status:1,msg:&#x27;fail&#x27;&#125;) &#125; res.send(&#123; status:0, msg:&#x27;success&#x27;, username:req.session.user.username, &#125;)&#125;)//退出登录的接口app.post(&#x27;/api/logout&#x27;,(req,res)=&gt;&#123; //清空当前客户端的session信息 req.session.destroy() res.send(&#123; status:0, msg:&#x27;退出登录成功&#x27; &#125;)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;运行在http://127.0.0.1&#x27;)&#125;) JWT认证机制：工作原理 jwt组成部分： 头部.有效荷载.签名 Header.PayLoad.Signature 客户端收到服务器返回的JWT后，通常会将它存储在localStorage或者sessionStorage中，此后客户端每次与服务端通信，都要带上这个JWT的字符串，进行身份认证，推荐把JWT放在Http请求头的Authorization字段中 Authorization：Bearer 在Express中使用JWT 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const express=require(&#x27;express&#x27;);const app=express();const cors=require(&#x27;cors&#x27;);//导入用于生成jwt字符串的包const jwt=require(&#x27;jsonwebtoken&#x27;);//导入用于将客户端发送过来的JWT字符串解析还原成JSON对象的包const expressJWT=require(&quot;express-jwt&quot;);//秘钥的本质是字符串const secretkey=&#x27;xiaochunzuishuai^_^&#x27;;//以/api/开头的不用权限，配置成功了express-jwt这个中间件，就可以把解析出来的用户信息挂载到req.user上app.use(expressJWT(&#123; secret:secretkey, algorithms: [&#x27;HS256&#x27;], &#125;).unless(&#123;path:[/^\\/api\\//]&#125;))const bodyParser=require(&#x27;body-parser&#x27;)app.use(cors());//托管静态页面app.use(express.static(&#x27;./pages&#x27;));//自定义解析Post提交过来的表单数据app.use(bodyParser.urlencoded(&#123;extended:false&#125;))app.use(bodyParser.json())//登录API接口app.post(&#x27;/api/login&#x27;,(req,res)=&gt;&#123; //判断用户提交的登录信息是否正确 const userInfo=req.body; if(userInfo.username!==&quot;admin&quot;||userInfo.password!==&quot;888888&quot;)&#123; return res.send(&#123;status:1,msg:&#x27;登录失败&#x27;&#125;) &#125; //登录成功生成JWT字符串，通过token属性响应给客户端 res.send(&#123; satus:0, msg:&#x27;success&#x27;, //不要把密码加密到token字符串中 token:jwt.sign(&#123;username:userInfo.username&#125;,secretkey,&#123;expiresIn:&#x27;100s&#x27;&#125;), data:req.user &#125;)&#125;)//有权限的接口,配置成功了express-jwt这个中间件，有权限的接口就可以通过req.user获取解析出来的用户信息app.get(&#x27;/admin/getInfo&#x27;,(req,res)=&gt;&#123; res.send(&#123; status:0, msg:&#x27;success&#x27;, data:req.user &#125;)&#125;)//退出登录的接口app.post(&#x27;/api/logout&#x27;,(req,res)=&gt;&#123; res.send(&#123; status:0, msg:&#x27;退出登录成功&#x27; &#125;)&#125;)//配置全局错误处理中间件app.use((err,req,res,next)=&gt;&#123; //token解析失败导致的错误,Token过期或不合法 if(err.name===&#x27;UnauthorizedError&#x27;)&#123; return res.send(&#123;status:401,message:&#x27;无效的token&#x27;&#125;) &#125; //其他原因导致的错误 res.send(&#123;status:500,message:&#x27;未知错误&#x27;&#125;)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;运行在http://127.0.0.1&#x27;)&#125;)","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"}],"tags":[]},{"title":"Web开发模式","slug":"Web开发模式","date":"2022-03-21T05:52:34.000Z","updated":"2022-03-21T06:09:19.188Z","comments":true,"path":"2022/03/21/Web开发模式/","link":"","permalink":"https://coloey.github.io/2022/03/21/Web%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"Web开发模式：服务端渲染的Web开发模式服务器发送给客户端的HTML页面是通在服务器通过字符串的拼接动态生成的。因此客户端不需要通过Ajax技术额外请求页面的数据 优点： 前端耗时少，因为服务端通过动态生成HTML内容，浏览器只需要直接渲染页面即可，尤其是移动端，更省电 有利于SEO，服务器响应的是完整的HTML页面，所以爬虫更容易获取信息，有利于SEO 缺点： 占用服务器资源，如果请求较多，会对服务器造成一定压力 不利于前后端分离，开发效率低。使用服务端渲染，则无法进行分工合作，尤其对于前端复杂的项目，不利于羡慕高效开发 前后端分离的Web开发模式：依赖于Ajax技术，后端负责接口开发，前端使用Ajav=x调用接口的开发模式 优点： 开发体验好，前端专注于UI开发，后端专注于接口开发 用户体验好，Ajax技术的应用，提高用户的体验，轻松实现局部页面刷新 减轻服务端的渲染压力，页面最终是在浏览器中生成的 缺点： 不利于SEO，完整的HTML页面需要在客户端动态拼接，所有爬虫无法提取页面有效信息，解决方法：利用Vue,React等前端框架的SSR技术解决 如何选择Web开发模式： 看业务场景 主要功能是展示页面且没有复杂交互并且需要良好的SEO，用服务端渲染 后台管理项目等交互性强用前后端分离 一般两者都会一起用","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"}],"tags":[]},{"title":"FormData","slug":"FormData","date":"2022-03-21T03:13:21.000Z","updated":"2022-03-21T03:14:47.585Z","comments":true,"path":"2022/03/21/FormData/","link":"","permalink":"https://coloey.github.io/2022/03/21/FormData/","excerpt":"","text":"表单，FormData 对象目录 [隐藏] 表单概述 FormData 对象 概述 实例方法 表单的内置验证 自动校验 checkValidity() willValidate 属性 validationMessage 属性 setCustomValidity() validity 属性 表单的 novalidate 属性 enctype 属性 文件上传 参考链接 表单概述表单（&lt;form&gt;）用来收集用户提交的数据，发送到服务器。比如，用户提交用户名和密码，让服务器验证，就要通过表单。表单提供多种控件，让开发者使用，具体的控件种类和用法请参考 HTML 语言的教程。本章主要介绍 JavaScript 与表单的交互。 12345678910111213&lt;form action=&quot;/handling-page&quot; method=&quot;post&quot;&gt; &lt;div&gt; &lt;label for=&quot;name&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;user_name&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;passwd&quot;&gt;密码：&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;passwd&quot; name=&quot;user_passwd&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;submit&quot; id=&quot;submit&quot; name=&quot;submit_button&quot; value=&quot;提交&quot; /&gt; &lt;/div&gt;&lt;/form&gt; 上面代码就是一个简单的表单，包含三个控件：用户名输入框、密码输入框和提交按钮。 用户点击“提交”按钮，每一个控件都会生成一个键值对，键名是控件的name属性，键值是控件的value属性，键名和键值之间由等号连接。比如，用户名输入框的name属性是user_name，value属性是用户输入的值，假定是“张三”，提交到服务器的时候，就会生成一个键值对user_name=张三。 所有的键值对都会提交到服务器。但是，提交的数据格式跟&lt;form&gt;元素的method属性有关。该属性指定了提交数据的 HTTP 方法。如果是 GET 方法，所有键值对会以 URL 的查询字符串形式，提交到服务器，比如/handling-page?user_name=张三&amp;user_passwd=123&amp;submit_button=提交。下面就是 GET 请求的 HTTP 头信息。 12GET /handling-page?user_name=张三&amp;user_passwd=123&amp;submit_button=提交Host: example.com 如果是 POST 方法，所有键值对会连接成一行，作为 HTTP 请求的数据体发送到服务器，比如user_name=张三&amp;user_passwd=123&amp;submit_button=提交。下面就是 POST 请求的头信息。 123456POST /handling-page HTTP/1.1Host: example.comContent-Type: application/x-www-form-urlencodedContent-Length: 74user_name=张三&amp;user_passwd=123&amp;submit_button=提交 注意，实际提交的时候，只要键值不是 URL 的合法字符（比如汉字“张三”和“提交”），浏览器会自动对其进行编码。 点击submit控件，就可以提交表单。 123&lt;form&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 上面表单就包含一个submit控件，点击这个控件，浏览器就会把表单数据向服务器提交。 注意，表单里面的&lt;button&gt;元素如果没有用type属性指定类型，那么默认就是submit控件。 123&lt;form&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt; 上面表单的&lt;button&gt;元素，点击以后也会提交表单。 除了点击submit控件提交表单，还可以用表单元素的submit()方法，通过脚本提交表单。 1formElement.submit(); 表单元素的reset()方法可以重置所有控件的值（重置为默认值）。 1formElement.reset() FormData 对象概述表单数据以键值对的形式向服务器发送，这个过程是浏览器自动完成的。但是有时候，我们希望通过脚本完成这个过程，构造或编辑表单的键值对，然后通过脚本发送给服务器。浏览器原生提供了 FormData 对象来完成这项工作。 FormData()首先是一个构造函数，用来生成表单的实例。 1var formdata = new FormData(form); FormData()构造函数的参数是一个 DOM 的表单元素，构造函数会自动处理表单的键值对。这个参数是可选的，如果省略该参数，就表示一个空的表单。 下面是一个表单。 123456789101112131415&lt;form id=&quot;myForm&quot; name=&quot;myForm&quot;&gt; &lt;div&gt; &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;useracc&quot;&gt;账号：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;useracc&quot; name=&quot;useracc&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;userfile&quot;&gt;上传文件：&lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;userfile&quot; name=&quot;userfile&quot;&gt; &lt;/div&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit!&quot;&gt;&lt;/form&gt; 我们用FormData()处理上面这个表单。 12345678910var myForm = document.getElementById(&#x27;myForm&#x27;);var formData = new FormData(myForm);// 获取某个控件的值formData.get(&#x27;username&#x27;) // &quot;&quot;// 设置某个控件的值formData.set(&#x27;username&#x27;, &#x27;张三&#x27;);formData.get(&#x27;username&#x27;) // &quot;张三&quot; 实例方法FormData 提供以下实例方法。 FormData.get(key)：获取指定键名对应的键值，参数为键名。如果有多个同名的键值对，则返回第一个键值对的键值。 FormData.getAll(key)：返回一个数组，表示指定键名对应的所有键值。如果有多个同名的键值对，数组会包含所有的键值。 FormData.set(key, value)：设置指定键名的键值，参数为键名。如果键名不存在，会添加这个键值对，否则会更新指定键名的键值。如果第二个参数是文件，还可以使用第三个参数，表示文件名。 FormData.delete(key)：删除一个键值对，参数为键名。 FormData.append(key, value)：添加一个键值对。如果键名重复，则会生成两个相同键名的键值对。如果第二个参数是文件，还可以使用第三个参数，表示文件名。 FormData.has(key)：返回一个布尔值，表示是否具有该键名的键值对。 FormData.keys()：返回一个遍历器对象，用于for...of循环遍历所有的键名。 FormData.values()：返回一个遍历器对象，用于for...of循环遍历所有的键值。 FormData.entries()：返回一个遍历器对象，用于for...of循环遍历所有的键值对。如果直接用for...of循环遍历 FormData 实例，默认就会调用这个方法。 下面是get()、getAll()、set()、append()方法的例子。 123456789var formData = new FormData();formData.set(&#x27;username&#x27;, &#x27;张三&#x27;);formData.append(&#x27;username&#x27;, &#x27;李四&#x27;);formData.get(&#x27;username&#x27;) // &quot;张三&quot;formData.getAll(&#x27;username&#x27;) // [&quot;张三&quot;, &quot;李四&quot;]formData.append(&#x27;userpic[]&#x27;, myFileInput.files[0], &#x27;user1.jpg&#x27;);formData.append(&#x27;userpic[]&#x27;, myFileInput.files[1], &#x27;user2.jpg&#x27;); 下面是遍历器的例子。 12345678910111213141516171819202122232425262728var formData = new FormData();formData.append(&#x27;key1&#x27;, &#x27;value1&#x27;);formData.append(&#x27;key2&#x27;, &#x27;value2&#x27;);for (var key of formData.keys()) &#123; console.log(key);&#125;// &quot;key1&quot;// &quot;key2&quot;for (var value of formData.values()) &#123; console.log(value);&#125;// &quot;value1&quot;// &quot;value2&quot;for (var pair of formData.entries()) &#123; console.log(pair[0] + &#x27;: &#x27; + pair[1]);&#125;// key1: value1// key2: value2// 等同于遍历 formData.entries()for (var pair of formData) &#123; console.log(pair[0] + &#x27;: &#x27; + pair[1]);&#125;// key1: value1// key2: value2 表单的内置验证自动校验表单提交的时候，浏览器允许开发者指定一些条件，它会自动验证各个表单控件的值是否符合条件。 1234567891011121314151617&lt;!-- 必填 --&gt;&lt;input required&gt;&lt;!-- 必须符合正则表达式 --&gt;&lt;input pattern=&quot;banana|cherry&quot;&gt;&lt;!-- 字符串长度必须为6个字符 --&gt;&lt;input minlength=&quot;6&quot; maxlength=&quot;6&quot;&gt;&lt;!-- 数值必须在1到10之间 --&gt;&lt;input type=&quot;number&quot; min=&quot;1&quot; max=&quot;10&quot;&gt;&lt;!-- 必须填入 Email 地址 --&gt;&lt;input type=&quot;email&quot;&gt;&lt;!-- 必须填入 URL --&gt;&lt;input type=&quot;URL&quot;&gt; 如果一个控件通过验证，它就会匹配:valid的 CSS 伪类，浏览器会继续进行表单提交的流程。如果没有通过验证，该控件就会匹配:invalid的 CSS 伪类，浏览器会终止表单提交，并显示一个错误信息。 1234567input:invalid &#123; border-color: red;&#125;input,input:valid &#123; border-color: #ccc;&#125; checkValidity()除了提交表单的时候，浏览器自动校验表单，还可以手动触发表单的校验。表单元素和表单控件都有checkValidity()方法，用于手动触发校验。 12345// 触发整个表单的校验form.checkValidity()// 触发单个表单控件的校验formControl.checkValidity() checkValidity()方法返回一个布尔值，true表示通过校验，false表示没有通过校验。因此，提交表单可以封装为下面的函数。 1234567function submitForm(action) &#123; var form = document.getElementById(&#x27;form&#x27;); form.action = action; if (form.checkValidity()) &#123; form.submit(); &#125;&#125; willValidate 属性控件元素的willValidate属性是一个布尔值，表示该控件是否会在提交时进行校验。 1234567// HTML 代码如下// &lt;form novalidate&gt;// &lt;input id=&quot;name&quot; name=&quot;name&quot; required /&gt;// &lt;/form&gt;var input = document.querySelector(&#x27;#name&#x27;);input.willValidate // true validationMessage 属性控件元素的validationMessage属性返回一个字符串，表示控件不满足校验条件时，浏览器显示的提示文本。以下两种情况，该属性返回空字符串。 该控件不会在提交时自动校验 该控件满足校验条件 1234// HTML 代码如下// &lt;form&gt;&lt;input type=&quot;text&quot; required&gt;&lt;/form&gt;document.querySelector(&#x27;form input&#x27;).validationMessage// &quot;请填写此字段。&quot; 下面是另一个例子。 1234var myInput = document.getElementById(&#x27;myinput&#x27;);if (!myInput.checkValidity()) &#123; document.getElementById(&#x27;prompt&#x27;).innerHTML = myInput.validationMessage;&#125; setCustomValidity()控件元素的setCustomValidity()方法用来定制校验失败时的报错信息。它接受一个字符串作为参数，该字符串就是定制的报错信息。如果参数为空字符串，则上次设置的报错信息被清除。 这个方法可以替换浏览器内置的表单验证报错信息，参数就是要显示的报错信息。 12345678910&lt;form action=&quot;somefile.php&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;Username&quot; pattern=&quot;[a-z]&#123;1,15&#125;&quot; id=&quot;username&quot; &gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 上面的表单输入框，要求只能输入小写字母，且不得超过15个字符。如果输入不符合要求（比如输入“ABC”），提交表单的时候，Chrome 浏览器会弹出报错信息“Please match the requested format.”，禁止表单提交。下面使用setCustomValidity()方法替换掉报错信息。 123456var input = document.getElementById(&#x27;username&#x27;);input.oninvalid = function (event) &#123; event.target.setCustomValidity( &#x27;用户名必须是小写字母，不能为空，最长不超过15个字符&#x27; );&#125; 上面代码中，setCustomValidity()方法是在invalid事件的监听函数里面调用。该方法也可以直接调用，这时如果参数不为空字符串，浏览器就会认为该控件没有通过校验，就会立刻显示该方法设置的报错信息。 1234567891011121314151617181920/* HTML 代码如下&lt;form&gt; &lt;p&gt;&lt;input type=&quot;file&quot; id=&quot;fs&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/p&gt;&lt;/form&gt;*/document.getElementById(&#x27;fs&#x27;).onchange = checkFileSize;function checkFileSize() &#123; var fs = document.getElementById(&#x27;fs&#x27;); var files = fs.files; if (files.length &gt; 0) &#123; if (files[0].size &gt; 75 * 1024) &#123; fs.setCustomValidity(&#x27;文件不能大于 75KB&#x27;); return; &#125; &#125; fs.setCustomValidity(&#x27;&#x27;);&#125; 上面代码一旦发现文件大于 75KB，就会设置校验失败，同时给出自定义的报错信息。然后，点击提交按钮时，就会显示报错信息。这种校验失败是不会自动消除的，所以如果所有文件都符合条件，要将报错信息设为空字符串，手动消除校验失败的状态。 validity 属性控件元素的属性validity属性返回一个ValidityState对象，包含当前校验状态的信息。 该对象有以下属性，全部为只读属性。 ValidityState.badInput：布尔值，表示浏览器是否不能将用户的输入转换成正确的类型，比如用户在数值框里面输入字符串。 ValidityState.customError：布尔值，表示是否已经调用setCustomValidity()方法，将校验信息设置为一个非空字符串。 ValidityState.patternMismatch：布尔值，表示用户输入的值是否不满足模式的要求。 ValidityState.rangeOverflow：布尔值，表示用户输入的值是否大于最大范围。 ValidityState.rangeUnderflow：布尔值，表示用户输入的值是否小于最小范围。 ValidityState.stepMismatch：布尔值，表示用户输入的值不符合步长的设置（即不能被步长值整除）。 ValidityState.tooLong：布尔值，表示用户输入的字数超出了最长字数。 ValidityState.tooShort：布尔值，表示用户输入的字符少于最短字数。 ValidityState.typeMismatch：布尔值，表示用户填入的值不符合类型要求（主要是类型为 Email 或 URL 的情况）。 ValidityState.valid：布尔值，表示用户是否满足所有校验条件。 ValidityState.valueMissing：布尔值，表示用户没有填入必填的值。 下面是一个例子。 123456var input = document.getElementById(&#x27;myinput&#x27;);if (input.validity.valid) &#123; console.log(&#x27;通过校验&#x27;);&#125; else &#123; console.log(&#x27;校验失败&#x27;);&#125; 下面是另外一个例子。 12345var txt = &#x27;&#x27;;if (document.getElementById(&#x27;myInput&#x27;).validity.rangeOverflow) &#123; txt = &#x27;数值超过上限&#x27;;&#125;document.getElementById(&#x27;prompt&#x27;).innerHTML = txt; 如果想禁止浏览器弹出表单验证的报错信息，可以监听invalid事件。 123456789101112131415161718192021222324var input = document.getElementById(&#x27;username&#x27;);var form = document.getElementById(&#x27;form&#x27;);var elem = document.createElement(&#x27;div&#x27;);elem.id = &#x27;notify&#x27;;elem.style.display = &#x27;none&#x27;;form.appendChild(elem);input.addEventListener(&#x27;invalid&#x27;, function (event) &#123; event.preventDefault(); if (!event.target.validity.valid) &#123; elem.textContent = &#x27;用户名必须是小写字母&#x27;; elem.className = &#x27;error&#x27;; elem.style.display = &#x27;block&#x27;; input.className = &#x27;invalid animated shake&#x27;; &#125;&#125;);input.addEventListener(&#x27;input&#x27;, function(event)&#123; if ( &#x27;block&#x27; === elem.style.display ) &#123; input.className = &#x27;&#x27;; elem.style.display = &#x27;none&#x27;; &#125;&#125;); 上面代码中，一旦发生invalid事件（表单验证失败），event.preventDefault()用来禁止浏览器弹出默认的验证失败提示，然后设置定制的报错提示框。 表单的 novalidate 属性表单元素的 HTML 属性novalidate，可以关闭浏览器的自动校验。 12&lt;form novalidate&gt;&lt;/form&gt; 这个属性也可以在脚本里设置。 1form.noValidate = true; 如果表单元素没有设置novalidate属性，那么提交按钮（&lt;button&gt;或&lt;input&gt;元素）的formnovalidate属性也有同样的作用。 123&lt;form&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot; formnovalidate&gt;&lt;/form&gt; enctype 属性表单能够用四种编码，向服务器发送数据。编码格式由表单的enctype属性决定。 假定表单有两个字段，分别是foo和baz，其中foo字段的值等于bar，baz字段的值是一个分为两行的字符串。 12The first line.The second line. 下面四种格式，都可以将这个表单发送到服务器。 （1）GET 方法 如果表单使用GET方法发送数据，enctype属性无效。 123456&lt;form action=&quot;register.php&quot; method=&quot;get&quot; onsubmit=&quot;AJAXSubmit(this); return false;&quot;&gt;&lt;/form&gt; 数据将以 URL 的查询字符串发出。 1?foo=bar&amp;baz=The%20first%20line.%0AThe%20second%20line. （2）application/x-www-form-urlencoded 如果表单用POST方法发送数据，并省略enctype属性，那么数据以application/x-www-form-urlencoded格式发送（因为这是默认值）。 123456&lt;form action=&quot;register.php&quot; method=&quot;post&quot; onsubmit=&quot;AJAXSubmit(this); return false;&quot;&gt;&lt;/form&gt; 发送的 HTTP 请求如下。 123Content-Type: application/x-www-form-urlencodedfoo=bar&amp;baz=The+first+line.%0D%0AThe+second+line.%0D%0A 上面代码中，数据体里面的%0D%0A代表换行符（\\r\\n）。 （3）text/plain 如果表单使用POST方法发送数据，enctype属性为text/plain，那么数据将以纯文本格式发送。 1234567&lt;form action=&quot;register.php&quot; method=&quot;post&quot; enctype=&quot;text/plain&quot; onsubmit=&quot;AJAXSubmit(this); return false;&quot;&gt;&lt;/form&gt; 发送的 HTTP 请求如下。 12345Content-Type: text/plainfoo=barbaz=The first line.The second line. （4）multipart/form-data 如果表单使用POST方法，enctype属性为multipart/form-data，那么数据将以混合的格式发送。 1234567&lt;form action=&quot;register.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; onsubmit=&quot;AJAXSubmit(this); return false;&quot;&gt;&lt;/form&gt; 发送的 HTTP 请求如下。 12345678910111213Content-Type: multipart/form-data; boundary=---------------------------314911788813839-----------------------------314911788813839Content-Disposition: form-data; name=&quot;foo&quot;bar-----------------------------314911788813839Content-Disposition: form-data; name=&quot;baz&quot;The first line.The second line.-----------------------------314911788813839-- 这种格式也是文件上传的格式。 文件上传用户上传文件，也是通过表单。具体来说，就是通过文件输入框选择本地文件，提交表单的时候，浏览器就会把这个文件发送到服务器。 1&lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;myFile&quot;&gt; 此外，还需要将表单&lt;form&gt;元素的method属性设为POST，enctype属性设为multipart/form-data。其中，enctype属性决定了 HTTP 头信息的Content-Type字段的值，默认情况下这个字段的值是application/x-www-form-urlencoded，但是文件上传的时候要改成multipart/form-data。 123456789&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;div&gt; &lt;label for=&quot;file&quot;&gt;选择一个文件&lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;myFile&quot; multiple&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;submit&quot; id=&quot;submit&quot; name=&quot;submit_button&quot; value=&quot;上传&quot; /&gt; &lt;/div&gt;&lt;/form&gt; 上面的 HTML 代码中，file 控件的multiple属性，指定可以一次选择多个文件；如果没有这个属性，则一次只能选择一个文件。 12var fileSelect = document.getElementById(&#x27;file&#x27;);var files = fileSelect.files; 然后，新建一个 FormData 实例对象，模拟发送到服务器的表单数据，把选中的文件添加到这个对象上面。 123456789101112var formData = new FormData();for (var i = 0; i &lt; files.length; i++) &#123; var file = files[i]; // 只上传图片文件 if (!file.type.match(&#x27;image.*&#x27;)) &#123; continue; &#125; formData.append(&#x27;photos[]&#x27;, file, file.name);&#125; 最后，使用 Ajax 向服务器上传文件。 1234567891011var xhr = new XMLHttpRequest();xhr.open(&#x27;POST&#x27;, &#x27;handler.php&#x27;, true);xhr.onload = function () &#123; if (xhr.status !== 200) &#123; console.log(&#x27;An error occurred!&#x27;); &#125;&#125;;xhr.send(formData); 除了发送 FormData 实例，也可以直接 AJAX 发送文件。 123456var file = document.getElementById(&#x27;test-input&#x27;).files[0];var xhr = new XMLHttpRequest();xhr.open(&#x27;POST&#x27;, &#x27;myserver/uploads&#x27;);xhr.setRequestHeader(&#x27;Content-Type&#x27;, file.type);xhr.send(file); 参考链接 HTML5 Form Validation With the “pattern” Attribute, Thoriq Firdaus","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"HTML5","slug":"Node/HTML5","permalink":"https://coloey.github.io/categories/Node/HTML5/"}],"tags":[]},{"title":"axios发送请求时后台接收的req.body为空","slug":"axios发送请求时后台接收的req-body为空","date":"2022-03-21T01:47:50.000Z","updated":"2022-03-21T03:12:20.438Z","comments":true,"path":"2022/03/21/axios发送请求时后台接收的req-body为空/","link":"","permalink":"https://coloey.github.io/2022/03/21/axios%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E6%97%B6%E5%90%8E%E5%8F%B0%E6%8E%A5%E6%94%B6%E7%9A%84req-body%E4%B8%BA%E7%A9%BA/","excerpt":"","text":"首先，先了解一下关于http协议里定义的四种常见数据的post方法，分别是：application/www-form-ulrencodedmultipart/form-dataapplication/jsontext/xml Express依赖bodyParser对请求的包体进行解析。默认支持application/json,application/www-form-urlencoded,multipart/form-data.单数对xml没有支持。需要自己代码来实现 用axios post请求提交数据的时候需要清楚发送请求的类型是哪种，后台用相应的方法解析 1 使用FormData提交表单数据 坑一：使用FormData时一定要在先绑定submit事件，在submit事件触发时发送axios post请求,否则获取不到formData里面的值 坑二:axios请求里面如果直接使用data:formData，浏览器会自动帮我们加上 Content-Type: multipart/form-data ，因此请求要这样设置： 123456789101112131415var form = document.getElementById(&quot;myForm&quot;); // 用表单来初始化 var formData = new FormData(form); // 我们可以根据name来访问表单中的字段 var username = formData.get(&quot;username&quot;); // 获取名字 var password = formData.get(&quot;password&quot;); // 获取密码 axios(&#123; method:&quot;post&quot;, url:&#x27;http://127.0.0.1/api/login&#x27;, data:&#123; username:username, password:password &#125; &#125;) 这样默认Content-type：application/json, 如果表单属性过多，可以先用一个对象接收： 123456789101112131415var form = document.getElementById(&quot;myForm&quot;); // 用表单来初始化 var formData = new FormData(form); // 我们可以根据name来访问表单中的字段 let myFormData=&#123;&#125;; //如果表单属性过多可以先遍历 for(let pair of formData.entries())&#123; myFormData[pair[0]]=pair[1]; &#125; axios(&#123; method:&quot;post&quot;, url:&#x27;http://127.0.0.1/api/login&#x27;, data:myFormData &#125;) 后台接收使用中间件body-parser解析表单体数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const express=require(&#x27;express&#x27;);const session=require(&#x27;express-session&#x27;);const cors=require(&#x27;cors&#x27;);const bodyParser=require(&#x27;body-parser&#x27;)const app=express();app.use(cors());app.use( session(&#123; secret:&#x27;xiaoqi&#x27;, resave:false, saveUninitialized:true &#125;))//托管静态页面app.use(express.static(&#x27;./pages&#x27;));//自定义解析Post提交过来的表单数据app.use(bodyParser.urlencoded(&#123;extended:false&#125;))app.use(bodyParser.json())//登录API接口app.post(&#x27;/api/login&#x27;,(req,res)=&gt;&#123; //判断用户提交的登录信息是否正确 //console.log(req.body) if(req.body.username!==&quot;admin&quot;||req.body.password!==&quot;888888&quot;)&#123; return res.send(&#123;status:1,msg:&#x27;登录失败&#x27;&#125;) &#125; //登录成功则把信息存储在Session中 console.log(req.body); req.session.user=req.body;//用户登录信息 req.session.islogin=true;//用户登录状态 res.send(&#123;status:0,msg:&#x27;登录成功&#x27;&#125;)&#125;)//获取用户姓名的接口app.get(&#x27;/api/username&#x27;,(req,res)=&gt;&#123; //从Session中获取用户姓名响应给客户端 if(!req.session.islogin)&#123; return res.send(&#123;status:1,msg:&#x27;fail&#x27;&#125;) &#125; res.send(&#123; status:0, msg:&#x27;success&#x27;, username:req.session.user.username, &#125;)&#125;)//退出登录的接口app.post(&#x27;/api/logout&#x27;,(req,res)=&gt;&#123; //清空当前客户端的session信息 req.session.destroy() res.send(&#123; status:0, msg:&#x27;退出登录成功&#x27; &#125;)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;运行在http://127.0.0.1&#x27;)&#125;)","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"}],"tags":[]},{"title":"node连接MySql报错ER_NOT_SUPPORTED_AUTH_MODE","slug":"node连接MySql报错ER-NOT-SUPPORTED-AUTH-MODE","date":"2022-03-20T05:28:16.000Z","updated":"2022-03-20T05:33:56.881Z","comments":true,"path":"2022/03/20/node连接MySql报错ER-NOT-SUPPORTED-AUTH-MODE/","link":"","permalink":"https://coloey.github.io/2022/03/20/node%E8%BF%9E%E6%8E%A5MySql%E6%8A%A5%E9%94%99ER-NOT-SUPPORTED-AUTH-MODE/","excerpt":"","text":"报错信息本人系统安装的是mysql-installer-community-8.0.18.0.msi这个版本，然后我本地使用node-mysql去连接数据库。 123456789101112131415const mysql=require(&#x27;mysql&#x27;)//建立MYSQL与数据库的联系const db=mysql.createPool(&#123; host:&#x27;127.0.0.1&#x27;,//数据库的ip地址 user:&#x27;root&#x27;, password:&#x27;123456&#x27;, database:&#x27;my_db_01&#x27;,//指定要操作哪个数据库&#125;)//测试mysql能否正常工作db.query(&#x27;select 1&#x27;,(err,result)=&gt;&#123; //mysql工作期间报错 if(err)return console.log(err.message) //能成功执行SQL语句 console.log(result);&#125;) 运行db.js 12PS D:\\Vue-chat\\Server&gt; node db.jsER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server; consider upgrading MySQL client 报错原因mysql8.0以上加密方式，Node还不支持。 解决第一步谷歌查到了 https://stackoverflow.com/questions/50093144/mysql-8-0-client-does-not-support-authentication-protocol-requested-by-server这个答案，和我报错的步骤基本一样，按照这个进行操作，登录MySql Command Line Client使用这个 12345mysql&gt; alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;123456&#x27;;Query OK, 0 rows affected (0.27 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.08 sec)","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"}],"tags":[]},{"title":"git遇到的坑","slug":"git遇到的坑","date":"2022-03-18T13:44:59.000Z","updated":"2022-03-18T13:45:30.601Z","comments":true,"path":"2022/03/18/git遇到的坑/","link":"","permalink":"https://coloey.github.io/2022/03/18/git%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/","excerpt":"","text":"解决用git push origin master时出现的问题不知道小伙伴们在使用git push origin master时有没有遇到下面的问题，今天我遇到了，原因一般是相同的，下面详细分析一下 报错内容：To github.com:/! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to ‘&#103;&#x69;&#x74;&#64;&#x67;&#105;&#116;&#x68;&#x75;&#98;&#x2e;&#99;&#111;&#109;:***/***’hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: ‘git pull …’) before pushing again.hint: See the ‘Note about fast-forwards’ in ‘git push –help’ for details. 大致翻译为：错误：无法将一些引用推送到’&#x67;&#105;&#x74;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#109;：****** / Demo.git’提示：由于当前分支的尖端位于其远程对应的后面，因此更新被拒绝。 合并远程更改（例如’git pull’），然后再次推送。 有关详细信息，请参见“ git push –help”中的“关于fast-forwards的注意事项”。 这个报错的原因是因为远程repository和本地的repository有冲突，下面有3种解决办法： 按上面报错内容中所给的提示先用git pull之后再用git push$ git pull origin master$ git push origin master 使用强制push的方法，但是这会使远程修改丢失，一般是不可取的，尤其是多人协作开发的时候$ git push origin master -f 如果不想merge远程和本地修改，可以先创建新的分支，然后再push$ git branch [name]$ git push origin [name]","categories":[{"name":"git","slug":"git","permalink":"https://coloey.github.io/categories/git/"}],"tags":[]},{"title":"vim","slug":"vim","date":"2022-03-18T13:42:38.000Z","updated":"2022-03-18T13:43:36.735Z","comments":true,"path":"2022/03/18/vim/","link":"","permalink":"https://coloey.github.io/2022/03/18/vim/","excerpt":"","text":"Vim可以分为三种模式，分别为： 命令行模式（Command mode） 插入模式（Insert mode） 底行模式（Lastline mode） 命令行模式 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。 插入模式 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 底行模式 将文件保存或退出vim，也可以设置编辑环境，如寻找字符串、列出行号……等。 不过，一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。 5. Vim的基本操作a) 进入Vim 在系统光标提示符后，输入vim及文件名后，回车，进入Vim编辑画面。 特别注意，进入vim之后，是处于「命令行模式（command mode）」，要切换到「插入模式（Insert mode）」才能够输入文字。 b) 切换至插入模式（Insert mode）编辑文件 在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 c) 插入模式（Insert mode）切换到命令行模式（Command mode） 在插入模式下，按一下「ESC」键即可。 d) 退出vim及保存文件 在命令行模式（Command mode）下，按冒号「:」键，进入底行模式（Last Line mode） 常见底行模式下的命令行： :w filename 文件以filename为文件名保存 :wq 文件存盘并退出vim :q 文件不存盘并退出vim :q! 文件不存盘强制退出vim 6. 命令行模式下的功能键（部分）a) 从命令行模式切换为插入模式的三种方式 「 i 」：从当前光标位置进入插入模式 「 a 」：从当前光标位置的下一个字符进入插入模式 「 o 」：从当前光标位置的下一行进入插入模式 b) 从插入模式切换为命令行模式 按「ESC」键 c) 移动光标 vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。 d) 行尾追加 不管光标在该行的什么位置，直接按大写字母「A」即可 e) 删除单词 dw：把光标停留在需要删除的单词前面，依次按下「d」「w」，即可 de：把光标停留在需要删除的单词前面（无视单词前面的空格），依次按下「d」「e」，即可 f) 从当前光标处删除到行末 把光标停留在需要删除的句子前面，依次按下「d」「$」，即可 g) 快速跳转到行首 按下数字「0」，即可 h) 使用计数以删除单词 示例：this ABC DE line FGHI JK LMN OP of words is Q RS TUV cleaned up. 依次将鼠标定位到ABC前，按「d」「2」「w」，可以删除：ABC DE 将鼠标定位到FGHI前，按「d」「4」「w」，可以删除：FGHI JK LMN OP 将鼠标定位到Q前，按「d」「3」「w」，可以删除：Q RS TUV 得到句子： this line of words is cleaned up. i) 删除当前行 鉴于删除当前行这一操作的高频性，vim设计者简化了快捷键，按「d」「d」即可。 连续删除两行，从当前行开始，则为：「2」「d」「d」 j) 撤销更改 a. 按小写字母「u」，撤销上一步的更改操作； b. 按大写字母「U」，撤销整行的更改操作； c. 「Ctrl+R」撤销上一步「撤销操作」。 k) 将刚删除的内容置入其他行 之前刚刚删除的内容，会放入Vim编辑器的寄存器中。基于如此原理，可以将之认为成Windows操作系统的「剪切」操作。 先在想删除的行，按「d」「d」，进行删除操作； 再在想插入那行的前一行按「p」键即可。 l) 替换 将光标放到需要改的字符前，先按「r」键，再输入想更改的字符即可。 m) 跳转 顶部跳转命令：先按「Control」+「g」键，在终端底部调出一栏，然后输入「g」「g」即可； 底部跳转命令：先按「Control」+「g」键，在终端底部调出一栏，然后输入大写字母「g」即可； 特定行跳转命令：直接输入行号，然后输入大写字母「g」即可。 n) 查找命令 字符串查找： 输入英文斜杠「/」，后面紧接需要搜索的字符串即可。 查找下一个相同字符串，就紧接着按小写字母「n」； 查找上一个相同字符串，就紧接着按大写字母「N」。 配对括号查找： 在编程语言里，配对括号「 ( 」「 ) 」「 { 」「 } 」很常见，当定位到一个配对括号的一半时（注意光标要定位在该括号之前），按「%」，即可自动跳转到与之匹配的第一个配对括号处。 o) 替换字符串 当前行替换命令 在标准命令行模式下，光标定位到当前行，按英文冒号「 ：」，再输入s/oldstring/newstring/g 回车，即可。 完整语句为： :s/dogg/dog/g 特定几行替换命令 在标准命令行模式下，按英文冒号「 ：」，再输入#,#s/oldstring/newstring/g 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： ***:*5,8s/dogg/dog/g 全文替换命令 在标准命令行模式下，按英文冒号「 ：」，再输入%s/oldstring/newstring/g 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： *:*%s/dogg/dog/g 全文替换命令（每个匹配项替换前需确认） 在标准命令行模式下，按英文冒号「 ：」，再输入%s/oldstring/newstring/gc 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： *:*%s/dogg/dog/gc 作者：饥人谷_李维超链接：https://www.jianshu.com/p/8b679b35c9d5来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。Vim可以分为三种模式，分别为： 命令行模式（Command mode） 插入模式（Insert mode） 底行模式（Lastline mode） 命令行模式 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。 插入模式 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 底行模式 将文件保存或退出vim，也可以设置编辑环境，如寻找字符串、列出行号……等。 不过，一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。 5. Vim的基本操作a) 进入Vim 在系统光标提示符后，输入vim及文件名后，回车，进入Vim编辑画面。 特别注意，进入vim之后，是处于「命令行模式（command mode）」，要切换到「插入模式（Insert mode）」才能够输入文字。 b) 切换至插入模式（Insert mode）编辑文件 在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 c) 插入模式（Insert mode）切换到命令行模式（Command mode） 在插入模式下，按一下「ESC」键即可。 d) 退出vim及保存文件 在命令行模式（Command mode）下，按冒号「:」键，进入底行模式（Last Line mode） 常见底行模式下的命令行： :w filename 文件以filename为文件名保存 :wq 文件存盘并退出vim :q 文件不存盘并退出vim :q! 文件不存盘强制退出vim 6. 命令行模式下的功能键（部分）a) 从命令行模式切换为插入模式的三种方式 「 i 」：从当前光标位置进入插入模式 「 a 」：从当前光标位置的下一个字符进入插入模式 「 o 」：从当前光标位置的下一行进入插入模式 b) 从插入模式切换为命令行模式 按「ESC」键 c) 移动光标 vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。 d) 行尾追加 不管光标在该行的什么位置，直接按大写字母「A」即可 e) 删除单词 dw：把光标停留在需要删除的单词前面，依次按下「d」「w」，即可 de：把光标停留在需要删除的单词前面（无视单词前面的空格），依次按下「d」「e」，即可 f) 从当前光标处删除到行末 把光标停留在需要删除的句子前面，依次按下「d」「$」，即可 g) 快速跳转到行首 按下数字「0」，即可 h) 使用计数以删除单词 示例：this ABC DE line FGHI JK LMN OP of words is Q RS TUV cleaned up. 依次将鼠标定位到ABC前，按「d」「2」「w」，可以删除：ABC DE 将鼠标定位到FGHI前，按「d」「4」「w」，可以删除：FGHI JK LMN OP 将鼠标定位到Q前，按「d」「3」「w」，可以删除：Q RS TUV 得到句子： this line of words is cleaned up. i) 删除当前行 鉴于删除当前行这一操作的高频性，vim设计者简化了快捷键，按「d」「d」即可。 连续删除两行，从当前行开始，则为：「2」「d」「d」 j) 撤销更改 a. 按小写字母「u」，撤销上一步的更改操作； b. 按大写字母「U」，撤销整行的更改操作； c. 「Ctrl+R」撤销上一步「撤销操作」。 k) 将刚删除的内容置入其他行 之前刚刚删除的内容，会放入Vim编辑器的寄存器中。基于如此原理，可以将之认为成Windows操作系统的「剪切」操作。 先在想删除的行，按「d」「d」，进行删除操作； 再在想插入那行的前一行按「p」键即可。 l) 替换 将光标放到需要改的字符前，先按「r」键，再输入想更改的字符即可。 m) 跳转 顶部跳转命令：先按「Control」+「g」键，在终端底部调出一栏，然后输入「g」「g」即可； 底部跳转命令：先按「Control」+「g」键，在终端底部调出一栏，然后输入大写字母「g」即可； 特定行跳转命令：直接输入行号，然后输入大写字母「g」即可。 n) 查找命令 字符串查找： 输入英文斜杠「/」，后面紧接需要搜索的字符串即可。 查找下一个相同字符串，就紧接着按小写字母「n」； 查找上一个相同字符串，就紧接着按大写字母「N」。 配对括号查找： 在编程语言里，配对括号「 ( 」「 ) 」「 { 」「 } 」很常见，当定位到一个配对括号的一半时（注意光标要定位在该括号之前），按「%」，即可自动跳转到与之匹配的第一个配对括号处。 o) 替换字符串 当前行替换命令 在标准命令行模式下，光标定位到当前行，按英文冒号「 ：」，再输入s/oldstring/newstring/g 回车，即可。 完整语句为： :s/dogg/dog/g 特定几行替换命令 在标准命令行模式下，按英文冒号「 ：」，再输入#,#s/oldstring/newstring/g 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： ***:*5,8s/dogg/dog/g 全文替换命令 在标准命令行模式下，按英文冒号「 ：」，再输入%s/oldstring/newstring/g 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： *:*%s/dogg/dog/g 全文替换命令（每个匹配项替换前需确认） 在标准命令行模式下，按英文冒号「 ：」，再输入%s/oldstring/newstring/gc 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： *:*%s/dogg/dog/gc","categories":[{"name":"vim","slug":"vim","permalink":"https://coloey.github.io/categories/vim/"}],"tags":[]},{"title":"JSONP解决跨域问题","slug":"JSONP解决跨域问题","date":"2022-03-14T09:46:33.000Z","updated":"2022-04-19T08:13:24.597Z","comments":true,"path":"2022/03/14/JSONP解决跨域问题/","link":"","permalink":"https://coloey.github.io/2022/03/14/JSONP%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"","text":"概念：浏览器通过script标签的src属性，请求服务器上的数据，同时服务器返回一个函数的调用，这种请求数据的方式叫做JSONP 如果项目中已经配置了CORS跨域资源共享，为防止冲突,必须在配置CORS中间件之前声明JSONP的接口，否则JSONP接口会被处理成开启了CORS的接口 123456789101112131415161718192021222324252627const express=require(&#x27;express&#x27;)//创建web服务器const app=express()//导入路由模块const apirouter=require(&#x27;./apirouter&#x27;)//在配置cors中间件之前定义JSONP的接口app.get(&#x27;/api/jsonp&#x27;,(req,res)=&gt;&#123; //1 得到客户端请求的回调函数名称 const funcName=req.query.callback //2 定义发送到客户端的JSON格式数据对象 const data=&#123;name:&#x27;zs&#x27;,age:20&#125; //3 拼接一个函数调用的字符串 const scriptStr=`$&#123;funcName&#125;($&#123;JSON.stringify(data)&#125;)` //4 把拼接的字符串响应给客户端的&lt;script&gt;标签进行解析执行 res.send(scriptStr)&#125;)app.use(express.urlencoded(&#123;extended:false&#125;))//在路由之前配置cors中间件const cors=require(&#x27;cors&#x27;)app.use(cors())//将路由模块注册为全局中间件app.use(&#x27;/api&#x27;,apirouter)app.listen(80,()=&gt;&#123; console.log(&#x27;运行在http://127.0.0.1&#x27;)&#125;) 发请求：HTML 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.0/jquery.min.js&quot;&gt; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btnJsonp&quot;&gt;Jsonp&lt;/button&gt; &lt;script&gt; $(&#x27;#btnJsonp&#x27;).on(&#x27;click&#x27;,function()&#123; $.ajax(&#123; type:&#x27;GET&#x27;, url:&#x27;http://127.0.0.1/api/jsonp&#x27;, dataType:&#x27;jsonp&#x27;, success:function(res)&#123; console.log(res) &#125; &#125;) &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; JSONP调用是通过动态创建script元素并为src属性指定跨域URL实现的，此时script和img元素类似，能够不受限制地从其他域加载资源，因为JSONP是有效的JavaScript,所以JSONP响应在被加载完成之后会立即执行，比如以上例子中，服务器返回了带有src的script标签，客户端·收到响应后，就会去请求http://127.0.0.1/api/jsonp?callback(data)数据 缺点： JSONP是从不同域拉取可执行代码，如果这个域不可信，则可能在响应中加入恶意内容 不好确定JSONP请求是否失败，虽然HTML5规定了script元素的onerror时间处理程序，但还没有被任何浏览器实现，为此，开发者经常需要使用计时器决定是否放弃等待响应","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"Express","slug":"Node/Express","permalink":"https://coloey.github.io/categories/Node/Express/"}],"tags":[]},{"title":"基于cors解决跨域问题","slug":"基于cors解决跨域问题","date":"2022-03-14T06:29:06.000Z","updated":"2022-03-14T09:13:22.067Z","comments":true,"path":"2022/03/14/基于cors解决跨域问题/","link":"","permalink":"https://coloey.github.io/2022/03/14/%E5%9F%BA%E4%BA%8Ecors%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"","text":"123456789101112131415161718192021222324252627282930apirouter.js:const express=require(&#x27;express&#x27;)//创建web服务器实例const router=express.Router()//挂载对应路由router.get(&#x27;/get&#x27;,(req,res)=&gt;&#123; res.send(&#123; status:0,//0表示成功，1表示失败 msg:&#x27;Get请求成功&#x27;, data:req.query &#125;)&#125;)//定义post接口router.post(&#x27;/post&#x27;,(req,res)=&gt;&#123; res.send(&#123; status:0,//0表示成功，1表示失败 msg:&#x27;Post请求成功&#x27;, data:req.body &#125;)&#125;)//定义delete接口router.delete(&#x27;/delete&#x27;,(req,res)=&gt;&#123; res.send(&#123; status:0,//0表示成功，1表示失败 msg:&#x27;Delete请求成功&#x27;, &#125;)&#125;)module.exports=router Get ,Post,Delete接口 123456789101112131415const express=require(&#x27;express&#x27;)//创建web服务器const app=express()//导入路由模块const apirouter=require(&#x27;./apirouter&#x27;)app.use(express.urlencoded(&#123;extended:false&#125;))//在路由之前配置cors中间件,解决跨域问题const cors=require(&#x27;cors&#x27;)app.use(cors())//将路由模块注册为全局中间件app.use(&#x27;/api&#x27;,apirouter)app.listen(80,()=&gt;&#123; console.log(&#x27;运行在http://127.0.0.1&#x27;)&#125;) 解决接口跨域问题CORS(主流方案) JSONP（有缺陷：只支持Get请求） 什么是CORSCORS(Cross-Origin Resource Sharing,跨域资源共享)，由一系列Http响应头组成，这些Http响应头决定浏览器是否阻止前端JS代码跨域获取资源。 浏览器的同源安全策略默认会阻止网页“跨域”获取资源，但如果接口服务器配置了CORS相关的HTTP响应头，就可以解决浏览器端的跨域访问限制。 浏览器：网页==》跨域请求 接口服务器（配置Access-Control-Allow-*相关响应头） ​ 《== 响应 CORS响应头部Access-Control-Allow-Origin响应头部可以携带一个Access-Control-Allow-Origin字段，语法如下： Access-Control-Allow-Origin:|* 其中origin参数指定了允许访问该资源的外域URL 例如：下面字段只允许访问来自http://itcast.cn的请求 res.setHeader(‘Access-Control-Allow-Origin’,’http://itcast.cn&#39;) *通配符表示允许来自任何域的请求 Access-Control-Allow-Headers默认情况下，CORS仅支持客户端向服务器发送9个请求头： Accept,Accept-Language,Content-Language,DPR,Downlink,Save-Data,Viewport-Width,Width,Content-Type(仅限于text-plain,multipart/form-data,application/x-www-form-urlencoded三者之一) 如果向服务器发送了额外的请求头信息，则需要在服务器端，通过Access-Control-Allow-Headers对额外的请求头进行声明，否则这次请求会失败 例如，允许客户端向服务器发送Content-Type请求头和X-Custom-Header请求头 res.setHeader(‘Access-Control-Allow-Header’,’Content-Type’,’X-Custom-Header’) Access-Control-Allow-Methods 默认情况下，CORS仅支持客户端发起GET,POST,HEAD请求。如果客户端希望通过PUT,DELETE等方式请求服务器的资源，则需要在服务器端，通过Access-Control-Allow-Methods来指明实际请求所允许的HTTP方法 123res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;,&#x27;POST,GET,DELETE,HEAD&#x27;)//允许所有HTTP请求方法res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;,&#x27;*&#x27;) 请求类型简单请求满足两个条件即为简单请求： 1 请求方式为GET,POST,HEAD三者之一 2 HTTP头部信息不超过以下几种字段：无定义头部字段，Accept,Accept-Language,Content-Language,Save-Data,Viewport-Width,Width,Content-Type(仅限于text-plain,multipart/form-data,application/x-www-form-urlencoded三者之一) 特点：客户端与服务器只发生一次请求 预检请求1 请求方式为GET,POST,HEAD之外的请求方法 2 请求头中包含自定义头部字段 3 向服务器发送了application/jso格式的数据 在浏览器服务器的正式通信之前，浏览器会先发送OPTION请求进行预检，以获知该服务器是否允许该实际请求，这一次OPTION称为预检请求，服务器成功响应预检请求后才会发送真正的请求并且携带真正的数据。 特点：客户端与服务器只发生两次请求 CORS注意事项1 CORS主要在服务器端进行配置，客户端浏览器无需做任何额外的配置，即可请求开启CORS的接口 2 CORS在浏览器中有兼容性，只有支持XMLHttpRequest Level2的浏览器才能正常访问开启了CORS的服务端接口（IE10+,Chrome4+等）","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"Express","slug":"Node/Express","permalink":"https://coloey.github.io/categories/Node/Express/"}],"tags":[]},{"title":"自定义表单中间件","slug":"自定义表单中间件","date":"2022-03-13T15:13:46.000Z","updated":"2022-03-13T15:32:36.539Z","comments":true,"path":"2022/03/13/自定义表单中间件/","link":"","permalink":"https://coloey.github.io/2022/03/13/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%8D%95%E4%B8%AD%E9%97%B4%E4%BB%B6/","excerpt":"","text":"12345678910111213const express=require(&#x27;express&#x27;)//创建web服务器实例const app=express()//导入处理查询字符串的querystring,通过这个模块提供的parse()函数，可以查询字符串，解析成对象的格式//const qs=require(&#x27;querystring&#x27;)const customBodyParser=require(&#x27;./custom-body-parser&#x27;)app.use(customBodyParser)app.post(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.send(req.body)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;express server running at http://127.0.0.1&#x27;)&#125;) customBodyParser.js 1234567891011121314151617const qs=require(&#x27;querystring&#x27;)const bodyParser=(req,res,next)=&gt;&#123; //1 定义一个str字符串，专门用来存储客户端发送过来的请求体数据 let str=&quot;&quot; //监听req的data事件 req.on(&#x27;data&#x27;,(chunk)=&gt;&#123; str+=chunk &#125;) //监听req的end事件 req.on(&#x27;end&#x27;,()=&gt;&#123; //在str存放的是完整的请求体数据，解析成对象格式 调用qs.parse()方法，把查询字符串解析为对象 const body=qs.parse(str) req.body=body//将解析处的请求体数据挂载为req.body next() &#125;)&#125;module.exports=bodyParser","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"Express","slug":"Node/Express","permalink":"https://coloey.github.io/categories/Node/Express/"}],"tags":[]},{"title":"路由","slug":"路由","date":"2022-03-12T15:34:29.000Z","updated":"2022-03-12T15:34:30.216Z","comments":true,"path":"2022/03/12/路由/","link":"","permalink":"https://coloey.github.io/2022/03/12/%E8%B7%AF%E7%94%B1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"中间件","slug":"中间件","date":"2022-03-12T07:57:20.000Z","updated":"2022-03-13T15:29:55.148Z","comments":true,"path":"2022/03/12/中间件/","link":"","permalink":"https://coloey.github.io/2022/03/12/%E4%B8%AD%E9%97%B4%E4%BB%B6/","excerpt":"","text":"使用express创建服务器，发起Get,Post请求123456789101112131415161718192021222324252627const express=require(&#x27;express&#x27;)//创建web服务器实例const app=express()//监听客户端的get请求post请求,并向客户端响应请求app.get(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.send(&#123;name:&#x27;zs&#x27;,age:20,gender:&#x27;男&#x27;&#125;)&#125;)app.post(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.send(&#x27;请求成功&#x27;)&#125;)//获取请求参数app.get(&quot;/&quot;,(req,res)=&gt;&#123; //req.query可以获取到客户端发送过来的查询参数向客户端响应一个查询参数 console.log(req.query) res.send(req.query)&#125;)//获取到URL中的动态参数app.get(&quot;/user/:id/:username&quot;,(req,res)=&gt;&#123; console.log(req.params) res.send(req.params)&#125;)//启动服务器app.listen(80,()=&gt;&#123; console.log(&#x27;express server running at http://127.0.0.1&#x27;)&#125;) 托管静态资源express.static()：创建一个静态资源服务器，通过如下代码可以将public目录下的图片，CSS文件，JavaScript文件对外开放访问 123456789101112const express=require(&#x27;express&#x27;)//创建web服务器实例const app=express()//托管多个静态资源目录,express.static会根据目录的添加顺序查找所需文件，http://127.0.0.1,public不出现在路径中app.use(express.static(&#x27;public&#x27;))app.use(express.static(&#x27;files&#x27;))//希望挂载前缀ap.use(&#x27;/public&#x27;,express.static(&#x27;public&#x27;,))//打开的是http://127.0.0.1/public，如果希望public出现在路径中则将访问前缀写public//启动服务器app.listen(80,()=&gt;&#123; console.log(&#x27;express server running at http://127.0.0.1&#x27;)&#125;) 中间件中间件的作用：多个中间件之间共享一份req和res,基于这种特性可以在上游的中间件中，统一为req或res对象添加自定义顶点属性或方法，供下游的中间件或路由进行使用 1234567891011121314151617const express=require(&quot;express&quot;)const app=express()//中间件的作用：共享req,resapp.use((req,res,next)=&gt;&#123; const time=Date.now() req.startTime=time next()&#125;)app.get(&#x27;/&#x27;,(req,res)=&gt;&#123; res.send(&#x27;Home page&#x27;+req.startTime)&#125;)app.get(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.send(&#x27;User page&#x27;+req.startTime)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;http://127.0.0.1&#x27;)&#125;) 中间件分类：[]: http://expressjs.com/en/guide/using-middleware.html 错误级别的中间件要注册在所有路由之后 1234567891011121314const express = require(&quot;express&quot;);const app=express()app.get(&#x27;/&#x27;,(req,res)=&gt;&#123; throw new Error(&#x27;服务器发生错误&#x27;) res.send(&#x27;Home page&#x27;)&#125;)//错误级别中间件必须注册在所有路由之后app.use((err,req,res,next)=&gt;&#123; console.error(err.message) res.send(&#x27;Something broke:&#x27;+err.message)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;http://127.0.0.1&#x27;)&#125;) 使用中间件的注意事项 要在路由之前注册中间件 客户端发送过来的请求，可以连续调用多个中间件进行处理 执行完中间件的业务代码，要记得调用next（）函数 连续调用的多个中间件时，多个中间件间共享req和res对象","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"Express","slug":"Node/Express","permalink":"https://coloey.github.io/categories/Node/Express/"}],"tags":[]},{"title":"Web和微信小程序中本地存储的差别","slug":"Web和微信小程序中本地存储的差别","date":"2022-03-01T09:23:54.000Z","updated":"2022-03-01T09:32:35.988Z","comments":true,"path":"2022/03/01/Web和微信小程序中本地存储的差别/","link":"","permalink":"https://coloey.github.io/2022/03/01/Web%E5%92%8C%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9A%84%E5%B7%AE%E5%88%AB/","excerpt":"","text":"Web和微信小程序中本地存储的差别使用上Web:localStorage.setItem(“key”,”value”) ​ localStorage.getItem(“key”) 小程序中：wx.setStorageSync(“key”,”value”); ​ wx.getStorageSync(“key”) 数据存储Web:不管存入的是什么类型的数据，最终都会先调用toString()，把数据编程字符串再存进去 小程序：不存在类型转换，存什么类型的数据进去，获取的就是什么类型的数据","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://coloey.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[]},{"title":"swiper","slug":"swiper","date":"2022-02-28T03:27:42.000Z","updated":"2022-02-28T03:31:48.073Z","comments":true,"path":"2022/02/28/swiper/","link":"","permalink":"https://coloey.github.io/2022/02/28/swiper/","excerpt":"","text":"swiper存在默认宽度和高度：100%*150px image存在默认宽度和高度：320px*240px 设计图片和轮播图： 1 先看原图的宽高：750*340 2 让图片的高度自适应 宽度等于100% 3 让swiper标签的高度变成和图片的一样高即可 4 图片标签mode=“widthFix”","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://coloey.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[]},{"title":"组件通信","slug":"组件通信","date":"2022-02-26T15:39:09.000Z","updated":"2022-02-26T15:40:12.435Z","comments":true,"path":"2022/02/26/组件通信/","link":"","permalink":"https://coloey.github.io/2022/02/26/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/","excerpt":"","text":"父组件向子组件传递数据1 父组件中： 123&lt;view&gt; &lt;Tab tabs=&quot;&#123;&#123;tabs&#125;&#125;&quot; binditemChange=&quot;handleItemChange&quot;&gt;&lt;/Tab&gt;&lt;/view&gt; 2.子组件： 1234567properties: &#123; tabs:&#123; type:Array, value:[] &#125; &#125;, 子组件向父组件传递数据：1 子组件：用this.triggerEvent(“事件名”,传递的参数) 123456789methods:&#123; handle(e)&#123; const &#123;index&#125;=e.currentTarget.dataset; this.triggerEvent(&quot;itemChange&quot;,&#123;index&#125;); &#125; &#125; 2 父组件：用”bind+事件名”触发自定义方法 123&lt;view&gt; &lt;Tab tabs=&quot;&#123;&#123;tabs&#125;&#125;&quot; binditemChange=&quot;handleItemChange&quot;&gt;&lt;/Tab&gt;&lt;/view&gt; 12345678910handleItemChange(e)&#123; //console.log(e) const &#123;index&#125;=e.detail; let &#123;tabs&#125;=this.data; tabs.forEach((v,i)=&gt;i===index?v.isActive=true:v.isActive=false); this.setData(&#123; tabs &#125;) &#125;","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://coloey.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[]},{"title":"事件绑定","slug":"事件绑定","date":"2022-02-25T09:06:50.000Z","updated":"2022-02-26T15:40:06.139Z","comments":true,"path":"2022/02/25/事件绑定/","link":"","permalink":"https://coloey.github.io/2022/02/25/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/","excerpt":"","text":"绑定输入事件 用bindinput 获取输入框的值用e.detail.value 输入框赋值用this.setData({num:e.detail.num}) 点击事件 关键字:bindtap 无法在小程序中的事件直接传参，通过自定义事件传参 事件源中获取自定义属性","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://coloey.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[]},{"title":"路由参数","slug":"路由参数","date":"2022-02-06T08:51:25.000Z","updated":"2022-02-06T15:07:41.991Z","comments":true,"path":"2022/02/06/路由参数/","link":"","permalink":"https://coloey.github.io/2022/02/06/%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0/","excerpt":"","text":"query参数：12345678&lt;li v-for=&#x27;m in messageList&#x27; :key=&#x27;m.id&#x27;&gt; &lt;!-- 通过query传递参数 --&gt; &lt;router-link :to=&quot; &#123; name:&#x27;messageDetail&#x27;, query:&#123;id:m.id,title:m.title&#125; &#125;&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt;&lt;/li&gt; params参数:1 配置路由声明接收param参数 1234567891011&#123;path:&#x27;/home&#x27;, component:Home, children:[ &#123;path:&#x27;news&#x27;, component:News&#125;, &#123;path:&#x27;message&#x27;, component:Message, children:[ &#123;path:&#x27;detail/:id/:title&#x27;,name:&#x27;messageDetail&#x27;,component:Detail&#125;//使用占位符声明接收params参数 ]&#125; ]&#125;, 2 传递参数 12345678910 &lt;li v-for=&#x27;m in messageList&#x27; :key=&#x27;m.id&#x27;&gt; &lt;!--跳转并携带params参数，to的字符写法--!&gt; &lt;router-link :to=&quot;`/home/message/detail/$&#123;m.id&#125;/$&#123;m.title&#125;`&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt; &lt;!-- 对象写法只能写name不能写path --&gt; &lt;!-- &lt;router-link :to=&quot; &#123;name:&#x27;messageDetail&#x27;, params:&#123;id:m.id,title:m.title&#125; &#125;&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt; --&gt;&lt;/li&gt; 注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置项 props配置123456789101112//props第一种写法，值为对象，该对象中的key-value都会以props的形式传给Detail组件props:&#123;a:1,b:&#x27;hello&#x27;&#125;,//props的第二种写法，值为布尔值，若布尔值为真，就会把该路由组件收到的所有params参数以props的形式传给Detail组件props:true,//第三种写法，值为函数props($route)&#123; return &#123;id:$route.query.id,title:$route.query.title&#125;&#125;,//解构赋值props(&#123;query&#125;)&#123; return &#123;id:query.id,title:query.title&#125;&#125; Detail组件接收参数： 123456&lt;script&gt;export default &#123; name:&#x27;Detail&#x27;, props:[&#x27;id&#x27;,&#x27;title&#x27;],&#125;&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"Vue3事件总线","slug":"Vue3事件总线","date":"2022-02-02T08:17:38.000Z","updated":"2022-02-02T08:38:36.586Z","comments":true,"path":"2022/02/02/Vue3事件总线/","link":"","permalink":"https://coloey.github.io/2022/02/02/Vue3%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/","excerpt":"","text":"全局事件总线一种组件间的通信方式，适用于任意组件间的通信。 安装全局事件总线： 引入/编写事件库 在入口文件中挂载 在组件中引入并使用 安装：npm install –save vue3-eventbus 挂载： 123//App.vueimport eventBus from &#x27;vue3-eventbus&#x27;app.use(eventBus) 使用： 12345678//Button.vueimport bus from &#x27;vue3-eventbus&#x27;export default &#123; setup()&#123; bus.emit(&#x27;foo&#x27;,&#123;a:&#x27;b&#x27;&#125;) &#125;&#125; 消息订阅预发布（pubsub) 安装pubsub:npm install pubsub-js 引入：import pubsub from “pubsub-js” 接收数据，A组件想接收数据，则在A组件中订阅消息，订阅回调留在A组件自身。 12345678910methods()&#123; demo(data)&#123; &#125;&#125;mounted()&#123;this.pid=pubsub.subscribe(&#x27;xxx&#x27;,(msg,data)=&gt;&#123;&#125;)//订阅消息&#125; 提供数据：pubsub.publish(‘xxx’,数据) 最好在beforeDestroy钩子中，用Pubsub.unsubscribe(pid)取消订阅","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"customRef","slug":"customRef","date":"2022-02-01T08:55:59.000Z","updated":"2022-02-01T09:03:45.036Z","comments":true,"path":"2022/02/01/customRef/","link":"","permalink":"https://coloey.github.io/2022/02/01/customRef/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031setup()&#123; function myRef(value,delay=500)&#123; let timeout return customRef((track,trigger)=&gt;&#123; return &#123; get()&#123; console.log(`有人从myRef中读取了数据:$&#123;value&#125;`) track()//通知Vue追踪value的变化（提前和get商量一下，让它认为这个value是可用的） return value &#125;, set(newValue)&#123; clearTimeout(timeout) console.log(`有人从myRef中修改了数据:$&#123;newValue&#125;`) timeout=setTimeout(()=&gt;&#123; value=newValue trigger()//通知Vue重新解析模板 &#125;,delay) &#125; &#125; &#125;) &#125; let val=myRef(&quot;hello&quot;) return &#123; val &#125; &#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"shallowReactive和shallowRef","slug":"shallowReactive和shallowRef","date":"2022-01-31T08:41:52.000Z","updated":"2022-02-01T07:57:53.734Z","comments":true,"path":"2022/01/31/shallowReactive和shallowRef/","link":"","permalink":"https://coloey.github.io/2022/01/31/shallowReactive%E5%92%8CshallowRef/","excerpt":"","text":"shallowReactive:只处理对象最外层属性的响应式（浅响应式） shallowRef:只处理基本数据类型的响应式，不进行对象的响应式处理 什么时候使用？ 如果有一个对象数据，结构比较深，但变化时只是外层属性变化==&gt;shallowReactive 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换==&gt;shallowRef","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"toRef","slug":"toRef","date":"2022-01-31T07:49:20.000Z","updated":"2022-05-04T03:47:58.739Z","comments":true,"path":"2022/01/31/toRef/","link":"","permalink":"https://coloey.github.io/2022/01/31/toRef/","excerpt":"","text":"toRef:作用：创建一个ref对象，其value值指向另一个对象中的某个属性，可以用来为源响应式对象上的某个 property 新创建一个 ref。然后，ref 可以被传递，它会保持对其源 property 的响应式连接。 语法：const name=toRef(person,’name’) 应用：要将响应式对象中的某个属性单独提供给外部使用时 扩展:toRefs与toRef功能一致，但可以批量创建多个ref对象，语法：toRefs(person),将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的 ref。 123456789101112const state = reactive(&#123; foo: 1, bar: 2&#125;)const fooRef = toRef(state, &#x27;foo&#x27;)fooRef.value++console.log(state.foo) // 2state.foo++console.log(fooRef.value) // 3 当你要将 prop 的 ref 传递给复合函数时，toRef 很有用： 12345export default &#123; setup(props) &#123; useSomeFeature(toRef(props, &#x27;foo&#x27;)) &#125;&#125; 即使源 property 不存在，toRef 也会返回一个可用的 ref。这使得它在使用可选 prop 时特别有用，可选 prop 并不会被 toRefs 处理。 toRefs将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的 ref。 123456789101112131415161718192021const state = reactive(&#123; foo: 1, bar: 2&#125;)const stateAsRefs = toRefs(state)/*stateAsRefs 的类型:&#123; foo: Ref&lt;number&gt;, bar: Ref&lt;number&gt;&#125;*/// ref 和原始 property 已经“链接”起来了state.foo++console.log(stateAsRefs.foo.value) // 2stateAsRefs.foo.value++console.log(state.foo) // 3 当从组合式函数返回响应式对象时，toRefs 非常有用，这样消费组件就可以在不丢失响应性的情况下对返回的对象进行解构/展开： 1234567891011121314151617181920212223function useFeatureX() &#123; const state = reactive(&#123; foo: 1, bar: 2 &#125;) // 操作 state 的逻辑 // 返回时转换为ref return toRefs(state)&#125;export default &#123; setup() &#123; // 可以在不失去响应性的情况下解构 const &#123; foo, bar &#125; = useFeatureX() return &#123; foo, bar &#125; &#125;&#125; toRefs 只会为源对象中包含的 property 生成 ref。如果要为特定的 property 创建 ref，则应当使用 toRef","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"watchEffect","slug":"watchEffect","date":"2022-01-30T15:44:30.000Z","updated":"2022-01-30T15:51:06.817Z","comments":true,"path":"2022/01/30/watchEffect/","link":"","permalink":"https://coloey.github.io/2022/01/30/watchEffect/","excerpt":"","text":"watch和watchEffect区别：watch:既要指明监视的属性，也要指明监视的回调 watchEffect:不用指明监视哪个属性，监视的回调中用到哪个属性就监视哪个属性 watchEffect有点像computed: 但computed注重的是计算出来的值即回调函数的返回值，所以必须要写返回值 而watch注重的是过程即回调函数的函数体，所以不用写返回值 123456789//watchEffect指定的回调函数中用到的数据只要发生变化，则直接重新执行回调 let sum=ref(1) let msg=ref(&quot;你好呀&quot;) watchEffect(()=&gt;&#123; const x1=sum.value const x2=person.firstName console.log(&#x27;watchEffect的回调被调用了&#x27;,x1,x2) &#125;)","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"二分查找","slug":"二分查找","date":"2022-01-30T07:37:59.000Z","updated":"2022-01-30T07:53:02.198Z","comments":true,"path":"2022/01/30/二分查找/","link":"","permalink":"https://coloey.github.io/2022/01/30/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"大家写二分法经常写乱，主要是因为对区间的定义没有想清楚，区间的定义就是不变量。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。 写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。 下面我用这两种区间的定义分别讲解两种不同的二分写法。 二分法第一种写法第一种写法，我们定义 target 是在一个在左闭右闭的区间里，也就是[left, right] （这个很重要非常重要）。 区间的定义这就决定了二分法的代码应该如何写，因为定义target在[left, right]区间，所以有如下两点： while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;= if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 1234567891011121314151617181920// 版本一class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right] while (left &lt;= right) &#123; // 当left==right，区间[left, right]依然有效，所以用 &lt;= int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2 if (nums[middle] &gt; target) &#123; right = middle - 1; // target 在左区间，所以[left, middle - 1] &#125; else if (nums[middle] &lt; target) &#123; left = middle + 1; // target 在右区间，所以[middle + 1, right] &#125; else &#123; // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 &#125; &#125; // 未找到目标值 return -1; &#125;&#125;; 二分法第二种写法如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。 有如下两点： while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的 if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle] 1234567891011121314151617181920// 版本二class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right) while (left &lt; right) &#123; // 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt; int middle = left + ((right - left) &gt;&gt; 1); if (nums[middle] &gt; target) &#123; right = middle; // target 在左区间，在[left, middle)中 &#125; else if (nums[middle] &lt; target) &#123; left = middle + 1; // target 在右区间，在[middle + 1, right)中 &#125; else &#123; // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 &#125; &#125; // 未找到目标值 return -1; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://coloey.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"插槽","slug":"插槽","date":"2022-01-29T15:41:20.000Z","updated":"2022-01-29T15:58:25.041Z","comments":true,"path":"2022/01/29/插槽/","link":"","permalink":"https://coloey.github.io/2022/01/29/%E6%8F%92%E6%A7%BD/","excerpt":"","text":"1 作用： 让父组件可以向子组件指定位置插入html结构，是一种组件间的通信方式，适用于父组件=&gt;子组件 2 使用方式 （1）默认插槽 123456789101112父组件： &lt;Category&gt; &lt;div&gt; html结构 &lt;/div&gt; &lt;/Category&gt;子组件： &lt;template&gt; &lt;div&gt; &lt;slot&gt;插槽默认内容&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 2 具名插槽 1234567891011121314151617181920212223242526父组件： &lt;Category&gt; &lt;template #header&gt; &lt;div&gt; html结构 &lt;/div&gt; &lt;/template&gt; &lt;template slot=&quot;center&quot;&gt; &lt;div&gt; html结构 &lt;/div&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;div&gt; html结构 &lt;/div&gt; &lt;/template&gt; &lt;/Category&gt;子组件： &lt;template&gt; &lt;div&gt; &lt;slot name=&quot;center&quot;&gt;插槽默认内容&lt;/slot&gt; &lt;slot name=&quot;footer&quot;&gt;插槽默认内容&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 3 作用域插槽 理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者决定，(games数据在Category组件中，但使用数据所遍历的结构由App组件决定) 12345678910111213141516171819202122232425262728293031323334353637383940414243父组件：&lt;Category title=&quot;游戏&quot;&gt; &lt;template v-slot=&quot;&#123;games&#125;&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(game,index) in games&quot; :key=&quot;index&quot;&gt; &#123;&#123;game&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/template&gt;&lt;/Category&gt;&lt;Category title=&quot;游戏&quot;&gt; &lt;template v-slot=&quot;&#123;games&#125;&quot;&gt; &lt;ol&gt; &lt;li v-for=&quot;(game,index) in games&quot; :key=&quot;index&quot;&gt; &#123;&#123;game&#125;&#125; &lt;/li&gt; &lt;/ol&gt; &lt;/template&gt;&lt;/Category&gt;子组件：&lt;template&gt;&lt;div&gt; &lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;/h3&gt; &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;&lt;/div&gt; &lt;/template&gt;&lt;script&gt;import &#123;reactive&#125; from &quot;vue&quot;export default &#123; name:&#x27;Category&#x27;, props:[&#x27;title&#x27;], setup()&#123; let games=reactive([&#x27;红色警戒&#x27;,&#x27;超级玛丽&#x27;,&#x27;穿越火线&#x27;,&#x27;魂斗罗&#x27;]) return&#123; games &#125; &#125;&#125;&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"ref函数","slug":"ref函数","date":"2022-01-27T07:38:53.000Z","updated":"2022-02-01T09:52:15.436Z","comments":true,"path":"2022/01/27/ref函数/","link":"","permalink":"https://coloey.github.io/2022/01/27/ref%E5%87%BD%E6%95%B0/","excerpt":"","text":"ref函数：作用：定义一个响应式函数 语法：const xxx=ref(initValue) 创建一个包含响应式数据的引用对象（reference对象，简称ref对象) JS中操作数据：xxx.value 模板中读取数据，不需要.value,直接 Ps: 接收的数据类型可以是：基本类型也可以是对象类型 基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成 对象基本类型的数据：内部是求助了Vue3中的一个新函数——reactive函数 ref与reactive对比：定义数据角度：ref用来定义：基本类型数据 reactive用来定义：对象（或数组类型数据） PS：ref也可以用来定义对象（或数组）类型数据，它内部会自动通过reactive转为代理对象 从原理角度对比：ref通过Object.defineProperty()的getter和setter来实现响应式（数据劫持） reactive通过使用Proxy来实现响应式，并通过Reflect操作源对象内部的数据 使用角度对比：ref定义的数据，操作数据需要通过.value,读取数据时模板直接读取不需要.value reactive定义的数据操作数据与读取数据均不需要.value 响应式数据的判断isRef:检查一个值是否为一个ref对象 isReactive:检查一个对象是否由reactive创建的响应式代理 isReadonly:检查一个对象是否由readonly创建的只读代理 isProxy:检查一个对象是否由reactive或者readonly方法创建的代理","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"props","slug":"props","date":"2022-01-27T04:14:42.000Z","updated":"2022-01-27T05:34:36.203Z","comments":true,"path":"2022/01/27/props/","link":"","permalink":"https://coloey.github.io/2022/01/27/props/","excerpt":"","text":"配置项:props 功能：让组件接收外部传来的数据 （1）传递数据： 第一种方式（只接收）：props:[‘name’] 第二种方式（限制类型）：props:{name:String} 第三种方式（限制类型，限制必要性，指定默认值）： props:{ ​ name:{ ​ type:String,//类型 ​ required:true,//必要性 ​ dedault:’老王’//默认值 ​ } } Ps:props是只读的，vue底层会监视你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后修改data中的数 eg:data(){ return{ myName:this.myName } }","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"生命周期钩子","slug":"生命周期钩子","date":"2022-01-26T02:13:45.000Z","updated":"2022-01-26T02:20:22.472Z","comments":true,"path":"2022/01/26/生命周期钩子/","link":"","permalink":"https://coloey.github.io/2022/01/26/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/","excerpt":"","text":"beforeCreate,created,beforeMount,mounted,beforeUpdated,updated,beforeUnmount,unmounted 常用生命周期钩子:mounted:发送ajax请求，启动定时器，绑定自定义事件，订阅消息等【初始化操作】 beforeUnmount:清除定时器，解绑自定义事件，取消订阅消息等【收尾工作】 关于销毁实例： 1销毁后借助Vue开发者工具看不到任何信息 2 销毁后自定义事件失效，但原生DOM事件依然有效 3 一般不会在beforeUnmount操作数据，因为即使操作数据，也不会触发更新流程了","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"自定义指令","slug":"自定义指令","date":"2022-01-25T09:14:32.000Z","updated":"2022-01-25T09:39:59.802Z","comments":true,"path":"2022/01/25/自定义指令/","link":"","permalink":"https://coloey.github.io/2022/01/25/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/","excerpt":"","text":"自定义指令1.语法：（1） 局部指令：​ directives:{指令名：配置对象}或 directives：{指令名:回调函数} （2）全局指令：Vue.directive(指令名，配置对象)或Vue.directive(指令名，回调函数) 2.配置对象中常用的回调created：在绑定元素的 attribute 或事件监听器被应用之前调用。在指令需要附加在普通的 v-on 事件监听器调用前的事件监听器中时，这很有用。` beforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用。mounted：指令与元素成功绑定时使用 updated:在包含组件的 VNode 及其子组件的 VNode 更新后调用。 beforeUpdate：在更新包含组件的 VNode 之前调用。 beforeUnmount：在卸载绑定元素的父组件之前调用 unmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次。 PS:指令定义时不加v-,，但是使用时要加v- 指令名如果是多个单词要用kebab-case命名方式，不要用camelCase命名 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 &lt;div id=&quot;root&quot;&gt; &lt;h3&gt;&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;h3&gt;当前n:&lt;span v-text=&quot;n&quot;&gt;&#123;&#123;n&#125;&#125;&lt;/span&gt;&lt;/h3&gt; &lt;h3&gt;放大10倍后的n：&lt;span v-big=&quot;n&quot;&gt;&#123;&#123;n&#125;&#125;&lt;/span&gt;&lt;/h3&gt; &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt; &lt;br&gt; &lt;input type=&quot;text&quot; v-fbind:value=&quot;n&quot;&gt; &lt;/div&gt;&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.createApp(&#123; data()&#123; return&#123; name:&quot;ann&quot;, n:1 &#125; &#125;, directives: &#123; //v-big被调用：指令与元素成功绑定时（一上来） 指令所在模板重新编译时 big(element,binding)&#123; element.innerText=binding.value*10 &#125;, /*fbind(element,binding)&#123; element.value=binding.value element.focus() &#125;,*/ fbind:&#123; // 当被绑定的元素挂载到 DOM 中时…… mounted(element,binding)&#123; console.log(this) element.value=binding.value element.focus() &#125;, updated(element,binding)&#123; element.value=binding.value &#125; &#125; &#125; &#125;).mount(&quot;#root&quot;) &lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"内置指令","slug":"内置指令","date":"2022-01-25T05:58:47.000Z","updated":"2022-01-25T07:45:44.154Z","comments":true,"path":"2022/01/25/内置指令/","link":"","permalink":"https://coloey.github.io/2022/01/25/%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4/","excerpt":"","text":"v-html:1 作用：向指定节点中渲染包含html的内容 2 与插值语法的区别： （1）v-html会替换掉节点中所有内容，则不会 （2）v-html可以识别html结构 3 严重注意：v-html有安全性问题 （1）在网站上动态渲染任意HTML非常危险，容易导致XSS攻击 （2）一定要在可信内容上使用v-html，永远不要用在用户提交的内容上 v-cloak(没有值)1 本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性 2 使用css配合一个v-clock可以解决网速慢时页面展示出的问题 123456789101112131415161718&lt;style&gt; [v-cloak]&#123; display:none &#125;&lt;/style&gt; &lt;h2 v-cloak&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;div&gt; &lt;script&gt;&lt;/script&gt;//延迟5秒的服务器 &lt;/div&gt; &lt;script&gt; Vue.createApp(&#123; data()&#123; return&#123; name:&#x27;Ann&#x27; &#125; &#125; &#125;) &lt;/script&gt; v-once: v-once 节点在初次动态渲染后，就被视为静态内容 以后数据改变不会引起v-once所在结构的更新，可以用于优化性能 v-pre:1.跳过其所在节点的编译过程 2.可利用它跳过没有使用指令语法，插值语法的节点，加快编译","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"收集表单数据","slug":"收集表单数据","date":"2022-01-25T03:09:55.000Z","updated":"2022-01-25T06:30:01.780Z","comments":true,"path":"2022/01/25/收集表单数据/","link":"","permalink":"https://coloey.github.io/2022/01/25/%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE/","excerpt":"","text":"收集表单数据： ,v-model收集的死是value值，用户输入的是value值 ,v-model收集的是value值，且给标签配置value值 (1）没有配置input的value属性，收集的是checked(true/false) (2)配置input的value属性： 若v-model的初始值是非数组，收集的是checked(true/false) 若v-model的初始值是数组，收集的是value组成的数组 PS： v-model有三个修饰符： lazy:失去焦点再收集数据 number:把输入的字符串转为有效数字 trim: 输入首尾空格过滤","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"Node.js基础","slug":"Node-js基础","date":"2022-01-24T13:57:44.000Z","updated":"2022-04-12T14:03:59.192Z","comments":true,"path":"2022/01/24/Node-js基础/","link":"","permalink":"https://coloey.github.io/2022/01/24/Node-js%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Node.js运行时结构： 1 异步IO 当Node.js执行I/O操作时，会在响应返回后恢复操作，而不是阻止线程并占用额外内存等待 2 单线程 实际JS线程+uv线程池+V8任务线程池+V8inspector线程 优点：不用考虑多线程同步问题，也就不需要锁，同时还能比较高效的利用系统资源 缺点：阻塞会产生负面影响，解决方法：多进程或多线程 3 跨平台 Node.js跨平台+JS无需编译环境（Web跨平台，诊断工具跨平台）","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"}],"tags":[]},{"title":"Vue监视数据原理","slug":"Vue监视数据原理","date":"2022-01-24T10:24:05.000Z","updated":"2022-01-25T01:45:04.281Z","comments":true,"path":"2022/01/24/Vue监视数据原理/","link":"","permalink":"https://coloey.github.io/2022/01/24/Vue%E7%9B%91%E8%A7%86%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/","excerpt":"","text":"Vue监视数据原理1 Vue会监视data中所有层次的数据（递归） 2 如何监视对象中的数据？ 通过setter实现监视，且要在new Vue的时候就传入要监测的数据。 （1）对象中后追加的属性，Vue默认不做响应式处理 （2）如需给后续添加的属性左响应式，请使用下面的API: ​ Vue.set(target,propertyName/index,value):target不允许是Vue实例或者vm中的data对象 vm.$set(target,propertyName/index,value) 3 如何监测数组中的数据？ 通过包裹数组更新元素的方法实现，本质做了两件事： （1） 调用原生对应的方法对数组进行更新 （2） 重新解析模板，进而更新页面 4 在Vue中修改数组中的某个元素一定要用如下方法： （1）使用这些API：push(),shift(),unshift(),splice(),sort(),reverse() （2）Vue.set()或vm.$set() 非变更方法，例如 filter()、concat() 和 slice()。它们不会变更原始数组，而总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组：","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"key作用与原理","slug":"key作用与原理","date":"2022-01-24T05:48:50.000Z","updated":"2022-03-21T06:52:14.947Z","comments":true,"path":"2022/01/24/key作用与原理/","link":"","permalink":"https://coloey.github.io/2022/01/24/key%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/","excerpt":"","text":"key的内部原理1 虚拟DOM中key的作用： key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】，随后Vue进行【新虚拟DOM】和【旧虚拟DOM】的对比，对比规则如下： 2 对比规则： （1）旧虚拟DOM中找到与新虚拟DOM相同的key： 若虚拟DOM中内容不变，则直接使用之前的真实DOM 若虚拟DOM中内容变了，则生成新的真实DOM，随后替换页面中的真实 DOM （2）旧虚拟DOM中未找到与新虚拟DOM相同的key，创建新的真实DOM，随后渲染到页面 3 用index作为key可能会引发的问题： （1）若对数据进行逆序添加，逆序删除等操作： 会产生没有必要的真实DOM更新==&gt;界面效果没问题，但是效率低 （2）如果结构中还包含输入类DOM： 会产生错误的DOM更新==&gt;界面有问题 4 开发中如何选择key? (1)最好使用每条数据的唯一标识作为key,比如id,身份证号，手机号等唯一值 (2)如果不存在对数据的逆序添加，逆序删除等破坏顺序的操作，仅用于渲染列表用于展示，使用index作为key是没有问题的","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"条件渲染","slug":"条件渲染","date":"2022-01-24T05:22:02.000Z","updated":"2022-01-24T05:48:38.577Z","comments":true,"path":"2022/01/24/条件渲染/","link":"","permalink":"https://coloey.github.io/2022/01/24/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/","excerpt":"","text":"条件渲染1 v-if: 写法： (1). v-if=”表达式” (2) v-else-if=”表达式” (3) v-else 适用于：切换频率较低的情景 特点：不展示的DOM元素直接被移除 注意：v-if和v-else-if,v-else一起使用时要求结构不能被打断 2 v-show 写法： v-show=”表达式” 适用于：切换频率较高的场景 特点：不展示的DOM元素未被移除，使用display=none隐藏掉 PS： 1 使用v-if时，元素可能无法获取到，而使用v-show一定可以获取到 2 v-if可以和template配合使用","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"绑定class样式","slug":"绑定class样式","date":"2022-01-24T03:39:15.000Z","updated":"2022-01-24T05:18:30.948Z","comments":true,"path":"2022/01/24/绑定class样式/","link":"","permalink":"https://coloey.github.io/2022/01/24/%E7%BB%91%E5%AE%9Aclass%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"绑定class样式12345678910111213141516171819202122232425262728293031323334 &lt;div id=&quot;demo&quot;&gt; &lt;!-- 绑定class样式--字符串写法，适用于样式类名不确定。需要动态确定 --&gt; &lt;div class=&quot;basic&quot; :class=&quot;mood&quot; @click=&quot;changeMood&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定，名字也不确定 --&gt; &lt;div class=&quot;basic&quot; :class=&quot;classArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定，名字也确定，但要动态决定用不用 --&gt; &lt;div class=&quot;basic&quot; :class=&quot;classObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.config.productionTip = false Vue.createApp(&#123; data()&#123; return&#123; name:&#x27;Ann&#x27;, mood:&#x27;normal&#x27;, classArr:[&#x27;c1&#x27;,&#x27;c2&#x27;,&#x27;c3&#x27;], classObj:&#123; &#x27;c1&#x27;:false, &#x27;c2&#x27;:false, &#125; &#125; &#125;, methods:&#123; changeMood()&#123; const arr=[&#x27;happy&#x27;,&#x27;sad&#x27;,&#x27;normal&#x27;] this.mood=arr[Math.floor(Math.random()*3)] &#125; &#125; &#125;).mount(&#x27;#demo&#x27;) &lt;/script&gt; 绑定style样式1 :style=”{fontSize: xxx}”,其中xxx是动态值","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"watch和computed区别","slug":"watch和computed区别","date":"2022-01-24T02:41:52.000Z","updated":"2022-05-06T15:48:21.304Z","comments":true,"path":"2022/01/24/watch和computed区别/","link":"","permalink":"https://coloey.github.io/2022/01/24/watch%E5%92%8Ccomputed%E5%8C%BA%E5%88%AB/","excerpt":"","text":"computed和watch的区别:1 computed能完成的功能watch也能完成，computed支持缓存 2 watch能完成的功能computed不一定能完成，例如watch能完成异步操作 PS： 1 所有被Vue管理的函数要写成普通函数，这样new Vue的实例的时候this才能绑定到新创建的vm或组件实例对象 2 所有不被Vue管理的函数比如（定时器的回调函数，ajax的回调函数和Promise的回调函数）最好写成箭头函数，箭头函数的this绑定会继承外层函数的this绑定 12345678910111213141516171819202122Vue.createApp(&#123; data()&#123; return &#123; firstName:&quot;张&quot;, lastName:&quot;三&quot;, fullName:&quot;张三&quot; &#125; &#125; watch:&#123; firstName(val)&#123; setTimeout(()=&gt;&#123; this.fullName=val+this.lastName&#125;,1000) &#125;, lastName(val)&#123; setTimeout(()=&gt;&#123; this.fullName=thia.firstName+val&#125;,1000) &#125; &#125;&#125;) 总结：watch和computed都是以Vue的依赖追踪机制为基础，当某一个依赖型数据（简单理解为放在data等对象下的实例数据）发生变化，所有依赖这个数据的相关数据会自动发生变化，即自动调用相关函数，来实现数据的变动 使用场景：computed:用于处理复杂的逻辑运算，一个数据首一个或多个数据影响，用来处理watch和methods无法处理或者处理起来不方便的情况，例如处理模板中的复杂表达式 watch:用来处理一个属性变化时，需要执行某些具体的业务操作逻辑，或要在数据变化时执行异步或开销较大的操作；例如用来监控路由，input输入值的特殊处理等","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"computed","slug":"computed","date":"2022-01-23T14:45:11.000Z","updated":"2022-01-30T14:46:44.584Z","comments":true,"path":"2022/01/23/computed/","link":"","permalink":"https://coloey.github.io/2022/01/23/computed/","excerpt":"","text":"计算属性1 定义： 要用的属性不存在，要通过已有的属性计算得来 2 原理： 底层借助了Object.defineproperty()方法提供的getter和setter。 3 get函数什么时候执行 (1) 初次读取时会执行一次 (2)当依赖的数据发生改变时会被再次调用 4 优势：与methods相比。内部有缓存机制，效率更高，调试方便 5 计算属性最终会出现在vm中，直接读取使用即可 如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变 简写：函数 Vue3中12345678910111213141516171819setup()&#123; //计算属性简写let fullName=computed(()=&gt;&#123; return person.firstName+&quot;-&quot;+person.lastName&#125;)//计算属性完整let fullName=comouted(&#123; get()&#123; return person.firstName+&quot;-&quot;+person.lastName &#125; set(val)&#123; const nameArr=value.split(&quot;-&quot;) person.firstName=nameArr[0] person.lastName=nameArr[1] &#125;&#125;)&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"事件处理","slug":"事件处理","date":"2022-01-23T10:35:27.000Z","updated":"2022-01-23T14:23:07.968Z","comments":true,"path":"2022/01/23/事件处理/","link":"","permalink":"https://coloey.github.io/2022/01/23/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/","excerpt":"","text":"事件的基本使用： 使用v-on:xxx或@xxx绑定事件，其中xxx是事件名 事件的回调需要配置在methods对象中，最终会在vm上 methods中配置的函数，不要用箭头函数，否则this就不是vm methods中配置的函数，都是被Vue管理的函数，this的指向是vm或组件实例对象 @click=”demo”和@click=”demo($event)”效果一致，但后者可以传参 事件修饰符prevent:阻止默认事件 stop：阻止事件冒泡 once:事件只触发一次 键盘事件1 Vue常用按键别名： 回车：enter 删除：delete 退出：esc 空格：space 换行：tab(特殊，必须配合keydown使用) 上：up 下:down 左:left 右:right 2 Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为keb-case(短横线命名) 3 系统修饰符(用法特殊):ctrl,alt,shift,meta (1)配合keyup使用：按下修饰键的同时再按下其他键，随后释放其他键，事件才被触发 (2)配合keydown使用：正常触发事件 4 也可以使用keyCode去指定具体的键 5 Vue.config.keyCode自定义键名=键码，可以定制按键别名","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"数据代理","slug":"数据代理","date":"2022-01-23T09:50:13.000Z","updated":"2022-01-24T10:26:42.258Z","comments":true,"path":"2022/01/23/数据代理/","link":"","permalink":"https://coloey.github.io/2022/01/23/%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86/","excerpt":"","text":"Vue中的数据代理：通过vm对象来代理data对象中属性的操作（读或写 Vue中数据代理的好处：更加方便操作data中的数据 基本原理 ​ 通过Object.defineProperty()把data对象中的所有属性添加到vm上中，为每一个添加到vm上的属性都指定一个getter()setter()函数，在getter()setter()函数；里面去操作data中对应的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243 const vm=Vue.createApp(&#123; data()&#123; return&#123; name:&#x27;Ann&#x27;, address:&#x27;06404&#x27; &#125; &#125; &#125;)vm&#123;..._data&#123; name:(...), address:(...), &#125;name:(...)address:(...)//Object.defineProperty()Object.defineProperty(vm,&#x27;name&#x27;,&#123; value:_data.name.get() enumerable: writable: configurable://默认为false,控制属性是否可以被删除 get()&#123; return _data.name.get() &#125; set(value)&#123; _data.name.set(value) &#125;&#125;)Object.defineProperty(vm,&#x27;address&#x27;,&#123; value:_data.address.get() enumerable: writable: configurable://默认为false,控制属性是否可以被删除 get()&#123; return _data.address.get() &#125; set(value)&#123; _data.address.set(value); &#125;&#125;)&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"MVVM","slug":"MVVM","date":"2022-01-23T08:23:36.000Z","updated":"2022-01-23T09:48:20.724Z","comments":true,"path":"2022/01/23/MVVM/","link":"","permalink":"https://coloey.github.io/2022/01/23/MVVM/","excerpt":"","text":"MVVM M:模型(Model) data中的数据 V：视图(View) 模板代码 VM:视图模型（ViewModel):Vue实例 data中的所有属性最后都出现在vm身上 vm上的所有属性及Vue原型上的所有属性，在Vue模板中都可以直接使用 12345678910&lt;div&gt;View&lt;/div&gt;const vm=Vue.createApp(&#123;//vm:VM data()&#123; return&#123; Model &#125; &#125;&#125;)","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"数据绑定","slug":"数据绑定","date":"2022-01-23T07:57:58.000Z","updated":"2022-01-23T08:05:06.352Z","comments":true,"path":"2022/01/23/数据绑定/","link":"","permalink":"https://coloey.github.io/2022/01/23/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/","excerpt":"","text":"数据绑定1. 单向绑定v-bind:数据只能从data流向页面 2.双向绑定v-model:数据不仅能从data流向页面，还能从页面流向data v-model:value的value可以简写为v-model,因为v-model默认收集的就是value值","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"模板语法","slug":"模板语法","date":"2022-01-23T07:36:44.000Z","updated":"2022-01-23T07:52:52.618Z","comments":true,"path":"2022/01/23/模板语法/","link":"","permalink":"https://coloey.github.io/2022/01/23/%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Vue 模板语法1 插值语法功能：用于解析标签体内容 写法：，xxx是js表达式，直接读取js中的所有data属性 2 指令语法功能： 用于解析标签（包括标签属性，标签内容等） 举例：v-bind:href=”xxx”,简写为:href=”xxx”,xxx同样可以写js表达式，且可以直接读取到data里的所有属性 写法：v-xxx","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"高阶函数","slug":"高阶函数","date":"2022-01-17T06:06:06.000Z","updated":"2022-01-17T09:29:33.289Z","comments":true,"path":"2022/01/17/高阶函数/","link":"","permalink":"https://coloey.github.io/2022/01/17/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/","excerpt":"","text":"高阶函数模板12345function HoF0(fn)&#123; return function(...args)&#123; return fn.apply(this,args); &#125;&#125; Once123456789function once(fn)&#123; return function(..args)&#123; if(fn)&#123; const ret=fn.apply(this,args); fn=null; return ret; &#125; &#125;&#125; Throttle1234567891011121314151617function throttle(fn,time=500)&#123; let timer; return function(...args)&#123; if(timer==null)&#123; fn.apply(this.args); timer=setTimeout(()=&gt;&#123; timer=null; &#125;,time) &#125; &#125;&#125;btn.onclick=throttle(function(e)&#123; circle.innerHTML=parseInt(circle.innerHTML)+1; circle.className=&#x27;fade&#x27;; setTimeout(()=&gt;circle.className=&#x27;&#x27;,250);&#125;); Debouce123456789101112function debouce(fn,dur)&#123; dur=dur||100; var timer; return function()&#123; clearTimeout(timer); timer=setTimeOut(()=&gt;&#123; fn.apply(this,arguments); &#125;,dur); &#125;&#125; iterative12345678910111213function iterative(fn)&#123; return function(subject,...rest)&#123; if(isIterable(subject))&#123; const ret=[]; for(let obj of subject)&#123; ret.push(fn.apply(this,[obj,...rest])); &#125; return ret; &#125; return fn.apply(this,[subject,...rest]); &#125;&#125; 过程抽象 HOF 装饰器 命令式/声明式 洗牌算法：123456789101112131415161718192021function*draw(cards)&#123; const c=[...cards]; for(let i=c.length;i&gt;0;i--)&#123; const pIdx=Math.floor(Math.random()*i); [c[pIdx],c[i-1]]=[c[i-1],c[pIdx]]; yield c[i-1]; &#125;&#125;function generate(amount,count)&#123; if(count&lt;=1)return [amount]; const cards=Array(amount-1).fill(0).map((_,i)=&gt;i+1); const pick=draw(cards); for(let i=0;i&lt;count;i++)&#123; result.push(pick.next().value); &#125; result.sort((a,b)=&gt;a-b); for(let i=count-1;i&gt;0;i--)&#123; result[i]=result[i]-result[i-1]; &#125; return result;&#125;","categories":[],"tags":[]},{"title":"CSS组合","slug":"布局","date":"2022-01-17T02:19:52.000Z","updated":"2022-01-17T09:30:12.395Z","comments":true,"path":"2022/01/17/布局/","link":"","permalink":"https://coloey.github.io/2022/01/17/%E5%B8%83%E5%B1%80/","excerpt":"","text":"组合：直接组合： AB 满足A同时满足B eg:input:focus 后代组合：A B 选中B，如果它是A的子孙 eg:nav a 亲子组合：A&gt;B 选中B如果它是A的子元素 eg:section&gt;p 兄弟选择器 AB 选中B如果它在A后且和A同级 eg:h2p 相邻选择器： A+B 选中B，如果它紧跟在A后面 eg:h2+p","categories":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"https://coloey.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"watch","slug":"watch","date":"2022-01-15T06:39:59.000Z","updated":"2022-01-30T15:44:57.822Z","comments":true,"path":"2022/01/15/watch/","link":"","permalink":"https://coloey.github.io/2022/01/15/watch/","excerpt":"","text":"watch()监视属性watch： 1 当被监视的属性变化时（也可以监视计算属性），回调函数自动调用，进行相关操作 2 监视的属性必须存在才能好进行监视 3 监视的两种写法： （1）在Vue.createApp时传入watch配置 （2）通过vm.$watch监视 4 深度监视 （1）Vue中的watch默认不监视对象内部值的改变（一层） （2）配置deep为true,可以检测对象内部值改变（多层） 监视多级结构中某个属性的变化：’number.a’ 监视多级结构中所有属性第1变化，用deep:true PS：（1）Vue自身可以检测对象内部值的改变但是Vue提供的watch默认不可以 （2）使用watch时根据数据的具体结构，决定是否采用深度监视 vm.$watch(expOrFn,callback,[options]) expOrFn:{string/Function} callback:{Function/Object} options:{Object} deep:{boolean} immediate:{boolean} 返回值：unwatch函数 用处：观察Vue实例上的一个表达式或者一个函数计算结果的变化，回调函数得到的参数为新值和旧值。表达式只接受简单的键路径，对于复杂表达式，用函数取代 12345678910111213141516171819202122232425262728293031323334//HTML&lt;div id=&quot;app&quot;&gt; &#123;&#123;a&#125;&#125;,&#123;&#123;b&#125;&#125;&lt;/div&gt;//键路径 &lt;script type=&quot;text/javascript&quot;&gt; var vm=new Vue(&#123; el:&quot;#app&quot;, data:&#123; a:&#123;value1:&#x27;hello&#x27;&#125;, b:&#123;value2:&#x27;beautiful&#x27;&#125; &#125; &#125;); vm.$watch(&#x27;b.value2&#x27;,function(newVal,oldVal)&#123; console.log(newVal,oldVal); &#125;); vm.b.value2=&#x27;bind&#x27;;//bind beautiful //修改对象内部的值但是侦听的是对象，对其属性或元素的更改不会触发侦听器，因为他们引用相同对象 vm.$watch(&#x27;a&#x27;,function(newVal,oldVal)&#123; console.log(newVal,oldVal); &#125;); vm.a.value1=&#x27;hei&#x27;;//没有侦听到//为了发现对象内部值的变化，可以在选项参数中指定 deep: true。这个选项同样适用于监听数组变更。 vm.$watch(&#x27;a&#x27;,function(newVal,oldVal)&#123; console.log(newVal,oldVal); &#125;,&#123;deep:true&#125;); vm.a.value1=&#x27;hei&#x27;;////在选项参数中指定 immediate: true 将立即以表达式的当前值触发回调 vm.$watch(&#x27;a&#x27;,function(newVal,oldVal)&#123; console.log(newVal,oldVal); &#125;,&#123;immediate:true&#125;); vm.a=&#123;&#125;//&#123;_ob_:Observer&#125;undefined &#123;_ob_:Observer&#125;&#123;_ob_:Observer&#125; &lt;/script&gt; 在带有immediate选项时不能在第一次回调时取消侦听给定的property 1234567const unwatch=vm.$watch( &#x27;a&#x27;, function(newVal,oldVal)&#123; console.log(newVal,oldVal); unwatch() &#125;,&#123;immediate:true&#125; )//报错 要在回调函数里调用一个取消侦听的函数应该先检查其函数的可用性 12345678let unwatch=null; unwatch=vm.$watch( &#x27;a&#x27;, function(newVal,oldVal)&#123; console.log(newVal,oldVal); if(unwatch)&#123;unwatch();&#125; &#125;,&#123;immediate:true&#125; ) Vue3中的watch两个“坑”： watch监视的是reactive定义的响应式数据则无法正确获得oldValue，watch监视的是reactive定义的响应式数据则强制开启深度监视,只能获取newValue,无法获取oldValue 监视reactive定义的某个对象中的属性（也是对象）,deep有效,仍然无法获取oldValue 关于.value: 如果ref定义的是一个数字或者字符，比如ref(0)不能用.value 如果ref定义的是一个对象，则里面的属性本质上是由reactive定义，如果要监视里面的属性则得用.value，.value后由reactive定义，则自动开启深度监视，或者开启深度监视 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 setup()&#123; let person=reactive(&#123; firstName:&quot;张&quot;, lastName:&quot;三&quot;, fullName:&#x27;&#x27;, job:&#123; one:&#x27;doctor&#x27;, tow:&#x27;teacher&#x27; &#125; &#125;) let sum=ref(0) let msg=ref(&quot;你好呀&quot;)//情况一：监视ref定义的响应式数据 watch(sum,(newValue,oldValue)=&gt;&#123; console.log(&quot;sum变化了&quot;,newValue,oldValue) &#125;) //情况二：监视多个ref定义的响应式数据 watch([sum,msg],(newValue,oldValue)=&gt;&#123; console.log(&quot;sum或msg变化了&quot;,newValue,oldValue) &#125;) //情况三：监视reactive定义的响应式数据：若watch监视的是reactive定义的响应式数据则无法正确获得oldValue，watch监视的是reactive定义的响应式数据则强制开启深度监视,只能获取newValue,无法获取oldValue watch(person,(newValue,oldValue)=&gt;&#123; console.log(&quot;person变化了&quot;,newValue,oldValue) &#125;,&#123;deep:false&#125;)//deep配置无效 //情况四:监视reactive定义的响应式数据中的某个属性 watch(()=&gt;person.firstName,(newValue,oldValue)=&gt;&#123; console.log(&quot;person的firstName变化了&quot;,newValue,oldValue) &#125;) //情况五：监视reactive定义的一个响应式数据中的某些属性 watch([()=&gt;person.firstName,()=&gt;person.lastName],(newValue,oldValue)=&gt;&#123; console.log(&quot;person的firstName/lastName变化了&quot;,newValue,oldValue) &#125;) //特殊情况监视reactive定义的某个对象中的属性（也是对象）,deep有效,仍然无法获取oldValue watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123; console.log(&quot;person的job变化了&quot;,newValue,oldValue) &#125;,&#123;deep:true&#125;) person.fullName=computed(&#123; get()&#123; return person.firstName+&#x27;-&#x27;+person.lastName &#125;, set(value)&#123; const nameArr=value.split(&#x27;-&#x27;) person.firstName=nameArr[0] person.lastName=nameArr[1] &#125; &#125;) watch() return &#123; person, sum, msg &#125; &#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[{"name":"watch","slug":"watch","permalink":"https://coloey.github.io/tags/watch/"}]},{"title":"addLoadEvent","slug":"addLoadEvent","date":"2022-01-10T09:41:16.000Z","updated":"2022-01-10T09:47:57.127Z","comments":true,"path":"2022/01/10/addLoadEvent/","link":"","permalink":"https://coloey.github.io/2022/01/10/addLoadEvent/","excerpt":"","text":"1234567891011function addLoadEvent(func)&#123; var oldonload=window.onload; if(typeof oldonload!=&#x27;function&#x27;)&#123; window.onload=func;//如果处理函数还没有绑定任何函数，就添加新函数 &#125;else&#123; window.onload=function()&#123; oldonload(); func(); &#125; &#125; &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"reduce","slug":"reduce","date":"2022-01-07T03:30:23.000Z","updated":"2022-01-07T13:25:55.147Z","comments":true,"path":"2022/01/07/reduce/","link":"","permalink":"https://coloey.github.io/2022/01/07/reduce/","excerpt":"","text":"arr.reduce(callback(accumulator,currentValue,index,array),InitValue) callback:执行数组中的每个值的函数，包括4个参数： accumulator currentValue 数组中正在处理的元素。 index 可选 数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则从索引1起始。 array可选 调用reduce()的数组 initialValue可选 作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。 返回累计处理后的结果 求数组中的所有值的和12345678910var sum=[0,1,2,3].reduce(function(accumulator,currentValue)&#123;return accumulator+currentValue;&#125;,0)//6//累加对象数组里的值var InitValue=0;var sum=[&#123;x:1&#125;,&#123;x:2&#125;,&#123;x:3&#125;].reduce(function(accumulator,currentValue)&#123; return accumulator+currentValue;&#125;,InitValue);console.log(sum);//6 将二维数组转为一维1var flattened=[[0,1],[2,3],[4,5],[6,7]].reduce(function(a,b)&#123;return a.concat(b);&#125;,[]) 计算数组中每个元素出现的个数1234567891011var names=[&#x27;Alice&#x27;,&#x27;Bob&#x27;,&#x27;Ann&#x27;,&#x27;Alice&#x27;,&#x27;Bob&#x27;]; var countNames=names.reduce((allNames,name)=&gt;&#123; if(name in allNames)&#123; allNames[name]++; &#125; else&#123; allNames[name]=1; &#125; return allNames; &#125;,&#123;&#125;); console.log(countNames); 按照属性对object分类123456789101112131415161718var people=[ &#123;name:&#x27;Alice&#x27;,age:20&#125;, &#123;name:&#x27;Max&#x27;,age:20&#125;, &#123;name:&#x27;Jane&#x27;,age:21&#125; ] function groupBy(objectArray,property)&#123; return objectArray.reduce(function(acc,obj)&#123; var key=obj[property]; if(!acc[key])&#123; acc[key]=[]; &#125; acc[key].push(obj); return acc; &#125;,&#123;&#125;); &#125; var groupedPeople=groupBy(people,&#x27;age&#x27;); console.log(groupedPeople); 使用扩展运算符绑定包含在对象数组中的数组123456789var friends=[&#123; name:&#x27;Anna&#x27;, books:[&#x27;Bible&#x27;,&#x27;Harry Potter&#x27;], age:21 &#125;, &#123;name:&#x27;Bob&#x27;,books:[&#x27;War and Peace&#x27;],age:16&#125;, &#123;name:&#x27;Mike&#x27;,books:[&#x27;The Shining&#x27;,&#x27;The Lord of the Rings&#x27;],age:18&#125;]; var allBooks=friends.reduce((prev,curr)=&gt;&#123;return [...prev,...curr.books]&#125;,[&#x27;Alphabet&#x27;]); console.log(allBooks); 数组去重123456789let myArray=[6,6,6,2,3,3,4,4,4,5]; let myOrderedArray=myArray.reduce((accumulator,currval)=&gt;&#123; if(accumulator.indexOf(currval)==-1)&#123; accumulator.push(currval); &#125; return accumulator; &#125;,[]) console.log(myOrderedArray);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"Promise","slug":"Promise","date":"2022-01-06T12:59:19.000Z","updated":"2022-01-07T13:00:23.474Z","comments":true,"path":"2022/01/06/Promise/","link":"","permalink":"https://coloey.github.io/2022/01/06/Promise/","excerpt":"","text":"期约状态机Promise可以通过 new 操作符来实例化。创建新期约时需要传入执行器（executor）函数作为参数 123let p = new Promise(() =&gt; &#123;&#125;);setTimeout(console.log, 0, p); // Promise &lt;pending&gt; 在把一个期约实例传给 console.log()时，控制台输出（可能因浏览器不同而略有差异）表明该实例处于待定（pending）状态。如前所述，期约是一个有状态的对象，可能处于如下 3 种状态之一： 待定（pending）是期约的最初始状态。在待定状态下，期约可以落定（settled）为代表成功的兑现（fulfilled）状态，或者代表失败的拒绝（rejected）状态。无论落定为哪种状态都是不可逆的。只要从待定转换为兑现或拒绝，期约的状态就不再改变。而有时候也称为“解决”，resolved） 兑现（fulfilled)每个期约只要状态切换为兑现，就会有一个私有的内部值（value） 拒绝（rejected）如果期约被拒绝，程序就会期待期约状态改变时可以拿到拒绝的理由 期约用途期约主要有两大用途。首先是抽象地表示一个异步操作。期约的状态代表期约是否完成。某些情况下，这个状态机就是期约可以提供的最有用的信息。 通过执行函数控制期约状态期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。其中，控制期约状态的转换是通过调用它的两个函数参数实现的。这两个函数参数通常都命名为 resolve()和 reject()。调用resolve()会把状态切换为兑现，调用 reject()会把状态切换为拒绝。另外，调用 reject()也会抛出错误 123456let p1=new Promise((resolve,reject)=&gt;resolve());setTimeout(console.log,0,p1);//Promise &lt;resolved&gt;let p2 = new Promise((resolve, reject) =&gt; reject());setTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;// Uncaught error (in promise) 在前面的例子中，并没有什么异步操作，因为在初始化期约时，执行器函数已经改变了每个期约的状态，执行器函数是同步执行的。这是因为执行器函数是期约的初始化程序。 添加 setTimeout 可以推迟切换状态： 1234let p = new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000));// 在 console.log 打印期约实例的时候，还不会执行超时回调（即 resolve()）setTimeout(console.log, 0, p); // Promise &lt;pending&gt; 无论 resolve()和 reject()中的哪个被调用，状态转换都不可撤销了。于是继续修改状态会静默失败，如下所示： 123456let p = new Promise((resolve, reject) =&gt; &#123;resolve();reject(); // 没有效果&#125;);setTimeout(console.log, 0, p); // Promise &lt;resolved&gt; Promise.resolve()下面两个期约实例实际上是一样的： let p1 = new Promise((resolve, reject) =&gt; resolve());let p2 = Promise.resolve(); 这个解决的期约的值对应着传给 Promise.resolve()的第一个参数。使用这个静态方法，实际上可以把任何值都转换为一个期约 12345678setTimeout(console.log,0,Promise.resolve());// Promise &lt;resolved&gt;: undefinedsetTimeout(console.log, 0, Promise.resolve(3));// Promise &lt;resolved&gt;: 3// 多余的参数会忽略setTimeout(console.log, 0, Promise.resolve(4, 5, 6));// Promise &lt;resolved&gt;: 4 对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此，Promise.resolve()可以说是一个幂等方法 1234567891011let p = Promise.resolve(7);setTimeout(console.log, 0, p === Promise.resolve(p));// truesetTimeout(console.log, 0, p === Promise.resolve(Promise.resolve(p)));// true//这个幂等性会保留传入期约的状态：let p = new Promise(() =&gt; &#123;&#125;);setTimeout(console.log, 0, p); // Promise &lt;pending&gt;setTimeout(console.log, 0, Promise.resolve(p)); // Promise &lt;pending&gt;setTimeout(console.log, 0, p === Promise.resolve(p)); // true 注意，这个静态方法能够包装任何非期约值，包括错误对象，并将其转换为解决的期约。因此，也可能导致不符合预期的行为： 1234let p = Promise.resolve(new Error(&#x27;foo&#x27;));setTimeout(console.log, 0, p);// Promise &lt;resolved&gt;: Error: foo Promise.reject()与 Promise.resolve()类似，Promise.reject()会实例化一个拒绝的期约并抛出一个异步错误（这个错误不能通过 try/catch 捕获，而只能通过拒绝处理程序捕获）。下面的两个期约实例实际上是一样的： let p1 = new Promise((resolve, reject) =&gt; reject());let p2 = Promise.reject(); 这个拒绝的期约的理由就是传给 Promise.reject()的第一个参数。这个参数也会传给后续的拒绝处理程序： 1234let p = Promise.reject(3);setTimeout(console.log, 0, p); // Promise &lt;rejected&gt;: 3p.then(null, (e) =&gt; setTimeout(console.log, 0, e)); // 3 关键在于，Promise.reject()并没有照搬 Promise.resolve()的幂等逻辑。如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由： 123setTimeout(console.log, 0, Promise.reject(Promise.resolve()));// Promise &lt;rejected&gt;: Promise &lt;resolved&gt; 同步/异步执行的二元性123456789101112try &#123;throw new Error(&#x27;foo&#x27;);&#125; catch(e) &#123;console.log(e); // Error: foo&#125;try &#123;Promise.reject(new Error(&#x27;bar&#x27;));&#125; catch(e) &#123;console.log(e);&#125;// Uncaught (in promise) Error: bar 第一个 try/catch 抛出并捕获了错误，第二个 try/catch 抛出错误却没有捕获到,这里的同步代码之所以没有捕获期约抛出的错误，是因为它没有通过异步模式捕获错误。从这里就可以看出期约真正的异步特性：它们是同步对象（在同步执行模式中使用），但也是异步执行模式的媒介。在前面的例子中，拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此，try/catch 块并不能捕获该错误。代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构——更具体地说，就是期约的方法。 Promise.prototype.then()Promise.prototype.then()是为期约实例添加处理程序的主要方法。这个 then()方法接收最多 两个参数：onResolved 处理程序和 onRejected 处理程序。这两个参数都是可选的，如果提供的话，则会在期约分别进入“兑现”和“拒绝”状态时执行。传给 then()的任何非函数类型的参数都会被静 默忽略。如果想只提供 onRejected 参数，那就要在 onResolved 参数的位置上传入 undefined。这 样有助于避免在内存中创建多余的对象 123456789101112131415function onResolved(id) &#123; setTimeout(console.log, 0, id, &#x27;resolved&#x27;); &#125; function onRejected(id) &#123; setTimeout(console.log, 0, id, &#x27;rejected&#x27;); &#125; let p1 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 3000)); let p2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 3000)); p1.then(() =&gt; onResolved(&#x27;p1&#x27;), () =&gt; onRejected(&#x27;p1&#x27;)); p2.then(() =&gt; onResolved(&#x27;p2&#x27;), () =&gt; onRejected(&#x27;p2&#x27;)); //（3 秒后）// p1 resolved // p2 rejected 1234567891011121314function onResolved(id) &#123; setTimeout(console.log, 0, id, &#x27;resolved&#x27;); &#125; function onRejected(id) &#123; setTimeout(console.log, 0, id, &#x27;rejected&#x27;); &#125; let p1 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 3000)); let p2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 3000)); // 非函数处理程序会被静默忽略，不推荐p1.then(&#x27;gobbeltygook&#x27;); // 不传 onResolved 处理程序的规范写法p2.then(null, () =&gt; onRejected(&#x27;p2&#x27;)); // p2 rejected（3 秒后 Promise.prototype.then()方法返回一个新的期约实例： 12345let p1 = new Promise(() =&gt; &#123;&#125;); let p2 = p1.then(); setTimeout(console.log, 0, p1); // Promise &lt;pending&gt; setTimeout(console.log, 0, p2); // Promise &lt;pending&gt; setTimeout(console.log, 0, p1 === p2); // false 这个新期约实例基于 onResovled 处理程序的返回值构建。换句话说，该处理程序的返回值会通过 Promise.resolve()包装来生成新期约。如果没有提供这个处理程序，则 Promise.resolve()就会 包装上一个期约解决之后的值。如果没有显式的返回语句，则 Promise.resolve()会包装默认的返回 值 undefined。 123456789101112131415161718192021222324252627282930313233let p1 = Promise.resolve(&#x27;foo&#x27;); // 若调用 then()时不传处理程序，则原样向后传let p2 = p1.then();setTimeout(console.log, 0, p2); // Promise &lt;resolved&gt;: foo // 这些都一样let p3 = p1.then(() =&gt; undefined); let p4 = p1.then(() =&gt; &#123;&#125;); let p5 = p1.then(() =&gt; Promise.resolve()); setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: undefined setTimeout(console.log, 0, p4); // Promise &lt;resolved&gt;: undefined setTimeout(console.log, 0, p5); // Promise &lt;resolved&gt;: undefined //如果有显式的返回值，则 Promise.resolve()会包装这个值：// 这些都一样let p6 = p1.then(() =&gt; &#x27;bar&#x27;); let p7 = p1.then(() =&gt; Promise.resolve(&#x27;bar&#x27;)); setTimeout(console.log, 0, p6); // Promise &lt;resolved&gt;: bar setTimeout(console.log, 0, p7); // Promise &lt;resolved&gt;: bar // Promise.resolve()保留返回的期约let p8 = p1.then(() =&gt; new Promise(() =&gt; &#123;&#125;)); let p9 = p1.then(() =&gt; Promise.reject()); // Uncaught (in promise): undefined setTimeout(console.log, 0, p8); // Promise &lt;pending&gt; setTimeout(console.log, 0, p9); // Promise &lt;rejected&gt;: undefined//抛出异常会返回拒绝的期约： let p10 = p1.then(() =&gt; &#123; throw &#x27;baz&#x27;; &#125;); // Uncaught (in promise) baz setTimeout(console.log, 0, p10); // Promise &lt;rejected&gt; baz //注意，返回错误值不会触发上面的拒绝行为，而会把错误对象包装在一个解决的期约中：... let p11 = p1.then(() =&gt; Error(&#x27;qux&#x27;)); setTimeout(console.log, 0, p11); // Promise &lt;resolved&gt;: Error: qux onRejected 处理程序也与之类似：onRejected 处理程序返回的值也会被 Promise.resolve() 包装。乍一看这可能有点违反直觉，但是想一想，onRejected 处理程序的任务不就是捕获异步错误吗？ 因此，拒绝处理程序在捕获错误后不抛出异常是符合期约的行为，应该返回一个解决期约 12345678910111213141516171819202122232425262728let p1 = Promise.reject(&#x27;foo&#x27;); // 调用 then()时不传处理程序则原样向后传let p2 = p1.then(); // Uncaught (in promise) foosetTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;: foo // 这些都一样let p3 = p1.then(null, () =&gt; undefined); let p4 = p1.then(null, () =&gt; &#123;&#125;); let p5 = p1.then(null, () =&gt; Promise.resolve()); setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: undefined setTimeout(console.log, 0, p4); // Promise &lt;resolved&gt;: undefined setTimeout(console.log, 0, p5); // Promise &lt;resolved&gt;: undefined // 这些都一样let p6 = p1.then(null, () =&gt; &#x27;bar&#x27;); let p7 = p1.then(null, () =&gt; Promise.resolve(&#x27;bar&#x27;)); setTimeout(console.log, 0, p6); // Promise &lt;resolved&gt;: bar setTimeout(console.log, 0, p7); // Promise &lt;resolved&gt;: bar // Promise.resolve()保留返回的期约let p8 = p1.then(null, () =&gt; new Promise(() =&gt; &#123;&#125;)); let p9 = p1.then(null, () =&gt; Promise.reject()); // Uncaught (in promise): undefined setTimeout(console.log, 0, p8); // Promise &lt;pending&gt; setTimeout(console.log, 0, p9); // Promise &lt;rejected&gt;: undefined let p10 = p1.then(null, () =&gt; &#123; throw &#x27;baz&#x27;; &#125;); // Uncaught (in promise) baz setTimeout(console.log, 0, p10); // Promise &lt;rejected&gt;: baz let p11 = p1.then(null, () =&gt; Error(&#x27;qux&#x27;)); setTimeout(console.log, 0, p11); // Promise &lt;resolved&gt;: Error: qux Promise.prototype.catch()Promise.prototype.catch()方法用于给期约添加拒绝处理程序。这个方法只接收一个参数： onRejected 处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用 Promise.prototype. then(null, onRejected) 1234567let p = Promise.reject(); let onRejected = function(e) &#123; setTimeout(console.log, 0, &#x27;rejected&#x27;); &#125;; // 这两种添加拒绝处理程序的方式是一样的：p.then(null, onRejected); // rejected p.catch(onRejected); // rejected Promise.prototype.catch()返回一个新的期约实例： 12345let p1 = new Promise(() =&gt; &#123;&#125;); let p2 = p1.catch(); setTimeout(console.log, 0, p1); // Promise &lt;pending&gt; setTimeout(console.log, 0, p2); // Promise &lt;pending&gt; setTimeout(console.log, 0, p1 === p2); // false Promise.prototype.finally()Promise.prototype.finally()方法用于给期约添加 onFinally 处理程序，这个处理程序在期 约转换为解决或拒绝状态时都会执行。这个方法可以避免 onResolved 和 onRejected 处理程序中出 现冗余代码。但 onFinally 处理程序没有办法知道期约的状态是解决还是拒绝，所以这个方法主要用清理代码 1234567let p1 = Promise.resolve(); let p2 = Promise.reject(); let onFinally = function() &#123; setTimeout(console.log, 0, &#x27;Finally!&#x27;) &#125; p1.finally(onFinally); // Finally p2.finally(onFinally); // Finally Promise.prototype.finally()方法返回一个新的期约实例： 12345let p1 = new Promise(() =&gt; &#123;&#125;); let p2 = p1.finally();setTimeout(console.log, 0, p1); // Promise &lt;pending&gt; setTimeout(console.log, 0, p2); // Promise &lt;pending&gt; setTimeout(console.log, 0, p1 === p2); // false 这个新期约实例不同于 then()或 catch()方式返回的实例。因为 onFinally 被设计为一个状态 无关的方法，所以在大多数情况下它将表现为父期约的传递 1234567891011121314151617181920212223242526let p1 = Promise.resolve(&#x27;foo&#x27;); // 这里都会原样后传let p2 = p1.finally(); let p3 = p1.finally(() =&gt; undefined); let p4 = p1.finally(() =&gt; &#123;&#125;); let p5 = p1.finally(() =&gt; Promise.resolve()); let p6 = p1.finally(() =&gt; &#x27;bar&#x27;); let p7 = p1.finally(() =&gt; Promise.resolve(&#x27;bar&#x27;)); let p8 = p1.finally(() =&gt; Error(&#x27;qux&#x27;)); setTimeout(console.log, 0, p2); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p4); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p5); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p6); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p7); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p8); // Promise &lt;resolved&gt;: foo //如果返回的是一个待定的期约，或者 onFinally 处理程序抛出了错误（显式抛出或返回了一个拒绝期约），则会返回相应的期约（待定或拒绝）// Promise.resolve()保留返回的期约let p9 = p1.finally(() =&gt; new Promise(() =&gt; &#123;&#125;)); let p10 = p1.finally(() =&gt; Promise.reject()); // Uncaught (in promise): undefined setTimeout(console.log, 0, p9); // Promise &lt;pending&gt; setTimeout(console.log, 0, p10); // Promise &lt;rejected&gt;: undefined let p11 = p1.finally(() =&gt; &#123; throw &#x27;baz&#x27;; &#125;); // Uncaught (in promise) baz setTimeout(console.log, 0, p11); // Promise &lt;rejected&gt;: baz 非重入期约方法当期约进入落定状态时，与该状态相关的处理程序仅仅会被排期，而非立即执行。跟在添加这个处 理程序的代码之后的同步代码一定会在处理程序之前先执行。即使期约一开始就是与附加处理程序关联 的状态，执行顺序也是这样的。这个特性由 JavaScript 运行时保证，被称为“非重入”（non-reentrancy） 特性。 1234567891011121314151617let synchronousResolve; // 创建一个期约并将解决函数保存在一个局部变量中let p = new Promise((resolve) =&gt; &#123; synchronousResolve = function() &#123; console.log(&#x27;1: invoking resolve()&#x27;); resolve(); console.log(&#x27;2: resolve() returns&#x27;); &#125;; &#125;); p.then(() =&gt; console.log(&#x27;4: then() handler executes&#x27;)); synchronousResolve(); console.log(&#x27;3: synchronousResolve() returns&#x27;); // 实际的输出：// 1: invoking resolve() // 2: resolve() returns // 3: synchronousResolve() returns // 4: then() handler executes 在这个例子中，即使期约状态变化发生在添加处理程序之后，处理程序也会等到运行的消息队列让 它出列时才会执行。 传递解决值和拒绝理由到了落定状态后，期约会提供其解决值（如果兑现）或其拒绝理由（如果拒绝）给相关状态的处理 程序。拿到返回值后，就可以进一步对这个值进行操作。比如，第一次网络请求返回的 JSON 是发送第 二次请求必需的数据，那么第一次请求返回的值就应该传给 onResolved 处理程序继续处理。当然，失 败的网络请求也应该把 HTTP 状态码传给 onRejected 处理程序。 在执行函数中，解决的值和拒绝的理由是分别作为 resolve()和 reject()的第一个参数往后传 的。然后，这些值又会传给它们各自的处理程序，作为 onResolved 或 onRejected 处理程序的唯一 参数。 1234let p1 = new Promise((resolve, reject) =&gt; resolve(&#x27;foo&#x27;)); p1.then((value) =&gt; console.log(value)); // foo let p2 = new Promise((resolve, reject) =&gt; reject(&#x27;bar&#x27;)); p2.catch((reason) =&gt; console.log(reason)); // bar then()和 catch()的 onRejected 处理程序在语义上相当于 try/catch。出发点都是捕获错误之 后将其隔离，同时不影响正常逻辑执行。为此，onRejected 处理程序的任务应该是在捕获异步错误之 后返回一个解决的期约。下面的例子中对比了同步错误处理与异步错误处理： 123456789101112131415161718192021console.log(&#x27;begin synchronous execution&#x27;); try &#123; throw Error(&#x27;foo&#x27;); &#125; catch(e) &#123; console.log(&#x27;caught error&#x27;, e); &#125; console.log(&#x27;continue synchronous execution&#x27;); // begin synchronous execution // caught error Error: foo // continue synchronous execution new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;begin asynchronous execution&#x27;); reject(Error(&#x27;bar&#x27;)); &#125;).catch((e) =&gt; &#123; console.log(&#x27;caught error&#x27;, e); &#125;).then(() =&gt; &#123; console.log(&#x27;continue asynchronous execution&#x27;); &#125;); // begin asynchronous execution // caught error Error: bar // continue asynchronous execution 期约连锁每个后续的处理程序都会等待前一个期约解决，然后实例化一个新期约并返回它。这种结构可以简 洁地将异步任务串行化，解决之前依赖回调的难题 1234567891011121314function delayedResolve(str) &#123; return new Promise((resolve, reject) =&gt; &#123; console.log(str); setTimeout(resolve, 1000); &#125;); &#125;delayedResolve(&#x27;p1 executor&#x27;) .then(() =&gt; delayedResolve(&#x27;p2 executor&#x27;)) .then(() =&gt; delayedResolve(&#x27;p3 executor&#x27;)) .then(() =&gt; delayedResolve(&#x27;p4 executor&#x27;)) // p1 executor（1 秒后）// p2 executor（2 秒后）// p3 executor（3 秒后）// p4 executor（4 秒后） Promise.all()Promise.all方法用于将多个 Promise 实例，这个静态方法接收一个可迭代对象，将参数转为 Promise 实例，再包装成一个新的 Promise 实例。 合成的期约只会在每个包含的期约都解决之后才解决 如果至少有一个包含的期约待定，则合成的期约也会待定。如果有一个包含的期约拒绝，则合成的 期约也会拒绝 1234567//永远待定let p1=Promise.all([new Promise(()=&gt;&#123;&#125;)]);setTimeout(console.log,0,p1);//Promise &lt;pending&gt;//一次拒绝会导致最终期约拒绝let p2=Promise.all([Promise.resolve(),Promise.reject(),Promise.resolve()]);setTimeout(console.log,0,p2);//Promise &lt;rejected&gt;//Uncaught (in promise) undefined 如果所有期约都成功解决，则合成期约的解决值就是所有包含期约解决值的数组，按照迭代器顺序: 1234567891011121314let p = Promise.all([ Promise.resolve(3), Promise.resolve(), Promise.resolve(4) ]); p.then((values) =&gt; setTimeout(console.log, 0, values)); // [3, undefined, 4] // 虽然只有第一个期约的拒绝理由会进入 // 拒绝处理程序，第二个期约的拒绝也// 会被静默处理，不会有错误跑掉let p = Promise.all([ Promise.reject(3), new Promise((resolve, reject) =&gt; setTimeout(reject, 1000)) ]); p.catch((reason) =&gt; setTimeout(console.log, 0, reason)); // 3 Promise.race()Promise.race()静态方法返回一个包装期约，是一组集合中最先解决或拒绝的期约的镜像。这个 方法接收一个可迭代对象，返回一个新期约 12345678910111213141516171819// 解决先发生，超时后的拒绝被忽略let p1 = Promise.race([ Promise.resolve(3), new Promise((resolve, reject) =&gt; setTimeout(reject, 1000)) ]); setTimeout(console.log, 0, p1); // Promise &lt;resolved&gt;: 3 // 拒绝先发生，超时后的解决被忽略let p2 = Promise.race([ Promise.reject(4), new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000)) ]); setTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;: 4 // 迭代顺序决定了落定顺序let p3 = Promise.race([ Promise.resolve(5), Promise.resolve(6), Promise.resolve(7) ]); setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: 5 串行期约合成1234567function addTwo(x)&#123;return x+1;&#125;function addThree(x)&#123;return x+3;&#125;function addFive(x)&#123;return x+5;&#125;function addTen(x)&#123; return [addTwo,addThree,addFive].reduce((promise,fn)=&gt;promise.then(fn),Promise.resolve(x));&#125;addTen(8).then(console.log); donePromise 对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为 Promise 内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。 12345678910111213asyncFunc() .then(f1) .catch(r1) .then(f2) .done();Promise.prototype.done=function(onResolved,onRejected)&#123; this.then(onResolved,onRejected) .catch(function(reason)&#123; //抛出一个全局错误 setTimeout(()=&gt;&#123;throw reason&#125;,0); &#125;); &#125; finallyfinally()f方法用于指定不管Promise对象最后状态如何，都会执行的操作，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。 123456789101112server.listen(0) .then(function () &#123; // run test &#125;) .finally(server.stop);Promise.prototype.finally=function(callback)&#123; let P=this.constructor; return this.then( value=&gt;P.resolve(callback()).then(()=&gt;value), reason=&gt;P.resolve(callback()).then(()=&gt;&#123;throw reason&#125;) ); &#125; 用途将图片的加载写成一个Promise，一旦加载完成，Promise的状态发生变化 123456789//加载图片 const preloadImage=function(path)&#123; return new Promise(function(resolve,reject)&#123; const image=new Image(); image.onload=resolve; image.onerror=reject; image.src=path; &#125;) &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"json","slug":"json","date":"2022-01-04T08:03:00.000Z","updated":"2022-01-04T09:00:12.474Z","comments":true,"path":"2022/01/04/json/","link":"","permalink":"https://coloey.github.io/2022/01/04/json/","excerpt":"","text":"把它当成一种数据格式，而不是编程语言。JSON 不属于 JavaScript，它们只是拥有相同的语法而已。JSON 也不是只能在 JavaScript 中使用，它是一种通用数据格式。很多语言都有解析和序列化 JSON 的内置能力。 语法 简单值：字符串、数值、布尔值和 null 可以在 JSON 中出现，就像在 JavaScript 中一样。特殊值 undefined 不可以。 对象：第一种复杂数据类型，对象表示有序键/值对。每个值可以是简单值，也可以是复杂类型。 数组：第二种复杂数据类型，数组表示可以通过数值索引访问的值的有序列表。数组的值可以是任意类型，包括简单值、对象，甚至其他数组。 简单值JavaScript 字符串与 JSON 字符串的主要区别是，JSON 字符串必须使用双引号（单引号会导致语法错误）。布尔值和 null 本身也是有效的 JSON 值 对象与 JavaScript 对象字面量相比，JSON 主要有两处不同。首先，没有变量声明（JSON 中没有变量）。其次，最后没有分号（不需要，因为不是 JavaScript 语句）。同样，用引号将属性名包围起来才是有效的JSON。属性的值可以是简单值或复杂数据类型值，后者可以在对象中再嵌入对象. 123456789&#123;&quot;name&quot;: &quot;Nicholas&quot;,&quot;age&quot;: 29,&quot;school&quot;: &#123;&quot;name&quot;: &quot;Merrimack College&quot;,&quot;location&quot;: &quot;North Andover, MA&quot;&#125;&#125; 数组数组在 JSON 中使用 JavaScript 的数组字面量形式表示. JavaScript 12let values = [25, &quot;hi&quot;, true]; Json 1[25,&quot;hi&quot;,true] JavaScript序列化为Jsonstringfy()：在序列化 JavaScript 对象时，所有函数和原型成员都会有意地在结果中省略。此外，值为 undefined的任何属性也会被跳过。最终得到的就是所有实例属性均为有效 JSON 数据类型的表 1234567891011let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;],edition: 4,year: 2017&#125;;let jsonText = JSON.stringify(book); 结果： {“title”:”Professional JavaScript”,”authors”:[“Nicholas C. Zakas”,”Matt Frisbie”],“edition”:4,”year”:2017} 还可以接收两个参数。这两个参数可以用于指定其他序列化 JavaScript 对象的方式。第一个参数是过滤器，可以是数组或函数；第二个参数是用于缩进结果 JSON 字符串的选项。 1234567891011let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;],edition: 4,year: 2017&#125;;let jsonText = JSON.stringify(book, [&quot;title&quot;, &quot;edition&quot;]); 如果第二个参数是一个函数，则行为又有不同。提供的函数接收两个参数：属性名（key）和属性值（value）。可以根据这个 key 决定要对相应属性执行什么操作。这个 key 始终是字符串，只是在值不属于某个键/值对时会是空字符串 返回的值就是相应 key 应该包含的结果。注意，返回 undefined 会导致属性被忽略 1234567891011121314151617181920212223242526let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;],edition: 4,year: 2017&#125;;let jsonText = JSON.stringify(book, (key, value) =&gt; &#123;switch(key) &#123;case &quot;authors&quot;:return value.join(&quot;,&quot;)case &quot;year&quot;:return 5000;case &quot;edition&quot;:return undefined;default:return value;&#125;&#125;);/*&#123;&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:&quot;Nicholas C. Zakas,MattFrisbie&quot;,&quot;year&quot;:5000&#125;*/ JSON.stringify()方法的第三个参数控制缩进和空格。在这个参数是数值时，表示每一级缩进的空格数。 123456789101112let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [ &quot;Nicholas C. Zakas&quot;, &quot;Matt Frisbie&quot;],edition: 4,year: 2017&#125;;let jsonText = JSON.stringify(book, null, 4); toJSON():在要序列化的对象中添加 toJSON()方法，序列化时会基于这个方法返回适当的 JSON 表示: 12345678910111213let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;],edition: 4,year: 2017,toJSON: function() &#123;//箭头函数不能定义toJSON(),因为剪头函数的词法作用域是全局作用域，在这种情况不合适return this.title;&#125;&#125;;let jsonText = JSON.stringify(book);//book对象返回图书的书名(this.title) toJSON()方法可以与过滤函数一起使用，在把对象传给 JSON.stringify()时会执行如下步骤。 (1) 如果可以获取实际的值，则调用 toJSON()方法获取实际的值，否则使用默认的序列化。(2) 否则，使用默认序列化时，如果提供了第二个参数，则应用过滤。(3) 第(2)步返回的每个值都会相应地进行序列化。(4) 如果提供了第三个参数，则相应地进行缩进。 ES6中堆JSON.stringfy的改造UTF-8 标准规定，0xD800到0xDFFF之间的码点，不能单独使用，必须配对使用。比如，\\uD834\\uDF06是两个码点，但是必须放在一起配对使用，代表字符𝌆。这是为了表示码点大于0xFFFF的字符的一种变通方法。单独使用\\uD834和\\uDFO6这两个码点是不合法的，或者颠倒顺序也不行，因为\\uDF06\\uD834并没有对应的字符。 JSON.stringify()的问题在于，它可能返回0xD800到0xDFFF之间的单个码点。 1JSON.stringify(&#x27;\\u&#123;D834&#125;&#x27;) // &quot;\\u&#123;D834&#125;&quot; 为了确保返回的是合法的 UTF-8 字符，ES2019 改变了JSON.stringify()的行为。如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。 1JSON.stringify(&#x27;\\u&#123;D834&#125;&#x27;) // &quot;&quot;\\\\uD834&quot;&quot;JSON.stringify(&#x27;\\uDF06\\uD834&#x27;) // &quot;&quot;\\\\udf06\\\\ud834&quot;&quot; 解析选项JSON.parse():接收一个参数，这个函数称为还原函数，还原函数接收两个参数，属性名key和属性名value，如果还原函数返回undefined，则结果中删除相应键，如果返回了其他任何值，则该值就会成为相应键的值插入到结果中。 123456789101112131415let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;],edition: 4,year: 2017,releaseDate: new Date(2017, 11, 1)&#125;;let jsonText = JSON.stringify(book);let bookCopy = JSON.parse(jsonText,(key, value) =&gt; key == &quot;releaseDate&quot; ? new Date(value) : value);alert(bookCopy.releaseDate.getFullYear());//对象仙贝序列化为JSON字符串，又被重新解析为一个对象bookCopy,还原函数查找&quot;releaseDate&quot;键，找到后根虎日期字符创建新的Date对象，得到的bookCopy.releaseDate属性又变回Date对象，可以调用其getFullYear()方法","categories":[],"tags":[]},{"title":"字符表示","slug":"字符表示","date":"2022-01-04T03:58:13.000Z","updated":"2022-01-04T04:14:36.508Z","comments":true,"path":"2022/01/04/字符表示/","link":"","permalink":"https://coloey.github.io/2022/01/04/%E5%AD%97%E7%AC%A6%E8%A1%A8%E7%A4%BA/","excerpt":"","text":"JavaScript字符表示JavaScript 字符串由 16 位码元（code unit）组成。对多数字符来说，每 16 位码元对应一个字符。换句话说，字符串的 length 属性表示字符串包含多少 16 位码元 JavaScript 字符串使用了两种 Unicode 编码混合的策略：UCS-2 和 UTF-16。对于可以采用 16 位编码的字符（U+0000~U+FFFF），这两种编码实际上是一样的。 查看指定码元charCodeAt()123456let message = &quot;abcde&quot;;// Unicode &quot;Latin small letter C&quot;的编码是 U+0063console.log(message.charCodeAt(2)); // 99// 十进制 99 等于十六进制 63console.log(99 === 0x63); // true 这个对应关系在扩展到 Unicode 增补字符平面时就不成立了。即 16 位只能唯一表示,65 536 个字符。这对于大多数语言字符集是足够了，在 Unicode 中称为基本多语言平面（BMP）。为了表示更多的字符，Unicode 采用了一个策略，即每个字符使用另外 16 位去选择一个增补平面。这种每个字符使用两个 16 位码元的策略称为代理对。 codePointAt()为正确解析既包含单码元字符又包含代理对字符的字符串，可以使用 codePointAt()来代替charCodeAt()。跟使用 charCodeAt()时类似，codePointAt()接收 16 位码元的索引并返回该索引位置上的码点（code point）。码点是 Unicode 中一个字符的完整标识。比如，”c”的码点是 0x0063，而”☺”的码点是 0x1F60A。码点可能是 16 位，也可能是 32 位，而 codePointAt()方法可以从指定码元位置识别完整的码点。 123456let message = &quot;ab☺de&quot;;console.log(message.codePointAt(1)); // 98console.log(message.codePointAt(2)); // 128522console.log(message.codePointAt(3)); // 56842console.log(message.codePointAt(4)); // 100 给定UTF-16码原创建字符fromCharCode()12345678910111213// Unicode &quot;Latin small letter A&quot;的编码是 U+0061// Unicode &quot;Latin small letter B&quot;的编码是 U+0062// Unicode &quot;Latin small letter C&quot;的编码是 U+0063// Unicode &quot;Latin small letter D&quot;的编码是 U+0064// Unicode &quot;Latin small letter E&quot;的编码是 U+0065console.log(String.fromCharCode(0x61, 0x62, 0x63, 0x64, 0x65)); // &quot;abcde&quot;// 0x0061 === 97// 0x0062 === 98// 0x0063 === 99// 0x0064 === 100// 0x0065 === 101console.log(String.fromCharCode(97, 98, 99, 100, 101)); // &quot;abcde&quot; fromCodePoint()fromCodePoint()：这个方法接收任意数量的码点，返回对应字符拼接起来的字符串 1234console.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)); // ab☺deconsole.log(String.fromCodePoint(97, 98, 128522, 100, 101)); // ab☺de normalize()规范化Unicode提供了 4种规范化形式，可以将类似上面的字符规范化为一致的格式，无论底层字符的代码是什么。这 4种规范化形式是：NFD（Normalization Form D）、NFC（Normalization Form C）、NFKD（Normalization Form KD）和 NFKC（Normalization Form KC）。可以使用 normalize()方法对字符串应用上述规范化形式，使用时需要传入表示哪种形式的字串：”NFD”、”NFC”、”NFKD”或”NFKC”。 通过比较字符串与其调用 normalize()的返回值，就可以知道该字符串是否已经规范化了 12345678910111213141516171819let a1 = String.fromCharCode(0x00C5),a2 = String.fromCharCode(0x212B),a3 = String.fromCharCode(0x0041, 0x030A);// U+00C5 是对 0+212B 进行 NFC/NFKC 规范化之后的结果console.log(a1 === a1.normalize(&quot;NFD&quot;)); // falseconsole.log(a1 === a1.normalize(&quot;NFC&quot;)); // trueconsole.log(a1 === a1.normalize(&quot;NFKD&quot;)); // falseconsole.log(a1 === a1.normalize(&quot;NFKC&quot;)); // true// U+212B 是未规范化的console.log(a2 === a2.normalize(&quot;NFD&quot;)); // falseconsole.log(a2 === a2.normalize(&quot;NFC&quot;)); // falseconsole.log(a2 === a2.normalize(&quot;NFKD&quot;)); // falseconsole.log(a2 === a2.normalize(&quot;NFKC&quot;)); // false// U+0041/U+030A 是对 0+212B 进行 NFD/NFKD 规范化之后的结果console.log(a3 === a3.normalize(&quot;NFD&quot;)); // trueconsole.log(a3 === a3.normalize(&quot;NFC&quot;)); // falseconsole.log(a3 === a3.normalize(&quot;NFKD&quot;)); // trueconsole.log(a3 === a3.normalize(&quot;NFKC&quot;)); // false 未规范化： 12345678let a1 = String.fromCharCode(0x00C5),a2 = String.fromCharCode(0x212B),a3 = String.fromCharCode(0x0041, 0x030A);console.log(a1, a2, a3); // Å, Å, Åconsole.log(a1 === a2); // falseconsole.log(a1 === a3); // falseconsole.log(a2 === a3); // false 选择同一种规范化形式可以让比较操作符返回正确的结果： 1234567let a1 = String.fromCharCode(0x00C5),a2 = String.fromCharCode(0x212B),a3 = String.fromCharCode(0x0041, 0x030A);console.log(a1.normalize(&quot;NFD&quot;) === a2.normalize(&quot;NFD&quot;)); // trueconsole.log(a2.normalize(&quot;NFKC&quot;) === a3.normalize(&quot;NFKC&quot;)); // trueconsole.log(a1.normalize(&quot;NFC&quot;) === a3.normalize(&quot;NFC&quot;)); // true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"媒体查询","slug":"媒体查询","date":"2022-01-03T09:42:17.000Z","updated":"2022-01-03T12:40:52.057Z","comments":true,"path":"2022/01/03/媒体查询/","link":"","permalink":"https://coloey.github.io/2022/01/03/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"媒体查询常被用于以下目的： 有条件的通过 @media 和 @import at-rules 用CSS 装饰样式。 用media= 属性为,,和其他HTML元素指定特定的媒体类型。 语法媒体类型和任意数量的媒体特性表达式构成。 当媒体类型（如果指定）与在其上显示文档的设备匹配并且所有媒体功能表达式都计算为true时，媒体查询将计算为true。 涉及未知媒体类型的查询始终为false。 媒体类型描述设备的一般类别。除非使用 not 或 only 逻辑操作符，媒体类型是可选的，并且会（隐式地）应用 all 类型。 1all 适用于所有设备。 1print 适用于在打印预览模式下在屏幕上查看的分页材料和文档。 （有关特定于这些格式的格式问题的信息，请参阅分页媒体。） 1screen 主要用于屏幕。 1speech 主要用于语音合成器。 定位媒体类型12@media screen, print &#123; ... &#125;/*用两个媒体查询来同时定位屏幕和打印设备*/ 媒体特性描述了 user agent、输出设备，或是浏览环境的具体特征。媒体特性表达式是完全可选的，它负责测试这些特性或特征是否存在、值为多少。每条媒体特性表达式都必须用括号括起来。 逻辑操作符 not, and, 和 only 可用于联合构造复杂的媒体查询，您还可以通过用逗号分隔多个媒体查询，将它们组合为一个规则。 and and 操作符用于将多个媒体查询规则组合成单条媒体查询，当每个查询规则都为真时则该条媒体查询为真，它还用于将媒体功能与媒体类型结合在一起。 notnot运算符用于否定媒体查询，如果不满足这个条件则返回true，否则返回false。 如果出现在以逗号分隔的查询列表中，它将仅否定应用了该查询的特定查询。 如果使用not运算符，则还必须指定媒体类型。 注意：在Level 3中，not关键字不能用于否定单个媒体功能表达式，而只能用于否定整个媒体查询。 onlyonly运算符仅在整个查询匹配时才用于应用样式，并且对于防止较早的浏览器应用所选样式很有用。 当不使用only时，旧版本的浏览器会将screen and (max-width: 500px)简单地解释为screen，忽略查询的其余部分，并将其样式应用于所有屏幕。 如果使用only运算符，则还必须指定媒体类型。 , (逗号)逗号用于将多个媒体查询合并为一个规则。 逗号分隔列表中的每个查询都与其他查询分开处理。 因此，如果列表中的任何查询为true，则整个media语句均返回true。 换句话说，列表的行为类似于逻辑或or运算符。 定位媒体特性1234567/*当用户的主要输入机制（例如鼠标）可以悬停在元素上*/@media (hover: hover) &#123; ... &#125;@media (max-width: 12450px) &#123; ... &#125;/*CSS将适用于任何带有彩色屏幕的设备*/@media (color) &#123; ... &#125;/*限制为带有屏幕的设备,宽度至少为30 em的横向的设备*/@media screen and (min-width: 30em) and (orientation: landscape) &#123; ... &#125;","categories":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"https://coloey.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"toggle","slug":"toggle","date":"2022-01-03T01:47:27.000Z","updated":"2022-01-03T12:40:32.389Z","comments":true,"path":"2022/01/03/toggle/","link":"","permalink":"https://coloey.github.io/2022/01/03/toggle/","excerpt":"","text":"DOMTokenList.toggle()DOMTokenList接口的toggle()方法从列表中删除一个给定的标记并返回false,如果标记不存在，则添加并且函数返回true tokenList.toggle(token,force); 参数：token:标记列表中你想探查并切换的DOMSring force(可选):Boolean值，设置后会将方法变成单向操作，如果设置为false，则会删除标记列表中匹配的给定标记，且不会再添加，如设置为true，则将在标记中添加给定标记，且不会再度删除 返回值：为布尔值 egHTML 1&lt;span class=&quot;a b&quot;&gt;classList is &#x27;a b&#x27;&lt;/span&gt; JavaScript 12345678910var span = document.querySelector(&quot;span&quot;);var classes = span.classList;span.onclick = function() &#123; var result = classes.toggle(&quot;c&quot;); if(result) &#123; span.textContent = &quot;&#x27;c&#x27; added; classList is now &#x27;&quot; + classes + &quot;&#x27;.&quot;; &#125; else &#123; span.textContent = &quot;&#x27;c&#x27; removed; classList is now &#x27;&quot; + classes + &quot;&#x27;.&quot;; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"align-self,align-item,align-content","slug":"对齐方式对比","date":"2022-01-03T01:42:03.000Z","updated":"2022-01-03T12:40:14.249Z","comments":true,"path":"2022/01/03/对齐方式对比/","link":"","permalink":"https://coloey.github.io/2022/01/03/%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94/","excerpt":"","text":"align-selfCSS属性 align-self 会对齐当前 grid 或 flex 行中的元素，并覆盖已有的 align-items 的值。In Grid, it aligns the item inside the grid area. 在 Flexbox 中，会按照 cross axis（当前 flex 元素排列方向的垂直方向）进行排列。 值auto:设置为父元素的 align-items 值。 normal: 效果取决于当前的布局模式: 绝对定位布局中，normal在绝对定位的替代元素上表现为start，在所有其他绝对定位元素上表现为stretch。 在绝对定位的静态元素上表现为stretch。 flex布局中表现为stretch。 在网格布局中表现为stretch,除了有部分比例或者一个固定大小的盒子的效果像start。 在块级和表格单元中无效。 flex-start:对齐到cross-axis的首端 flex-end:对齐到cross-axis的尾端 center:对齐到cross-axis的中间，如果该元素的 cross-size 尺寸大于 flex 容器，将在两个方向均等溢出。 safe:如果元素大小溢出对齐的容器，则将元素改为对齐，就像start unsafe:无论元素和对齐容器的相对大小如何都遵循给定的对齐值 egHTML 1234567891011&lt;section&gt; &lt;div&gt; Item#1 &lt;/div&gt; &lt;div&gt; Item#2 &lt;/div&gt; &lt;div&gt; Item#3 &lt;/div&gt;&lt;/section&gt; CSS 1234567891011121314151617section &#123; display: flex; align-items: center; height: 120px; background: beige;&#125;div &#123; height: 60px; background: cyan; margin: 5px;&#125;div:nth-child(3) &#123; align-self: flex-end; background: pink;&#125; align-itemsCSS align-items属性将所有直接子节点上的align-self值设置为一个组。 目前，Flexbox和CSS网格布局支持此属性。在Flexbox中，它控制十字轴上项目的对齐方式，在网格布局中，它控制块轴上项目的对齐方式。 align-contentalign-content 属性设置了浏览器如何沿着弹性盒子布局的纵轴和网格布局的主轴在内容项之间和周围分配空间。 123456789101112131415161718192021222324252627282930313233343536/* 基本位置对齐 *//*align-content不采用左右值 */align-content: center; /* 将项目放置在中点 */align-content: start; /* 最先放置项目 */align-content: end; /* 最后放置项目 */align-content: flex-start; /* 从起始点开始放置flex元素 */align-content: flex-end; /* 从终止点开始放置flex元素 *//* 默认对齐 */align-content: normal;/*基线对齐*/align-content: baseline;align-content: first baseline;align-content: last baseline;/* 分布式对齐 */align-content: space-between; /* 均匀分布项目 第一项与起始点齐平， 最后一项与终止点齐平 */align-content: space-around; /* 均匀分布项目 项目在两端有一半大小的空间*/align-content: space-evenly; /* 均匀分布项目 项目周围有相等的空间 */align-content: stretch; /* 均匀分布项目 拉伸‘自动’-大小的项目以充满容器 *//* 溢出对齐 */align-content: safe center;align-content: unsafe center;/* 全局属性 */align-content: inherit; /* 继承 */align-content: initial; /* 初始值 */align-content: unset; /* 未设置 */ justify-itemsjustify-items 属性为所有盒中的项目定义了默认的 justify-self ， 可以使这些项目以默认方式沿适当轴线对齐到每个盒子。 justify-contentjustify-content 属性定义了浏览器之间，如何分配顺着弹性容器主轴(或者网格行轴) 的元素之间及其周围的空间。 1234567891011121314151617181920212223242526272829303132/* Positional alignment */justify-content: center; /* 居中排列 */justify-content: start; /* Pack items from the start */justify-content: end; /* Pack items from the end */justify-content: flex-start; /* 从行首起始位置开始排列 */justify-content: flex-end; /* 从行尾位置开始排列 */justify-content: left; /* Pack items from the left */justify-content: right; /* Pack items from the right *//* Baseline alignment */justify-content: baseline;justify-content: first baseline;justify-content: last baseline;/* Distributed alignment */justify-content: space-between; /* 均匀排列每个元素 首个元素放置于起点，末尾元素放置于终点 */justify-content: space-around; /* 均匀排列每个元素 每个元素周围分配相同的空间 */justify-content: space-evenly; /* 均匀排列每个元素 每个元素之间的间隔相等 */justify-content: stretch; /* 均匀排列每个元素 &#x27;auto&#x27;-sized 的元素会被拉伸以适应容器的大小 *//* Overflow alignment */justify-content: safe center;justify-content: unsafe center;/* Global values */justify-content: inherit;justify-content: initial;justify-content: unset; justify-self[justify-self 在 Flexbox布局中失效]在主轴上，Flexbox将我们的内容作为一个组进行处理。 计算布置子元素所需的空间量，然后剩余空间可用于分配。 justify-content属性控制剩余空间的使用方式。 设置justify-content：flex-end，额外空间放在所有子元素之前，justify-content：space-around，它放在该维度的子元素的两侧，等等。 这意味着在Flexbox中，justify-self属性没有意义，因为我们总是处理移动整个元素组。 在十字轴上，align-self是有意义的，因为我们可能在该维度中的flex容器中有额外的空间，其中单个元素可以移动到开始和结束位置。","categories":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"https://coloey.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"富文本","slug":"富文本","date":"2021-12-13T11:59:24.000Z","updated":"2021-12-30T07:18:06.906Z","comments":true,"path":"2021/12/13/富文本/","link":"","permalink":"https://coloey.github.io/2021/12/13/%E5%AF%8C%E6%96%87%E6%9C%AC/","excerpt":"","text":"富文本编辑在空白 HTML 文件中嵌入一个iframe。通过 designMode 属性，可以将这个空白文档变成可以编辑的，实际编辑的则是元素的 HTML。designMode 属性有两个可能的值：”off”（默认值）和”on”。设置为”on”时 富文本交互使用 document.execCommand()。这个方法在文档上执行既定的命令，可以实现大多数格式化任务。document.execCommand()可以接收 3 个参数：要执行的命令、表示浏览器是否为命令提供用户界面的布尔值和执行命令必需的值 12345678910// 在内嵌窗格中切换粗体文本样式frames[&quot;richedit&quot;].document.execCommand(&quot;bold&quot;, false, null);// 在内嵌窗格中切换斜体文本样式frames[&quot;richedit&quot;].document.execCommand(&quot;italic&quot;, false, null);// 在内嵌窗格中创建指向 www.wrox.com 的链接frames[&quot;richedit&quot;].document.execCommand(&quot;createlink&quot;, false,&quot;http://www.wrox.com&quot;);// 在内嵌窗格中为内容添加&lt;h1&gt;标签frames[&quot;richedit&quot;].document.execCommand(&quot;formatblock&quot;, false, &quot;&lt;h1&gt;&quot;); 富文本选择在内嵌窗格中使用 getSelection()方法，可以获得富文本编辑器的选区。这个方法暴露在document 和 window 对象上，返回表示当前选中文本的 Selection 对象 12345678910let selection = frames[&quot;richedit&quot;].getSelection();// 取得选中的文本let selectedText = selection.toString();// 取得表示选区的范围let range = selection.getRangeAt(0);// 高亮选中的文本let span = frames[&quot;richedit&quot;].document.createElement(&quot;span&quot;);span.style.backgroundColor = &quot;yellow&quot;;range.surroundContents(span); 通过表单提交富文本12345form.addEventListener(&quot;submit&quot;,(event)=&gt;&#123; let target=event.target; target.elements[&quot;comments&quot;].value=frames[&quot;richedit&quot;].document.body.innerHTML;//使用内嵌窗格 //target.elements[&quot;comments&quot;].value=document.getElementById(&quot;richedit&quot;).innerHTML;//使用contenteditable&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"表单序列化","slug":"表单序列化","date":"2021-12-12T11:09:55.000Z","updated":"2021-12-30T07:17:55.272Z","comments":true,"path":"2021/12/12/表单序列化/","link":"","permalink":"https://coloey.github.io/2021/12/12/%E8%A1%A8%E5%8D%95%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"表单在js中可以使用表单字段的type属性连同其name属性和value属性来进行序列化 字段名和值是 URL 编码的并以和号（&amp;）分隔。 禁用字段不会发送。 复选框或单选按钮只在被选中时才发送。 类型为”reset”或”button”的按钮不会发送。 多选字段的每个选中项都有一个值。 通过点击提交按钮提交表单时，会发送该提交按钮；否则，不会发送提交按钮。类型为”image”的元素视同提交按钮。 select元素的值是被选中option元素的 value 属性。如果元素没有 value 属性，则该值是它的文本 返回的结果是查询字符串的格式 1234567891011121314151617181920212223242526272829303132333435363738394041function serialize(form)&#123; let parts=[]; let optValue; for(let field of form.elements)&#123; switch(field.type)&#123; case &quot;select-one&quot;: case &quot;select-multiple&quot;: if(field.name.length)&#123; for(let option of field.options)&#123; if(option.selected)&#123; if(option.hasAttribute)&#123; optValue=(option.hasAttribute(&quot;value&quot;)?option.value:option.text); &#125;else&#123; optValue=(option.attributes[&quot;value&quot;].specified?option.value:option.text); &#125; parts.push(`$&#123;encodeURIComponent(field.name)&#125;=`+`$&#123;encodeURIComponent(optValue)&#125;`); &#125; &#125; &#125; break; case undefined://字段集 case &quot;file&quot;://文件输入 case &quot;submit&quot;://提交按钮 case &quot;reset&quot;://重置按钮 case &quot;button&quot;://自定义按钮 break; case &quot;radio&quot;://单选按钮 case &quot;checkbox&quot;://复选框 if(!field.checked)&#123;//没被选中，跳出switch，否则进入default分支，将字段的名字和值编码后添加进parts数组 break; &#125; default: //不包含没有名字的表单字段 if(field.name.length)&#123; parts.push(`$&#123;encodeURIComponent(field.name)&#125;=`+`$&#123;encodeURIComponent(field.value)&#125;`) &#125; &#125; &#125; return parts.join(&quot;&amp;&quot;);&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"DOM编程","slug":"DOM-DOM编程","date":"2021-12-12T09:15:15.000Z","updated":"2022-01-24T08:12:45.132Z","comments":true,"path":"2021/12/12/DOM-DOM编程/","link":"","permalink":"https://coloey.github.io/2021/12/12/DOM-DOM%E7%BC%96%E7%A8%8B/","excerpt":"","text":"DOM编程动态脚本1234567891011function loadScriptString(code)&#123; var script=document.createElement(&quot;script&quot;); script.type=&quot;text/javascript&quot;; try&#123; script.appendChild(document.createTextNode(code));//旧版本的IE浏览器可能出问题 &#125;catch(ex)&#123; script.text=code; &#125; document.body.appendChild(script);&#125;loadScriptString(&quot;function sayHi()&#123;alert(&#x27;hi&#x27;);&#125;&quot;); 动态样式123456789101112function loadStyleString(css)&#123; let style=document.createElement(&quot;style&quot;); style.type=&quot;text/css&quot;; try&#123; style.appendChild(document.createTextNode(css)); &#125;catch(ex)&#123; style.styleSheet.cssText=css; &#125; let head=document.getElementsByTagName(&quot;head&quot;)[0]; head.appendChild(style);&#125;loadStyleString(&quot;body[background-color:red&#125;&quot;); 对于IE，要小心使用styleSheet.cssText，如果重用同一个style元素并设置该属性超过一次，则可能导致浏览器崩溃，将cssText设置为空字符串也可能导致浏览器崩溃 表单12345678910111213141516171819let table=document.createElement(&quot;table&quot;);table.border=1;table.width=&quot;100%&quot;;let tbody=document.createElement(&quot;tbody&quot;);table.appendChild(tbody);table.insertRow(0);tbody.rows[0].insertCell(0);tbody.rows[0].cells[0].appendChild(document.createTextNode(&quot;Cell 1,1&quot;));tbody.rows[0].insertCell(1);tbody.rows[0].cells[1].appendChild(document.createTextNode(&quot;Cell 2,1&quot;));table.insertRow(1);tbody.rows[1].insertCell(0);tbody.rows[1].cells[0].appendChild(document.createTextNode(&quot;Cell 1,2&quot;));tbody.rows[1].insertCell(1);tbody.rows[1].cells[1].appendChild(document.createTextNode(&quot;Cell 2,2&quot;));document.body.appendChild(table); NodeList12345let divs=document.getElementsByTagName(&quot;div&quot;);for(let i=0,len=divs.length;i&lt;len;i++)&#123; let div=doocument.createElement(&quot;div&quot;); document.body.appendChild(div);&#125;//避免导致无穷循环 Mutationobserver接口在DOM被修改时异步执行回调，使用MutationObserver可以观察整个文档，DOM树的一部分或某个元素 MutationObserver的实例通过调用MutationObserver构造函数并传入一个回调函数创建 1let observer=new MutationObserver(()=&gt;console.log(&#x27;DOM was mutated&#x27;)); observe()方法接收两个参数：要观察其变化的DOM节点，以及一个MutationObserverInit对象（用于控制观察哪些方面的变化，是一个键值对形式配置选项的字典） 12let observer=new MutationObserver(()=&gt;console.log(&#x27;&lt;body&gt; attributes changed&#x27;));observer.observe(document.body,&#123;attributes:true&#125;); body元素上任何属性发生变化都会被这个MutationObserver实例发现，然后异步执行注册的回调函数,body元素后代修改或其他非属性修改不会触发回调进入任务 123456let observer=new MutationObserver(()=&gt;console.log(&#x27;&lt;body&gt; attributes changed&#x27;));observer.observe(document.body,&#123;attributes:true&#125;);document.body.className=&#x27;foo&#x27;;console.log(&#x27;Changed body class&#x27;);//Changed body class//&lt;body&gt; attributes changed 回调与MutationRecord每次回调都会收到一个MutationRecord实例的数组,包含的信息发生了什么变化以及DOM哪一部分受到影响 123456789let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));[observer.observe(document.body,&#123;attributes:true&#125;);document.body.setAttributeNS(&#x27;foo&#x27;,&#x27;bar&#x27;,&#x27;baz&#x27;);//连续修改多个MutationRecord实例，回调函数就会受到包含这些实例的数组，顺序为变化事件的顺序let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));observer.observe(document.body,&#123;attributes:true&#125;);document.body.className=&#x27;foo&#x27;;document.body.className=&#x27;bar&#x27;;//[MutationRecord, MutationRecord] disconnect()方法会停止此后变化事件的回调，也会抛弃已经加入任务队列要异步执行的回调 1234567891011let observer=new MutationObserver(()=&gt;console.log(&#x27;&lt;body&gt;attributes changed&#x27;));observer.observe(document.body,&#123;attributes:true&#125;);document.body.className=&#x27;foo&#x27;;observer.disconnect();document.body.className=&#x27;bar&#x27;;//无日志输出//让已经入队的回调函数执行完毕后再调用disconnect()setTimeout(()=&gt;&#123; observer.disconnect(); document.body.className=&#x27;bar&#x27;;&#125;,0); 复用MutationObserver12345678910let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords.map((x)=&gt;x.target)));let childA=document.createElement(&#x27;div&#x27;); childB=document.createElement(&#x27;span&#x27;);document.body.appendChild(childA);document.body.appendChild(childB);observer.observe(childA,&#123;attributes:true&#125;);observer.observe(childB,&#123;attributes:true&#125;);childA.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);childB.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);//[div, span] 重用MutationObserver调用diaconnect()不会结束MutationObserver的生命，还可以重新使用这个观察者，再将它关联到新的目标结点 MutationObserverInit与观察范围观察属性设置attributes为true,观察所有属性 123456789let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));observer.observe(document.body,&#123;attributes:true&#125;);//添加属性document.body.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);//修改属性document.body.setAttribute(&#x27;foo&#x27;,&#x27;baz&#x27;);//移除属性document.body.removeAttribute(&#x27;foo&#x27;); 用attributeFilter添加白名单属性 123456let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));observer.observe(document.body,&#123;attributeFilter:[&#x27;foo&#x27;]&#125;);//添加白名单属性document.body.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);//添加被排除的属性document.body.setAttribute(&#x27;baz&#x27;,&#x27;qux&#x27;); 在记录中保存属性原来的值 123456let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords.map((x)=&gt;x.oldValue)));observer.observe(document.body,&#123;attributeOldValue:true&#125;);document.body.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);document.body.setAttribute(&#x27;foo&#x27;,&#x27;baz&#x27;);document.body.setAttribute(&#x27;foo&#x27;,&#x27;qux&#x27;);//[null, &#x27;bar&#x27;, &#x27;baz&#x27;] 观察字符数据12345678910111213let observer=new MutationObserver(document.body.firstChild,&#123;characterData:true&#125;);document.body.firstChild.textContent=&#x27;foo&#x27;;//创建要观察的文本节点observer.observe(document.body.firstChild,&#123;characterData:true&#125;);document.body.firstChild.textContent=&#x27;foo&#x27;;document.body.firstChild.textContent=&#x27;bar&#x27;;document.body.firstChild.textContent=&#x27;baz&#x27;;//使用characterDataOldValuelet observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords.map((x)=&gt;x.oldValue)));document.body.firstChild.textContent=&#x27;foo&#x27;;//创建要观察的文本节点observer.observe(document.body.firstChild,&#123;characterDataOldValue:true&#125;);document.body.firstChild.textContent=&#x27;foo&#x27;;document.body.firstChild.textContent=&#x27;bar&#x27;;document.body.firstChild.textContent=&#x27;baz&#x27;; 观察子节点12345678document.body.innerHTML=&#x27;&#x27;;let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));//创建两个初始子节点document.body.appendChild(document.createElement(&#x27;div&#x27;));document.body.appendChild(document.createElement(&#x27;span&#x27;));observer.observe(document.body,&#123;childList:true&#125;);document.body.insertBefore(document.body.lastChild,document.body.firstChild);//发生两次变化，先移除节点再添加节点 观察子树12345document.body.innerHTML=&#x27;&#x27;;let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));document.body.appendChild(document.createElement(&#x27;div&#x27;));observer.observe(document.body,&#123;attributes:true,subtree:true&#125;);document.body.firstChild.setAttribute(&#x27;foo&#x27;,&#x27;baz&#x27;); 异步回调与记录队列takeRecords()方法清空记录队列，取出并·返回其中的所有MutationRecord实例,可以用在希望断开与观察目标的联系，但又希望处理由于disconnect()而被抛弃的记录队列中的MutationRecord实例 12345678let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));observer.observe(document.body,&#123;attributes:true&#125;);document.body.className=&#x27;foo&#x27;;document.body.className=&#x27;bar&#x27;;console.log(observer.takeRecords());console.log(observer.takeRecords());//[MutationRecord, MutationRecord]//[]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"DOM-节点层级","slug":"DOM-节点层级","date":"2021-12-12T09:13:55.000Z","updated":"2022-01-24T08:14:25.394Z","comments":true,"path":"2021/12/12/DOM-节点层级/","link":"","permalink":"https://coloey.github.io/2021/12/12/DOM-%E8%8A%82%E7%82%B9%E5%B1%82%E7%BA%A7/","excerpt":"","text":"Node类型DOM Level 描述为名为Node的接口，Node接口在JavaScript中被实现为Node类型，所有结点都继承Node类型，因此所有类型都共享相同的基本属性和方法。 节点类型可通过与这些常量比较来确定 12345678//节点类型可通过与这些常量比较确定，如果两者相等，则意味着someNode是一个元素节点if(someNode.nodeType==Node.ELEMENT_NODE)&#123; alert(&quot;Node is an element&quot;);&#125;//nodeName和nodeValue保存着有关节点的信息if(someNode.nodeType==1)&#123; value=someNode.nodeName;//会显示元素的标签名&#125; 节点关系节点与其他节点的关系可形容为家族关系，每个节点有一个childNodes属性其中包含一个NodeList的实例，NodeList是一个类数组对象，它是DOM结构的查询，DOM结构的变化会自动地在NodeList中反映出来，用于存储可以按位置存取的有序节点。可以使用中括号或者item()方法访问它的值 1234let firstChild=someNode.childNodes[0];let secondChild=someNode.childNodes.item(1);let count=someNode.childNodes.length;let arrayofNodes=Array.from(someNode.childNodes); parentNode指向DOM树中的父元素，childNode中所有节点都有同一个父元素，parentNode指向同一个节点，childNodes列表中每个结点都是同一列表中其他节点的同胞节点，使用previousSibling和nextSibling可以在这个列表的节点间导航。 hasChildNodes()节点返回true则说明节点有一个或多个子节点。 ownerDocument属性是一个指向代表整个文档的文档节点的指针 操纵节点appendChild():用于在childNodes列表末尾添加节点，返回新添加的节点。 123let returnedNode=someNode.appendChild(newNode);alert(returnedNode==newNode);//truealert(someNode.lastChild==newNode);//true inserBefore():接收两个参数，要插入的节点和参照节点。要插入的节点会变成参照节点的前一个同胞节点，并被返回 12345678910returnedNode=someNode.insertBefore(newNode,null);alert(newNode==someNode.lastChild);//true//作为新的第一个子节点插入retunedNode=someNode.insertBefore(newNode,someNode.firstChild);alert(returnedNode==newNode);//truealert(newNode==someNode.fiestChild);//true//插入最后一个子节点的前面returnedNode==someNode.insertBefore(newNode,someNode.lastChild);alert(newNode==someNode.childNodes[someNode.childNodes.length-2]);//true replaceChild():接收两个参数，要插入的节点和要替换的节点。要替换的节点被返回并从文档中被移除 1returnedNode=someNode.replaceChild(newNode,someNode.lastChild);//替换最后一个子节点 removeChild():接收一个参数，即要被移除的节点，被移除的节点会被返回 1let formerFirstChild=someNode.removeChild(someNode.firstChild); cloneNode():传入true参数会进行深复制，即复制节点和整个子DOM树；传入false进行浅复制，只会复制该方法的节点。复制返回的节点属于文档所有，但未指定父节点，称为孤儿节点，通过appendChild()和insertBefore()，replaceChild()方法把孤儿节点添加到文档中 normalize():处理文本节点，如果发现空文本节点则将其删除否则如果两个同胞节点相邻则将其合并为一个文本节点 Document类型表示文档节点的类型,document是HTMLDocument的实例（HTMLDocument继承Document）,表示整个HTML页面，document是window对象的属性是一个全局对象。 nodetype等于9 nodeName值为“#document” nodevalue值为null parentNode值为null ownerDocument值为null 子节点可以使DocumentType(最多一个)，Element(最多一个)，ProcessingInstruction或Comment类型 文档子节点documentElement:始终指向HTML页面中的元素 1234567&lt;html&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;let html=document.documentElement;//取得对&lt;html&gt;的引用alert(html===document.childNodes[0]);alert(html===document.firstChild); document.body:直接指向body元素，取得对body的引用 文档信息title:显示浏览器窗口或标签页的标题栏 URL:包含当前页面的完整URL domain:包含页面的域名 referrer:包含空字符串 123//document.URL=&quot;http://www.wrox.com/WileyCDA/&quot;,document.domain就是www.wrox.comdocument=&quot;wrrox.com&quot;;//成功document=&quot;nczonline.net&quot;;//出错,不能给这个属性设置URL中不包含的值 当页面中包含来自某个不同子域的窗格（)或内嵌窗格()设置document.domain是有用的，比如一个加载自www.wrox.com的页面包含一个内嵌窗格其中的页面加载自p2p.wrox.com，这两个页面包含不同的字符串，内部和外部不能相互访问对方的JavaScript对象，如果每个页面都把document.domain设置为wrox.com,那两个页面就可以相互通信 12document.domain=&quot;wrox.com&quot;;//放松，成功document.doman=&quot;p2p2.wrox.com&quot;;//收紧，失败,一旦放松就不能收紧 定位元素getElementById()：接收一个要获取元素的ID，如果找到这个元素则返回，没找到返回null。参数I必须跟元素在页面中大的id属性完全匹配，包括大小写 12&lt;div id=&quot;myDiv&quot;&gt;ome text&lt;/div&gt;let div=document.getElementById(&quot;myDiv&quot;);//取得对&lt;div&gt;的引用,如果存在多个相同ID的元素则返回在文档中的第一个元素 getElementsByTagName():接收一个参数，即要获取元素的标签名,返回包含0个或多个元素的NodeList，在HTML文档中返回一个HTMLCollection对象 12345678910let images=document.getElementsByTagName(&quot;img&quot;);alert(images.length);//图片数量alert(images[0].src);//第一张图片的src属性alert(images.item(0).src);//通过name属性获得引用&lt;img src=&quot;myImage.gif&quot; name=&quot;myImage&quot;&gt;;let myImage=images.namedItem(&quot;myImage&quot;);//images[&quot;myImage&quot;]//取得文档的所有元素let allElements=document.getElementsByTagName(&quot;*&quot;); getElementsByName():返回具有给定name属性的所有元素，常用于单选按钮 12345678910&lt;fieldset&gt; &lt;legend&gt;Which color do you prefer?&lt;/legend&gt; &lt;ul&gt; &lt;li&gt; &lt;input type=&quot;radio&quot; value=&quot;red&quot; name=&quot;color&quot; id=&quot;colorRed&quot;&gt;&lt;label for=&quot;colorRed&quot;&gt;Red&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;radio&quot; value=&quot;blue&quot; name=&quot;color&quot; id=&quot;colorBlue&quot;&gt;&lt;label for=&quot;colorBlue&quot;&gt;Blue&lt;/label&gt; &lt;/li&gt; let radios=document.getElementsByName(&quot;color&quot;); Element类型 nodeType=1 nodeName值为元素的标签名 nodeValue的值为null parentNode值为Document或Element对象 子节点可以是Element,Text,Comment,ProcessingInstruction等类型 通过nodeName或tagName属性获得元素的标签名 1234567891011121314151617181920//使用对象属性&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt; &lt;script&gt; let div=document.getElementById(&quot;myDiv&quot;); alert(div.tagName);//&quot;DIV&quot; alert(div.tagName==div.nodeName);//true if(element.tagName.toLowerCase()==&quot;div&quot;)&#123; //,HTML中，元素标签名以答谢表示，XML中标签名与代码中的大小写一致，不确定脚本是HTML还是XML运行，推荐将标签名转换为小写形式，适合所有文档 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; HTML元素 id:元素在文档中的唯一标识符 title：包含元素的额外信息，通常以提示条形式展示 lang：元素内容的语言代码 dir：语言的书写方向（ltr从左到右，rtl从右到左) className:相当于class属性，用于指定元素的CSS类 取得属性1234567891011121314151617181920212223//使用对象属性&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;myDiv&quot; class=&quot;bd&quot; title=&quot;Body text&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;2&lt;/div&gt; &lt;script&gt; var div=document.getElementById(&quot;myDiv&quot;); alert(div.id); alert(div.className); alert(div.title); alert(div.lang); alert(div.dir); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;//使用getAttribute()方法alert(div.getAttribute(&quot;class&quot;)); getAttribute()主要用于取得自定义属性的值，其他情况使用对象属性 设置属性setAttribute():接收两个参数，要设置的属性名和属性值,如果属性存在则用指定的值替换原来的值 1234567//直接给对象属性赋值div.id=&quot;someOtherId&quot;//在对象属性上添加自定义属性，不会让它变成元素的属性div.mycolor=&quot;red&quot;;alert(div.getAttribute(&quot;mycolor&quot;));//null//使用setAttribute赋值div.setAttribute(&quot;id&quot;,&quot;someOtherId&quot;); attributes属性attributes属性包含一个NamedNodeMap实例，是一个类似NodeList的“实时”集合，元素的每个属性都表示为一个Attr节点，并保存在NamedNodeMap对象中 attributed属性中的每个节点的nodeName是对应属性的名字，nodeValue是属性的值 12345678function outputAttributes(element)&#123; let pairs=[]; for(let i=0,len=element.attributes.length;i&lt;len;++i)&#123; const attribute=element.attributes[i]; pairs.push(`$&#123;attribute.nodeName&#125;=$&#123;attribute.nodeValue&#125;`); return pairs.join(&quot; &quot;); &#125;&#125; 创建元素document.createElement():一个参数，即要创建元素的标签名 1234let div=document.createElement(&quot;div&quot;);div.id=&quot;myNewDiv&quot;;div.className=&quot;box&quot;;document.body.appendChild(div); Text 类型Text节点由Text类型表示，包含按字面解释的纯文本，也可能包含转义后的HTML字符，Text节点中包含的文本可以通过nodeValue或者data属性访问 nodetype=3 nodeName=”#text” nodeValue值为节点中包含的文本 parentNode值为Element对象 不支持子节点 appendData(text):向节点末尾添加文本text deleteData(offset,count),从位置offset开始删除count个字符 insertData(offset,text),在位置offset插入text； replaceData(offset,count,text)，用text替换从位置offset到offset+count大的文本 splitText(offset),在位置offset将当前文本节点拆分为两个文本节点 substringData(offset,count),提取从位置offset到offset+count的文本 包含文本内容的每个元素最多只能有一个文本节点 创建文本节点document.createTextNode():创建新文本节点，接收一个参数，即要插入节点的文本 123456789let element=document.createElement(&quot;div&quot;);element.className=&quot;message&quot;;let textNode=document.createTextNode(&quot;Hello world!&quot;);element.appendChild(textNode);let anotherTextNode=document.createTextNode(&quot;Yippee&quot;);element.appendChild(anotherTextNode);document.body.appendChild(element); 规范化文本节点合并文本节点1234567891011let element=document.createElement(&quot;div&quot;);element.className=&quot;message&quot;;let textNode=document.createTextNode(&quot;Hello World&quot;);element.appendChild(textNode);let anotherTextNode=document.createTextNode(&quot;Yippee&quot;);element.appendChild(anotherTextNode);document.body.appendChild(element);alert(element.childNodes.length);//2element.normalize();alert(element.childNodes.length);//1alert(element.firstChild.nodeValue); 拆分文本节点12345678910let element=document.createElement(&quot;div&quot;);element.className=&quot;message&quot;;let textNode=document.createTextNode(&quot;Hello World&quot;);element.appendChild(textNode);document.body.appendChild(element);let newNode=element.firstChild.splitText(5);alert(element.fiestChild.nodeValue);//&quot;Hello&quot;alert(newNode.nodeValue);//&quot;world&quot;alert(element.chileNodes.length);//2 Comment类型 nodeType=8 nodeName=”#comment” nodeValue值为注释内容 parentNode值为Document或Element对象 不支持子节点 Comment类型与Text类型继承自同一个基类(CharacterData),因此拥有除splitText之外的Text节点所有的字符串操作方法 CDATASection类型继承Text类型，拥有除splitText之外的Text节点所有的字符串操作方法 DocumentType类型 在DOM Level1中不支持动态创建，只能在解析文档代码时创建，DocumentType对象保存在document.doctype属性中. DocumentType对象有3个属性：name,entities,notations. name是文档名称，entities是这个文档类型描述实体的NameNodeMap,而notations是这个文档类型描述的表示法的NamedNodeMap. 浏览器文档通常是HTML或XHTML类型，所以entities和notations列表为空，只有name属性有用，包含文档类型的名称 DocumentFragment类型 nodeType=11 nodeName=”#document-fragment” nodeValue=null parentNode=null 子节点可以是Element,ProcessingInstruction,Comment,Text,CDATASection 充当其他要被添加的文档节点的仓库 123456789&lt;ul id=&quot;myList&quot;&gt;&lt;/ul&gt;let fragment=document.createDocumentFragment();let ul=document.getElementById(&quot;myList&quot;);for(let i=0;i&lt;3;i++)&#123; let li=document.createElement(&quot;li&quot;); li.appendChild(document.createTextNode(`Item $&#123;i+1&#125;`)); fragment.appendChild(li);&#125;ul.appendChild(fragment); Attr类型属性是存在于元素attributes属性中的节点 nodeType=2 nodeName值为属性名 nodeValue值为属性值 parentNode值为null Attr对象上3个属性 name包含属性名 value包含属性值 specified是一个布尔值，表示属性使用的是默认值和还是被指定的值 1234567let attr=document.createAttribute(&quot;align&quot;);//创建新的Attr节点，参数为属性名attr.value=&quot;left&quot;;element.setAttributeNode(attr);//添加属性节点alert(element.attributes[&quot;align&quot;].value);//返回对应属性节点alert(element.getAttributeNode(&quot;align&quot;).value);//返回对应属性节点alert(element.getAttribute(&quot;align&quot;));//只返回属性值","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"选择框编程","slug":"选择框编程","date":"2021-12-12T09:07:36.000Z","updated":"2021-12-30T07:18:26.023Z","comments":true,"path":"2021/12/12/选择框编程/","link":"","permalink":"https://coloey.github.io/2021/12/12/%E9%80%89%E6%8B%A9%E6%A1%86%E7%BC%96%E7%A8%8B/","excerpt":"","text":"选项处理使用选择框的selectedIndex属性 123456789101112131415161718192021222324252627282930 &lt;form method=&quot;post&quot;&gt; &lt;select name=&quot;location&quot; id=&quot;selLocation&quot;&gt; &lt;option value=&quot;Sunnyvalue,CA&quot;&gt;Sunnyvalue&lt;/option&gt; &lt;option value=&quot;Los Angeles,CA&quot;&gt;Los Angeles&lt;/option&gt; &lt;option value=&quot;Mountain View,CA&quot;&gt;Mountain View&lt;/option&gt; &lt;option value=&quot;&quot;&gt;China&lt;/option&gt; &lt;option &gt;Australia&lt;/option&gt; &lt;/select&gt; &lt;/form&gt; &lt;script src=&quot;example3.js&quot;&gt;&lt;/script&gt; let selectbox=document.forms[0].elements[&quot;location&quot;];function getSelectedOptions(selectbox)&#123; let result=new Array(); for(let option of selectbox.options)&#123; if(option.selected)&#123; result.push(option); &#125; &#125; return result;&#125;let selectedOptions=getSelectedOptions(selectbox);let message=&quot;&quot;;for(let option of selectedOptions)&#123; message+=`Selected index:$&#123;option.index&#125;\\n`+`Selected text:$&#123;option.text&#125;\\n`+`Selected value:$&#123;option.value&#125;\\n`;&#125;console.log(message); 添加选项动态创建选项1234let newOption=document.createElement(&quot;option&quot;);newOption.appendChild(document.createTextNode(&quot;Option text&quot;));newOption.setAttribute(&quot;value&quot;,&quot;Option value&quot;);selectbox.appendChild(newOption); 使用Option构造函数创建选项,接收两个参数：text和value，用选择框的add方法添加选项 12let newOption=new Option(&quot;Option text&quot;,&quot;Option value&quot;);selectbox.add(newOption,undefined);//在列表末尾添加选项 移除选项123456789selectbox.removeChild(selectbox.options[0]);//移除第一项selectbox.remove(0);//移除第一项selectbox.options[0]=null;//清除选项框的所有选项function clearSelectbox(selectbox)&#123; for(let option of selectbox.options)&#123; selectbox.remove(0); &#125;&#125; 移动和重排选项1234let selectbox1=document.getElementById(&quot;selLocations1&quot;);let selectbox2=document.getElementById(&quot;selLocations2&quot;);selectbox2.appendChild(selectbox1.options[0]);//将选项从第一个选择框移动到另一个选择框 重排选项 123456let selectbox1=document.getElementById(&quot;selLocations1&quot;);let optionToMove=selectbox1.options[1];selectbox1.insertBefore(optionToMove,selectbox1.options[optionToMove.index-1]);//将要重排的选项移动到它原先位置的前前面let selectbox1=document.getElementById(&quot;selLocations1&quot;);let optionToMove=selectbox1.options[1];selectbox1.insertBefore(optionToMove,selectbox1.options[optionToMove.index+2]);//将要重排的选项移动到它原先位置的后面一位","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"文本框编程","slug":"文本框","date":"2021-12-09T12:46:20.000Z","updated":"2021-12-30T07:18:16.782Z","comments":true,"path":"2021/12/09/文本框/","link":"","permalink":"https://coloey.github.io/2021/12/09/%E6%96%87%E6%9C%AC%E6%A1%86/","excerpt":"","text":"文本框编程表示文本框的两种方式123456&lt;input type=&quot;text&quot; size=&quot;25&quot; maxlength=&quot;50&quot; value=&quot;initial value&quot;&gt; //创建多行文本框 &lt;textarea rows=&quot;25&quot; cols=&quot;5&quot;&gt;initial value&lt;/textarea&gt;//用使用value属性读写文本框let textbox=document.forms[0].elements[&quot;textbox1&quot;];textbox.value=&quot;Some new value&quot;; 选择文本select()用于全选文本 123456let form=document.getElementById(&quot;myForm&quot;); let textbox=form.elements[0]; textbox.addEventListener(&quot;focus&quot;,(event)=&gt;&#123; event.target.select(); console.log(`Text selected:$&#123;textbox.value&#125;`); &#125;); setSelectionRange()用于部分选择文本 1234567let form=document.getElementById(&quot;myForm&quot;);let textbox=form.elements[0];textbox.addEventListener(&quot;focus&quot;,(event)=&gt;&#123; event.target.select(); textbox.setSelectionRange(0,1); console.log(`Text selected:$&#123;textbox.value&#125;`); &#125;); 屏蔽按键12345textbox.addEventListener(&quot;keypress&quot;,(event)=&gt;&#123; if(!/\\d/.test(String.fromCharCode(event.charCode))&amp;&amp;event.charCode&gt;9&amp;&amp;!event.ctrlKey)&#123;//屏蔽非数字字符但允许同样触发keypress事件的所有基础按键以及ctrl键 event.preventDefault(); &#125;&#125;) 自动切换1234567891011121314151617181920212223242526&lt;form method=&quot;post&quot;&gt; &lt;input type=&quot;text &quot; name=&quot;tel1&quot; id=&quot;textTel1&quot; maxlength=&quot;3&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;tel2&quot; id=&quot;textTel2&quot; maxlength=&quot;3&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;tel3&quot; id=&quot;textTel3&quot; maxlength=&quot;4&quot;&gt; &lt;/form&gt; let inputIds=[&quot;textTel1&quot;,&quot;textTel2&quot;,&quot;textTel3&quot;];for(let id of inputIds)&#123; let textbox=document.getElementById(id); textbox.addEventListener(&quot;keyup&quot;,(event)=&gt;&#123; let target=event.target; if(target.value.length==target.maxLength)&#123; let form=target.form; for(let i=0,len=form.elements.length;i&lt;len;i++)&#123; if(form.elements[i]==target)&#123; if(form.elements[i+1])&#123; form.elements[i+1].focus(); &#125; return; &#125; &#125; &#125; &#125;); &#125;;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"表单","slug":"表单","date":"2021-12-09T12:11:33.000Z","updated":"2021-12-30T07:17:44.744Z","comments":true,"path":"2021/12/09/表单/","link":"","permalink":"https://coloey.github.io/2021/12/09/%E8%A1%A8%E5%8D%95/","excerpt":"","text":"表单禁用表单避免多次提交表单可以在第一次点击后禁用表单 12345678let form=document.getElementById(&quot;myForm&quot;);form.addEventListener(&quot;submit&quot;,(event)=&gt;&#123; let target=event.target; //取得提交按钮 let btn=target.elements[&quot;submit-btn&quot;]; //禁用提交按钮 btn.disabled=true;&#125;) focus()把焦点设置到表单字段,这意味着该字段会变成活动字段并可以响应键盘事件,autofocus()会自动为带有该属性的元素设置焦点 12345678let form=document.getElementById(&quot;myForm&quot;);window.addEventListener(&quot;load&quot;,(event)=&gt;&#123; let element=form.elements[0]; if(element.autofocus!==true)&#123; element.focus(); console.log(&quot;JS focus&quot;); &#125; &#125;) 表单的公共事件","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"BOM","slug":"BOM","date":"2021-11-25T12:47:05.000Z","updated":"2021-12-30T07:04:56.946Z","comments":true,"path":"2021/11/25/BOM/","link":"","permalink":"https://coloey.github.io/2021/11/25/BOM/","excerpt":"","text":"BOMlocation对象提供当前窗口加载文档的信息，以及通常的导航功能，它既是window的属性也是document的属性。 查询字符串123456789101112131415161718let getQueryStringArgs=function()&#123; //取得没有开头问号的查询字符串 let qs=(location.search.length&gt;0)?location.search.substring(1):&quot;&quot;; let args=&#123;&#125;; for(let item of(qs.split(&#x27;&amp;&#x27;).map(kv=&gt;kv.split(&#x27;=&#x27;))))&#123; let name=item[0]; value=item[1]; if(name.length)&#123; args[name]=value; &#125; &#125; return args;&#125;//qs=&quot;?q=javaScript&amp;num=10&quot;;let args=getQueryStringArgs();alert(args[&quot;q&quot;]);alert(args[&#x27;num&#x27;]); 使用USLSearchParams检查和修改查询字符串 123456789101112let qs=&quot;?q=javaScript&amp;num=10&quot;;let searchParams=new URLSearchParams(qs);alert(searchParams.toString());searchParams.has(&quot;num&quot;);searchParams.get(&quot;num&quot;);searchParams.set(&quot;page&quot;,&quot;3&quot;);alert(searchParams.toString());searchParams.delete(&quot;q&quot;);alert(searchParams.toString());for(let param of searchParams)&#123; console.log(param);&#125; 操作地址通过修改location对象修改浏览器地址，使用assign方法传进一个URL,会导航到新URL同时在浏览器历史记录增加一条记录，下面三种方法功能相同 123location.assign(&quot;http://www.wrox.com&quot;);window.location=&quot;http://www.wrox.com&quot;;location.href=&quot;http://www.wrox.com&quot;; 通过修改location属性可以修改当前加载的页面,hash,search,hostname,pathname.port属性被设置为新值后会修改当前的URL 123456789101112//假设当前URL为http://www.wrox.com/WileyCDA/location.assign(&quot;http://www.wrox.com/WileyCDA&quot;);//把URL修改为http://www.wrox.com/WileyCDA/#section1location.hash=&quot;#section1&quot;;//把URL修改为http://www.wrox.com/WileyCDA/?q=javascriptlocation.search=&quot;?q=javascript&quot;;//把URL修改为http://www.somewhere.com/WileyCDA/location.hostname=&quot;www.somewhere.com&quot;;//把URL修改为http://www.somewhere.com/mydir/location.pathname=&quot;mydir&quot;;//把URL修改为http://www.somewhere.com:8080/WileyCDA/location.port=8080; 以上的修改会在浏览器中增加记录，点击后退即可导航到前一个界面，不希望增加历史记录可以使用replace()方法，reload()可以重新加载当前页面，如果页面自从上次请求后没有修改过，则浏览器可能会从缓存中加载页面，如果想强制从服务器中加载，必须传入true history对象history用来导航历史记录，同时不会暴露用户访问过的URL。 12345678history.go(-1);//后退一页history.go(1);//前进一页history.go(&quot;wrox.com&quot;)//导航到最近的wrox.com页面//go有两个简写方法：back()和forward()history.back();//后退一页history.forward()//前进一页//history的length属性记录历史记录有多少条目if(history.length==1)&#123;//这是用户窗口第一个页面&#125; navigator对象navigator对象通常用来确定浏览器的类型 检测插件123456789101112131415161718192021222324252627282930313233343536function hasPlugin(name)&#123; name=name.toLowerCase(); for(let plugin of window.navigator.plugins)&#123; if(plugin.name.toLowerCase().indexOf(name)&gt;-1)&#123;return true;&#125; &#125; return false;&#125;//alert(hasPlugin(&quot;Flash&quot;));//alert(hasPlugin(&quot;QuickTime&quot;));function hasIEPlugin(name)&#123; try&#123; new ActiveXObject(name); return true; &#125;catch(ex)&#123; return false; &#125;&#125;//在所有浏览器中检测插件function hasFlash()&#123; var result=hasPlugin(&quot;Flash&quot;); if(!result)&#123; result=hasIEPlugin(&quot;ShockwaveFlash.ShockwaveFlash&quot;); &#125;return result;&#125;function hasQuickTime()&#123; var res=hasPlugin(&quot;QuickTime&quot;); if(!res)&#123; res=hasIEPlugin(&quot;QuickTime.QuickTime&quot;); &#125; return res;&#125;alert(hasFlash());alert(hasQuickTime()); 注册处理程序registerProtocolHandler()方法可以把一个网站注册处理为某种特定类型信息应用程序，传入3个参数：要处理的协议（“mailto或ftp),处理该协议的URL，以及应用名称 例如，把一个Web应用程序注册为默认客户端 1navigator.registerProtocolHandler(&quot;mailto&quot;,&quot;http://www.somemailclient.com?cmd=%s&quot;,&quot;Some Mail Client&quot;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"HTML+CSS","slug":"HTML+CSS","date":"2021-11-25T12:42:24.000Z","updated":"2021-12-30T07:17:34.845Z","comments":true,"path":"2021/11/25/HTML+CSS/","link":"","permalink":"https://coloey.github.io/2021/11/25/HTML+CSS/","excerpt":"","text":"定位：定位总结： static: 不脱标，不能使用边偏移 relative:不脱标（占有位置），可用margin,相对于自身位置移动 absolute:脱标（不占有位置）,不可用margin,带有定位的父级 fixed：脱标（不占有位置），浏览器可视区 sticky:不脱标（占有位置），浏览器可视区 绝对定位特点：如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位 如果祖先元素有定位（相对，绝对，固定定位）则以最近一级的有定位的祖先元素为参考点移动位置 绝对定位不占有原先的位置（脱标） 叠放次序 z-index在使用定位布局时，可以使用z-index来控制盒子的前后次序 语法： 选择器{z-index:1;} 数值可以是正整数，负整数或者0，默认是auto，数值越大，盒子越靠上 如果属性相同，则按照书写顺序，后来居上 数字后面不能加单位 只有定位的盒子才有z-index属性 定位的拓展1.绝对定位盒子居中 left:50% margin-left:-100px; 2.定位特殊性：绝对定位固定定位和浮动相似 行内元素添加绝对或者固定定位，可以直接设置高度和宽度（span) 块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小 脱标的盒子不会触发外边距合并问题 3.绝对定位（固定定位）会完全压住盒子浮动元素只会压住下面标准流的盒子，但是不会压住下面标准流的文字（图片）但是绝对定位（固定定位）会压住下面标准流的所有内容 浮动之所以不会压住下面文字是因为浮动最初的目的是为了做文字环绕效果 元素里的显示和隐藏display 显示隐藏元素 但是不保留位置 隐藏元素不想要原来位置，用none，否则用block visibility显示隐藏元素 但是保留原来的位置,visible为元素可见，hidden为元素隐藏 overflow 溢出显示隐藏 但是只是对于溢出的部分处理,scoll:溢出的部分显示滚动条，visible:溢出部分可见,hidden:溢出部分不可见,auto:没溢出则不显示滚动条，溢出则超出部分显示滚动条。 用户界面样式鼠标样式cursorli &#123;cursor: pointer; &#125; default 默认小白鼠标 pointer 小手 move 移动 text 文本 not-allowed 禁止 vertical-align实现行内块和文字居中对齐vertical-align:middle 解决图片底部默认空白空隙：图片底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐解决方法：1.给图片添加vertical-align:middle或者top或者bottom 2.把图片转为块级元素 display:block 单行文字溢出显示省略号white-space:nomal:如果文字显示不开自动换行 white-space:nowrap:如果文字显示不开强制一行内显示 overflow:hidden(溢出部分隐藏) text-overflow:ellipsis(文字溢出部分用省略号显示) 多行文本溢出显示省略号​ width: 150px; ​ height: 65px; ​ background-color: pink; ​ margin: 100px auto; ​ overflow: hidden; ​ text-overflow: ellipsis; ​ display: -webkit-box; ​ /* 从第几行开始省略 */ ​ -webkit-line-clamp: 3; ​ -webkit-box-orient: vertical; 常见布局技巧margin负值使用让每个盒子margin往左移动-1px，正好压住相邻盒子的边框 鼠标经过盒子提高当前盒子层级（如果没有定位，则加相对定位（保留位置）如果都有定位则用z-index) 文字围绕浮动元素三角形制作 weight:0; height:0; border-color:transparent red transparent transprent; border-style:solid; border-width:22px 8px 0 0;(上面的宽，右边的小一些) HTML新标签header:头部标签 nav：导航标签 article:内容标签 section:定义文档某个区域 aside:侧边栏标签 footer：尾部标签 主要针对搜索引擎，这些新标签页面中可以使用多次，在IE9中，需要把这些元素转换为块级元素 视频用mp4格式 autoplay:自动播放 controls:向用户使用播放控件 width:设置播放器宽度 height:设置高度 loop:是否循环播放 src：url（视频url地址） poster:加载等待的画面图片 muted：静音播放 新增input表单type=”email” type=”url” type=”date” type=”time” type=”month” type=”week” type=”numbers” type=”tel” type=”search” type=”color” input属性 required=”requied”表示该内容不能为空，必填 placeholder=”placeholder”提示文本，表单提示信息 autofocus=”autofocus”自动聚焦属性，页面加载完成自动聚焦到指定表单 autocomplete：默认为on，当用户键入字段时基于之前键入的值显示出字段，关闭为off multiple:可以多选文件提交 新增选择器属性选择器E[att]选择具有att属性的E元素 E[att=”val”]选择具有att属性且属性值等于val的E元素 E[att^=”val”]选择具有att属性且属性值以val开头 E[att$=”val”]选择具有att属性且属性值中含有val的E元素 伪类选择器E:first-child:匹配父元素的第一个子元素 E:last-child:匹配父元素的最后一个元素 E:nth-child(n)匹配父元素的第n个元素 E:nth-child(even)匹配父元素的第偶数个元素，odd则第奇数个元素 E:nth-child(n)，从0开始计算，但是第0个元素或者超出元素个数会被忽略 nth-child(2n):偶数，2n+1:奇数 5n:5 10 15… n+5:从第5个开始到最后 -n+5：前5个（包含第5个） nth-of-type():会把指定孩子排序号，执行的时候先看E指定的元素，之后根据E回去看是第几个孩子 nth-child:对于父元素里面所有孩子进行排序选择，先找到第n个孩子，然后看着是否和E匹配 无序列表用nth-child比较多 类选择器，属性选择器和伪类选择器权重为10 伪元素选择器::before:在元素内部的前面插入内容 ::after:在元素内部的后面插入内容 before和after创建一个元素，属于行内元素 新创建的这个元素在文档树中找不到，因此称为伪元素 语法：element::before{}, before和after必须有content属性 伪元素和标签选择器一样，权重为1 伪元素选择器：清除浮动.clearfix:after { content:’’; display:block;//插入的元素必须是块级 height:0;//不要看见这个元素 clear:both; visibility:hidden;//不要看见这个元素 } .clearfix:before,.clearfix:after { content:’’; diaplay:table;//元素在一行显示且转化为块级元素 } CSS盒子模型box-sizing:content-box，盒子大小为width+padding+border(CSS3之前默认) box-sizing:border-box,盒子大小为width 如果盒子模型我们改为了box-sizing：border-box，那padding和border就不会撑大盒子（前提padding和border不会超过width宽度） CSS过渡（重点）transition:要过渡的属性 花费时间 运动曲线 何时开始 1属性：想要变化的CSS属性，宽度高度 背景颜色内外边距都可以 如果想要所有属性都变化过度则用all 2花费时间：单位是秒（必需写单位 3运动曲线默认为ease 4何时开始：单位是秒 可以设置延迟触发时间 默认是0s CSS filter属性修改图片的颜色为黑白 1img&#123;filter:grayscale(100%)&#125;","categories":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"https://coloey.github.io/categories/HTML-CSS/"}],"tags":[]},{"title":"DOM扩展","slug":"DOM扩展","date":"2021-11-25T08:47:24.000Z","updated":"2021-12-30T07:17:21.260Z","comments":true,"path":"2021/11/25/DOM扩展/","link":"","permalink":"https://coloey.github.io/2021/11/25/DOM%E6%89%A9%E5%B1%95/","excerpt":"","text":"Selectors APIquerySelector()接收CSS选择符参数，返回匹配模式的第一个后代元素，如果没有匹配项则返回null 12345678let body=document.querySelector(&quot;body&quot;);//取得id名为myDiv的元素let myDiv=document.querySelector(&quot;#myDiv&quot;);//取得类名为“selector&quot;的第一个元素let selected=document.querySelector(&quot;.selected&quot;);//取得类名为&quot;button&quot;的图片let img=document.querySelector(&quot;img.button&quot;); querySelectorAll()接收一个查询参数，返回所有匹配的节点，即一个NodeList的静态实例 1234567891011//取得id为&#x27;myDiv&#x27;的&lt;div&gt;元素中的所有&lt;em&gt;元素let ems=document.getElementByid(&#x27;myDiv&#x27;).querySelectorAll(&quot;em&quot;);//取得所有类名中包含&#x27;selected&#x27;的元素let selecteds=document.querySelectorAll(&quot;.selected&quot;);//取得所有是&lt;p&gt;元素子元素的&lt;strong&gt;元素let strongs=document.querySelectorAll(&quot;p strong&quot;);for(let strong of strongs)&#123; strong.className=&quot;important&quot;; //strong.item(i).className=&quot;important&quot;; //strong[i].className=&quot;important&quot;;&#125; HTML5getElementsByClassName()接收一个参数，即包含一个或多个类名的字符串，返回类名中包含相应类的元素的NodeList 1234//取得所有类名中包含&#x27;username&#x27;和&#x27;current&#x27;元素let allCurrentUsernames=document.getElementsByClassName(&quot;username current&quot;);//取得id为“myDiv&quot;的元素子树中所有包含&#x27;selected’类的元素let selected=document.getElementById(&quot;myDiv&quot;).getElementsByClassName(&quot;selected&quot;); 这个方法返回以调用它的对象为根元素的子树中所有匹配的元素，在document上调用getElementsByClassName()返回文档中所有匹配的元素，而在特定元素中调用getElementsByClassName()返回该元素后代中匹配的元素 classList属性 add(value) contains(value) remove(value) toggle(value)：如果类名列表中已经存在指定的value，则删除，如果不存在，添加 123456div.classList.remove(&quot;disabled&quot;);div.classList.add(&quot;current&quot;);//检测类名if(div.classList.contains(&quot;bd&quot;)&amp;&amp;!div.classList.contains(&quot;disabled&quot;))&#123; &#125; 焦点管理12345let button=document.getElementById(&quot;myButton&quot;);button.focus();console.log(document.activeElement===button);console.log(document.hasFocus());//true文档已经拥有焦点","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]}],"categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"浏览器","slug":"浏览器","permalink":"https://coloey.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"HTTP","slug":"计算机网络/HTTP","permalink":"https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/"},{"name":"webpack","slug":"前端工程化/webpack","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://coloey.github.io/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"},{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"浏览器渲染机制","slug":"浏览器渲染机制","permalink":"https://coloey.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://coloey.github.io/categories/WebSocket/"},{"name":"http","slug":"http","permalink":"https://coloey.github.io/categories/http/"},{"name":"Vue","slug":"Node/Vue","permalink":"https://coloey.github.io/categories/Node/Vue/"},{"name":"算法","slug":"算法","permalink":"https://coloey.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"HTML5","slug":"Node/HTML5","permalink":"https://coloey.github.io/categories/Node/HTML5/"},{"name":"git","slug":"git","permalink":"https://coloey.github.io/categories/git/"},{"name":"vim","slug":"vim","permalink":"https://coloey.github.io/categories/vim/"},{"name":"Express","slug":"Node/Express","permalink":"https://coloey.github.io/categories/Node/Express/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://coloey.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"https://coloey.github.io/categories/HTML-CSS/"}],"tags":[{"name":"watch","slug":"watch","permalink":"https://coloey.github.io/tags/watch/"}]}