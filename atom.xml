<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小柒</title>
  
  <subtitle>www.xiaoqi.cn</subtitle>
  <link href="https://coloey.github.io/atom.xml" rel="self"/>
  
  <link href="https://coloey.github.io/"/>
  <updated>2022-05-03T09:14:13.809Z</updated>
  <id>https://coloey.github.io/</id>
  
  <author>
    <name>小柒</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue3性能提升的几个方面</title>
    <link href="https://coloey.github.io/2022/05/03/Vue3%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E9%9D%A2/"/>
    <id>https://coloey.github.io/2022/05/03/Vue3%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E9%9D%A2/</id>
    <published>2022-05-03T08:54:35.000Z</published>
    <updated>2022-05-03T09:14:13.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译阶段："><a href="#编译阶段：" class="headerlink" title="编译阶段："></a>编译阶段：</h1><ul><li>diff算法优化</li><li>静态提升</li><li>事件监听缓存</li><li>SSR优化</li></ul><h2 id="diff算法优化"><a href="#diff算法优化" class="headerlink" title="diff算法优化"></a>diff算法优化</h2><p>vue3在diff算法中相比vue2增加了静态标记</p><p>作用是为了会发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较。已经标记静态结点的p标签在diff过程中不会比较，把性能进一步提高</p><p><img src="/2022/05/03/Vue3%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E9%9D%A2/vueyou1.png"></p><p>关于静态类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> enum PatchFlags &#123;</span><br><span class="line">  TEXT = <span class="number">1</span>,<span class="comment">// 动态的文本节点</span></span><br><span class="line">  CLASS = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,  <span class="comment">// 2 动态的 class</span></span><br><span class="line">  STYLE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,  <span class="comment">// 4 动态的 style</span></span><br><span class="line">  PROPS = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,  <span class="comment">// 8 动态属性，不包括类名和样式</span></span><br><span class="line">  FULL_PROPS = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,  <span class="comment">// 16 动态 key，当 key 变化时需要完整的 diff 算法做比较</span></span><br><span class="line">  HYDRATE_EVENTS = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,  <span class="comment">// 32 表示带有事件监听器的节点</span></span><br><span class="line">  STABLE_FRAGMENT = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,   <span class="comment">// 64 一个不会改变子节点顺序的 Fragment</span></span><br><span class="line">  KEYED_FRAGMENT = <span class="number">1</span> &lt;&lt; <span class="number">7</span>, <span class="comment">// 128 带有 key 属性的 Fragment</span></span><br><span class="line">  UNKEYED_FRAGMENT = <span class="number">1</span> &lt;&lt; <span class="number">8</span>, <span class="comment">// 256 子节点没有 key 的 Fragment</span></span><br><span class="line">  NEED_PATCH = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,   <span class="comment">// 512</span></span><br><span class="line">  DYNAMIC_SLOTS = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,  <span class="comment">// 动态 solt</span></span><br><span class="line">  HOISTED = -<span class="number">1</span>,  <span class="comment">// 特殊标志是负整数表示永远不会用作 diff</span></span><br><span class="line">  BAIL = -<span class="number">2</span> <span class="comment">// 一个特殊的标志，指代差异算法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态提升"><a href="#静态提升" class="headerlink" title="静态提升"></a>静态提升</h2><p>Vue3中堆不参与更新得元素，会做静态提升，只会被创建一次，在渲染时直接复用，这样就免去了重复的创建节点，大型应用会受益于这个改动，免去重复的创建操作，优化了运行时候的内存占用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>没有做静态提升之前</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (_openBlock(), _createBlock(_Fragment, <span class="literal">null</span>, [</span><br><span class="line">    _createVNode(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;你好&quot;</span>),</span><br><span class="line">    _createVNode(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, _toDisplayString(_ctx.message), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ], <span class="number">64</span> <span class="comment">/* STABLE_FRAGMENT */</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做了静态提升后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _hoisted_1 = <span class="comment">/*#__PURE__*/</span>_createVNode(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;你好&quot;</span>, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (_openBlock(), _createBlock(_Fragment, <span class="literal">null</span>, [</span><br><span class="line">    _hoisted_1,</span><br><span class="line">    _createVNode(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, _toDisplayString(_ctx.message), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ], <span class="number">64</span> <span class="comment">/* STABLE_FRAGMENT */</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the console for the AST</span></span><br></pre></td></tr></table></figure><p>静态内容_hosted_1被放置在render函数外，每次渲染的时候只要取_hosted_即可，同时_hosted_1被打上PatchFlag,静态标记为-1，特殊标记是负整数表示永远不会用于Diff</p><h2 id="事件监听缓存"><a href="#事件监听缓存" class="headerlink" title="事件监听缓存"></a>事件监听缓存</h2><p>默认情况下绑定事件行为会被认为是动态绑定，所以每次都会去追踪它的变化</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span> = <span class="string">&#x27;onClick&#x27;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>没开启事件监听器缓存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> render = <span class="comment">/*#__PURE__*/</span>_withId(<span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (_openBlock(), _createBlock(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    _createVNode(<span class="string">&quot;button&quot;</span>, &#123; <span class="attr">onClick</span>: _ctx.onClick &#125;, <span class="string">&quot;点我&quot;</span>, <span class="number">8</span> <span class="comment">/* PROPS */</span>, [<span class="string">&quot;onClick&quot;</span>])</span><br><span class="line">                                             <span class="comment">// PROPS=1&lt;&lt;3,// 8 //动态属性，但不包含类名和样式</span></span><br><span class="line">  ]))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>开启事件监听器缓存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (_openBlock(), _createBlock(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    _createVNode(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">onClick</span>: _cache[<span class="number">1</span>] || (_cache[<span class="number">1</span>] = <span class="function">(<span class="params">...args</span>) =&gt;</span> (_ctx.onClick(...args)))</span><br><span class="line">    &#125;, <span class="string">&quot;点我&quot;</span>)</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启缓存后，没有了静态标记，也就是说下次diff算法的时候直接使用</p><h2 id="SSR优化"><a href="#SSR优化" class="headerlink" title="SSR优化"></a>SSR优化</h2><p>当静态内容大到一定量级，会用createStaticVNode方法在客户端生成一个static node,这些静态node,会被直接innerHtml,就不需要创建对象，任何根据对象渲染</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">div&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">...  // 很多个静态属性</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编译后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mergeProps <span class="keyword">as</span> _mergeProps &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ssrRenderAttrs <span class="keyword">as</span> _ssrRenderAttrs, ssrInterpolate <span class="keyword">as</span> _ssrInterpolate &#125; <span class="keyword">from</span> <span class="string">&quot;@vue/server-renderer&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ssrRender</span>(<span class="params">_ctx, _push, _parent, _attrs, $props, $setup, $data, $options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _cssVars = &#123; <span class="attr">style</span>: &#123; <span class="attr">color</span>: _ctx.color &#125;&#125;</span><br><span class="line">  _push(<span class="string">`&lt;div<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">    _ssrRenderAttrs(_mergeProps(_attrs, _cssVars))</span></span></span><br><span class="line"><span class="subst"><span class="string">  &#125;</span>&gt;&lt;div&gt;&lt;span&gt;你好&lt;/span&gt;...&lt;div&gt;&lt;span&gt;你好&lt;/span&gt;&lt;div&gt;&lt;span&gt;<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">    _ssrInterpolate(_ctx.message)</span></span></span><br><span class="line"><span class="subst"><span class="string">  &#125;</span>&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="源码体积"><a href="#源码体积" class="headerlink" title="源码体积"></a>源码体积</h1><p>相比Vue2,Vue3整体体积变小，除了移除一些不常用API，最重要的是Tree shaking,任何一个函数，如ref,reactive,computed,仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小</p><h1 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a>响应式系统</h1><p>vue2采用的是defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter,setter,实现响应式,而vue3采用proxy重写响应式系统，因为proxy可以对整个对象进行监听，所有不需要深度遍历</p><ul><li>可以监听动态属性的添加</li><li>可以监听到数组索引和数组length属性</li><li>可以监听删除属性</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编译阶段：&quot;&gt;&lt;a href=&quot;#编译阶段：&quot; class=&quot;headerlink&quot; title=&quot;编译阶段：&quot;&gt;&lt;/a&gt;编译阶段：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;diff算法优化&lt;/li&gt;
&lt;li&gt;静态提升&lt;/li&gt;
&lt;li&gt;事件监听缓存&lt;/li&gt;
&lt;li&gt;SSR优</summary>
      
    
    
    
    <category term="Vue" scheme="https://coloey.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue diff算法</title>
    <link href="https://coloey.github.io/2022/05/03/Vue-diff%E7%AE%97%E6%B3%95/"/>
    <id>https://coloey.github.io/2022/05/03/Vue-diff%E7%AE%97%E6%B3%95/</id>
    <published>2022-05-03T07:53:37.000Z</published>
    <updated>2022-05-03T08:27:20.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>diss算法是一种同层的树节点进行比较的高效算法</p><p>两个特点：</p><p>比较只会在同层级进行，不会跨层级比较</p><p>在diff比较过程中，循环会从两边向中间比较</p><p><code>diff</code> 算法的在很多场景下都有应用，在 <code>vue</code> 中，作用于虚拟 <code>dom</code> 渲染成真实 <code>dom</code> 的新旧 <code>VNode</code> 节点比较</p><h2 id="二、比较方式"><a href="#二、比较方式" class="headerlink" title="二、比较方式"></a>二、比较方式</h2><p><code>diff</code>整体策略为：深度优先，同层比较</p><ol><li>比较只会在同层级进行, 不会跨层级比较</li></ol><img src="/2022/05/03/Vue-diff%E7%AE%97%E6%B3%95/91e9c9519a11caa0c5bf70714383f054.png" alt="img" style="zoom:50%;"><ol><li>比较的过程中，循环从两边向中间收拢</li></ol><img src="/2022/05/03/Vue-diff%E7%AE%97%E6%B3%95/2dcd6ad5cf82c65b9cfc43a27ba1e4ec.png" alt="img" style="zoom:50%;"><p>下面举个<code>vue</code>通过<code>diff</code>算法更新的例子：</p><p>新旧<code>VNode</code>节点如下图所示：</p><p><img src="/2022/05/03/Vue-diff%E7%AE%97%E6%B3%95/diff1.png"></p><p>第一次循环后，发现旧节点D与新节点D相同，直接复用旧节点D作为<code>diff</code>后的第一个真实节点，同时旧节点<code>endIndex</code>移动到C，新节点的 <code>startIndex</code> 移动到了 C</p><p><img src="/2022/05/03/Vue-diff%E7%AE%97%E6%B3%95/diff2.png"></p><p>第二次循环后，同样是旧节点的末尾和新节点的开头(都是 C)相同，同理，<code>diff</code> 后创建了 C 的真实节点插入到第一次创建的 B 节点后面。同时旧节点的 <code>endIndex</code> 移动到了 B，新节点的 <code>startIndex</code> 移动到了 E</p><p><img src="/2022/05/03/Vue-diff%E7%AE%97%E6%B3%95/diff3.png"></p><p>第三次循环中，发现E没有找到，这时候只能直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。同时新节点的 <code>startIndex</code> 移动到了 A。旧节点的 <code>startIndex</code> 和 <code>endIndex</code> 都保持不动</p><p><img src="/2022/05/03/Vue-diff%E7%AE%97%E6%B3%95/diff4.png"></p><p>第四次循环中，发现了新旧节点的开头(都是 A)相同，于是 <code>diff</code> 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。同时旧节点的 <code>startIndex</code> 移动到了 B，新节点的<code> startIndex</code> 移动到了 B</p><p><img src="/2022/05/03/Vue-diff%E7%AE%97%E6%B3%95/diff5.png"></p><p>第五次循环中，情形同第四次循环一样，因此 <code>diff</code> 后创建了 B 真实节点 插入到前一次创建的 A 节点后面。同时旧节点的 <code>startIndex </code>移动到了 C，新节点的 startIndex 移动到了 F</p><p><img src="/2022/05/03/Vue-diff%E7%AE%97%E6%B3%95/diff6.png"></p><p>新节点的 <code>startIndex</code> 已经大于 <code>endIndex</code> 了，需要创建 <code>newStartIdx</code> 和 <code>newEndIdx</code> 之间的所有节点，也就是节点F，直接创建 F 节点对应的真实节点放到 B 节点后面</p><p><img src="/2022/05/03/Vue-diff%E7%AE%97%E6%B3%95/diff7.png"></p><h2 id="三、原理分析"><a href="#三、原理分析" class="headerlink" title="三、原理分析"></a>三、原理分析</h2><p>当数据发生改变时，<code>set</code>方法会调用<code>Dep.notify</code>通知所有订阅者<code>Watcher</code>，订阅者就会调用<code>patch</code>给真实的<code>DOM</code>打补丁，更新相应的视图</p><p>源码位置：src/core/vdom/patch.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode)) &#123; <span class="comment">// 没有新节点，直接执行destory钩子函数</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(oldVnode)) invokeDestroyHook(oldVnode)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</span><br><span class="line">        isInitialPatch = <span class="literal">true</span></span><br><span class="line">        createElm(vnode, insertedVnodeQueue) <span class="comment">// 没有旧节点，直接用新节点生成dom元素</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType)</span><br><span class="line">        <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">            <span class="comment">// 判断旧节点和新节点自身一样，一致执行patchVnode</span></span><br><span class="line">            patchVnode(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则直接销毁及旧节点，根据新节点生成dom元素</span></span><br><span class="line">            <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (oldVnode.nodeType === <span class="number">1</span> &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;</span><br><span class="line">                    oldVnode.removeAttribute(SSR_ATTR)</span><br><span class="line">                    hydrating = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isTrue(hydrating)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">                        invokeInsertHook(vnode, insertedVnodeQueue, <span class="literal">true</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVnode</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                oldVnode = emptyNodeAt(oldVnode)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> vnode.elm</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>patch</code>函数前两个参数位为<code>oldVnode</code> 和 <code>Vnode</code> ，分别代表旧的节点和新节点，主要做了四个判断：</p><ul><li>没有新节点，直接触发旧节点的<code>destory</code>钩子</li><li>没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 <code>createElm</code></li><li>旧节点和新节点自身一样，通过 <code>sameVnode</code> 判断节点是否一样，一样时，直接调用 <code>patchVnode </code>去处理这两个节点</li><li>旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点</li></ul><p>下面主要讲的是<code>patchVnode</code>部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span> (<span class="params">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果新旧节点一致，什么都不做</span></span><br><span class="line">    <span class="keyword">if</span> (oldVnode === vnode) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让vnode.el引用到现在的真实dom，当el修改时，vnode.el会同步变化</span></span><br><span class="line">    <span class="keyword">const</span> elm = vnode.elm = oldVnode.elm</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步占位符</span></span><br><span class="line">    <span class="keyword">if</span> (isTrue(oldVnode.isAsyncPlaceholder)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(vnode.asyncFactory.resolved)) &#123;</span><br><span class="line">        hydrate(oldVnode.elm, vnode, insertedVnodeQueue)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnode.isAsyncPlaceholder = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新旧都是静态节点，并且具有相同的key</span></span><br><span class="line">    <span class="comment">// 当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上</span></span><br><span class="line">    <span class="comment">// 也不用再有其他操作</span></span><br><span class="line">    <span class="keyword">if</span> (isTrue(vnode.isStatic) &amp;&amp;</span><br><span class="line">      isTrue(oldVnode.isStatic) &amp;&amp;</span><br><span class="line">      vnode.key === oldVnode.key &amp;&amp;</span><br><span class="line">      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))</span><br><span class="line">    ) &#123;</span><br><span class="line">      vnode.componentInstance = oldVnode.componentInstance</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> i</span><br><span class="line">    <span class="keyword">const</span> data = vnode.data</span><br><span class="line">    <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) &#123;</span><br><span class="line">      i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> oldCh = oldVnode.children</span><br><span class="line">    <span class="keyword">const</span> ch = vnode.children</span><br><span class="line">    <span class="keyword">if</span> (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)</span><br><span class="line">      <span class="keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果vnode不是文本节点或者注释节点</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">      <span class="comment">// 并且都有子节点</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">        <span class="comment">// 并且子节点不完全一致，则调用updateChildren</span></span><br><span class="line">        <span class="keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果只有新的vnode有子节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="comment">// elm已经引用了老的dom节点，在老的dom节点上添加子节点</span></span><br><span class="line">        addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果新vnode没有子节点，而Oldvnode有子节点，直接删除老的oldCh</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">        removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果老节点是文本节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">        nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果新vnode和老vnode是文本节点或注释节点</span></span><br><span class="line">      <span class="comment">// 但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">      nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>patchVnode</code>主要做了几个判断：</p><ul><li>新节点是否是文本节点，如果是，则直接更新<code>dom</code>的文本内容为新节点的文本内容</li><li>新节点和旧节点如果都有子节点，则处理比较更新子节点</li><li>只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新<code>DOM</code>，并且添加进父节点</li><li>只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把<code>DOM</code> 删除</li></ul><p>子节点不完全一致，则调用<code>updateChildren</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span> (<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> oldStartIdx = <span class="number">0</span> <span class="comment">// 旧头索引</span></span><br><span class="line">    <span class="keyword">let</span> newStartIdx = <span class="number">0</span> <span class="comment">// 新头索引</span></span><br><span class="line">    <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span> <span class="comment">// 旧尾索引</span></span><br><span class="line">    <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span> <span class="comment">// 新尾索引</span></span><br><span class="line">    <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>] <span class="comment">// oldVnode的第一个child</span></span><br><span class="line">    <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx] <span class="comment">// oldVnode的最后一个child</span></span><br><span class="line">    <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>] <span class="comment">// newVnode的第一个child</span></span><br><span class="line">    <span class="keyword">let</span> newEndVnode = newCh[newEndIdx] <span class="comment">// newVnode的最后一个child</span></span><br><span class="line">    <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">    <span class="comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class="line">    <span class="comment">// to ensure removed elements stay in correct relative positions</span></span><br><span class="line">    <span class="comment">// during leaving transitions</span></span><br><span class="line">    <span class="keyword">const</span> canMove = !removeOnly</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果oldStartVnode和oldEndVnode重合，并且新的也都重合了，证明diff完了，循环结束</span></span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">      <span class="comment">// 如果oldVnode的第一个child不存在</span></span><br><span class="line">      <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">        <span class="comment">// oldStart索引右移</span></span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果oldVnode的最后一个child不存在</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">        <span class="comment">// oldEnd索引左移</span></span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// oldStartVnode和newStartVnode是同一个节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">        <span class="comment">// patch oldStartVnode和newStartVnode， 索引左移，继续循环</span></span><br><span class="line">        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// oldEndVnode和newEndVnode是同一个节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">        <span class="comment">// patch oldEndVnode和newEndVnode，索引右移，继续循环</span></span><br><span class="line">        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// oldStartVnode和newEndVnode是同一个节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">        <span class="comment">// patch oldStartVnode和newEndVnode</span></span><br><span class="line">        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">        <span class="comment">// 如果removeOnly是false，则将oldStartVnode.eml移动到oldEndVnode.elm之后</span></span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">        <span class="comment">// oldStart索引右移，newEnd索引左移</span></span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果oldEndVnode和newStartVnode是同一个节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">        <span class="comment">// patch oldEndVnode和newStartVnode</span></span><br><span class="line">        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">        <span class="comment">// 如果removeOnly是false，则将oldEndVnode.elm移动到oldStartVnode.elm之前</span></span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">        <span class="comment">// oldEnd索引左移，newStart索引右移</span></span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果都不匹配</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试在oldChildren中寻找和newStartVnode的具有相同的key的Vnode</span></span><br><span class="line">        idxInOld = isDef(newStartVnode.key)</span><br><span class="line">          ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果未找到，说明newStartVnode是一个新的节点</span></span><br><span class="line">        <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">          <span class="comment">// 创建一个新Vnode</span></span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果找到了和newStartVnodej具有相同的key的Vnode，叫vnodeToMove</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          vnodeToMove = oldCh[idxInOld]</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !vnodeToMove) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              <span class="string">&#x27;It seems there are duplicate keys that is causing an update error. &#x27;</span> +</span><br><span class="line">              <span class="string">&#x27;Make sure each v-for item has a unique key.&#x27;</span></span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 比较两个具有相同的key的新节点是否是同一个节点</span></span><br><span class="line">          <span class="comment">//不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。</span></span><br><span class="line">          <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">            <span class="comment">// patch vnodeToMove和newStartVnode</span></span><br><span class="line">            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)</span><br><span class="line">            <span class="comment">// 清除</span></span><br><span class="line">            oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">            <span class="comment">// 如果removeOnly是false，则将找到的和newStartVnodej具有相同的key的Vnode，叫vnodeToMove.elm</span></span><br><span class="line">            <span class="comment">// 移动到oldStartVnode.elm之前</span></span><br><span class="line">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果key相同，但是节点不相同，则创建一个新的节点</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右移</span></span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>while</code>循环主要处理了以下五种情景：</p><ul><li>当新老 <code>VNode</code> 节点的 <code>start</code> 相同时，直接 <code>patchVnode</code> ，同时新老 <code>VNode</code> 节点的开始索引都加 1</li><li>当新老 <code>VNode</code> 节点的 <code>end</code>相同时，同样直接 <code>patchVnode</code> ，同时新老 <code>VNode</code> 节点的结束索引都减 1</li><li>当老 <code>VNode</code> 节点的 <code>start</code> 和新 <code>VNode</code> 节点的 <code>end</code> 相同时，这时候在 <code>patchVnode</code> 后，还需要将当前真实 <code>dom</code> 节点移动到 <code>oldEndVnode</code> 的后面，同时老 <code>VNode</code> 节点开始索引加 1，新 <code>VNode</code> 节点的结束索引减 1</li><li>当老 <code>VNode</code> 节点的 <code>end</code> 和新 <code>VNode</code> 节点的 <code>start</code> 相同时，这时候在 <code>patchVnode</code> 后，还需要将当前真实 <code>dom</code> 节点移动到 <code>oldStartVnode</code> 的前面，同时老 <code>VNode</code> 节点结束索引减 1，新 <code>VNode</code> 节点的开始索引加 1</li><li>如果都不满足以上四种情形，那说明没有相同的节点可以复用，则会分为以下两种情况：<ul><li>从旧的 <code>VNode</code> 为 <code>key</code> 值，对应 <code>index</code> 序列为 <code>value</code> 值的哈希表中找到与 <code>newStartVnode</code> 一致 <code>key</code> 的旧的 <code>VNode</code> 节点，再进行<code>patchVnode </code>，同时将这个真实 <code>dom </code>移动到 <code>oldStartVnode</code> 对应的真实 <code>dom</code> 的前面</li><li>调用 <code>createElm</code> 创建一个新的 <code>dom</code> 节点放到当前 <code>newStartIdx</code> 的位置</li></ul></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><p>当数据发生改变时，订阅者<code>watcher</code>就会调用<code>patch</code>给真实的<code>DOM</code>打补丁</p></li><li><p>通过<code>isSameVnode</code>进行判断，相同则调用<code>patchVnode</code>方法</p></li><li><p>```<br>patchVnode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  做了以下操作：</span><br><span class="line"></span><br><span class="line">  - 找到对应的真实`dom`，称为`el`</span><br><span class="line">  - 如果都有文本节点且不相等，将`el`文本节点设置为`Vnode`的文本节点</span><br><span class="line">  - 如果`oldVnode`有子节点而`VNode`没有，则删除`el`子节点</span><br><span class="line">  - 如果`oldVnode`没有子节点而`VNode`有，则将`VNode`的子节点真实化后添加到`el`</span><br><span class="line">  - 如果两者都有子节点，则执行`updateChildren`函数比较子节点</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  updateChildren</span><br></pre></td></tr></table></figure><p>主要做了以下操作：</p><ul><li>设置新旧<code>VNode</code>的头尾指针</li><li>新旧头尾指针进行比较，循环向中间靠拢，根据情况调用<code>patchVnode</code>进行<code>patch</code>重复流程、调用<code>createElem</code>创建一个新节点，从哈希表寻找 <code>key</code>一致的<code>VNode</code> 节点再分情况操作</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、是什么&quot;&gt;&lt;a href=&quot;#一、是什么&quot; class=&quot;headerlink&quot; title=&quot;一、是什么&quot;&gt;&lt;/a&gt;一、是什么&lt;/h2&gt;&lt;p&gt;diss算法是一种同层的树节点进行比较的高效算法&lt;/p&gt;
&lt;p&gt;两个特点：&lt;/p&gt;
&lt;p&gt;比较只会在同层级进行，不会</summary>
      
    
    
    
    <category term="Vue" scheme="https://coloey.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Composition API 与Options API</title>
    <link href="https://coloey.github.io/2022/05/03/Composition-API-%E4%B8%8EOptions-API/"/>
    <id>https://coloey.github.io/2022/05/03/Composition-API-%E4%B8%8EOptions-API/</id>
    <published>2022-05-03T06:46:26.000Z</published>
    <updated>2022-05-03T06:46:26.485Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>强缓存和协商缓存</title>
    <link href="https://coloey.github.io/2022/05/02/%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/"/>
    <id>https://coloey.github.io/2022/05/02/%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/</id>
    <published>2022-05-02T14:40:35.000Z</published>
    <updated>2022-05-02T15:05:25.812Z</updated>
    
    <content type="html"><![CDATA[<p>这里说的缓存是指浏览器（客户端）在本地磁盘中对访问过的资源保存的副本文件。</p><p>浏览器缓存主要有以下几个优点：</p><ul><li>减少重复数据请求，避免通过网络再次加载资源，节省流量。</li><li>降低服务器的压力，提升网站性能。</li><li>加快客户端加载网页的速度， 提升用户体验。</li></ul><p>浏览器缓存分为强缓存和协商缓存，两者有两个比较明显的区别：</p><ul><li>如果浏览器命中强缓存，则不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，即客户端与服务器之间存在一次通信。</li><li>在 chrome 中强缓存（虽然没有发出真实的 http 请求）的请求状态码返回是 200 (from cache)；而协商缓存如果命中走缓存的话，请求的状态码是 304 (not modified)。 不同浏览器的策略不同，在 Fire Fox中，from cache 状态码是 304.</li></ul><h2 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h2><p>浏览器在第一次请求后缓存资源，再次请求时，会进行下面两个步骤：</p><ul><li>浏览器会获取该缓存资源的 header 中的信息，根据 response header 中的 expires 和 cache-control 来判断是否命中强缓存，如果命中则直接从缓存中获取资源。</li><li>如果没有命中强缓存，浏览器就会发送请求到服务器，这次请求会带上 IF-Modified-Since 或者 IF-None-Match, 它们的值分别是第一次请求返回 Last-Modified或者 Etag，由服务器来对比这一对字段来判断是否命中。如果命中，则服务器返回 304 状态码，并且不会返回资源内容，浏览器会直接从缓存获取；否则服务器最终会返回资源的实际内容，并更新 header 中的相关缓存字段。</li></ul><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>强缓存是根据返回头中的 Expires 或者 Cache-Control 两个字段来控制的，都是表示资源的缓存有效时间。</p><ul><li>Expires 是 http 1.0 的规范，值是一个GMT 格式的时间点字符串，比如 Expires:Mon,18 Oct 2066 23:59:59 GMT 。这个时间点代表资源失效的时间，如果当前的时间戳在这个时间之前，则判定命中缓存。有一个缺点是，失效时间是一个<strong>绝对时间</strong>，如果服务器时间与客户端时间偏差较大时，就会导致缓存混乱。而服务器的时间跟用户的实际时间是不一样是很正常的，所以 Expires 在实际使用中会带来一些麻烦。</li><li>Cache-Control这个字段是 http 1.1 的规范，一般常用该字段的 max-age 值来进行判断，它是一个<strong>相对时间</strong>，比如 .Cache-Control:max-age=3600 代表资源的有效期是 3600 秒。并且返回头中的 Date 表示消息发送的时间，表示当前资源在 Date ~ Date +3600s 这段时间里都是有效的。不过我在实际使用中常常遇到设置了 max-age 之后，在 max-age 时间内重新访问资源却会返回 304 not modified ，这是由于服务器的时间与本地的时间不同造成的。当然 Cache-Control 还有其他几个值可以设置， 不过相对来说都很少用了：<ul><li>no-cache 不使用本地缓存。需要使用协商缓存。</li><li>no-store直接禁止浏览器缓存数据，每次请求资源都会向服务器要完整的资源， 类似于 network 中的 disabled cache。</li><li>public 可以被所有用户缓存，包括终端用户和 cdn 等中间件代理服务器。</li><li>private 只能被终端用户的浏览器缓存。</li></ul></li></ul><p>如果 Cache-Control与 Expires 同时存在的话， Cache-Control 的优先级高于 Expires 。</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>协商缓存是由服务器来确定缓存资源是否可用。 主要涉及到两对属性字段，都是成对出现的，即第一次请求的响应头带上某个字, Last-Modified 或者 Etag，则后续请求则会带上对应的请求字段 If-Modified-Since或者 If-None-Match，若响应头没有 Last-Modified 或者 Etag 字段，则请求头也不会有对应的字段。</p><ul><li>Last-Modified/If-Modified-Since 二者的值都是 GMT 格式的时间字符串， Last-Modified 标记最后文件修改时间， 下一次请求时，请求头中会带上 If-Modified-Since 值就是 Last-Modified 告诉服务器我本地缓存的文件最后修改的时间，在服务器上根据文件的最后修改时间判断资源是否有变化， 如果文件没有变更则返回 304 Not Modified ，请求不会返回资源内容，浏览器直接使用本地缓存。当服务器返回 304 Not Modified 的响应时，response header 中不会再添加的 Last-Modified 去试图更新本地缓存的 Last-Modified， 因为既然资源没有变化，那么 Last-Modified 也就不会改变；如果资源有变化，就正常返回返回资源内容，新的 Last-Modified 会在 response header 返回，并在下次请求之前更新本地缓存的 Last-Modified，下次请求时，If-Modified-Since会启用更新后的 Last-Modified。</li><li>Etag/If-None-Match， 值都是由服务器为每一个资源生成的唯一标识串，只要资源有变化就这个值就会改变。服务器根据文件本身算出一个哈希值并通过 ETag字段返回给浏览器，接收到 If-None-Match 字段以后，服务器通过比较两者是否一致来判定文件内容是否被改变。与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于在服务器上ETag 重新计算过，response header中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。</li></ul><p>HTTP 中并没有指定如何生成 ETag，可以由开发者自行生成，哈希是比较理想的选择。</p><h1 id="ETag的出现，主要是为了解决-Last-Modified-无法解决的一些问题："><a href="#ETag的出现，主要是为了解决-Last-Modified-无法解决的一些问题：" class="headerlink" title="ETag的出现，主要是为了解决 Last-Modified 无法解决的一些问题："></a>ETag的出现，主要是为了解决 Last-Modified 无法解决的一些问题：</h1><ul><li>某些服务器不能精确得到文件的最后修改时间， 这样就无法通过最后修改时间来判断文件是否更新了。</li><li>某些文件的修改非常频繁，在秒以下的时间内进行修改. Last-Modified只能精确到秒。</li><li>一些文件的最后修改时间改变了，但是内容并未改变。 我们不希望客户端认为这个文件修改了</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里说的缓存是指浏览器（客户端）在本地磁盘中对访问过的资源保存的副本文件。&lt;/p&gt;
&lt;p&gt;浏览器缓存主要有以下几个优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少重复数据请求，避免通过网络再次加载资源，节省流量。&lt;/li&gt;
&lt;li&gt;降低服务器的压力，提升网站性能。&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="HTTP" scheme="https://coloey.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>浏览器垃圾回收机制</title>
    <link href="https://coloey.github.io/2022/05/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://coloey.github.io/2022/05/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2022-05-02T08:04:33.000Z</published>
    <updated>2022-05-02T08:29:52.291Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标记清理"><a href="#标记清理" class="headerlink" title="标记清理"></a>标记清理</h1><ul><li>变量进入上下文，会加上标记，证明其存在于该上下文</li><li>将所有在上下文中的变量以及上下文中被访问引用的变量标记去掉，表明这些变量活跃有用</li><li>在此之后再被加上标记的变量标记为准备删除的变量，原因是任何在上下文中的变量都访问不到它们</li><li>执行内存清理，销毁标记的所有非活跃值并回收之前被占用的内存</li></ul><h1 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h1><p>引用计数策略相对而言不常用，弊端较多，其思路对每个值记录它被引用的次数，通过最后对次数的判断（引用数为0）来决定是否保留，具体规则：</p><ul><li>声明一个变量，赋予它一个引用值，计数+1</li><li>同一值被赋予另外一个变量，引用+1</li><li>保存对该值引用的变量被其他值覆盖，引用+1</li><li>引用为0，回收内存</li></ul><p>局限：容易造成循环引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">problem</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a=<span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    <span class="keyword">let</span> b=<span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    a.c=b;</span><br><span class="line">    b.d=a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a和b通过各自的属性相互引用，意味着它们的引用数都为2，在函数结束后，这两个对象不再作用域内，在引用计数策略下，a和b在函数结束后还会存在，因为它们的引用数永远捕获变为0，如果函数被多次调用就会导致大量内存永远不会被释放。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;标记清理&quot;&gt;&lt;a href=&quot;#标记清理&quot; class=&quot;headerlink&quot; title=&quot;标记清理&quot;&gt;&lt;/a&gt;标记清理&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;变量进入上下文，会加上标记，证明其存在于该上下文&lt;/li&gt;
&lt;li&gt;将所有在上下文中的变量以及上下文中被访问引用</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>浏览器事件循环机制和Node中的事件循环机制</title>
    <link href="https://coloey.github.io/2022/05/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E5%92%8CNode%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
    <id>https://coloey.github.io/2022/05/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E5%92%8CNode%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/</id>
    <published>2022-05-02T03:58:28.000Z</published>
    <updated>2022-05-02T16:00:45.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器的事件循环机制："><a href="#浏览器的事件循环机制：" class="headerlink" title="浏览器的事件循环机制："></a>浏览器的事件循环机制：</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p><code>JavaScript</code> 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事</p><p>为什么要这么设计，跟<code>JavaScript</code>的应用场景有关</p><p><code>JavaScript</code> 初期作为一门浏览器脚本语言，通常用于操作 <code>DOM</code> ，如果是多线程，一个线程进行了删除 <code>DOM</code> ，另一个添加 <code>DOM</code>，此时浏览器该如何处理？</p><p>为了解决单线程运行阻塞问题，<code>JavaScript</code>用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop）</p><h3 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h3><p>在<code>JavaScript</code>中，所有的任务都可以分为</p><ul><li>同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行</li><li>异步任务：异步执行的任务，比如<code>ajax</code>网络请求，<code>setTimeout </code>定时函数等</li></ul><p><img src="/2022/05/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E5%92%8CNode%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/node1.png"></p><p>从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就是事件循环</p><h2 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h2><p>如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">console.log(1)</span><br><span class="line"></span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;new Promise&#x27;)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;then&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(3)</span><br></pre></td></tr></table></figure><p>如果按照上面流程图来分析代码，我们会得到下面的执行步骤：</p><ul><li><code>console.log(1) </code>，同步任务，主线程中执行</li><li><code>setTimeout()</code> ，异步任务，放到 <code>Event Table</code>，0 毫秒后<code>console.log(2) </code>回调推入 <code>Event Queue</code> 中</li><li><code>new Promise</code> ，同步任务，主线程直接执行</li><li><code>.then</code> ，异步任务，放到 <code>Event Table</code></li><li><code>console.log(3)</code>，同步任务，主线程执行</li></ul><p>所以按照分析，它的结果应该是 <code>1</code> =&gt; <code>&#39;new Promise&#39;</code> =&gt; <code>3</code> =&gt; <code>2</code> =&gt; <code>&#39;then&#39;</code></p><p>但是实际结果是：<code>1</code>=&gt;<code>&#39;new Promise&#39;</code>=&gt; <code>3</code> =&gt; <code>&#39;then&#39;</code> =&gt; <code>2</code></p><p>出现分歧的原因在于异步任务执行顺序，事件队列其实是一个“先进先出”的数据结构，排在前面的事件会优先被主线程读取</p><p>例子中 <code>setTimeout</code>回调事件是先进入队列中的，按理说应该先于 <code>.then</code> 中的执行，但是结果却偏偏相反</p><p>原因在于异步任务还可以细分为微任务与宏任务</p><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p>一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前</p><p>常见的微任务有：</p><ul><li>Promise.then</li><li>MutaionObserver</li><li>Object.observe（已废弃；Proxy 对象替代）</li><li>process.nextTick（Node.js）</li></ul><h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><p>宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合</p><p>常见的宏任务有：</p><ul><li>script (可以理解为外层同步代码)</li><li>setTimeout/setInterval</li><li>UI rendering/UI事件</li><li>postMessage、MessageChannel</li><li>setImmediate、I/O（Node.js）</li></ul><p>按照这个流程，它的执行机制是：</p><ul><li>执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中</li><li>当前宏任务执行完成后，会查看微任务的事件队列，<strong>然后将里面的所有微任务依次执行完</strong></li></ul><p>回到上面的题目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">console.log(1)</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;, 0)</span><br><span class="line">new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;new Promise&#x27;)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;then&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(3)</span><br></pre></td></tr></table></figure><p>流程如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 遇到 console.log(1) ，直接打印 1</span><br><span class="line">// 遇到定时器，属于新的宏任务，留着后面执行</span><br><span class="line">// 遇到 new Promise，这个是直接执行的，打印 &#x27;new Promise&#x27;</span><br><span class="line">// .then 属于微任务，放入微任务队列，后面再执行</span><br><span class="line">// 遇到 console.log(3) 直接打印 3</span><br><span class="line">// 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 &#x27;then&#x27;</span><br><span class="line">// 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 2</span><br></pre></td></tr></table></figure><h2 id="async与await"><a href="#async与await" class="headerlink" title="async与await"></a>async与await</h2><p><code>async</code> 是异步的意思，<code>await </code>则可以理解为等待</p><p>放到一起可以理解<code>async</code>就是用来声明一个异步方法，而 <code>await </code>是用来等待异步方法执行</p><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p><code>async</code>函数返回一个<code>promise</code>对象，下面两种方法是等效的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">    return Promise.resolve(&#x27;TEST&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// asyncF is equivalent to f!</span><br><span class="line">async function asyncF() &#123;</span><br><span class="line">    return &#x27;TEST&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>正常情况下，<code>await</code>命令后面是一个 <code>Promise </code>对象，返回该对象的结果。如果不是 <code>Promise </code>对象，就直接返回对应的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function f()&#123;</span><br><span class="line">    // 等同于</span><br><span class="line">    // return 123</span><br><span class="line">    return await 123</span><br><span class="line">&#125;</span><br><span class="line">f().then(v =&gt; console.log(v)) // 123</span><br></pre></td></tr></table></figure><p>不管<code>await</code>后面跟着的是什么，<code>await</code>都会阻塞后面的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function fn1 ()&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">    await fn2()</span><br><span class="line">    console.log(2) // 阻塞</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function fn2 ()&#123;</span><br><span class="line">    console.log(&#x27;fn2&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1()</span><br><span class="line">console.log(3)</span><br></pre></td></tr></table></figure><p>上面的例子中，<code>await</code> 会阻塞下面的代码（即加入微任务队列），先执行 <code>async </code>外面的同步代码，同步代码执行完，再回到 <code>async</code> 函数中，再执行之前阻塞的代码</p><p>所以上述输出结果为：<code>1</code>，<code>fn2</code>，<code>3</code>，<code>2</code></p><h1 id="Node中的事件循环机制"><a href="#Node中的事件循环机制" class="headerlink" title="Node中的事件循环机制"></a>Node中的事件循环机制</h1><p>事件循环分为6个阶段：</p><p><img src="/2022/05/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E5%92%8CNode%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/node2.png"></p><p>timers:执行timer的回调，即setTimeout,setInterval里面的回调函数</p><p>I/O事件回调阶段：执行延迟到下一个循环迭代的I/O阶段，即上一轮循环中未被执行的一些I/O回调</p><p>idle,prepare(闲置阶段):仅内部使用</p><p>poll(轮询阶段)：检查新的I/O事件，执行与I/O相关的回调，（几乎所有情况下，除了关闭的回调函数，那些由计时器和setImmediate（）调度的之外），其余情况node将在适当的时候在此阻塞</p><p>check(检查阶段)：setImmediate()回调函数在这里执行</p><p>close callback（关闭事件回调阶段）：一些关闭的回调函数，如socket.on(‘close’,…)</p><p>除了上述6个阶段，还存在process.nextTick,其不属于事件循环的任何一个阶段，<strong>它属于该阶段与下阶段之间的过渡，即本阶段执行结束，进入下一个阶段前要执行的回调，类似插队</strong></p><p><img src="/2022/05/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E5%92%8CNode%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/node3.png"></p><p>在Node中，同样存在宏任务和微任务，与浏览器的事件循环相似</p><p>微任务：</p><ul><li>next tick queue:process.nextTick</li><li>other queue:Promise的then回调，queueMicrotask</li></ul><p>宏任务：</p><ul><li>timer queue:setTimeout,setInterval</li><li>poll queue:IO事件</li><li>check queue:setImmediate</li><li>close queue:close事件</li></ul><p>执行顺序：</p><ul><li>next tick microtask queue</li><li>other microtask queue</li><li>timer queue</li><li>poll queue</li><li>check queue</li><li>close queue</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> async2()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout0&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout2&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;setImmediate&#x27;</span>));</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick1&#x27;</span>));</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick2&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    resolve();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise3&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>分析过程：</p><ul><li>先找到同步任务，输出script start</li><li>遇到第一个 setTimeout，将里面的回调函数放到 timer 队列中</li><li>遇到第二个 setTimeout，300ms后将里面的回调函数放到 timer 队列中</li><li>遇到第一个setImmediate，将里面的回调函数放到 check 队列中</li><li>遇到第一个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行</li><li>执行 async1函数，输出 async1 start</li><li>执行 async2 函数，输出 async2，async2 后面的输出 async1 end进入微任务，等待下一轮的事件循环</li><li>遇到第二个，将其里面的回调函数放到本轮同步任务执行完毕后执行</li><li>遇到 new Promise，执行里面的立即执行函数，输出 promise1、promise2</li><li>then里面的回调函数进入微任务队列</li><li>遇到同步任务，输出 script end</li><li>执行下一轮回到函数，先依次输出 nextTick 的函数，分别是 nextTick1、nextTick2</li><li>然后执行微任务队列，依次输出 async1 end、promise3</li><li>执行timer 队列，依次输出 setTimeout0</li><li>接着执行 check 队列，依次输出 setImmediate</li><li>300ms后，timer 队列存在任务，执行输出 setTimeout2</li></ul><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">script end</span><br><span class="line">nextTick1</span><br><span class="line">nextTick2</span><br><span class="line">async1 end</span><br><span class="line">promise3</span><br><span class="line">setTimeout0</span><br><span class="line">setImmediate</span><br><span class="line">setTimeout2</span><br></pre></td></tr></table></figure><p>最后有一道是关于<code>setTimeout</code>与<code>setImmediate</code>的输出顺序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setImmediate&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">情况一：</span><br><span class="line"><span class="built_in">setTimeout</span></span><br><span class="line">setImmediate</span><br><span class="line"></span><br><span class="line">情况二：</span><br><span class="line">setImmediate</span><br><span class="line"><span class="built_in">setTimeout</span></span><br></pre></td></tr></table></figure><p>分析下流程：</p><ul><li>外层同步代码一次性全部执行完，遇到异步API就塞到对应的阶段</li><li>遇到<code>setTimeout</code>，虽然设置的是0毫秒触发，但实际上会被强制改成1ms，时间到了然后塞入<code>times</code>阶段</li><li>遇到<code>setImmediate</code>塞入<code>check</code>阶段</li><li>同步代码执行完毕，进入Event Loop</li><li>先进入<code>times</code>阶段，检查当前时间过去了1毫秒没有，如果过了1毫秒，满足<code>setTimeout</code>条件，执行回调，如果没过1毫秒，跳过</li><li>跳过空的阶段，进入check阶段，执行<code>setImmediate</code>回调</li></ul><p>这里的关键在于这1ms，如果同步代码执行时间较长，进入<code>Event Loop</code>的时候1毫秒已经过了，<code>setTimeout</code>先执行，如果1毫秒还没到，就先执行了<code>setImmediate</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;浏览器的事件循环机制：&quot;&gt;&lt;a href=&quot;#浏览器的事件循环机制：&quot; class=&quot;headerlink&quot; title=&quot;浏览器的事件循环机制：&quot;&gt;&lt;/a&gt;浏览器的事件循环机制：&lt;/h1&gt;&lt;h2 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;he</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>箭头函数和普通函数区别</title>
    <link href="https://coloey.github.io/2022/05/02/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB/"/>
    <id>https://coloey.github.io/2022/05/02/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB/</id>
    <published>2022-05-02T03:21:43.000Z</published>
    <updated>2022-05-02T03:37:43.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="箭头函数和普通函数区别"><a href="#箭头函数和普通函数区别" class="headerlink" title="箭头函数和普通函数区别"></a>箭头函数和普通函数区别</h1><ol><li><p>语法更加简洁清晰</p></li><li><p>箭头函数不会创建自己的this</p></li></ol><p>所以它不会有自己的this,它只会从<strong>自己的作用域链的上一层继承this</strong>，作用域链包括全局作用域，块作用域和函数作用域</p><ol start="3"><li>箭头函数继承而来的this指向永远不变</li></ol><p>对象obj的方法b时用箭头函数定义的，这个函数中的this永远指向它<strong>定义时所处的全局环境中的this</strong>,即使这个函数是作为对象obj的方法调用，它依然指向window对象</p><ol start="4"><li>call()/apply()/bind()无法改变箭头函数中this得指向</li></ol><p>call()/apply()/bind()方法可以用来动态修改this的指向，但由于箭头函数的this定义时就已经确定且永远不会改变，所以使用这些犯法永远也改变不了箭头函数this的指向，但是代码也不会报错</p><ol start="5"><li>箭头函数不能用作构造函数调用</li></ol><p>构造函数的new原理：</p><p>箭头函数是ES6中的提出来的，<strong>它没有prototype，也没有自己的this指向，更不可以使用arguments参数</strong>，所以不能New一个箭头函数。</p><p>new操作符的实现步骤如下：</p><p>1、创建一个空的简单JavaScript对象（即{}）；</p><p>2、为步骤1新创建的对象添加属性__proto__，将该属性链接至构造函数的原型对象 ；</p><p>3、将步骤1新创建的对象作为this的上下文 ；</p><p>4、如果该函数没有返回对象，则返回this。</p><p>所以，上面的第二、三步，箭头函数都是没有办法执行的。</p><ol start="6"><li>箭头函数不能用作Generator函数，不能使用yield关键字</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;箭头函数和普通函数区别&quot;&gt;&lt;a href=&quot;#箭头函数和普通函数区别&quot; class=&quot;headerlink&quot; title=&quot;箭头函数和普通函数区别&quot;&gt;&lt;/a&gt;箭头函数和普通函数区别&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;语法更加简洁清晰&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>tree shaking</title>
    <link href="https://coloey.github.io/2022/05/01/tree-shaking/"/>
    <id>https://coloey.github.io/2022/05/01/tree-shaking/</id>
    <published>2022-05-01T14:15:55.000Z</published>
    <updated>2022-05-02T15:28:56.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tree-shaking如何工作的呢？"><a href="#tree-shaking如何工作的呢？" class="headerlink" title="tree shaking如何工作的呢？"></a>tree shaking如何工作的呢？</h1><p>虽然 tree shaking 的概念在 1990 就提出了，但直到 ES6 的 <code>ES6-style</code> 模块出现后才真正被利用起来。</p><p>在ES6以前，我们可以使用CommonJS引入模块：require()，这种引入是动态的，也意味着我们可以基于条件来导入需要的代码</p><p>但是CommonJS规范无法确定在实际运行前需要或者不需要某些模块，所以CommonJS不适合tree-shaking机制。在 ES6 中，引入了完全静态的导入语法：import。</p><p>因为tree shaking只能在静态modules下工作。ECMAScript 6 模块加载是静态的,因此整个依赖树可以被静态地推导出解析语法树。所以在 ES6 中使用 tree shaking 是非常容易的。</p><h1 id="tree-shaking的原理是什么"><a href="#tree-shaking的原理是什么" class="headerlink" title="tree shaking的原理是什么?"></a>tree shaking的原理是什么?</h1><ul><li>ES6 Module引入进行静态分析，故而编译的时候正确判断到底加载了哪些模块</li><li>静态分析程序流，判断哪些模块和变量未被使用或者引用，进而删除对应代码</li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="将文件标记为无副作用-side-effect-free"><a href="#将文件标记为无副作用-side-effect-free" class="headerlink" title="将文件标记为无副作用(side-effect-free)"></a>将文件标记为无副作用(side-effect-free)</h2><p>在一个纯粹的 ESM 模块世界中，识别出哪些文件有副作用很简单。然而，我们的项目无法达到这种纯度，所以，此时有必要向 webpack 的 compiler 提供提示哪些代码是“纯粹部分”。</p><p>这种方式是通过 package.json 的 <code>&quot;sideEffects&quot;</code> 属性来实现的。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;your-project&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;sideEffects&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如同上面提到的，如果所有代码都不包含副作用，我们就可以简单地将该属性标记为 <code>false</code>，来告知 webpack，它可以安全地删除未用到的 export 导出。</p><blockquote><p>「副作用」的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export。举例说明，例如 polyfill，它影响全局作用域，并且通常不提供 export。</p></blockquote><h2 id="压缩输出"><a href="#压缩输出" class="headerlink" title="压缩输出"></a>压缩输出</h2><p>通过如上方式，我们已经可以通过 <code>import</code> 和 <code>export</code> 语法，找出那些需要删除的“未使用代码(dead code)”，然而，我们不只是要找出，还需要在 bundle 中删除它们。为此，我们将使用 <code>-p</code>(production) 这个 webpack 编译标记，来启用 uglifyjs 压缩插件。</p><blockquote><p>注意，<code>--optimize-minimize</code> 标记也会在 webpack 内部调用 <code>UglifyJsPlugin</code>。</p></blockquote><p>从 webpack 4 开始，也可以通过 <code>&quot;mode&quot;</code> 配置选项轻松切换到压缩输出，只需设置为 <code>&quot;production&quot;</code>。</p><p><strong>webpack.config.js</strong></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#x27;./src/index.js&#x27;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;bundle.js&#x27;,</span><br><span class="line">    path: path.resolve(__dirname, &#x27;dist&#x27;)</span><br><span class="line"><span class="deletion">- &#125;</span></span><br><span class="line"><span class="addition">+ &#125;,</span></span><br><span class="line"><span class="addition">+ mode: &quot;production&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意，也可以在命令行接口中使用 <code>--optimize-minimize</code> 标记，来使用 <code>UglifyJSPlugin</code>。为了学会使用 <em>tree shaking</em>，你必须……</p></blockquote><ul><li>使用 ES2015 模块语法（即 <code>import</code> 和 <code>export</code>）。</li><li>在项目 <code>package.json</code> 文件中，添加一个 “sideEffects” 入口。</li><li>引入一个能够删除未引用代码(dead code)的压缩工具(minifier)（例如 <code>UglifyJSPlugin</code>）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tree-shaking如何工作的呢？&quot;&gt;&lt;a href=&quot;#tree-shaking如何工作的呢？&quot; class=&quot;headerlink&quot; title=&quot;tree shaking如何工作的呢？&quot;&gt;&lt;/a&gt;tree shaking如何工作的呢？&lt;/h1&gt;&lt;p&gt;虽然</summary>
      
    
    
    
    <category term="前端工程化" scheme="https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    <category term="webpack" scheme="https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack/"/>
    
    
  </entry>
  
  <entry>
    <title>HMR</title>
    <link href="https://coloey.github.io/2022/05/01/HMR/"/>
    <id>https://coloey.github.io/2022/05/01/HMR/</id>
    <published>2022-05-01T09:42:46.000Z</published>
    <updated>2022-05-02T15:44:58.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>HMR 全称是Hot Module Replacement,理解为模块热替换，指在应用程序运行过程中，替换，添加，删除模块，而无需重新刷新整个应用。</p><p>例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失，如果使用HME，就可以实现只将修改的模块实时替换至应用中，不必完全舒心整个应用。</p><p>在webpack中配置热模块：</p><p>webpack.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack=<span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">devServer</span>:&#123;</span><br><span class="line">        <span class="attr">hot</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述这种配置，如果我们修改并保存CSS文件，确实能够以不刷新地形式更新到页面中，但是，当我们修改并保存js文件之后，页面依旧舒刷新了，这里并没有触发热模块，所以，HMR并不像Webpack的其他特性一样可以开箱即用，需要取指定那些模块发生更新时进行HMR</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">module</span>.hot)&#123;</span><br><span class="line">    <span class="built_in">module</span>.hot.accept(<span class="string">&#x27;./util.js&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;utils.js更新了&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p><img src="/2022/05/01/HMR/1-16514062164851.png"></p><ul><li>Webpack Compile:将JS源代码编译成bundle.js</li><li>HMR Server:用来将热更新的文件输出给HMR Runtime</li><li>Bundle Server:静态资源文件服务器，提供文件访问路径</li><li>HMR Runtime:socket服务器，会被注入到浏览器，更新文件的变化</li><li>bundle.js:构建输出的文件</li><li>在HMR Runtime和HMR Server之间建立websocket，即图上4号线，用于实时更新文件变化</li></ul><p>分成两个阶段：</p><p>启动阶段为1-2-A-B</p><p>在编写未经过webpack打包的源码后，Webpack Compile将源码和HMR Runtime一起编译成bundle文件，传输Bundle Server静态资源服务器</p><p>更新阶段为1-2-3-4</p><p>当某一个文件或者模块发生变化时，webpack监听到文件变化对文件重新编译打包，编译生成唯一的hash值，这个hash值用来作为下一次热更新的标识，根据变化的内容生成两个补丁文件:manifest(包含了hash和chunkId,用来说明变化的内容)和chunk.js模块，由于socket服务器在HMR Runtime和HMR Server之间建立websocket链接，单文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的hash值，如下图的h属性，做为下一次热更新的标识</p><p><img src="/2022/05/01/HMR/2-16514082193272.png"></p><p>在浏览器接收到这条消息之前，浏览器已经在上一次socket消息中记住了此时的hash标识，这时候我们会<strong>创建一个ajax去服务端请求获取到变化内容的manifest文件</strong></p><p>manifest文件包含重新build生成的hash值，以及变化的模块，对应上图的c属性,<strong>浏览器根据manifest文件获取模块变化的内容，从而触发render流程，实现局部模块更新</strong></p><p><img src="/2022/05/01/HMR/3-16514086996663.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于webpack热模块更新总结：</p><ul><li>通过webpack-dev-server创建两个服务器，提供静态资源的服务(express)和Socket服务</li><li>express server负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）</li><li>socket server是一个websocket的长连接，双方可以通信</li><li>当socket server监听到对应的模块发生变化时，会生成两个文件.json(manifest文件)和.js文件(update chunk)</li><li>通过长连接，socket server可以直接将这两个文件主动发送给客户端（浏览器）</li><li>浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h1&gt;&lt;p&gt;HMR 全称是Hot Module Replacement,理解为模块热替换，指在应用程序运行过程中，替换，添加，删除模块，而无需重</summary>
      
    
    
    
    <category term="前端工程化" scheme="https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    <category term="webpack" scheme="https://coloey.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack/"/>
    
    
  </entry>
  
  <entry>
    <title>手写object.freeze</title>
    <link href="https://coloey.github.io/2022/04/30/%E6%89%8B%E5%86%99object-freeze/"/>
    <id>https://coloey.github.io/2022/04/30/%E6%89%8B%E5%86%99object-freeze/</id>
    <published>2022-04-30T14:04:32.000Z</published>
    <updated>2022-04-30T14:12:45.297Z</updated>
    
    <content type="html"><![CDATA[<p>object.freeze()=不可扩展（preventExtensions)+不可配置(configurable:false)+不可写(writable:fasle)</p><p>object.seal()=不可扩展+不可配置</p><p>preventExtensions=不可添加属性+不可改__proto__</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _objectFreeze = <span class="function"><span class="params">object</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 补全代码</span></span><br><span class="line">                <span class="comment">//Object.defineProperty(object,)</span></span><br><span class="line">                <span class="keyword">const</span> props=<span class="built_in">Object</span>.getOwnPropertyNames(object);</span><br><span class="line">                props.forEach(<span class="function"><span class="params">prop</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">const</span> des=<span class="built_in">Object</span>.getOwnPropertyDescriptor(object,prop);</span><br><span class="line">                    <span class="keyword">if</span>(des.get||des.set)&#123;</span><br><span class="line">                        <span class="built_in">Object</span>.defineProperty(object,prop,&#123;</span><br><span class="line">                            <span class="attr">configurable</span>:<span class="literal">false</span>,<span class="comment">//小写</span></span><br><span class="line">                            <span class="attr">writable</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">get</span>:des.get,</span><br><span class="line">                            <span class="attr">set</span>:des.set</span><br><span class="line">                        </span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="built_in">Object</span>.defineProperty(object,prop,&#123;</span><br><span class="line">                           <span class="attr">configurable</span>:<span class="literal">false</span>,</span><br><span class="line">                           <span class="attr">writable</span>:<span class="literal">false</span>,</span><br><span class="line">                        </span><br><span class="line">                        &#125;)</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                            </span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Object</span>.preventExtensions(object);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>数据属性的值不可更改，<strong>访问器属性（有getter和setter）也同样（但由于是函数调用，</strong>给人的错觉是还是可以修改这个属性）。如果一个属性的值是个对象，则这个对象中的属性是可以修改的，除非它也是个冻结对象。数组作为一种对象，被冻结，其元素不能被修改。没有数组元素可以被添加或移除。</p><p>这个方法<strong>返回传递的对象</strong>，而不是创建一个被冻结的副本。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;object.freeze()=不可扩展（preventExtensions)+不可配置(configurable:false)+不可写(writable:fasle)&lt;/p&gt;
&lt;p&gt;object.seal()=不可扩展+不可配置&lt;/p&gt;
&lt;p&gt;preventExtensi</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>常见正则表达式</title>
    <link href="https://coloey.github.io/2022/04/30/%E5%B8%B8%E8%A7%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://coloey.github.io/2022/04/30/%E5%B8%B8%E8%A7%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-04-30T07:23:53.000Z</published>
    <updated>2022-04-30T08:32:15.128Z</updated>
    
    <content type="html"><![CDATA[<p>匹配邮箱：</p><p>{username@hostname.com|edu|info)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^[A-Za-z0-<span class="number">9</span>]+([-.][A-Za-z0-<span class="number">9</span>]+)*@[A-Za-z0-<span class="number">9</span>]+(\.[A-Za-z0-<span class="number">9</span>]+)*\.[A-Za-z]&#123;<span class="number">2</span>,<span class="number">6</span>&#125;$/</span><br></pre></td></tr></table></figure><p>用户名可以包含点号和连字符，但是用户名以字符开头因此用/\w+[-.\w+]*,但是\w会匹配ASCII字母和数字，但有些系统中\w能够匹配非ASCII字母，，因此将\w换成[-A-Za-z0-9],结尾的域名一般在2-6个字符</p><p>匹配URL</p><p>比如匹配http或者https开头的url</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^((http|https)):\/\/)?[-A-Za-z0-<span class="number">9</span>]+(\.[A-Za-z0-<span class="number">9</span>]+)*\.[A-Za-z]&#123;<span class="number">2</span>,<span class="number">6</span>&#125;[a-zA-Z0-9_:\@&amp;?=+,.!~%*\$]*(?&lt;![.,?!])$/</span><br></pre></td></tr></table></figure><p>主机名仍然为[A-Za-z0-9]+(.[A-Za-z0-9]+)*.[A-Za-z]{2,6}，路径名[a-zA-Z0-9_:@&amp;?=+,.!~%*$]*可有可无，结尾不能是./?!这些符号</p><p>或者</p><p>根据题目要求判断参数URL是否合法。首先URL结构一般包括协议、主机名、主机端口、路径、请求信息、哈希，而本题协议已给出为HTTP(S)，使用正则匹配URL，核心步骤有：</p><ol><li>首先必须是以http(s)开头并且可以不包含协议头部信息</li><li>主机名可以使用”-“符号，所以两种情况都要判断，包含”-“或不包含”-“</li><li>顶级域名很多，直接判断”.”之后是否为字母即可</li><li>最后判断端口、路径和哈希，这些参数可有可无</li></ol><p><strong>参考答案</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _isUrl = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^((http|https):\/\/)?(([A-Za-z0-9]+-[A-Za-z0-9]+|[A-Za-z0-9]+)\.)+([A-Za-z]+)(:\d+)?(\/.*)?(\?.*)?(#.*)?$/</span>.test(url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>匹配手机号</p><p>手机号一般是1开头，第二位只能是3-9，最多9个数字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^<span class="number">1</span>[<span class="number">3</span>-<span class="number">9</span>]\d&#123;<span class="number">9</span>&#125;$&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;匹配邮箱：&lt;/p&gt;
&lt;p&gt;{username@hostname.com|edu|info)&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s</summary>
      
    
    
    
    <category term="正则表达式" scheme="https://coloey.github.io/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>DOM事件</title>
    <link href="https://coloey.github.io/2022/04/29/DOM%E4%BA%8B%E4%BB%B6/"/>
    <id>https://coloey.github.io/2022/04/29/DOM%E4%BA%8B%E4%BB%B6/</id>
    <published>2022-04-29T15:07:41.000Z</published>
    <updated>2022-05-02T15:47:58.141Z</updated>
    
    <content type="html"><![CDATA[<p>Dom事件流</p><p>DOM2事件流分为3个阶段：事件捕获，到达目标和事件冒泡，事件捕获最先发生，为提前拦截事件提供了可能，然后，实际的目标元素接收到事件后，最后一个阶段是冒泡，最迟要在这个阶段响应事件。</p><p>实际目标（div元素）在补货阶段不会接收到事件，这是因为捕获阶段从document到html到body就结束，下一个阶段，即会在div元素上触发事件的‘到达目标阶段，通常在事处理中被认为是事件冒泡的第一部分，然后，冒泡阶段开始，事件反转传播到文档</p><p><img src="/2022/04/29/DOM%E4%BA%8B%E4%BB%B6/dom1.png"></p><p>事件处理程序</p><p>HTML事件处理程序:</p><p>这种交互能力是通过为onclick属性指定JavaScript代码值实现。</p><p>showMessage()函数时单独在script元素中定义，也可以在外部文件定义，作为事件处理程序的代码可以访问全局作用域中的一切</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showMessage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;button&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;Click me&#x27;</span> <span class="attr">onclick</span>=<span class="string">&quot;showMessage()&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure><p>DOM0事件处理程序</p><p>每个元素（包括window和document）都有通常小写的事件处理程序属性，比如onclick,只要把这个属性赋值为一个函数即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>);</span><br><span class="line">btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id)<span class="comment">//myBtn</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所赋函数被视为元素的方法，因此，事件处理程序会在元素的作用域中运行，即this等于元素</strong>以这种方式添加事件处理程序时注册在事件流的冒泡阶段</p><p>通过将事件处理程序属性的值设置为null，可以移除通过Dom0添加的事件处理程序</p><p>DOM2事件处理程序</p><p>DOM2 Events为事件处理程序的赋值和移除定义了两个方法：addEventListener()和removeEventListener(),它们接收3个参数：事件名，事件处理函数和一个布尔值，true表示在捕获阶段调用事件处理程序，false(默认值)表示在冒泡阶段调用事件处理程序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>)</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>使用DOM2的主要优势是<strong>可以为同一个事件添加多个事件处理程序</strong></p><p>通过addEventListener()添加的事件处理程序通过removeEventListener()移除要传入与添加时同样的参数，因此无法使用addEventListener()添加的匿名函数移除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>)</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line">btn.removeEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id)</span><br><span class="line">&#125;,<span class="literal">false</span>)<span class="comment">//没有效果</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> handler=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>)</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,handler,<span class="literal">false</span>);</span><br><span class="line">btn.removeEventListener(<span class="string">&#x27;click&#x27;</span>,handler,<span class="literal">false</span>)<span class="comment">//有效果</span></span><br></pre></td></tr></table></figure><p>事件对象</p><p>DOM事件对象</p><p>event对象时传给事件处理程序唯一参数</p><p><img src="/2022/04/29/DOM%E4%BA%8B%E4%BB%B6/dom2.png" alt="2"></p><p><img src="/2022/04/29/DOM%E4%BA%8B%E4%BB%B6/dom3.png"></p><p>在事件处理程序内部，this对象始终等于currentTarget的值，而target只包含事件的实际目标，如果事件处理程序直接添加在了意图目标，则this,currentTarget,target的值一样</p><p>如果添加在父结点上，则不一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.currentTarget===<span class="built_in">document</span>.body);<span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>===<span class="built_in">document</span>.body)<span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.target===<span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>))<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>this和currentTarget等于document.body:它是注册事件处理程序的元素</li><li>target属性等于按钮本身：按钮时click的真正目标</li><li>由于按钮本身没有注册事件处理程序，因此click事件冒泡到document.body，触发了在它上面注册的处理程序</li></ol><p>type属性可以处理多个事件</p><p>preventDefault()方法用于阻止特定事件的默认动作，比如链接的默认行为是在被单击时导航到href属性指定的URL，阻止这个导航可以在onclick事件处理程序中取消，通过preventDefault()取消默认行为，事件对象的cancleable属性被设为true</p><p>stopPropagation()方法用于立即阻止事件流在DOM结构中传播，取消后序事件的捕获或冒泡。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>)</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id)</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">document</span>.body.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;body click&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于click事件不会传播到document.body，因此onclick事件处理程序永远不会执行</p><p>eventPhase用于确定事件流所处阶段，如果事件处理程序在捕获阶段被调用，则eventphase等于1，到达目标阶段为2，冒泡阶段为3</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">&#x27;myBtn&#x27;</span>)</span><br><span class="line">btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.eventPhase);<span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.eventPhase);<span class="comment">//1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">document</span>.body.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.eventPhase);<span class="comment">//3</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Dom事件流&lt;/p&gt;
&lt;p&gt;DOM2事件流分为3个阶段：事件捕获，到达目标和事件冒泡，事件捕获最先发生，为提前拦截事件提供了可能，然后，实际的目标元素接收到事件后，最后一个阶段是冒泡，最迟要在这个阶段响应事件。&lt;/p&gt;
&lt;p&gt;实际目标（div元素）在补货阶段不会接收到事件，</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>深拷贝与浅拷贝</title>
    <link href="https://coloey.github.io/2022/04/29/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://coloey.github.io/2022/04/29/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2022-04-29T10:16:43.000Z</published>
    <updated>2022-05-01T03:01:24.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据类型存储"><a href="#一、数据类型存储" class="headerlink" title="一、数据类型存储"></a>一、数据类型存储</h2><p>前面文章我们讲到，<code>JavaScript</code>中存在两大数据类型：</p><ul><li>基本类型</li><li>引用类型</li></ul><p>基本类型数据保存在在栈内存中</p><p>引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中</p><h2 id="二、浅拷贝"><a href="#二、浅拷贝" class="headerlink" title="二、浅拷贝"></a>二、浅拷贝</h2><p>浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝</p><p>如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址</p><p>即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址</p><p>下面简单实现一个浅拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newObj=&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.hasOwnProperty(prop))&#123;</span><br><span class="line">            newObj.prop=obj.prop;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>JavaScript</code>中，存在浅拷贝的现象有：</p><ul><li><code>Object.assign</code></li><li><code>Array.prototype.slice()</code>, <code>Array.prototype.concat()</code></li><li>使用拓展运算符实现的复制</li></ul><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">nature</span>: [<span class="string">&#x27;smart&#x27;</span>, <span class="string">&#x27;good&#x27;</span>],</span><br><span class="line">    <span class="attr">names</span>: &#123;</span><br><span class="line">        <span class="attr">name1</span>: <span class="string">&#x27;fx&#x27;</span>,</span><br><span class="line">        <span class="attr">name2</span>: <span class="string">&#x27;xka&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">love</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;fx is a great girl&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">Object</span>.assign(&#123;&#125;, fxObj);</span><br></pre></td></tr></table></figure><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fxArr = [<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>]</span><br><span class="line"><span class="keyword">const</span> fxArrs = fxArr.slice(<span class="number">0</span>)</span><br><span class="line">fxArrs[<span class="number">1</span>] = <span class="string">&quot;love&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(fxArr) <span class="comment">// [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(fxArrs) <span class="comment">// [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fxArr = [<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>]</span><br><span class="line"><span class="keyword">const</span> fxArrs = fxArr.concat()</span><br><span class="line">fxArrs[<span class="number">1</span>] = <span class="string">&quot;love&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(fxArr) <span class="comment">// [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(fxArrs) <span class="comment">// [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="拓展运算符"><a href="#拓展运算符" class="headerlink" title="拓展运算符"></a>拓展运算符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fxArr = [<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>]</span><br><span class="line"><span class="keyword">const</span> fxArrs = [...fxArr]</span><br><span class="line">fxArrs[<span class="number">1</span>] = <span class="string">&quot;love&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(fxArr) <span class="comment">// [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(fxArrs) <span class="comment">// [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]</span></span><br></pre></td></tr></table></figure><h2 id="三、深拷贝"><a href="#三、深拷贝" class="headerlink" title="三、深拷贝"></a>三、深拷贝</h2><p>深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性</p><p>常见的深拷贝方式有：</p><ul><li>_.cloneDeep()</li><li>jQuery.extend()</li><li>JSON.stringify()</li><li>手写循环递归</li></ul><h3 id="cloneDeep"><a href="#cloneDeep" class="headerlink" title="_.cloneDeep()"></a>_.cloneDeep()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">    <span class="attr">c</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = _.cloneDeep(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.b.f === obj2.b.f);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="jQuery-extend"><a href="#jQuery-extend" class="headerlink" title="jQuery.extend()"></a>jQuery.extend()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $ = <span class="built_in">require</span>(<span class="string">&#x27;jquery&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">    <span class="attr">c</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = $.extend(<span class="literal">true</span>, &#123;&#125;, obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.b.f === obj2.b.f); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2=<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1));</span><br></pre></td></tr></table></figure><p>但是这种方式存在弊端，会忽略<code>undefined</code>、<code>symbol</code>和<code>函数</code>,而且无法深拷贝循环引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">    <span class="attr">name1</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">name3</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="attr">name4</span>:  <span class="built_in">Symbol</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;name: &quot;A&quot;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="循环递归"><a href="#循环递归" class="headerlink" title="循环递归"></a>循环递归</h3><p>这里用WeakMap原因：WeakMap的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p><p>关于WeakMap看</p><p>[]: <a href="https://www.bookstack.cn/read/es6-3rd/spilt.4.docs-set-map.md">https://www.bookstack.cn/read/es6-3rd/spilt.4.docs-set-map.md</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cloneDeep1 = <span class="function">(<span class="params">target, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 对于传入参数处理</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">&#x27;object&#x27;</span> || target === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 哈希表中存在直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (hash.has(target)) <span class="keyword">return</span> hash.get(target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">  hash.set(target, cloneTarget);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 针对Symbol属性</span></span><br><span class="line">  <span class="keyword">const</span> symKeys = <span class="built_in">Object</span>.getOwnPropertySymbols(target);</span><br><span class="line">  <span class="keyword">if</span> (symKeys.length) &#123;</span><br><span class="line">    symKeys.forEach(<span class="function"><span class="params">symKey</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> target[symKey] === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target[symKey] !== <span class="literal">null</span>) &#123;</span><br><span class="line">        cloneTarget[symKey] = cloneDeep1(target[symKey]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cloneTarget[symKey] = target[symKey];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(target, i)) &#123;</span><br><span class="line">      cloneTarget[i] =</span><br><span class="line">        <span class="keyword">typeof</span> target[i] === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target[i] !== <span class="literal">null</span></span><br><span class="line">        ? cloneDeep1(target[i], hash)</span><br><span class="line">        : target[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>前提为拷贝类型为引用类型的情况下：</p><ul><li>浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址</li><li>深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、数据类型存储&quot;&gt;&lt;a href=&quot;#一、数据类型存储&quot; class=&quot;headerlink&quot; title=&quot;一、数据类型存储&quot;&gt;&lt;/a&gt;一、数据类型存储&lt;/h2&gt;&lt;p&gt;前面文章我们讲到，&lt;code&gt;JavaScript&lt;/code&gt;中存在两大数据类型：&lt;/p&gt;</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>line-height原理</title>
    <link href="https://coloey.github.io/2022/04/29/line-height%E5%8E%9F%E7%90%86/"/>
    <id>https://coloey.github.io/2022/04/29/line-height%E5%8E%9F%E7%90%86/</id>
    <published>2022-04-29T06:06:50.000Z</published>
    <updated>2022-05-02T15:51:52.431Z</updated>
    
    <content type="html"><![CDATA[<p>一、line-height是什么<br>line-height 属性设置行间的距离（行高），说的直白一点，就是设置两段段文本之间的距离如果我们把一段文本的line-height设置为父容器的高度就可以实现文本垂直居中了。</p><p>二、分析其原理<br>首先来看个图</p><p><img src="/2022/04/29/line-height%E5%8E%9F%E7%90%86/l1.png"></p><p>如图，每一行文字，可看成由上间距、文本内容、下间距构成，根据行高的标准定义，行高等于两条基线之间的距离，即第一行的3-4+上下间距+第二行的1-2+2-3，因为css中每一行的上间距和下间距肯定是相等的，所以代换一下，行高就等于它本身的上间距+下间距+文本高度。因此，我们也可以把行高记为，行高就是一行的高度，这一行的高度中包含了上下两个间距和文本内容本身。而文本内容在每一行中都是居中的，所以利用这个原理，就可以实现垂直居中。</p><p>看个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">line-height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css"><span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">哈哈哈</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/04/29/line-height%E5%8E%9F%E7%90%86/l2.png"></p><p>如上图所示。本例子中，我们设置div的高度为200px，然后里面有一行文本，我们设置了行高为200px，设置完200px后，文字本身16px不会改变，变的是它的上间距和下间距。正如上图所描述的那样。我想到这，你就应该明白了line-height为什么可以使其垂直居中了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、line-height是什么&lt;br&gt;line-height 属性设置行间的距离（行高），说的直白一点，就是设置两段段文本之间的距离如果我们把一段文本的line-height设置为父容器的高度就可以实现文本垂直居中了。&lt;/p&gt;
&lt;p&gt;二、分析其原理&lt;br&gt;首先来看个图&lt;/</summary>
      
    
    
    
    <category term="CSS" scheme="https://coloey.github.io/categories/CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>解决canvas中获取跨域图片数据问题</title>
    <link href="https://coloey.github.io/2022/04/28/%E8%A7%A3%E5%86%B3canvas%E4%B8%AD%E8%8E%B7%E5%8F%96%E8%B7%A8%E5%9F%9F%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/"/>
    <id>https://coloey.github.io/2022/04/28/%E8%A7%A3%E5%86%B3canvas%E4%B8%AD%E8%8E%B7%E5%8F%96%E8%B7%A8%E5%9F%9F%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-27T16:02:36.000Z</published>
    <updated>2022-04-28T08:15:03.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么-canvas-认为跨域图片数据为-污染的数据"><a href="#为什么-canvas-认为跨域图片数据为-污染的数据" class="headerlink" title="为什么 canvas 认为跨域图片数据为 污染的数据"></a>为什么 canvas 认为跨域图片数据为 污染的数据</h2><p>当请求跨域图片数据，而未满足跨域请求资源的条件时。如果canvas使用未经跨域允许的图片的原始数据，这些是不可信的数据，可能会暴露页面的数据。</p><h2 id="请求图片资源-同域"><a href="#请求图片资源-同域" class="headerlink" title="请求图片资源 - 同域"></a>请求图片资源 - 同域</h2><p>Request Headers带有cookie。图片数据是被canvas信任的。</p><h2 id="请求图片资源-跨域"><a href="#请求图片资源-跨域" class="headerlink" title="请求图片资源 - 跨域"></a>请求图片资源 - 跨域</h2><p>默认情况下，直接请求跨域图片。因为不符合跨域请求资源的条件，图片数据是不被canvas信任的。</p><p>为了解决图片跨域资源共享的问题， <img> 元素提供了支持的属性：crossOrigin，该属性一共有两个值可选：anonymous 和 use-credentials，下面列举了两者的使用场景，以及满足的条件。</p><p>(anonymous:匿名的)</p><table><thead><tr><th></th><th>anonymous</th><th>use-credentials</th></tr></thead><tbody><tr><td>用途</td><td>匿名请求跨域图片资源，不会发送证书（比如cookie等）</td><td>具名请求跨域图片资源，会携带证书数据</td></tr><tr><td>Request Headers</td><td>origin</td><td>origin、cookie</td></tr><tr><td>Response headers</td><td>Access-Control-Allow-Origin</td><td>Access-Control-Allow-Origin、Access-Control-Allow-Credentials</td></tr><tr><td>所需条件</td><td>Access-Control-Allow-Origin 字段值需要包含请求域。</td><td>Access-Control-Allow-Origin 字段值需要包含请求域，且不能为通配符 *。Access-Control-Allow-Credentials 字段值需要为 true，表明允许请求发送证书数据。</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas=<span class="built_in">document</span>.createElement(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> context=canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> img=<span class="keyword">new</span> Image();</span><br><span class="line">img.crossOrigin=<span class="string">&#x27;anonymous&#x27;</span>;</span><br><span class="line">img.onload=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    context.drawImage(<span class="built_in">this</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    context.getImageData(<span class="number">0</span>,<span class="number">0</span>,img.width,img.height);</span><br><span class="line">&#125;</span><br><span class="line">img.src=<span class="string">&quot;https://b.com/a.png&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么-canvas-认为跨域图片数据为-污染的数据&quot;&gt;&lt;a href=&quot;#为什么-canvas-认为跨域图片数据为-污染的数据&quot; class=&quot;headerlink&quot; title=&quot;为什么 canvas 认为跨域图片数据为 污染的数据&quot;&gt;&lt;/a&gt;为什么 canv</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>图片懒加载</title>
    <link href="https://coloey.github.io/2022/04/25/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <id>https://coloey.github.io/2022/04/25/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/</id>
    <published>2022-04-25T09:07:16.000Z</published>
    <updated>2022-04-27T15:41:55.061Z</updated>
    
    <content type="html"><![CDATA[<p>实现图片懒加载</p><p>懒加载是一种网页性能优化方式，提升用户体验，比如懒加载图片，进入页面时，我们只请求可视区域的图片资源</p><p>总结：</p><p>全部加载会影响用户体验</p><p>浪费用户的流量，有些用户不想全部看完，全部加载会耗费大量流量</p><p>实现方式：</p><p>html实现</p><p>最简单的实现方式给img标签加上 loading=”lazy”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;./example.jpg&quot;</span> loading=<span class="string">&quot;lazy&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>js实现原理</p><ul><li>通过js监听页面的滚动</li><li>使用js实现的原理主要是判断当前图片是否到了可视区域：</li><li>拿到所有图片的dom</li><li>遍历每个图片判断当前图片是否到达了可视区域范围</li><li>如果到了就设置图片的src属性</li><li>绑定window的scroll事件，对其进行事件监听</li></ul><p>在页面初始化时，img图片的src放在data-src属性上，当匀速处于可视区范围，就把data-src赋值给src属性，完成图片加载</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Lazyload<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin-bottom</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/default.png&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./img/1.jpg&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/default.png&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./img/2.jpg&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/default.png&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./img/3.jpg&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/default.png&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./img/4.jpg&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/default.png&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./img/5.jpg&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/default.png&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./img/6.jpg&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/default.png&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./img/7.jpg&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/default.png&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./img/8.jpg&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/default.png&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./img/9.jpg&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/default.png&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./img/10.jpg&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>先获取所有图片的dom,通过document.body.clientHeight获取可视区高度，<strong>在使用element.getBoundingClientRect()直接得到元素相对浏览器的top值</strong>，遍历每个图片判断图片是否到达了可视区域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyLoad</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> viewHeight=<span class="built_in">document</span>.body.clientHeight;<span class="comment">//获取可视区高度</span></span><br><span class="line">    <span class="keyword">let</span> imgs=<span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;img[data-src]&quot;</span>)</span><br><span class="line">    imgs.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(item.data-src==<span class="string">&#x27;&#x27;</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">let</span> rect=item.getBoundingClientRect();</span><br><span class="line">        <span class="keyword">if</span>(rect.top&lt;viewHeight&amp;&amp;rect.bottom&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            item.src=item.data-src</span><br><span class="line">            item.removeAttribute(<span class="string">&#x27;data-src&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样存在性能问题，因为scroll事件会在很短事件内触发多次，严重影响页面性能，为了提高网页性能，我们需要一个节流函数来控制函数的多次触发，在一段时间内只执行一次回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">fn,...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> context=<span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">if</span>(!temer)&#123;</span><br><span class="line">            timer=<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                fn.apply(context,args);</span><br><span class="line">                timer=<span class="literal">null</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scroll</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;scroll&quot;</span>,throttle(lazyload,<span class="number">200</span>))</span><br></pre></td></tr></table></figure><h2 id="拓展：-IntersectionObserver"><a href="#拓展：-IntersectionObserver" class="headerlink" title="拓展： IntersectionObserver"></a>拓展： IntersectionObserver</h2><p>通过上面例子的实现，我们要实现懒加载都需要去监听 scroll 事件，尽管我们可以通过函数节流的方式来阻止高频率的执行函数，但是我们还是需要去计算 scrollTop，offsetHeight 等属性，有没有简单的不需要计算这些属性的方式呢，答案就是 <code>IntersectionObserver</code>。</p><p><code>IntersectionObserver</code> 是一个比较新的 API，可以自动”观察”元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。我们来看一下它的用法</p><p>[]: <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver">https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> imgs=<span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;img[data-src]&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> config=&#123;</span><br><span class="line">    <span class="attr">rootMargin</span>:<span class="string">&#x27;0px&#x27;</span>,</span><br><span class="line">    <span class="attr">threshold</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> observer=<span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries,self</span>)=&gt;</span>&#123;</span><br><span class="line">    entries.forEach(<span class="function">(<span class="params">entry</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(entry.isIntersecting)&#123;</span><br><span class="line">            <span class="keyword">let</span> img=entry.target;</span><br><span class="line">            <span class="keyword">let</span> realsrc=img.dataset.src;</span><br><span class="line">            <span class="keyword">if</span>(src)&#123;</span><br><span class="line">                img.src=realsrc;</span><br><span class="line">                img.removeAttribute(<span class="string">&#x27;data-src&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            self.unobserve(entry.target);<span class="comment">//解除观察</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,config)</span><br><span class="line">imgs.forEach(<span class="function">(<span class="params">image</span>)=&gt;</span>&#123;</span><br><span class="line">    observer.observe(image)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;实现图片懒加载&lt;/p&gt;
&lt;p&gt;懒加载是一种网页性能优化方式，提升用户体验，比如懒加载图片，进入页面时，我们只请求可视区域的图片资源&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;全部加载会影响用户体验&lt;/p&gt;
&lt;p&gt;浪费用户的流量，有些用户不想全部看完，全部加载会耗费大量流量&lt;/p&gt;</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>object.create()和new区别</title>
    <link href="https://coloey.github.io/2022/04/25/object-create-%E5%92%8Cnew%E5%8C%BA%E5%88%AB/"/>
    <id>https://coloey.github.io/2022/04/25/object-create-%E5%92%8Cnew%E5%8C%BA%E5%88%AB/</id>
    <published>2022-04-25T02:44:18.000Z</published>
    <updated>2022-05-01T01:54:53.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.creat=<span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> F=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">F.prototype=o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部定义一个新对象，并且让F.prototype对象赋值为引进的对象/函数o,并return一个新的对象</p><h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">o,...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o1=&#123;&#125;;</span><br><span class="line">    o1.__proto__=o.prototype;</span><br><span class="line">    <span class="keyword">var</span> res=o.call(o1,args);</span><br><span class="line">    <span class="keyword">return</span> res <span class="keyword">typeof</span> <span class="built_in">Object</span>?res:o1;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Base=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1=<span class="keyword">new</span> Base();</span><br><span class="line"><span class="keyword">var</span> o2=<span class="built_in">Object</span>.create(Base);</span><br><span class="line"><span class="built_in">console</span>.log(o1.a);<span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(o2.a);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p><strong>Object.create失去了原来对象属性的访问</strong>：F创建后函数调用结束后被销毁，o2直接指向Base构造函数，<strong>o2没有指向它的prototype，</strong>因此o2.consructor不能通过prototype对找到构造函数，所以是undefined,但是如果Base是一个对象，则o2.a值为2，因为o2的[[Prototype]]指向了对象Base</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Base = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">Base.prototype.a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> Base();</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(Base);</span><br><span class="line"><span class="built_in">console</span>.log(o1.a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(o2.a); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>这里Base.prototype.a会去找它的[[Prototype]]上看是否有a，没有就重新设置了一个a，值为3，**而实际上o1.constructor通过默认的[[Prototype]]委托指向Base.prototype,进而委托到constructor指向的构造函数。所以这里的o1.a=2;o2.a仍旧是undefined，因为o2直接指向的是Base,没有指向它的prototype</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>小结</p><table><thead><tr><th>比较</th><th>new</th><th>Object.create</th></tr></thead><tbody><tr><td>构造函数</td><td>保留原构造函数属性</td><td>丢失原构造函数属性</td></tr><tr><td>原型链</td><td>原构造函数prototype属性</td><td>原构造函数/（对象）本身</td></tr><tr><td>作用对象</td><td>function</td><td>function和object</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Object-create&quot;&gt;&lt;a href=&quot;#Object-create&quot; class=&quot;headerlink&quot; title=&quot;Object.create()&quot;&gt;&lt;/a&gt;Object.create()&lt;/h1&gt;&lt;figure class=&quot;highlight </summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>new 原理</title>
    <link href="https://coloey.github.io/2022/04/24/new-%E5%8E%9F%E7%90%86/"/>
    <id>https://coloey.github.io/2022/04/24/new-%E5%8E%9F%E7%90%86/</id>
    <published>2022-04-24T15:50:57.000Z</published>
    <updated>2022-04-24T15:56:45.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>在<code>JavaScript</code>中，<code>new</code>操作符用于创建一个给定构造函数的实例对象</p><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1function Person(name, age)&#123;</span><br><span class="line">2    this.name = name;</span><br><span class="line">3    this.age = age;</span><br><span class="line">4&#125;</span><br><span class="line">5Person.prototype.sayName = function () &#123;</span><br><span class="line">6    console.log(this.name)</span><br><span class="line">7&#125;</span><br><span class="line">8const person1 = new Person(&#x27;Tom&#x27;, 20)</span><br><span class="line">9console.log(person1)  // Person &#123;name: &quot;Tom&quot;, age: 20&#125;</span><br><span class="line">10t.sayName() // &#x27;Tom&#x27;</span><br></pre></td></tr></table></figure><p>从上面可以看到：</p><ul><li><code>new</code> 通过构造函数 <code>Person</code> 创建出来的实例可以访问到构造函数中的属性</li><li><code>new</code> 通过构造函数 <code>Person</code> 创建出来的实例可以访问到构造函数原型链中的属性（即实例与构造函数通过原型链连接了起来）</li></ul><p>现在在构建函数中显式加上返回值，并且这个返回值是一个原始类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1function Test(name) &#123;</span><br><span class="line">2  this.name = name</span><br><span class="line">3  return 1</span><br><span class="line">4&#125;</span><br><span class="line">5const t = new Test(&#x27;xxx&#x27;)</span><br><span class="line">6console.log(t.name) // &#x27;xxx&#x27;</span><br></pre></td></tr></table></figure><p>可以发现，构造函数中返回一个原始值，然而这个返回值并没有作用</p><p>下面在构造函数中返回一个对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1function Test(name) &#123;</span><br><span class="line">2  this.name = name</span><br><span class="line">3  console.log(this) // Test &#123; name: &#x27;xxx&#x27; &#125;</span><br><span class="line">4  return &#123; age: 26 &#125;</span><br><span class="line">5&#125;</span><br><span class="line">6const t = new Test(&#x27;xxx&#x27;)</span><br><span class="line">7console.log(t) // &#123; age: 26 &#125;</span><br><span class="line">8console.log(t.name) // &#x27;undefined&#x27;</span><br></pre></td></tr></table></figure><p>从上面可以发现，构造函数如果返回值为一个对象，那么这个返回值会被正常使用</p><h2 id="二、流程"><a href="#二、流程" class="headerlink" title="二、流程"></a>二、流程</h2><p>从上面介绍中，我们可以看到<code>new</code>关键字主要做了以下的工作：</p><ul><li>创建一个新的对象<code>obj</code></li><li>将对象与构建函数通过原型链连接起来</li><li>将构建函数中的<code>this</code>绑定到新建的对象<code>obj</code>上</li><li>根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理</li></ul><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1function Person(name, age)&#123;</span><br><span class="line">2    this.name = name;</span><br><span class="line">3    this.age = age;</span><br><span class="line">4&#125;</span><br><span class="line">5const person1 = new Person(&#x27;Tom&#x27;, 20)</span><br><span class="line">6console.log(person1)  // Person &#123;name: &quot;Tom&quot;, age: 20&#125;</span><br><span class="line">7t.sayName() // &#x27;Tom&#x27;</span><br></pre></td></tr></table></figure><h2 id="手写new-操作符"><a href="#手写new-操作符" class="headerlink" title="手写new 操作符"></a>手写new 操作符</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my</span> <span class="title">new</span>(<span class="params">Func,..args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> obj=&#123;&#125;;</span><br><span class="line">    obj.__proto__=Func.prototype;</span><br><span class="line">    <span class="keyword">let</span> result=Func.apply(obj,args);</span><br><span class="line">    <span class="keyword">return</span> result instanceOf <span class="built_in">Object</span>?result:obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、是什么&quot;&gt;&lt;a href=&quot;#一、是什么&quot; class=&quot;headerlink&quot; title=&quot;一、是什么&quot;&gt;&lt;/a&gt;一、是什么&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;JavaScript&lt;/code&gt;中，&lt;code&gt;new&lt;/code&gt;操作符用于创建一个给定构造函数的</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>实现node中的EventEmitter</title>
    <link href="https://coloey.github.io/2022/04/24/%E5%AE%9E%E7%8E%B0node%E4%B8%AD%E7%9A%84EventEmitter/"/>
    <id>https://coloey.github.io/2022/04/24/%E5%AE%9E%E7%8E%B0node%E4%B8%AD%E7%9A%84EventEmitter/</id>
    <published>2022-04-24T14:08:59.000Z</published>
    <updated>2022-04-30T14:48:00.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>我们了解到，<code>Node </code>采用了事件驱动机制，而<code>EventEmitter </code>就是<code>Node</code>实现事件驱动的基础</p><p>在<code>EventEmitter</code>的基础上，<code>Node </code>几乎所有的模块都继承了这个类，这些模块拥有了自己的事件，可以绑定／触发监听器，实现了异步操作</p><p><code>Node.js</code> 里面的许多对象都会分发事件，比如 fs.readStream 对象会在文件被打开的时候触发一个事件</p><p>这些产生事件的对象都是 events.EventEmitter 的实例，这些对象有一个 eventEmitter.on() 函数，用于将一个或多个函数绑定到命名事件上</p><h2 id="二、使用方法"><a href="#二、使用方法" class="headerlink" title="二、使用方法"></a>二、使用方法</h2><p><code>Node </code>的<code>events</code>模块只提供了一个<code>EventEmitter</code>类，这个类实现了<code>Node</code>异步事件驱动架构的基本模式——观察者模式</p><p>在这种模式中，被观察者(主体)维护着一组其他对象派来(注册)的观察者，有新的对象对主体感兴趣就注册观察者，不感兴趣就取消订阅，主体有更新的话就依次通知观察者们</p><p>基本代码如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmitter</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;触发了event事件！&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">myEmitter.on(<span class="string">&#x27;event&#x27;</span>, callback)</span><br><span class="line">myEmitter.emit(<span class="string">&#x27;event&#x27;</span>)</span><br><span class="line">myEmitter.removeListener(<span class="string">&#x27;event&#x27;</span>, callback);</span><br></pre></td></tr></table></figure><p>通过实例对象的<code>on</code>方法注册一个名为<code>event</code>的事件，通过<code>emit</code>方法触发该事件，而<code>removeListener</code>用于取消事件的监听</p><p>关于其常见的方法如下：</p><ul><li>emitter.addListener/on(eventName, listener) ：添加类型为 eventName 的监听事件到事件数组尾部</li><li>emitter.prependListener(eventName, listener)：添加类型为 eventName 的监听事件到事件数组头部</li><li>emitter.emit(eventName[, …args])：触发类型为 eventName 的监听事件</li><li>emitter.removeListener/off(eventName, listener)：移除类型为 eventName 的监听事件</li><li>emitter.once(eventName, listener)：添加类型为 eventName 的监听事件，以后只能执行一次并删除</li><li>emitter.removeAllListeners([eventName])： 移除全部类型为 eventName 的监听事件</li></ul><h2 id="三、实现过程"><a href="#三、实现过程" class="headerlink" title="三、实现过程"></a>三、实现过程</h2><p>通过上面的方法了解，<code>EventEmitter</code>是一个构造函数，内部存在一个包含所有事件的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.events = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>events</code>存放的监听事件的函数的结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;event1&quot;</span>: [f1,f2,f3]，</span><br><span class="line">  <span class="string">&quot;event2&quot;</span>: [f4,f5]，</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后开始一步步实现实例方法，首先是<code>emit</code>，第一个参数为事件的类型，第二个参数开始为触发事件函数的参数，实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">emit</span>(<span class="params">type, ...args</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.events[type].forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Reflect</span>.apply(item, <span class="built_in">this</span>, args);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当实现了<code>emit</code>方法之后，然后实现<code>on</code>、<code>addListener</code>、<code>prependListener</code>这三个实例方法，都是添加事件监听触发函数，实现也是大同小异</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">on</span>(<span class="params">type, handler</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.events[type]) &#123;</span><br><span class="line">        <span class="built_in">this</span>.events[type] = [];</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="built_in">this</span>.events[type].push(handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">addListener</span>(<span class="params">type,handler</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.on(type,handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">prependListener</span>(<span class="params">type, handler</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.events[type]) &#123;</span><br><span class="line">        <span class="built_in">this</span>.events[type] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.events[type].unshift(handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着就是实现事件监听的方法<code>removeListener/on</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">removeListener</span>(<span class="params">type, handler</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.events[type]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.events[type] = <span class="built_in">this</span>.events[type].filter(<span class="function"><span class="params">item</span> =&gt;</span> item !== handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">off</span>(<span class="params">type,handler</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.removeListener(type,handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再来实现<code>once</code>方法， 再传入事件监听处理函数的时候进行封装，利用闭包的特性维护当前状态，通过<code>fired</code>属性值判断事件函数是否执行过</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">once</span>(<span class="params">type, handler</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.on(type, <span class="built_in">this</span>._onceWrap(type, handler, <span class="built_in">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">_onceWrap</span>(<span class="params">type, handler, target</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> state = &#123; <span class="attr">fired</span>: <span class="literal">false</span>, handler, type , target&#125;;</span><br><span class="line">    <span class="keyword">const</span> wrapFn = <span class="built_in">this</span>._onceWrapper.bind(state);</span><br><span class="line">    state.wrapFn = wrapFn;</span><br><span class="line">    <span class="keyword">return</span> wrapFn;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">_onceWrapper</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.fired) &#123;</span><br><span class="line">      <span class="built_in">this</span>.fired = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">Reflect</span>.apply(<span class="built_in">this</span>.handler, <span class="built_in">this</span>.target, args);</span><br><span class="line">      <span class="built_in">this</span>.target.off(<span class="built_in">this</span>.type, <span class="built_in">this</span>.wrapFn);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.events=&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">on</span>(<span class="params">type,handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">this</span>.events[type])&#123;</span><br><span class="line">            <span class="built_in">this</span>.events[type]=[]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.events[type].push(handler)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">addListener</span>(<span class="params">type,handler</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.on(type,handler)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">prependListener</span>(<span class="params">type,handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">this</span>.events[type])&#123;</span><br><span class="line">            <span class="built_in">this</span>.events[type]=[]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.events[type].unshift(handler)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">removeListener</span>(<span class="params">type,handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">this</span>.events[type])&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.events[type]=<span class="built_in">this</span>.events[type].filter(<span class="function"><span class="params">item</span>=&gt;</span>item!==handler)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">off</span>(<span class="params">type,handler</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.removeListener(type,handler)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">emit</span>(<span class="params">type,...args</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.events[type].forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">Reflect</span>.apply(item,<span class="built_in">this</span>,args);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">once</span>(<span class="params">type,handler</span>)</span>&#123;</span><br><span class="line">         <span class="comment">//把监听器注销，即利用闭包，在内部函数中销毁了外部函数的引用</span></span><br><span class="line">        <span class="keyword">let</span> temp=<span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">            handler(args);</span><br><span class="line">            <span class="built_in">this</span>.off(type,temp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.on(event,temp)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、是什么&quot;&gt;&lt;a href=&quot;#一、是什么&quot; class=&quot;headerlink&quot; title=&quot;一、是什么&quot;&gt;&lt;/a&gt;一、是什么&lt;/h2&gt;&lt;p&gt;我们了解到，&lt;code&gt;Node &lt;/code&gt;采用了事件驱动机制，而&lt;code&gt;EventEmitter &lt;/co</summary>
      
    
    
    
    <category term="Node" scheme="https://coloey.github.io/categories/Node/"/>
    
    
  </entry>
  
  <entry>
    <title>防抖节流</title>
    <link href="https://coloey.github.io/2022/04/24/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    <id>https://coloey.github.io/2022/04/24/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</id>
    <published>2022-04-24T09:49:35.000Z</published>
    <updated>2022-04-24T10:09:28.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>本质上是优化高频率执行代码的一种手段</p><p>如：浏览器的 <code>resize</code>、<code>scroll</code>、<code>keypress</code>、<code>mousemove</code> 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能</p><p>为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用<code>throttle</code>（节流）和<code>debounce</code>（防抖）的方式来减少调用频率</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</li><li>防抖: n 秒后再执行该事件，若在 n 秒内被重复触发，则重新计时</li></ul><h1 id="节流："><a href="#节流：" class="headerlink" title="节流："></a>节流：</h1><p>用时间戳实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttled</span>(<span class="params">fn,delay=<span class="number">500</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> oldTime=<span class="keyword">new</span> <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> newTime=<span class="keyword">new</span> <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span>(newTime-oldTime&gt;=delay)&#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>,args);</span><br><span class="line">            oldTime=<span class="keyword">new</span> <span class="built_in">Date</span>.now();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用定时器实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttled</span>(<span class="params">fn,delay=<span class="number">500</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">..args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">            timer=<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                fn.apply(<span class="built_in">this</span>,args);</span><br><span class="line">                timer=<span class="literal">null</span>;</span><br><span class="line">            &#125;,delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="防抖："><a href="#防抖：" class="headerlink" title="防抖："></a>防抖：</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn,delay=<span class="number">500</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timer)<span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer=<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>,args);<span class="comment">//每次执行，都先清除该计时器，然后下面重新开始计数，即不执行 debounce 一段时间 wait 后，setTimeout 里面的代码才会执行</span></span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>立即执行的防抖函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn,delay=<span class="number">500</span>,immediate</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(immediate)&#123;</span><br><span class="line">            immediate=!immediate;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>,args);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(timer)<span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">            timer=<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                fn.apply(<span class="built_in">this</span>,args);</span><br><span class="line">            &#125;,delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>相同点：</p><ul><li>都可以通过使用 <code>setTimeout</code> 实现</li><li>目的都是，降低回调执行频率。节省计算资源</li></ul><p>不同点：</p><ul><li>函数防抖，在一段连续操作结束后，处理回调，利用<code>clearTimeout </code>和 <code>setTimeout</code>实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能</li><li>函数防抖关注一定时间连续触发的事件，因为会清除定时器，只在最后执行一次，而函数节流一段时间内只执行一次,不会清除定时器，因此会在隔一段时间执行一次。</li></ul><p>例如，都设置时间频率为500ms，在2秒时间内，频繁触发函数，节流，每隔 500ms 就执行一次。防抖，则不管调动多少次方法，在2s后，只会执行一次</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>防抖在连续的事件，只需触发一次回调的场景有：</p><ul><li>搜索框搜索输入。只需用户最后一次输入完，再发送请求</li><li>手机号、邮箱验证输入检测</li><li>窗口大小<code>resize</code>。只需窗口调整完成后，计算窗口大小。防止重复渲染。</li></ul><p>节流在间隔一段时间执行一次回调的场景有：</p><ul><li>滚动加载，加载更多或滚到底部监听</li><li>搜索框，搜索联想功能</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h1&gt;&lt;p&gt;本质上是优化高频率执行代码的一种手段&lt;/p&gt;
&lt;p&gt;如：浏览器的 &lt;code&gt;resize&lt;/code&gt;、&lt;code&gt;scroll&lt;</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
</feed>
