<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小柒</title>
  
  <subtitle>www.xiaoqi.cn</subtitle>
  <link href="https://coloey.github.io/atom.xml" rel="self"/>
  
  <link href="https://coloey.github.io/"/>
  <updated>2022-02-06T15:07:41.991Z</updated>
  <id>https://coloey.github.io/</id>
  
  <author>
    <name>小柒</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>路由参数</title>
    <link href="https://coloey.github.io/2022/02/06/%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0/"/>
    <id>https://coloey.github.io/2022/02/06/%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0/</id>
    <published>2022-02-06T08:51:25.000Z</published>
    <updated>2022-02-06T15:07:41.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="query参数："><a href="#query参数：" class="headerlink" title="query参数："></a>query参数：</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&#x27;m in messageList&#x27;</span> <span class="attr">:key</span>=<span class="string">&#x27;m.id&#x27;</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 通过query传递参数 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">          &#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">              name:&#x27;messageDetail&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">              query:&#123;id:m.id,title:m.title&#125;</span></span></span><br><span class="line"><span class="string"><span class="tag">          &#125;&quot;</span>&gt;</span>&#123;&#123;m.title&#125;&#125;<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="params参数"><a href="#params参数" class="headerlink" title="params参数:"></a>params参数:</h1><p>1 配置路由声明接收param参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:Home,</span><br><span class="line">            <span class="attr">children</span>:[</span><br><span class="line">                &#123;<span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">                <span class="attr">component</span>:News&#125;,</span><br><span class="line">                &#123;<span class="attr">path</span>:<span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">                <span class="attr">component</span>:Message, </span><br><span class="line">                <span class="attr">children</span>:[</span><br><span class="line">                    &#123;<span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;messageDetail&#x27;</span>,<span class="attr">component</span>:Detail&#125;<span class="comment">//使用占位符声明接收params参数</span></span><br><span class="line">                ]&#125;</span><br><span class="line">            ]&#125;,</span><br></pre></td></tr></table></figure><p>2 传递参数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&#x27;m in messageList&#x27;</span> <span class="attr">:key</span>=<span class="string">&#x27;m.id&#x27;</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--跳转并携带params参数，to的字符写法--!&gt;</span></span><br><span class="line"><span class="comment">         &lt;router-link :to=&quot;`/home/message/detail/$&#123;m.id&#125;/$&#123;m.title&#125;`&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt; </span></span><br><span class="line"><span class="comment">         &lt;!-- 对象写法只能写name不能写path --&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- &lt;router-link :to=&quot;</span></span><br><span class="line"><span class="comment">          &#123;name:&#x27;messageDetail&#x27;,</span></span><br><span class="line"><span class="comment">          params:&#123;id:m.id,title:m.title&#125;</span></span><br><span class="line"><span class="comment">          </span></span><br><span class="line"><span class="comment">              &#125;&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置项</p><h1 id="props配置"><a href="#props配置" class="headerlink" title="props配置"></a>props配置</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//props第一种写法，值为对象，该对象中的key-value都会以props的形式传给Detail组件</span></span><br><span class="line"><span class="attr">props</span>:&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="string">&#x27;hello&#x27;</span>&#125;,</span><br><span class="line"><span class="comment">//props的第二种写法，值为布尔值，若布尔值为真，就会把该路由组件收到的所有params参数以props的形式传给Detail组件</span></span><br><span class="line"><span class="attr">props</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="comment">//第三种写法，值为函数</span></span><br><span class="line"><span class="function"><span class="title">props</span>(<span class="params">$route</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;<span class="attr">id</span>:$route.query.id,<span class="attr">title</span>:$route.query.title&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//解构赋值</span></span><br><span class="line"><span class="function"><span class="title">props</span>(<span class="params">&#123;query&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">id</span>:query.id,<span class="attr">title</span>:query.title&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Detail组件接收参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;Detail&#x27;</span>,</span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;query参数：&quot;&gt;&lt;a href=&quot;#query参数：&quot; class=&quot;headerlink&quot; title=&quot;query参数：&quot;&gt;&lt;/a&gt;query参数：&lt;/h1&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    <category term="Vue" scheme="https://coloey.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue3事件总线</title>
    <link href="https://coloey.github.io/2022/02/02/Vue3%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/"/>
    <id>https://coloey.github.io/2022/02/02/Vue3%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/</id>
    <published>2022-02-02T08:17:38.000Z</published>
    <updated>2022-02-02T08:38:36.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a>全局事件总线</h1><p>一种组件间的通信方式，适用于任意组件间的通信。</p><p>安装全局事件总线：</p><ol><li><p>引入/编写事件库</p></li><li><p>在入口文件中挂载</p></li><li><p>在组件中引入并使用</p><p>安装：npm install –save vue3-eventbus</p><p>挂载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//App.vue</span><br><span class="line">import eventBus from &#x27;vue3-eventbus&#x27;</span><br><span class="line">app.use(eventBus)</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Button.vue</span><br><span class="line">import bus from &#x27;vue3-eventbus&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">setup()&#123;</span><br><span class="line">bus.emit(&#x27;foo&#x27;,&#123;a:&#x27;b&#x27;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="消息订阅预发布（pubsub"><a href="#消息订阅预发布（pubsub" class="headerlink" title="消息订阅预发布（pubsub)"></a>消息订阅预发布（pubsub)</h1><ol><li><p>安装pubsub:npm install pubsub-js</p></li><li><p>引入：import pubsub from “pubsub-js”</p></li><li><p>接收数据，A组件想接收数据，则在A组件中订阅消息，订阅回调留在A组件自身。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">methods()&#123;</span><br><span class="line">demo(data)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mounted()&#123;</span><br><span class="line">this.pid=pubsub.subscribe(&#x27;xxx&#x27;,(msg,data)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;)//订阅消息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>提供数据：pubsub.publish(‘xxx’,数据)</li><li>最好在beforeDestroy钩子中，用Pubsub.unsubscribe(pid)取消订阅</li></ol></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;全局事件总线&quot;&gt;&lt;a href=&quot;#全局事件总线&quot; class=&quot;headerlink&quot; title=&quot;全局事件总线&quot;&gt;&lt;/a&gt;全局事件总线&lt;/h1&gt;&lt;p&gt;一种组件间的通信方式，适用于任意组件间的通信。&lt;/p&gt;
&lt;p&gt;安装全局事件总线：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="Vue" scheme="https://coloey.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>customRef</title>
    <link href="https://coloey.github.io/2022/02/01/customRef/"/>
    <id>https://coloey.github.io/2022/02/01/customRef/</id>
    <published>2022-02-01T08:55:59.000Z</published>
    <updated>2022-02-01T09:03:45.036Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">setup()&#123;</span><br><span class="line">        function myRef(value,delay=500)&#123;</span><br><span class="line">            let timeout</span><br><span class="line">            return customRef((track,trigger)=&gt;&#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    get()&#123;</span><br><span class="line">                        console.log(`有人从myRef中读取了数据:$&#123;value&#125;`)</span><br><span class="line">                        track()//通知Vue追踪value的变化（提前和get商量一下，让它认为这个value是可用的）</span><br><span class="line">                        return value</span><br><span class="line">                    &#125;,</span><br><span class="line">                    set(newValue)&#123;</span><br><span class="line">                        clearTimeout(timeout)</span><br><span class="line">                        console.log(`有人从myRef中修改了数据:$&#123;newValue&#125;`)</span><br><span class="line">                        timeout=setTimeout(()=&gt;&#123;</span><br><span class="line">                            value=newValue</span><br><span class="line">                            trigger()//通知Vue重新解析模板</span><br><span class="line">                        &#125;,delay)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        let val=myRef(&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line">        return &#123;</span><br><span class="line">            val</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    <category term="Vue" scheme="https://coloey.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>shallowReactive和shallowRef</title>
    <link href="https://coloey.github.io/2022/01/31/shallowReactive%E5%92%8CshallowRef/"/>
    <id>https://coloey.github.io/2022/01/31/shallowReactive%E5%92%8CshallowRef/</id>
    <published>2022-01-31T08:41:52.000Z</published>
    <updated>2022-02-01T07:57:53.734Z</updated>
    
    <content type="html"><![CDATA[<p>shallowReactive:只处理对象最外层属性的响应式（浅响应式）</p><p>shallowRef:只处理基本数据类型的响应式，不进行对象的响应式处理</p><p>什么时候使用？</p><p>如果有一个对象数据，结构比较深，但变化时只是外层属性变化==&gt;shallowReactive</p><p>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换==&gt;shallowRef</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;shallowReactive:只处理对象最外层属性的响应式（浅响应式）&lt;/p&gt;
&lt;p&gt;shallowRef:只处理基本数据类型的响应式，不进行对象的响应式处理&lt;/p&gt;
&lt;p&gt;什么时候使用？&lt;/p&gt;
&lt;p&gt;如果有一个对象数据，结构比较深，但变化时只是外层属性变化==&amp;gt;</summary>
      
    
    
    
    <category term="Vue" scheme="https://coloey.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>toRef</title>
    <link href="https://coloey.github.io/2022/01/31/toRef/"/>
    <id>https://coloey.github.io/2022/01/31/toRef/</id>
    <published>2022-01-31T07:49:20.000Z</published>
    <updated>2022-02-01T07:57:57.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="toRef"><a href="#toRef" class="headerlink" title="toRef:"></a>toRef:</h1><p>作用：创建一个ref对象，其value值指向另一个对象中的某个属性</p><p>语法：const name=toRef(person,’name’)</p><p>应用：要将响应式对象中的某个属性单独提供给外部使用时</p><p>扩展:toRefs与toRef功能一致，但可以批量创建多个ref对象，语法：toRefs(person),将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的 <a href="https://v3.cn.vuejs.org/api/refs-api.html#ref"><code>ref</code></a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  setup()&#123;</span><br><span class="line">        let person=reactive(&#123;</span><br><span class="line">            firstName:&quot;张&quot;,</span><br><span class="line">            lastName:&quot;三&quot;,</span><br><span class="line">            fullName:&#x27;&#x27;,</span><br><span class="line">            job:&#123;</span><br><span class="line">                one:&#x27;doctor&#x27;,</span><br><span class="line">                tow:&#x27;teacher&#x27;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">        person.fullName=computed(&#123;</span><br><span class="line">            get()&#123;</span><br><span class="line">                return person.firstName+&#x27;-&#x27;+person.lastName</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            set(value)&#123;</span><br><span class="line">                const nameArr=value.split(&#x27;-&#x27;)</span><br><span class="line">                person.firstName=nameArr[0]</span><br><span class="line">                person.lastName=nameArr[1]</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        return &#123;</span><br><span class="line">            person,</span><br><span class="line">            firstName:toRef(person,&#x27;firstName&#x27;),</span><br><span class="line">            lastName:toRef(person,&#x27;lastName&#x27;),</span><br><span class="line">            one:toRef(person.job,&#x27;one&#x27;),</span><br><span class="line">            fullName:toRef(person,&#x27;fullName&#x27;)</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">//toRefs:</span><br><span class="line">/*return &#123;</span><br><span class="line">            person,</span><br><span class="line">            ...toRefs(person),</span><br><span class="line">           </span><br><span class="line">           </span><br><span class="line">        &#125;*/</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;toRef&quot;&gt;&lt;a href=&quot;#toRef&quot; class=&quot;headerlink&quot; title=&quot;toRef:&quot;&gt;&lt;/a&gt;toRef:&lt;/h1&gt;&lt;p&gt;作用：创建一个ref对象，其value值指向另一个对象中的某个属性&lt;/p&gt;
&lt;p&gt;语法：const name=t</summary>
      
    
    
    
    <category term="Vue" scheme="https://coloey.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>watchEffect</title>
    <link href="https://coloey.github.io/2022/01/30/watchEffect/"/>
    <id>https://coloey.github.io/2022/01/30/watchEffect/</id>
    <published>2022-01-30T15:44:30.000Z</published>
    <updated>2022-01-30T15:51:06.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="watch和watchEffect区别："><a href="#watch和watchEffect区别：" class="headerlink" title="watch和watchEffect区别："></a>watch和watchEffect区别：</h1><p>watch:既要指明监视的属性，也要指明监视的回调</p><p>watchEffect:不用指明监视哪个属性，监视的回调中用到哪个属性就监视哪个属性</p><p>watchEffect有点像computed:</p><p>但computed注重的是计算出来的值即回调函数的返回值，所以必须要写返回值</p><p>而watch注重的是过程即回调函数的函数体，所以不用写返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//watchEffect指定的回调函数中用到的数据只要发生变化，则直接重新执行回调</span><br><span class="line">let sum=ref(1)</span><br><span class="line">        let msg=ref(&quot;你好呀&quot;)</span><br><span class="line">         watchEffect(()=&gt;&#123;</span><br><span class="line">            const x1=sum.value</span><br><span class="line">            const x2=person.firstName</span><br><span class="line">            console.log(&#x27;watchEffect的回调被调用了&#x27;,x1,x2)</span><br><span class="line">        &#125;)</span><br><span class="line">       </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;watch和watchEffect区别：&quot;&gt;&lt;a href=&quot;#watch和watchEffect区别：&quot; class=&quot;headerlink&quot; title=&quot;watch和watchEffect区别：&quot;&gt;&lt;/a&gt;watch和watchEffect区别：&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Vue" scheme="https://coloey.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://coloey.github.io/2022/01/30/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://coloey.github.io/2022/01/30/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2022-01-30T07:37:59.000Z</published>
    <updated>2022-01-30T07:53:02.198Z</updated>
    
    <content type="html"><![CDATA[<p>大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p><p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p><p>下面我用这两种区间的定义分别讲解两种不同的二分写法。</p><h1 id="二分法第一种写法"><a href="#二分法第一种写法" class="headerlink" title="二分法第一种写法"></a>二分法第一种写法</h1><p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。</p><p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p><ul><li><p>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</p></li><li><p>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class="line">            <span class="keyword">int</span> middle = left + ((right - left) / <span class="number">2</span>);<span class="comment">// 防止溢出 等同于(left + right)/2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>; <span class="comment">// target 在左区间，所以[left, middle - 1]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，所以[middle + 1, right]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二分法第二种写法"><a href="#二分法第二种写法" class="headerlink" title="二分法第二种写法"></a>二分法第二种写法</h1><p>如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p><p>有如下两点：</p><ul><li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li><li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>(); <span class="comment">// 定义target在左闭右开的区间里，即：[left, right)</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class="line">            <span class="keyword">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle; <span class="comment">// target 在左区间，在[left, middle)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大家写二分法经常写乱，主要是因为&lt;strong&gt;对区间的定义没有想清楚，区间的定义就是不变量&lt;/strong&gt;。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是&lt;strong&gt;循环不变量&lt;/strong&gt;规则。&lt;/</summary>
      
    
    
    
    <category term="算法" scheme="https://coloey.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>插槽</title>
    <link href="https://coloey.github.io/2022/01/29/%E6%8F%92%E6%A7%BD/"/>
    <id>https://coloey.github.io/2022/01/29/%E6%8F%92%E6%A7%BD/</id>
    <published>2022-01-29T15:41:20.000Z</published>
    <updated>2022-01-29T15:58:25.041Z</updated>
    
    <content type="html"><![CDATA[<p>1 作用：</p><p>让父组件可以向子组件指定位置插入html结构，是一种组件间的通信方式，适用于父组件=&gt;子组件</p><p>2 使用方式</p><p>（1）默认插槽</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">父组件：</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            html结构</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line">子组件：</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">            &lt;slot&gt;插槽默认内容&lt;/slot&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>2 具名插槽</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">父组件：</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">         &lt;template #header&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">                html结构</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">        &lt;template slot=&quot;center&quot;&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">                html结构</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">        &lt;template v-slot:footer&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">                html结构</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line">子组件：</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">            &lt;slot name=&quot;center&quot;&gt;插槽默认内容&lt;/slot&gt;</span><br><span class="line">            &lt;slot name=&quot;footer&quot;&gt;插槽默认内容&lt;/slot&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>3 作用域插槽</p><p>理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者决定，(games数据在Category组件中，但使用数据所遍历的结构由App组件决定)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">父组件：</span><br><span class="line">&lt;Category title=&quot;游戏&quot;&gt;</span><br><span class="line">    &lt;template v-slot=&quot;&#123;games&#125;&quot;&gt;</span><br><span class="line">         &lt;ul&gt;</span><br><span class="line">        &lt;li v-for=&quot;(game,index) in games&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">            &#123;&#123;game&#125;&#125;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;     </span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line">&lt;Category title=&quot;游戏&quot;&gt;</span><br><span class="line">    &lt;template v-slot=&quot;&#123;games&#125;&quot;&gt;</span><br><span class="line">         &lt;ol&gt;</span><br><span class="line">        &lt;li v-for=&quot;(game,index) in games&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">            &#123;&#123;game&#125;&#125;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">    &lt;/ol&gt;     </span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line">子组件：</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;/h3&gt;</span><br><span class="line">    &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;reactive&#125; from &quot;vue&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#x27;Category&#x27;,</span><br><span class="line">    props:[&#x27;title&#x27;],</span><br><span class="line">    setup()&#123;</span><br><span class="line">        let games=reactive([&#x27;红色警戒&#x27;,&#x27;超级玛丽&#x27;,&#x27;穿越火线&#x27;,&#x27;魂斗罗&#x27;])</span><br><span class="line">        return&#123;</span><br><span class="line">            games</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1 作用：&lt;/p&gt;
&lt;p&gt;让父组件可以向子组件指定位置插入html结构，是一种组件间的通信方式，适用于父组件=&amp;gt;子组件&lt;/p&gt;
&lt;p&gt;2 使用方式&lt;/p&gt;
&lt;p&gt;（1）默认插槽&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;tabl</summary>
      
    
    
    
    <category term="Vue" scheme="https://coloey.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>ref函数</title>
    <link href="https://coloey.github.io/2022/01/27/ref%E5%87%BD%E6%95%B0/"/>
    <id>https://coloey.github.io/2022/01/27/ref%E5%87%BD%E6%95%B0/</id>
    <published>2022-01-27T07:38:53.000Z</published>
    <updated>2022-02-01T09:52:15.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ref函数："><a href="#ref函数：" class="headerlink" title="ref函数："></a>ref函数：</h1><p>作用：定义一个响应式函数</p><p>语法：const xxx=ref(initValue)</p><p>创建一个包含响应式数据的引用对象（reference对象，简称ref对象)</p><p>JS中操作数据：xxx.value</p><p>模板中读取数据，不需要.value,直接<div></div></p><p>Ps:</p><p>接收的数据类型可以是：基本类型也可以是对象类型</p><p>基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成</p><p>对象基本类型的数据：内部是求助了Vue3中的一个新函数——reactive函数</p><h2 id="ref与reactive对比："><a href="#ref与reactive对比：" class="headerlink" title="ref与reactive对比："></a>ref与reactive对比：</h2><h3 id="定义数据角度："><a href="#定义数据角度：" class="headerlink" title="定义数据角度："></a>定义数据角度：</h3><p>ref用来定义：基本类型数据</p><p>reactive用来定义：对象（或数组类型数据）</p><p>PS：ref也可以用来定义对象（或数组）类型数据，它内部会自动通过reactive转为代理对象</p><h3 id="从原理角度对比："><a href="#从原理角度对比：" class="headerlink" title="从原理角度对比："></a>从原理角度对比：</h3><p>ref通过Object.defineProperty()的getter和setter来实现响应式（数据劫持）</p><p>reactive通过使用Proxy来实现响应式，并通过Reflect操作源对象内部的数据</p><h3 id="使用角度对比："><a href="#使用角度对比：" class="headerlink" title="使用角度对比："></a>使用角度对比：</h3><p>ref定义的数据，操作数据需要通过.value,读取数据时模板直接读取不需要.value</p><p>reactive定义的数据操作数据与读取数据均不需要.value</p><h1 id="响应式数据的判断"><a href="#响应式数据的判断" class="headerlink" title="响应式数据的判断"></a>响应式数据的判断</h1><p>isRef:检查一个值是否为一个ref对象</p><p>isReactive:检查一个对象是否由reactive创建的响应式代理</p><p>isReadonly:检查一个对象是否由readonly创建的只读代理</p><p>isProxy:检查一个对象是否由reactive或者readonly方法创建的代理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ref函数：&quot;&gt;&lt;a href=&quot;#ref函数：&quot; class=&quot;headerlink&quot; title=&quot;ref函数：&quot;&gt;&lt;/a&gt;ref函数：&lt;/h1&gt;&lt;p&gt;作用：定义一个响应式函数&lt;/p&gt;
&lt;p&gt;语法：const xxx=ref(initValue)&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Vue" scheme="https://coloey.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>props</title>
    <link href="https://coloey.github.io/2022/01/27/props/"/>
    <id>https://coloey.github.io/2022/01/27/props/</id>
    <published>2022-01-27T04:14:42.000Z</published>
    <updated>2022-01-27T05:34:36.203Z</updated>
    
    <content type="html"><![CDATA[<p>配置项:props</p><p>功能：让组件接收外部传来的数据</p><p>（1）传递数据：</p><p>第一种方式（只接收）：props:[‘name’]</p><p>第二种方式（限制类型）：props:{name:String}</p><p>第三种方式（限制类型，限制必要性，指定默认值）：</p><p>props:{</p><p>​    name:{</p><p>​        type:String,//类型</p><p>​        required:true,//必要性</p><p>​        dedault:’老王’//默认值</p><p>​    }</p><p>}</p><p>Ps:props是只读的，vue底层会监视你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后修改data中的数</p><p>eg:data(){</p><p>return{</p><p>myName:this.myName</p><p>}</p><p>}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;配置项:props&lt;/p&gt;
&lt;p&gt;功能：让组件接收外部传来的数据&lt;/p&gt;
&lt;p&gt;（1）传递数据：&lt;/p&gt;
&lt;p&gt;第一种方式（只接收）：props:[‘name’]&lt;/p&gt;
&lt;p&gt;第二种方式（限制类型）：props:{name:String}&lt;/p&gt;
&lt;p&gt;第三种方式（限制类</summary>
      
    
    
    
    <category term="Vue" scheme="https://coloey.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>生命周期钩子</title>
    <link href="https://coloey.github.io/2022/01/26/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/"/>
    <id>https://coloey.github.io/2022/01/26/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/</id>
    <published>2022-01-26T02:13:45.000Z</published>
    <updated>2022-01-26T02:20:22.472Z</updated>
    
    <content type="html"><![CDATA[<p>beforeCreate,created,beforeMount,mounted,beforeUpdated,updated,beforeUnmount,unmounted</p><h1 id="常用生命周期钩子"><a href="#常用生命周期钩子" class="headerlink" title="常用生命周期钩子:"></a>常用生命周期钩子:</h1><p>mounted:发送ajax请求，启动定时器，绑定自定义事件，订阅消息等【初始化操作】</p><p>beforeUnmount:清除定时器，解绑自定义事件，取消订阅消息等【收尾工作】</p><p>关于销毁实例：</p><p>1销毁后借助Vue开发者工具看不到任何信息</p><p>2 销毁后自定义事件失效，但原生DOM事件依然有效</p><p>3 一般不会在beforeUnmount操作数据，因为即使操作数据，也不会触发更新流程了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;beforeCreate,created,beforeMount,mounted,beforeUpdated,updated,beforeUnmount,unmounted&lt;/p&gt;
&lt;h1 id=&quot;常用生命周期钩子&quot;&gt;&lt;a href=&quot;#常用生命周期钩子&quot; class=&quot;h</summary>
      
    
    
    
    <category term="Vue" scheme="https://coloey.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>自定义指令</title>
    <link href="https://coloey.github.io/2022/01/25/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"/>
    <id>https://coloey.github.io/2022/01/25/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</id>
    <published>2022-01-25T09:14:32.000Z</published>
    <updated>2022-01-25T09:39:59.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1><h2 id="1-语法："><a href="#1-语法：" class="headerlink" title="1.语法："></a>1.语法：</h2><h3 id="（1）-局部指令："><a href="#（1）-局部指令：" class="headerlink" title="（1） 局部指令："></a>（1） 局部指令：</h3><p>​    directives:{指令名：配置对象}或 directives：{指令名:回调函数}</p><h3 id="（2）全局指令："><a href="#（2）全局指令：" class="headerlink" title="（2）全局指令："></a>（2）全局指令：</h3><p>Vue.directive(指令名，配置对象)或Vue.directive(指令名，回调函数)</p><h2 id="2-配置对象中常用的回调"><a href="#2-配置对象中常用的回调" class="headerlink" title="2.配置对象中常用的回调"></a>2.配置对象中常用的回调</h2><p><code>created</code>：在绑定元素的 attribute 或事件监听器被应用之前调用。在指令需要附加在普通的 <code>v-on</code> 事件监听器调用前的事件监听器中时，这很有用。` </p><p><code>beforeMount</code>：当指令第一次绑定到元素并且在挂载父组件之前调用。<code>mounted</code>：指令与元素成功绑定时使用</p><p><code>updated</code>:在包含组件的 VNode <strong>及其子组件的 VNode</strong> 更新后调用。</p><p><code>beforeUpdate</code>：在更新包含组件的 VNode 之前调用。</p><p><code>beforeUnmount</code>：在卸载绑定元素的父组件之前调用</p><p><code>unmounted</code>：当指令与元素解除绑定且父组件已卸载时，只调用一次。</p><p>PS:指令定义时不加v-,，但是使用时要加v-</p><p>指令名如果是多个单词要用kebab-case命名方式，不要用camelCase命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div id=&quot;root&quot;&gt;</span><br><span class="line">        &lt;h3&gt;&#123;&#123;name&#125;&#125;&lt;/h3&gt;</span><br><span class="line">        &lt;h3&gt;当前n:&lt;span v-text=&quot;n&quot;&gt;&#123;&#123;n&#125;&#125;&lt;/span&gt;&lt;/h3&gt;</span><br><span class="line">        &lt;h3&gt;放大10倍后的n：&lt;span v-big=&quot;n&quot;&gt;&#123;&#123;n&#125;&#125;&lt;/span&gt;&lt;/h3&gt;</span><br><span class="line">        &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-fbind:value=&quot;n&quot;&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        Vue.createApp(&#123;</span><br><span class="line">            data()&#123;</span><br><span class="line">                return&#123;</span><br><span class="line">                    name:&quot;ann&quot;,</span><br><span class="line">                    n:1</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            directives: &#123;</span><br><span class="line">                //v-big被调用：指令与元素成功绑定时（一上来） 指令所在模板重新编译时</span><br><span class="line">                big(element,binding)&#123;</span><br><span class="line">                   element.innerText=binding.value*10</span><br><span class="line">                   </span><br><span class="line">                &#125;,</span><br><span class="line">               /*fbind(element,binding)&#123;</span><br><span class="line">                    element.value=binding.value</span><br><span class="line">                    element.focus()</span><br><span class="line">                &#125;,*/</span><br><span class="line">               fbind:&#123;</span><br><span class="line">                   // 当被绑定的元素挂载到 DOM 中时……</span><br><span class="line">                    mounted(element,binding)&#123;</span><br><span class="line">                        console.log(this)</span><br><span class="line">                        element.value=binding.value</span><br><span class="line">                        element.focus()</span><br><span class="line"></span><br><span class="line">                    &#125;,</span><br><span class="line">                    updated(element,binding)&#123;</span><br><span class="line">                        element.value=binding.value</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).mount(&quot;#root&quot;)</span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自定义指令&quot;&gt;&lt;a href=&quot;#自定义指令&quot; class=&quot;headerlink&quot; title=&quot;自定义指令&quot;&gt;&lt;/a&gt;自定义指令&lt;/h1&gt;&lt;h2 id=&quot;1-语法：&quot;&gt;&lt;a href=&quot;#1-语法：&quot; class=&quot;headerlink&quot; title=&quot;1.语</summary>
      
    
    
    
    <category term="Vue" scheme="https://coloey.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>内置指令</title>
    <link href="https://coloey.github.io/2022/01/25/%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4/"/>
    <id>https://coloey.github.io/2022/01/25/%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4/</id>
    <published>2022-01-25T05:58:47.000Z</published>
    <updated>2022-01-25T07:45:44.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="v-html"><a href="#v-html" class="headerlink" title="v-html:"></a>v-html:</h1><p>1 作用：向指定节点中渲染包含html的内容</p><p>2 与插值语法的区别：</p><p>（1）v-html会替换掉节点中所有内容，则不会</p><p>（2）v-html可以识别html结构</p><p>3 严重注意：v-html有安全性问题</p><p>（1）在网站上动态渲染任意HTML非常危险，容易导致XSS攻击</p><p>（2）一定要在可信内容上使用v-html，永远不要用在用户提交的内容上</p><h1 id="v-cloak-没有值"><a href="#v-cloak-没有值" class="headerlink" title="v-cloak(没有值)"></a>v-cloak(没有值)</h1><p>1 本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性</p><p>2 使用css配合一个v-clock可以解决网速慢时页面展示出的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">        [v-cloak]&#123;</span><br><span class="line">            display:none</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"> &lt;h2 v-cloak&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;script&gt;&lt;/script&gt;//延迟5秒的服务器</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        Vue.createApp(&#123;</span><br><span class="line">            data()&#123;</span><br><span class="line">                return&#123;</span><br><span class="line">                    name:&#x27;Ann&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="v-once"><a href="#v-once" class="headerlink" title="v-once:"></a>v-once:</h1><ol><li>v-once 节点在初次动态渲染后，就被视为静态内容</li><li> 以后数据改变不会引起v-once所在结构的更新，可以用于优化性能</li></ol><h1 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre:"></a>v-pre:</h1><p>1.跳过其所在节点的编译过程</p><p>2.可利用它跳过没有使用指令语法，插值语法的节点，加快编译</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;v-html&quot;&gt;&lt;a href=&quot;#v-html&quot; class=&quot;headerlink&quot; title=&quot;v-html:&quot;&gt;&lt;/a&gt;v-html:&lt;/h1&gt;&lt;p&gt;1 作用：向指定节点中渲染包含html的内容&lt;/p&gt;
&lt;p&gt;2 与插值语法的区别：&lt;/p&gt;
&lt;p&gt;（1）</summary>
      
    
    
    
    <category term="Vue" scheme="https://coloey.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>收集表单数据</title>
    <link href="https://coloey.github.io/2022/01/25/%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE/"/>
    <id>https://coloey.github.io/2022/01/25/%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE/</id>
    <published>2022-01-25T03:09:55.000Z</published>
    <updated>2022-01-25T06:30:01.780Z</updated>
    
    <content type="html"><![CDATA[<p>收集表单数据：</p><p><input type="text">,v-model收集的死是value值，用户输入的是value值</p><p><input type="radio">,v-model收集的是value值，且给标签配置value值</p><input type="checkbox"><p>(1）没有配置input的value属性，收集的是checked(true/false)</p><p>(2)配置input的value属性：</p><p>若v-model的初始值是非数组，收集的是checked(true/false)</p><p>若v-model的初始值是数组，收集的是value组成的数组</p><p>PS：</p><p>v-model有三个修饰符：</p><p>lazy:失去焦点再收集数据</p><p>number:把输入的字符串转为有效数字</p><p>trim: 输入首尾空格过滤</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;收集表单数据：&lt;/p&gt;
&lt;p&gt;&lt;input type=&quot;text&quot;&gt;,v-model收集的死是value值，用户输入的是value值&lt;/p&gt;
&lt;p&gt;&lt;input type=&quot;radio&quot;&gt;,v-model收集的是value值，且给标签配置value值&lt;/p&gt;
&lt;input </summary>
      
    
    
    
    <category term="Vue" scheme="https://coloey.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Node.js基础</title>
    <link href="https://coloey.github.io/2022/01/24/Node-js%E5%9F%BA%E7%A1%80/"/>
    <id>https://coloey.github.io/2022/01/24/Node-js%E5%9F%BA%E7%A1%80/</id>
    <published>2022-01-24T13:57:44.000Z</published>
    <updated>2022-01-25T01:50:03.806Z</updated>
    
    <content type="html"><![CDATA[<p>Node.js运行时结构：</p><p>1 异步IO</p><p>当Node.js执行I/O操作时，会在响应返回后恢复操作，而不是阻止线程并占用额外内存等待</p><p>2 单线程</p><p>实际JS线程+uv线程池+V8任务线程池+V8inspector线程</p><p>优点：不用考虑多线程同步问题，也就不需要锁，同时还能比较高效的利用系统资源</p><p>缺点：阻塞会产生负面影响，解决方法：多进程或多线程</p><p>3 跨平台</p><p>Node.js跨平台+JS无需编译环境（Web跨平台，诊断工具跨平台）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Node.js运行时结构：&lt;/p&gt;
&lt;p&gt;1 异步IO&lt;/p&gt;
&lt;p&gt;当Node.js执行I/O操作时，会在响应返回后恢复操作，而不是阻止线程并占用额外内存等待&lt;/p&gt;
&lt;p&gt;2 单线程&lt;/p&gt;
&lt;p&gt;实际JS线程+uv线程池+V8任务线程池+V8inspector线程&lt;/</summary>
      
    
    
    
    <category term="Node.js" scheme="https://coloey.github.io/categories/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue监视数据原理</title>
    <link href="https://coloey.github.io/2022/01/24/Vue%E7%9B%91%E8%A7%86%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/"/>
    <id>https://coloey.github.io/2022/01/24/Vue%E7%9B%91%E8%A7%86%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86/</id>
    <published>2022-01-24T10:24:05.000Z</published>
    <updated>2022-01-25T01:45:04.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue监视数据原理"><a href="#Vue监视数据原理" class="headerlink" title="Vue监视数据原理"></a>Vue监视数据原理</h1><p>1 Vue会监视data中所有层次的数据（递归）</p><p>2 如何监视对象中的数据？</p><p>通过setter实现监视，且要在new Vue的时候就传入要监测的数据。</p><p>（1）对象中后追加的属性，Vue默认不做响应式处理</p><p>（2）如需给后续添加的属性左响应式，请使用下面的API:</p><p>​    Vue.set(target,propertyName/index,value):target不允许是Vue实例或者vm中的data对象</p><p> vm.$set(target,propertyName/index,value)</p><p>3 如何监测数组中的数据？</p><p>通过包裹数组更新元素的方法实现，本质做了两件事：</p><p>（1） 调用原生对应的方法对数组进行更新</p><p>（2） 重新解析模板，进而更新页面</p><p>4 在Vue中修改数组中的某个元素一定要用如下方法：</p><p>（1）使用这些API：push(),shift(),unshift(),splice(),sort(),reverse()</p><p>（2）Vue.set()或vm.$set()</p><p>非变更方法，例如 <code>filter()</code>、<code>concat()</code> 和 <code>slice()</code>。它们不会变更原始数组，而<strong>总是返回一个新数组</strong>。当使用非变更方法时，可以用新数组替换旧数组：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue监视数据原理&quot;&gt;&lt;a href=&quot;#Vue监视数据原理&quot; class=&quot;headerlink&quot; title=&quot;Vue监视数据原理&quot;&gt;&lt;/a&gt;Vue监视数据原理&lt;/h1&gt;&lt;p&gt;1 Vue会监视data中所有层次的数据（递归）&lt;/p&gt;
&lt;p&gt;2 如何监视对象中的</summary>
      
    
    
    
    <category term="Vue" scheme="https://coloey.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>key作用与原理</title>
    <link href="https://coloey.github.io/2022/01/24/key%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
    <id>https://coloey.github.io/2022/01/24/key%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/</id>
    <published>2022-01-24T05:48:50.000Z</published>
    <updated>2022-01-24T07:01:04.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="key的内部原理"><a href="#key的内部原理" class="headerlink" title="key的内部原理"></a>key的内部原理</h1><p>1 虚拟DOM中key的作用：</p><p>key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】，随后Vue进行【新虚拟DOM】和【旧虚拟DOM】的对比，对比规则如下：</p><p>2 对比规则：</p><p>（1）旧虚拟DOM中找到与新虚拟DOM相同的key：</p><ul><li><p> 若虚拟DOM中内容不变，则直接使用之前的真实DOM</p></li><li><p>若虚拟DOM中内容变了，则生成新的真实DOM，随后替换页面中的真实    DOM    </p></li></ul><p>（2）旧虚拟DOM中未找到与新虚拟DOM相同的key，创建新的真实DOM，随后渲染到页面</p><p>3 用index作为key可能会引发的问题：</p><p>（1）若对数据进行逆序添加，逆序删除等操作：</p><p>会产生没有必要的真实DOM更新==&gt;界面效果没问题，但是效率低</p><p>（2）如果结构中还包含输入类DOM：</p><p>会产生错误的DOM更新==&gt;界面有问题</p><p>4 开发中如何选择key?</p><p>(1)最好使用每条数据的唯一标识作为key,比如id,身份证号，手机号等唯一值</p><p>(2)如果不存在对数据的逆序添加，逆序删除等破坏顺序的操作，仅用于渲染列表用于展示，使用index作为key是没有问题的</p><p><img src="/2022/01/24/key%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/image-20220124150028215.png" alt="image-20220124150028215"></p><p><img src="/2022/01/24/key%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/image-20220124150059555.png" alt="image-20220124150059555"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;key的内部原理&quot;&gt;&lt;a href=&quot;#key的内部原理&quot; class=&quot;headerlink&quot; title=&quot;key的内部原理&quot;&gt;&lt;/a&gt;key的内部原理&lt;/h1&gt;&lt;p&gt;1 虚拟DOM中key的作用：&lt;/p&gt;
&lt;p&gt;key是虚拟DOM对象的标识，当数据发生变化时</summary>
      
    
    
    
    <category term="Vue" scheme="https://coloey.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>条件渲染</title>
    <link href="https://coloey.github.io/2022/01/24/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/"/>
    <id>https://coloey.github.io/2022/01/24/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</id>
    <published>2022-01-24T05:22:02.000Z</published>
    <updated>2022-01-24T05:48:38.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><p>1 v-if:</p><p>写法：</p><p>(1). v-if=”表达式”</p><p>(2) v-else-if=”表达式”</p><p>(3) v-else</p><p>适用于：切换频率较低的情景</p><p>特点：不展示的DOM元素直接被移除</p><p>注意：v-if和v-else-if,v-else一起使用时要求结构不能被打断</p><p>2 v-show</p><p>写法： v-show=”表达式”</p><p>适用于：切换频率较高的场景</p><p>特点：不展示的DOM元素未被移除，使用display=none隐藏掉</p><p>PS：</p><p>1 使用v-if时，元素可能无法获取到，而使用v-show一定可以获取到</p><p>2 v-if可以和template配合使用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;条件渲染&quot;&gt;&lt;a href=&quot;#条件渲染&quot; class=&quot;headerlink&quot; title=&quot;条件渲染&quot;&gt;&lt;/a&gt;条件渲染&lt;/h1&gt;&lt;p&gt;1 v-if:&lt;/p&gt;
&lt;p&gt;写法：&lt;/p&gt;
&lt;p&gt;(1). v-if=”表达式”&lt;/p&gt;
&lt;p&gt;(2) v-else-if</summary>
      
    
    
    
    <category term="Vue" scheme="https://coloey.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>绑定class样式</title>
    <link href="https://coloey.github.io/2022/01/24/%E7%BB%91%E5%AE%9Aclass%E6%A0%B7%E5%BC%8F/"/>
    <id>https://coloey.github.io/2022/01/24/%E7%BB%91%E5%AE%9Aclass%E6%A0%B7%E5%BC%8F/</id>
    <published>2022-01-24T03:39:15.000Z</published>
    <updated>2022-01-24T05:18:30.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="绑定class样式"><a href="#绑定class样式" class="headerlink" title="绑定class样式"></a>绑定class样式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">        &lt;!-- 绑定class样式--字符串写法，适用于样式类名不确定。需要动态确定 --&gt;</span><br><span class="line">        &lt;div class=&quot;basic&quot; :class=&quot;mood&quot; @click=&quot;changeMood&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;</span><br><span class="line">        &lt;!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定，名字也不确定 --&gt;</span><br><span class="line">        &lt;div class=&quot;basic&quot; :class=&quot;classArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;</span><br><span class="line">        &lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定，名字也确定，但要动态决定用不用 --&gt;</span><br><span class="line">        &lt;div class=&quot;basic&quot; :class=&quot;classObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        Vue.config.productionTip = false</span><br><span class="line">        Vue.createApp(&#123;</span><br><span class="line">            data()&#123;</span><br><span class="line">                return&#123;</span><br><span class="line">                    name:&#x27;Ann&#x27;,</span><br><span class="line">                    mood:&#x27;normal&#x27;,</span><br><span class="line">                    classArr:[&#x27;c1&#x27;,&#x27;c2&#x27;,&#x27;c3&#x27;],</span><br><span class="line">                    classObj:&#123;</span><br><span class="line">                        &#x27;c1&#x27;:false,</span><br><span class="line">                        &#x27;c2&#x27;:false,</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                changeMood()&#123;</span><br><span class="line">                    const arr=[&#x27;happy&#x27;,&#x27;sad&#x27;,&#x27;normal&#x27;]</span><br><span class="line">                    this.mood=arr[Math.floor(Math.random()*3)]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;).mount(&#x27;#demo&#x27;)</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="绑定style样式"><a href="#绑定style样式" class="headerlink" title="绑定style样式"></a>绑定style样式</h1><p>1 :style=”{fontSize: xxx}”,其中xxx是动态值</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;绑定class样式&quot;&gt;&lt;a href=&quot;#绑定class样式&quot; class=&quot;headerlink&quot; title=&quot;绑定class样式&quot;&gt;&lt;/a&gt;绑定class样式&lt;/h1&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;t</summary>
      
    
    
    
    <category term="Vue" scheme="https://coloey.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>watch和computed区别</title>
    <link href="https://coloey.github.io/2022/01/24/watch%E5%92%8Ccomputed%E5%8C%BA%E5%88%AB/"/>
    <id>https://coloey.github.io/2022/01/24/watch%E5%92%8Ccomputed%E5%8C%BA%E5%88%AB/</id>
    <published>2022-01-24T02:41:52.000Z</published>
    <updated>2022-01-24T02:55:41.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别:"></a>computed和watch的区别:</h1><p>1 computed能完成的功能watch也能完成</p><p>2 watch能完成的功能computed不一定能完成，例如watch能完成异步操作</p><p>PS：</p><p>1 所有被Vue管理的函数要写成普通函数，这样new Vue的实例的时候this才能绑定到新创建的vm或组件实例对象</p><p>2 所有不被Vue管理的函数比如（定时器的回调函数，ajax的回调函数和Promise的回调函数）最好写成箭头函数，箭头函数的this绑定会继承外层函数的this绑定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Vue.createApp(&#123;</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">firstName:&quot;张&quot;,</span><br><span class="line">lastName:&quot;三&quot;,</span><br><span class="line">fullName:&quot;张三&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">watch:&#123;</span><br><span class="line">firstName(val)&#123;</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">this.fullName=val+this.lastName&#125;,1000)</span><br><span class="line">&#125;,</span><br><span class="line">lastName(val)&#123;</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">this.fullName=thia.firstName+val&#125;,1000)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;computed和watch的区别&quot;&gt;&lt;a href=&quot;#computed和watch的区别&quot; class=&quot;headerlink&quot; title=&quot;computed和watch的区别:&quot;&gt;&lt;/a&gt;computed和watch的区别:&lt;/h1&gt;&lt;p&gt;1 comput</summary>
      
    
    
    
    <category term="Vue" scheme="https://coloey.github.io/categories/Vue/"/>
    
    
  </entry>
  
</feed>
